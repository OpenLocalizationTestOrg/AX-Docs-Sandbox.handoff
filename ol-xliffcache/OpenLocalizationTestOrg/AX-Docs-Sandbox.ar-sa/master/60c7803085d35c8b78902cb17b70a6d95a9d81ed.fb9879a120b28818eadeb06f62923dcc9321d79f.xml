{"nodes":[{"pos":[32,45],"content":"Macros in X++","needQuote":true,"needEscape":true,"nodes":[{"content":"Macros in X++","pos":[0,13]}]},{"pos":[59,116],"content":"This topic describes how to create and use macros in X++.","needQuote":true,"needEscape":true,"nodes":[{"content":"This topic describes how to create and use macros in X++.","pos":[0,57]}]},{"pos":[598,611],"content":"Macros in X++","linkify":"Macros in X++","nodes":[{"content":"Macros in X++","pos":[0,13]}]},{"content":"This topic describes how to create and use macros in X++.","pos":[613,670]},{"content":"Precompiler directives are processed before the the code is compiler.","pos":[672,741]},{"content":"The directives declare and handle macros and their values.","pos":[742,800]},{"content":"The directives are removed by the precompiler so that the X++ compiler never encounters them.","pos":[801,894]},{"content":"The X++ compiler only sees the sequence of characters written into the X++ code by the directives.","pos":[895,993]},{"pos":[998,1026],"content":"\\#define and \\#if directives","linkify":"\\#define and \\#if directives","nodes":[{"content":"<ph id=\"ph1\">\\#</ph>define and <ph id=\"ph2\">\\#</ph>if directives","pos":[0,28],"source":"\\#define and \\#if directives"}]},{"content":"All precompiler directives and symbols begin with the <ph id=\"ph1\">\\#</ph> character.","pos":[1027,1094],"source":"All precompiler directives and symbols begin with the \\# character."},{"content":"A macro can be defined at any point in the code.","pos":[1095,1143]},{"content":"The variable can have a value that is a sequence of characters, but it is not required to have a value.","pos":[1144,1247]},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> directive tells the precompiler to create the macro variable, including an optional value.","pos":[1248,1355],"source":" The **\\#define** directive tells the precompiler to create the macro variable, including an optional value."},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>if<ept id=\"p1\">**</ept> directive tests whether the variable is defined, and optionally, whether it has a specific value.","pos":[1356,1466],"source":" The **\\#if** directive tests whether the variable is defined, and optionally, whether it has a specific value."},{"content":"The X++ precompiler directives, the macro names that they define, and the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>if<ept id=\"p1\">**</ept> directive value tests are all case-insensitive.","pos":[1467,1597],"source":" The X++ precompiler directives, the macro names that they define, and the **\\#if** directive value tests are all case-insensitive."},{"content":"However, it is a best practice to begin macro names with an uppercase letter.","pos":[1598,1675]},{"pos":[1681,1693],"content":"Code example","linkify":"Code example","nodes":[{"content":"Code example","pos":[0,12]}]},{"content":"In the following code sample, a macro named <bpt id=\"p1\">**</bpt>MyMacro<ept id=\"p1\">**</ept> is defined.","pos":[1695,1762],"source":"In the following code sample, a macro named **MyMacro** is defined."},{"content":"It is not given a value in the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define.MyMacro<ept id=\"p1\">**</ept> definition line.","pos":[1763,1831],"source":" It is not given a value in the **\\#define.MyMacro** definition line."},{"content":"Therefore it behaves as if the value is a zero-length sequence of characters.","pos":[1832,1909]},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>if.MyMacro<ept id=\"p1\">**</ept> statement tests whether <bpt id=\"p2\">**</bpt>MyMacro<ept id=\"p2\">**</ept> is defined.","pos":[1910,1978],"source":" The **\\#if.MyMacro** statement tests whether **MyMacro** is defined."},{"content":"Because <bpt id=\"p1\">**</bpt>MyMacro<ept id=\"p1\">**</ept> is defined, the lines of code before the first <bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\#</ph>endif<ept id=\"p2\">**</ept> are included in the X++ code at the test location.","pos":[1979,2108],"source":" Because **MyMacro** is defined, the lines of code before the first **\\#endif** are included in the X++ code at the test location."},{"content":"Near the end of the example there is an <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>ifnot.MyMacro<ept id=\"p1\">**</ept> test.","pos":[2109,2174],"source":" Near the end of the example there is an **\\#ifnot.MyMacro** test."},{"content":"Because <bpt id=\"p1\">**</bpt>MyMacro<ept id=\"p1\">**</ept> is defined, that test is false and no lines are written into the X++ code.","pos":[2175,2269],"source":" Because **MyMacro** is defined, that test is false and no lines are written into the X++ code."},{"content":"After the precompile phase ends for this method, the <bpt id=\"p1\">**</bpt>MyMacro<ept id=\"p1\">**</ept> definition goes out of scope and is no longer known to the system.","pos":[2270,2401],"source":" After the precompile phase ends for this method, the **MyMacro** definition goes out of scope and is no longer known to the system."},{"pos":[3069,3106],"content":"Precompile and Compile Error Messages","linkify":"Precompile and Compile Error Messages","nodes":[{"content":"Precompile and Compile Error Messages","pos":[0,37]}]},{"content":"When you are developing code that contains macros, you must understand whether an error message is generated during the precompile or the compile phase.","pos":[3107,3259]},{"content":"The two key words to look for are:","pos":[3260,3294]},{"content":"Lexical – This indicates a precompile error.","pos":[3300,3344]},{"content":"Syntax – This indicates a compile error.","pos":[3349,3389]},{"content":"The following code example has a lexical error caused by the first closing parenthesis, which marks the end of the directive.","pos":[3391,3516]},{"content":"Therefore the precompiler is confused by the last two characters, \"\";)\".","pos":[3517,3589]},{"content":"The following code example has a syntax error caused by using the non-existent <bpt id=\"p1\">**</bpt><ph id=\"ph1\">++++</ph><ept id=\"p1\">**</ept> operator.","pos":[3629,3726],"source":"The following code example has a syntax error caused by using the non-existent **++++** operator."},{"content":"The X++ compiler encounters this operator after <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>MyMacro2<ept id=\"p1\">**</ept> is replaced by the macro value.The macro definition is correct even though its value is not accepted X++ syntax.","pos":[3727,3902],"source":" The X++ compiler encounters this operator after **\\#MyMacro2** is replaced by the macro value.The macro definition is correct even though its value is not accepted X++ syntax."},{"pos":[3956,3973],"content":"\\#undef directive","linkify":"\\#undef directive","nodes":[{"content":"<ph id=\"ph1\">\\#</ph>undef directive","pos":[0,17],"source":"\\#undef directive"}]},{"content":"You can use the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>undef<ept id=\"p1\">**</ept> directive to remove a macro definition that exists from a previous <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>define.<ept id=\"p2\">**</ept>","pos":[3974,4082],"source":"You can use the **\\#undef** directive to remove a macro definition that exists from a previous **\\#define.**"},{"content":"After a macro name has been created by <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> and then removed by <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>undef,<ept id=\"p2\">**</ept> the macro can be created again by another <bpt id=\"p3\">**</bpt><ph id=\"ph3\">\\#</ph>define.<ept id=\"p3\">**</ept>","pos":[4083,4223],"source":" After a macro name has been created by **\\#define** and then removed by **\\#undef,** the macro can be created again by another **\\#define.**"},{"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>undef<ept id=\"p1\">**</ept> has no effect on macros that are created by the <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>localmacro<ept id=\"p2\">**</ept> directive.","pos":[4224,4311],"source":"**\\#undef** has no effect on macros that are created by the **\\#localmacro** directive."},{"content":"In the following code sample, the macro <bpt id=\"p1\">**</bpt>MyMacro<ept id=\"p1\">**</ept> is undefined by using the <ph id=\"ph1\">\\#</ph>undef directive.","pos":[4312,4408],"source":" In the following code sample, the macro **MyMacro** is undefined by using the \\#undef directive."},{"content":"The <ph id=\"ph1\">\\#</ph>undef occurs between the two <ph id=\"ph2\">\\#</ph>if tests for its existence.","pos":[4409,4473],"source":" The \\#undef occurs between the two \\#if tests for its existence."},{"content":"The output shows only the first <ph id=\"ph1\">\\#</ph>if test was true.","pos":[4474,4525],"source":" The output shows only the first \\#if test was true."},{"pos":[4911,4928],"content":"Use a Macro Value","linkify":"Use a Macro Value","nodes":[{"content":"Use a Macro Value","pos":[0,17]}]},{"content":"You can define a macro name to have a value.","pos":[4929,4973]},{"content":"A macro value is a sequence of characters.","pos":[4974,5016]},{"content":"A macro value is not a string (or <bpt id=\"p1\">**</bpt>str<ept id=\"p1\">**</ept>) in the formal sense of a data type.","pos":[5017,5095],"source":" A macro value is not a string (or **str**) in the formal sense of a data type."},{"content":"You assign a value to a macro by appending the value enclosed in parentheses at the end of a <ph id=\"ph1\">\\#</ph>define directive.","pos":[5096,5208],"source":" You assign a value to a macro by appending the value enclosed in parentheses at the end of a \\#define directive."},{"content":"You can use the macro symbol where you want the value to occur in the X++ code.","pos":[5209,5288]},{"content":"A macro symbol is the name of the macro with the <ph id=\"ph1\">\\#</ph> character added as a prefix.","pos":[5289,5369],"source":" A macro symbol is the name of the macro with the \\# character added as a prefix."},{"content":"The following code sample shows a macro symbol <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>MyMacro.<ept id=\"p1\">**</ept>","pos":[5370,5431],"source":" The following code sample shows a macro symbol **\\#MyMacro.**"},{"content":"The symbol is replaced by the value of the macro.","pos":[5432,5481]},{"pos":[6078,6096],"content":"Test a Macro Value","linkify":"Test a Macro Value","nodes":[{"content":"Test a Macro Value","pos":[0,18]}]},{"content":"You can test a macro to see whether it has a value.","pos":[6097,6148]},{"content":"You can also test to see whether its value is equal to a specific sequence of characters.","pos":[6149,6238]},{"content":"These tests enable you to conditionally include lines of code in your X++ program.","pos":[6239,6321]},{"content":"There is no way you can test whether a defined macro has a value.","pos":[6322,6387]},{"content":"You can only test whether a specific value matches the value of a macro.","pos":[6388,6460]},{"content":"As a best practice, any macro name that you define should always have a value, or it should never have a value.","pos":[6461,6572]},{"content":"When you alternate between these modes, your code becomes difficult to understand.","pos":[6573,6655]},{"content":"For macros that have a value, you can vary the value when you see fit.","pos":[6656,6726]},{"content":"In the following code sample, two <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>if<ept id=\"p1\">**</ept> tests are run to determine whether the macro <bpt id=\"p2\">**</bpt>MyIntMacro<ept id=\"p2\">**</ept> exists.","pos":[6727,6837],"source":" In the following code sample, two **\\#if** tests are run to determine whether the macro **MyIntMacro** exists."},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>if.MyIntMacro()<ept id=\"p1\">**</ept> test is true.","pos":[6838,6877],"source":" The **\\#if.MyIntMacro()** test is true."},{"content":"This syntax behaves the same as <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>if.MyIntMacro.<ept id=\"p1\">**</ept>","pos":[6878,6930],"source":" This syntax behaves the same as **\\#if.MyIntMacro.**"},{"content":"The following code sample shows the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>if.DebugMacro(heavy)<ept id=\"p1\">**</ept> directive that tests the value of the <bpt id=\"p2\">**</bpt>DebugMacro<ept id=\"p2\">**</ept> macro.","pos":[7569,7691],"source":"The following code sample shows the **\\#if.DebugMacro(heavy)** directive that tests the value of the **DebugMacro** macro."},{"content":"If the value is the five character sequence <bpt id=\"p1\">**</bpt>heavy<ept id=\"p1\">**</ept>, then the test is true.","pos":[7692,7769],"source":" If the value is the five character sequence **heavy**, then the test is true."},{"pos":[8490,8522],"content":"\\#defInc and \\#defDec directives","linkify":"\\#defInc and \\#defDec directives","nodes":[{"content":"<ph id=\"ph1\">\\#</ph>defInc and <ph id=\"ph2\">\\#</ph>defDec directives","pos":[0,32],"source":"\\#defInc and \\#defDec directives"}]},{"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>defInc<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>defDec<ept id=\"p2\">**</ept> are the only directives that interpret the value of a macro and they apply apply only to macros that have a value that can be converted to the formal <bpt id=\"p3\">**</bpt>int<ept id=\"p3\">**</ept> type.","pos":[8523,8716],"source":"**\\#defInc** and **\\#defDec** are the only directives that interpret the value of a macro and they apply apply only to macros that have a value that can be converted to the formal **int** type."},{"content":"The value can only contain numerals.","pos":[8717,8753]},{"content":"The only non-numeric character allowed is a leading negative sign (-).","pos":[8754,8824]},{"content":"The integer value is treated as an X++ <bpt id=\"p1\">**</bpt>int<ept id=\"p1\">**</ept>, not as an <bpt id=\"p2\">**</bpt>int64<ept id=\"p2\">**</ept>.","pos":[8825,8893],"source":" The integer value is treated as an X++ **int**, not as an **int64**."},{"content":"For macro names that are used by the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>defInc<ept id=\"p1\">**</ept> directive, it is important that the <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>define<ept id=\"p2\">**</ept> directive that creates the macro not reside in a class declaration.","pos":[8894,9060],"source":" For macro names that are used by the **\\#defInc** directive, it is important that the **\\#define** directive that creates the macro not reside in a class declaration."},{"content":"The behavior of <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>defInc<ept id=\"p1\">**</ept> in these cases is unpredictable.","pos":[9061,9122],"source":" The behavior of **\\#defInc** in these cases is unpredictable."},{"content":"Instead, such macros should be defined in only a method.","pos":[9123,9179]},{"content":"We recommend that the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>defInc<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>defDec<ept id=\"p2\">**</ept> directives only be used for macros that have an integer value.","pos":[9180,9294],"source":" We recommend that the **\\#defInc** and **\\#defDec** directives only be used for macros that have an integer value."},{"content":"The precompiler follows special rules for <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>defInc<ept id=\"p1\">**</ept> when the macro value is not an integer, or when the value is unusual or extreme.","pos":[9295,9430],"source":" The precompiler follows special rules for **\\#defInc** when the macro value is not an integer, or when the value is unusual or extreme."},{"content":"The following table lists the values that <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>defInc<ept id=\"p1\">**</ept> converts to zero (0) and then increments.","pos":[9431,9527],"source":" The following table lists the values that **\\#defInc** converts to zero (0) and then increments."},{"content":"When a value is converted to 0 by <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>defInc,<ept id=\"p1\">**</ept> the original value cannot be recovered, not even by <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>defDec.<ept id=\"p2\">**</ept>","pos":[9528,9641],"source":" When a value is converted to 0 by **\\#defInc,** the original value cannot be recovered, not even by **\\#defDec.**"},{"content":"Macro value","pos":[9645,9656]},{"content":"Behavior","pos":[9665,9673]},{"content":"(+55)","pos":[10091,10096]},{"content":"The positive sign (+) prefix makes the precompiler treat this as a non-numeric string.","pos":[10111,10197]},{"content":"The precompiler treats all non-numeric strings as 0 when it handles a <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>defInc<ept id=\"p1\">**</ept> (or <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>defDec)<ept id=\"p2\">**</ept> directive.","pos":[10198,10309],"source":" The precompiler treats all non-numeric strings as 0 when it handles a **\\#defInc** (or **\\#defDec)** directive."},{"content":"(\"3\")","pos":[10314,10319]},{"content":"Integers enclosed in quotation marks are treated as 0.","pos":[10334,10388]},{"content":"The quotation marks are discarded, and these changes persist.","pos":[10389,10450]},{"content":"( )","pos":[10537,10540]},{"content":"A string of spaces is treated as 0, and then incremented.","pos":[10557,10614]},{"content":"()","pos":[10760,10762]},{"pos":[10780,10910],"content":"A zero-length string is treated as 0, and then incremented, when the value is enclosed in parentheses, as in <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define.MyMac().<ept id=\"p1\">**</ept>","source":"A zero-length string is treated as 0, and then incremented, when the value is enclosed in parentheses, as in **\\#define.MyMac().**"},{"content":"(Random string.)","pos":[10983,10999]},{"content":"Any non-numeric string of characters is treated as 0, and then incremented.","pos":[11003,11078]},{"content":"(0x12)","pos":[11206,11212]},{"content":"Hexadecimal numbers are treated as non-numeric strings.","pos":[11226,11281]},{"content":"Therefore they are converted to 0, and then incremented.","pos":[11282,11338]},{"content":"(-44)","pos":[11429,11434]},{"content":"Negative numbers are acceptable, including integers without the negative sign (-).","pos":[11449,11531]},{"content":"(2147483647)","pos":[11652,11664]},{"pos":[11672,11768],"content":"The maximum positive <bpt id=\"p1\">**</bpt>int<ept id=\"p1\">**</ept> value is changed to the minimum negative <bpt id=\"p2\">**</bpt>int<ept id=\"p2\">**</ept> value by <ph id=\"ph1\">\\#</ph>defInc.","source":"The maximum positive **int** value is changed to the minimum negative **int** value by \\#defInc."},{"content":"(999888777666555)","pos":[11875,11892]},{"content":"Any large number, beyond the capacity of <bpt id=\"p1\">**</bpt>int<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>int64<ept id=\"p2\">**</ept>.","pos":[11895,11958],"source":"Any large number, beyond the capacity of **int** and **int64**."},{"content":"This is treated as the maximum positive <bpt id=\"p1\">**</bpt>int<ept id=\"p1\">**</ept> value.","pos":[11959,12013],"source":" This is treated as the maximum positive **int** value."},{"content":"(5.8)","pos":[12098,12103]},{"content":"Real numbers are truncated by <ph id=\"ph1\">\\#</ph>defDec (and <ph id=\"ph2\">\\#</ph>defInc).","pos":[12118,12172],"source":"Real numbers are truncated by \\#defDec (and \\#defInc)."},{"content":"Subsequent symbol substitution shows that the truncation persists.","pos":[12173,12239]},{"content":"When no value and no parentheses are provided for the directive <ph id=\"ph1\">\\#</ph>define.MyValuelessMacro, the precompiler rejects use of the directive <ph id=\"ph2\">\\#</ph>defInc.MyValuelessMacro.","pos":[12341,12503],"source":"When no value and no parentheses are provided for the directive \\#define.MyValuelessMacro, the precompiler rejects use of the directive \\#defInc.MyValuelessMacro."},{"pos":[12547,12559],"content":"Code example","linkify":"Code example","nodes":[{"content":"Code example","pos":[0,12]}]},{"content":"In the following code sample, the initial value of the macro <bpt id=\"p1\">**</bpt>CounterMacroA<ept id=\"p1\">**</ept> is a string that can be converted into an integer.","pos":[12561,12690],"source":"In the following code sample, the initial value of the macro **CounterMacroA** is a string that can be converted into an integer."},{"content":"The sample shows how the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>defInc<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>defDec<ept id=\"p2\">**</ept> directives can be used for this macro name.","pos":[12691,12789],"source":" The sample shows how the **\\#defInc** and **\\#defDec** directives can be used for this macro name."},{"pos":[13537,13561],"content":"\\#globaldefine directive","linkify":"\\#globaldefine directive","nodes":[{"content":"<ph id=\"ph1\">\\#</ph>globaldefine directive","pos":[0,24],"source":"\\#globaldefine directive"}]},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>globaldefine<ept id=\"p1\">**</ept> directive is similar to the <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>define<ept id=\"p2\">**</ept> directive.","pos":[13562,13636],"source":"The **\\#globaldefine** directive is similar to the **\\#define** directive."},{"content":"The difference is that <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> directives generally take precedence over <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>globalmacro<ept id=\"p2\">**</ept> directives.","pos":[13637,13744],"source":" The difference is that **\\#define** directives generally take precedence over **\\#globalmacro** directives."},{"content":"This is true regardless of which directive occurs first in the X++ code.","pos":[13745,13817]},{"content":"A <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>globaldefine<ept id=\"p1\">**</ept> never overwrites a <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>define<ept id=\"p2\">**</ept> directive that has both a macro name and a value.","pos":[13818,13920],"source":" A **\\#globaldefine** never overwrites a **\\#define** directive that has both a macro name and a value."},{"content":"A <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>globaldefine<ept id=\"p1\">**</ept> can overwrite another <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>globaldefine. <ept id=\"p2\">**</ept>A <bpt id=\"p3\">**</bpt><ph id=\"ph3\">\\#</ph>define<ept id=\"p3\">**</ept> directive that has only a name does not overwrite a <ph id=\"ph4\">\\#</ph>globalmacro that has both a name and a value.","pos":[13921,14098],"source":" A **\\#globaldefine** can overwrite another **\\#globaldefine. **A **\\#define** directive that has only a name does not overwrite a \\#globalmacro that has both a name and a value."},{"content":"It is recommended that you use <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define,<ept id=\"p1\">**</ept> and that you do not use <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>globaldefine.<ept id=\"p2\">**</ept>","pos":[14099,14187],"source":" It is recommended that you use **\\#define,** and that you do not use **\\#globaldefine.**"},{"content":"Use of <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>globaldefine<ept id=\"p1\">**</ept> can create uncertainty that makes code difficult to maintain.","pos":[14188,14275],"source":" Use of **\\#globaldefine** can create uncertainty that makes code difficult to maintain."},{"content":"The exact semantics of <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>globaldefine<ept id=\"p1\">**</ept> cannot be achieved through <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>if<ept id=\"p2\">**</ept> test directives.","pos":[14276,14370],"source":" The exact semantics of **\\#globaldefine** cannot be achieved through **\\#if** test directives."},{"content":"By using <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>if<ept id=\"p1\">**</ept> tests you can avoid overwriting a <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>define<ept id=\"p2\">**</ept> and a <bpt id=\"p3\">**</bpt><ph id=\"ph3\">\\#</ph>globaldefine.<ept id=\"p3\">**</ept>","pos":[14371,14461],"source":" By using **\\#if** tests you can avoid overwriting a **\\#define** and a **\\#globaldefine.**"},{"content":"But <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>if<ept id=\"p1\">**</ept> tests cannot distinguish between <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>define<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt><ph id=\"ph3\">\\#</ph>globaldefine<ept id=\"p3\">**</ept> macros.","pos":[14462,14551],"source":" But **\\#if** tests cannot distinguish between **\\#define** and **\\#globaldefine** macros."},{"content":"The following code sample is the closest you can come to achieving the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>globaldefine<ept id=\"p1\">**</ept> semantic with other directives such as <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>if.<ept id=\"p2\">**</ept>","pos":[14552,14690],"source":" The following code sample is the closest you can come to achieving the **\\#globaldefine** semantic with other directives such as **\\#if.**"},{"pos":[15069,15081],"content":"Code example","linkify":"Code example","nodes":[{"content":"Code example","pos":[0,12]}]},{"content":"The following code sample shows a difference in the behavior of <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>globaldefine.<ept id=\"p2\">**</ept>","pos":[15083,15183],"source":"The following code sample shows a difference in the behavior of **\\#define** and **\\#globaldefine.**"},{"content":"Following the code sample is a table explaining the conclusions from the output.","pos":[15184,15264]},{"content":"The primary test case in the code sample is labeled <bpt id=\"p1\">**</bpt>12<ept id=\"p1\">**</ept>.","pos":[15265,15324],"source":" The primary test case in the code sample is labeled **12**."},{"pos":[18562,18578],"content":"Macro parameters","linkify":"Macro parameters","nodes":[{"content":"Macro parameters","pos":[0,16]}]},{"content":"You can define macro values to include parameter symbols.","pos":[18579,18636]},{"content":"The first parameter symbol is %1, the second is %2, and so on.","pos":[18637,18699]},{"content":"You pass values for the parameters when you reference the macro symbol name for expansion.","pos":[18700,18790]},{"content":"Macro parameter values are character sequences of no formal type, and they are comma delimited.","pos":[18791,18886]},{"content":"There is no way to pass in a comma as part of a parameter value.","pos":[18887,18951]},{"content":"The number of parameters passed can be less than, greater than, or equal to the number of parameters that the macro value is designed to receive.","pos":[18952,19097]},{"content":"The system tolerates mismatches in the number of parameters passed.","pos":[19098,19165]},{"content":"If fewer parameters are passed than the macro expects, each omitted parameter is treated as a zero-length sequence of characters.","pos":[19166,19295]},{"content":"In the following code sample, <bpt id=\"p1\">**</bpt>MyMacro<ept id=\"p1\">**</ept> is defined to have a value that contains parameters.","pos":[19296,19390],"source":" In the following code sample, **MyMacro** is defined to have a value that contains parameters."},{"content":"Macro substitution symbols are given with parameter values in parentheses.","pos":[19391,19465]},{"pos":[20212,20253],"content":"\\#localmacro and \\#globalmacro directives","linkify":"\\#localmacro and \\#globalmacro directives","nodes":[{"content":"<ph id=\"ph1\">\\#</ph>localmacro and <ph id=\"ph2\">\\#</ph>globalmacro directives","pos":[0,41],"source":"\\#localmacro and \\#globalmacro directives"}]},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>localmacro<ept id=\"p1\">**</ept> directive is a good choice when you want a macro to have a value that is several lines long, or when your macro value contains a closing parenthesis.","pos":[20254,20424],"source":"The **\\#localmacro** directive is a good choice when you want a macro to have a value that is several lines long, or when your macro value contains a closing parenthesis."},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>localmacro<ept id=\"p1\">**</ept> directive is a good choice when you want your macro value to be lines of X++ or SQL code.","pos":[20425,20535],"source":" The **\\#localmacro** directive is a good choice when you want your macro value to be lines of X++ or SQL code."},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>localmacro<ept id=\"p1\">**</ept> directive can be written as <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>macro.<ept id=\"p2\">**</ept>","pos":[20536,20597],"source":" The **\\#localmacro** directive can be written as **\\#macro.**"},{"content":"However, <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>localmacro<ept id=\"p1\">**</ept> is the recommended term.","pos":[20598,20648],"source":" However, **\\#localmacro** is the recommended term."},{"content":"Both macros have the same behavior.","pos":[20649,20684]},{"content":"By using the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>if<ept id=\"p1\">**</ept> directive, you can test whether a macro name is declared with the <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>define<ept id=\"p2\">**</ept> directive.","pos":[20685,20796],"source":" By using the **\\#if** directive, you can test whether a macro name is declared with the **\\#define** directive."},{"content":"However, you cannot test whether the macro name is declared with the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>localmacro<ept id=\"p1\">**</ept> directive.","pos":[20797,20893],"source":" However, you cannot test whether the macro name is declared with the **\\#localmacro** directive."},{"content":"Only macros declared by using the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> directive are affected by the <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>undef<ept id=\"p2\">**</ept> directive.","pos":[20894,20993],"source":" Only macros declared by using the **\\#define** directive are affected by the **\\#undef** directive."},{"content":"In a <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> directive, you can specify a name that is already in scope as a <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>localmacro.<ept id=\"p2\">**</ept>","pos":[20994,21093],"source":" In a **\\#define** directive, you can specify a name that is already in scope as a **\\#localmacro.**"},{"content":"The effect is to discard the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>localmacro<ept id=\"p1\">**</ept> and create a <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>define<ept id=\"p2\">**</ept> macro.","pos":[21094,21172],"source":" The effect is to discard the **\\#localmacro** and create a **\\#define** macro."},{"content":"This also applies to the opposite sequence, which means that a <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>localmacro<ept id=\"p1\">**</ept> can redefine a <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>define.<ept id=\"p2\">**</ept>","pos":[21173,21281],"source":" This also applies to the opposite sequence, which means that a **\\#localmacro** can redefine a **\\#define.**"},{"content":"A <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>localmacro<ept id=\"p1\">**</ept> (that has both a macro name and a value) always overrides a previous <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>localmacro<ept id=\"p2\">**</ept> that has the same name.","pos":[21282,21410],"source":" A **\\#localmacro** (that has both a macro name and a value) always overrides a previous **\\#localmacro** that has the same name."},{"content":"However, you cannot always be sure whether the override occurs when you use <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>globalmacro.<ept id=\"p1\">**</ept>","pos":[21411,21505],"source":" However, you cannot always be sure whether the override occurs when you use **\\#globalmacro.**"},{"content":"For this reason we recommend that you do not use <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>globalmacro. <ept id=\"p1\">**</ept>This same problem occurs with <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>globaldefine.<ept id=\"p2\">**</ept>","pos":[21506,21623],"source":" For this reason we recommend that you do not use **\\#globalmacro. **This same problem occurs with **\\#globaldefine.**"},{"content":"The main difference between a <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> macro and a <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>localmacro<ept id=\"p2\">**</ept> macro is in how their syntax is terminated.","pos":[21624,21739],"source":" The main difference between a **\\#define** macro and a **\\#localmacro** macro is in how their syntax is terminated."},{"content":"The terminators are as follows:","pos":[21740,21771]},{"pos":[21777,21815],"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> – is terminated by– <bpt id=\"p2\">**</bpt>)<ept id=\"p2\">**</ept>","source":"**\\#define** – is terminated by– **)**"},{"pos":[21820,21871],"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>localmacro<ept id=\"p1\">**</ept> – is terminated by– <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>endmacro<ept id=\"p2\">**</ept>","source":"**\\#localmacro** – is terminated by– **\\#endmacro**"},{"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>localmacro<ept id=\"p1\">**</ept> is a better choice for macros with multiple line values.","pos":[21873,21946],"source":"**\\#localmacro** is a better choice for macros with multiple line values."},{"content":"Multiple line values are typically lines of X++ or SQL code.","pos":[21947,22007]},{"content":"X++ and SQL contain lots of parentheses, and these would prematurely terminate a <ph id=\"ph1\">\\#</ph>define.","pos":[22008,22098],"source":" X++ and SQL contain lots of parentheses, and these would prematurely terminate a \\#define."},{"content":"Both <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>localmacro<ept id=\"p2\">**</ept> can be declared and terminated on either a single line or on subsequent lines.","pos":[22099,22216],"source":" Both **\\#define** and **\\#localmacro** can be declared and terminated on either a single line or on subsequent lines."},{"content":"In practice, the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> is terminated on the same line that it is declared on.","pos":[22217,22301],"source":" In practice, the **\\#define** is terminated on the same line that it is declared on."},{"content":"In practice, the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>localmacro<ept id=\"p1\">**</ept> is terminated on a subsequent line.","pos":[22302,22371],"source":" In practice, the **\\#localmacro** is terminated on a subsequent line."},{"content":"Where both macro names and values are supplied, the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>globalmacro<ept id=\"p1\">**</ept> directive cannot override the <ph id=\"ph2\">\\#</ph>define directive.","pos":[22372,22491],"source":" Where both macro names and values are supplied, the **\\#globalmacro** directive cannot override the \\#define directive."},{"content":"Also, the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>globaldefine<ept id=\"p1\">**</ept> directive cannot override the <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>localmacro<ept id=\"p2\">**</ept> directive.","pos":[22492,22578],"source":" Also, the **\\#globaldefine** directive cannot override the **\\#localmacro** directive."},{"pos":[22584,22597],"content":"Code examples","linkify":"Code examples","nodes":[{"content":"Code examples","pos":[0,13]}]},{"content":"The following code sample shows how to use the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>localmacro<ept id=\"p1\">**</ept> directive.","pos":[22599,22673],"source":"The following code sample shows how to use the **\\#localmacro** directive."},{"content":"It demonstrates that the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>undef<ept id=\"p1\">**</ept> directive does not affect <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>localmacro<ept id=\"p2\">**</ept> macros.","pos":[22674,22761],"source":" It demonstrates that the **\\#undef** directive does not affect **\\#localmacro** macros."},{"content":"It also shows that <ph id=\"ph1\">\\#</ph>if tests cannot determine whether a <bpt id=\"p1\">**</bpt><ph id=\"ph2\">\\#</ph>localmacro<ept id=\"p1\">**</ept> macro has been defined.","pos":[22762,22859],"source":" It also shows that \\#if tests cannot determine whether a **\\#localmacro** macro has been defined."},{"pos":[23590,23764],"content":"The following X++ code sample shows that <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>localmacro<ept id=\"p1\">**</ept> overrides a <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>globalmacro<ept id=\"p2\">**</ept> of the same macro name, but that <bpt id=\"p3\">**</bpt><ph id=\"ph3\">\\#</ph>globalmacro<ept id=\"p3\">**</ept> does not override <bpt id=\"p4\">**</bpt><ph id=\"ph4\">\\#</ph>localmacro.<ept id=\"p4\">**</ept>","source":"The following X++ code sample shows that **\\#localmacro** overrides a **\\#globalmacro** of the same macro name, but that **\\#globalmacro** does not override **\\#localmacro.**"},{"pos":[24411,24432],"content":"Nesting Macro Symbols","linkify":"Nesting Macro Symbols","nodes":[{"content":"Nesting Macro Symbols","pos":[0,21]}]},{"content":"You can nest precompiler definition directives inside an outer definition directive.","pos":[24433,24517]},{"content":"The main definition directives are <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>localmacro. <ept id=\"p2\">**</ept>The cases for which this topic provides code samples are as follows:","pos":[24518,24656],"source":" The main definition directives are **\\#define** and **\\#localmacro. **The cases for which this topic provides code samples are as follows:"},{"content":"Transitive substitution: A <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> macro can have the symbol for another macro as its value.","pos":[24662,24759],"source":"Transitive substitution: A **\\#define** macro can have the symbol for another macro as its value."},{"content":"Transitive substitution of the symbol occurs in X++ code.","pos":[24760,24817]},{"pos":[24822,24925],"content":"No transitive substitution: An <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>if<ept id=\"p1\">**</ept> directive test of a macro value does not perform substitutions.","source":"No transitive substitution: An **\\#if** directive test of a macro value does not perform substitutions."},{"pos":[24930,25074],"content":"Macro within a macro: A <ph id=\"ph1\">\\#</ph>define directive can be given inside a <bpt id=\"p1\">**</bpt><ph id=\"ph2\">\\#</ph>localmacro<ept id=\"p1\">**</ept> directive, or a <bpt id=\"p2\">**</bpt><ph id=\"ph3\">\\#</ph>localmacro<ept id=\"p2\">**</ept> can be inside a <bpt id=\"p3\">**</bpt><ph id=\"ph4\">\\#</ph>define.<ept id=\"p3\">**</ept>","source":"Macro within a macro: A \\#define directive can be given inside a **\\#localmacro** directive, or a **\\#localmacro** can be inside a **\\#define.**"},{"pos":[25080,25103],"content":"Transitive Substitution","linkify":"Transitive Substitution","nodes":[{"content":"Transitive Substitution","pos":[0,23]}]},{"content":"In the following code sample, the value of the first <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> variable includes a symbol (<ph id=\"ph2\">\\#</ph>D) of the second <bpt id=\"p2\">**</bpt><ph id=\"ph3\">\\#</ph>define<ept id=\"p2\">**</ept> variable.","pos":[25105,25240],"source":"In the following code sample, the value of the first **\\#define** variable includes a symbol (\\#D) of the second **\\#define** variable."},{"content":"This works even though the expansion symbol <ph id=\"ph1\">\\#</ph>D occurs before macro <bpt id=\"p1\">**</bpt>D<ept id=\"p1\">**</ept> is defined.","pos":[25241,25326],"source":" This works even though the expansion symbol \\#D occurs before macro **D** is defined."},{"pos":[25812,25838],"content":"No transitive substitution","linkify":"No transitive substitution","nodes":[{"content":"No transitive substitution","pos":[0,26]}]},{"content":"The following code sample tries to determine whether two macro variables have the same value, without specifying what that value might be.","pos":[25840,25978]},{"content":"The output shows that this determination cannot be made..","pos":[25979,26036]},{"content":"The following code sample shows that the <ph id=\"ph1\">\\#</ph>defInc directive does not lead to transitive substitution of symbol values.","pos":[26616,26734],"source":"The following code sample shows that the \\#defInc directive does not lead to transitive substitution of symbol values."},{"content":"For more information about the <ph id=\"ph1\">\\#</ph>defInc directive, see How to: Use the <ph id=\"ph2\">\\#</ph>defInc and <ph id=\"ph3\">\\#</ph>defDec Directives.","pos":[26735,26839],"source":" For more information about the \\#defInc directive, see How to: Use the \\#defInc and \\#defDec Directives."},{"content":"After the <ph id=\"ph1\">\\#</ph>defInc.E2 directive, the subsequent output value for <ph id=\"ph2\">\\#</ph>E2 shows the value for <bpt id=\"p1\">**</bpt>E2<ept id=\"p1\">**</ept> is converted to zero (0) by <ph id=\"ph3\">\\#</ph>defInc.E2 before it is incremented to one (1).","pos":[26840,27013],"source":" After the \\#defInc.E2 directive, the subsequent output value for \\#E2 shows the value for **E2** is converted to zero (0) by \\#defInc.E2 before it is incremented to one (1)."},{"content":"Before the conversion, the value of <bpt id=\"p1\">**</bpt>E2<ept id=\"p1\">**</ept> was the three characters <ph id=\"ph1\">\\#</ph>E2.","pos":[27014,27087],"source":" Before the conversion, the value of **E2** was the three characters \\#E2."},{"content":"The output for test case <bpt id=\"p1\">**</bpt>36<ept id=\"p1\">**</ept> shows the value has been converted to 1.","pos":[27088,27160],"source":" The output for test case **36** shows the value has been converted to 1."},{"pos":[27981,28001],"content":"Macro within a macro","linkify":"Macro within a macro","nodes":[{"content":"Macro within a macro","pos":[0,20]}]},{"content":"A <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> directive can be given inside a <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>localmacro<ept id=\"p2\">**</ept> directive, and a <bpt id=\"p3\">**</bpt><ph id=\"ph3\">\\#</ph>localmacro<ept id=\"p3\">**</ept> can be inside a <ph id=\"ph4\">\\#</ph>define.","pos":[28003,28126],"source":"A **\\#define** directive can be given inside a **\\#localmacro** directive, and a **\\#localmacro** can be inside a \\#define."},{"content":"This is shown in the following code sample.","pos":[28127,28170]},{"pos":[29050,29070],"content":"\\#macrolib directive","linkify":"\\#macrolib directive","nodes":[{"content":"<ph id=\"ph1\">\\#</ph>macrolib directive","pos":[0,20],"source":"\\#macrolib directive"}]},{"content":"In the Application Explorer under the Macros node, there are many library nodes that contain sets of macro directives.","pos":[29071,29189]},{"content":"Both <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>localmacro<ept id=\"p2\">**</ept> often appear in the contents of these macro libraries.","pos":[29190,29283],"source":" Both **\\#define** and **\\#localmacro** often appear in the contents of these macro libraries."},{"content":"You can use the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>macrolib.MyAOTMacroLibrary<ept id=\"p1\">**</ept> to include the contents of a macro library in your X++ code.","pos":[29284,29393],"source":" You can use the **\\#macrolib.MyAOTMacroLibrary** to include the contents of a macro library in your X++ code."},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>if<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>undef<ept id=\"p2\">**</ept> directives do not apply to <bpt id=\"p3\">**</bpt><ph id=\"ph3\">\\#</ph>macrolib<ept id=\"p3\">**</ept> names.","pos":[29394,29471],"source":" The **\\#if** and **\\#undef** directives do not apply to **\\#macrolib** names."},{"content":"However, they do apply to <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> directives that are the contents of a <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>macrolib<ept id=\"p2\">**</ept> macro.","pos":[29472,29570],"source":" However, they do apply to **\\#define** directives that are the contents of a **\\#macrolib** macro."},{"content":"The directive <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>macrolib.MyAOTMacroLibrary<ept id=\"p1\">**</ept> can also be written as <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>MyAOTMacroLibrary.<ept id=\"p2\">**</ept>","pos":[29571,29665],"source":" The directive **\\#macrolib.MyAOTMacroLibrary** can also be written as **\\#MyAOTMacroLibrary.**"},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>macrolib<ept id=\"p1\">**</ept> prefix is recommended because it is never ambiguous to a person who later reads the code.","pos":[29666,29774],"source":" The **\\#macrolib** prefix is recommended because it is never ambiguous to a person who later reads the code."},{"pos":[29780,29802],"content":"Create a macro library","linkify":"Create a macro library","nodes":[{"content":"Create a macro library","pos":[0,22]}]},{"content":"To create a macro library:","pos":[29804,29830]},{"pos":[29836,29927],"content":"In <bpt id=\"p1\">**</bpt>Solution Explorer,<ept id=\"p1\">**</ept> right-click on the project, select <bpt id=\"p2\">**</bpt>Add<ept id=\"p2\">**</ept> and then <bpt id=\"p3\">**</bpt>New item.<ept id=\"p3\">**</ept>","source":"In **Solution Explorer,** right-click on the project, select **Add** and then **New item.**"},{"pos":[29932,30024],"content":"In the <bpt id=\"p1\">**</bpt>Add New Item<ept id=\"p1\">**</ept> dialog, select Installed and then <bpt id=\"p2\">**</bpt>AX Artifacts<ept id=\"p2\">**</ept> in the left pane.","source":"In the **Add New Item** dialog, select Installed and then **AX Artifacts** in the left pane."},{"pos":[30029,30066],"content":"In the middle pane, select <bpt id=\"p1\">**</bpt>Macro.<ept id=\"p1\">**</ept>","source":"In the middle pane, select **Macro.**"},{"content":"Enter a name and click <bpt id=\"p1\">**</bpt>Add.<ept id=\"p1\">**</ept>","pos":[30071,30102],"source":"Enter a name and click **Add.**"},{"content":"Save the macro file and refresh the Application Explorer to find your macro library.","pos":[30103,30187]},{"pos":[30193,30206],"content":"Code examples","linkify":"Code examples","nodes":[{"content":"Code examples","pos":[0,13]}]},{"content":"Dynamics AX has an macro library that is named <bpt id=\"p1\">**</bpt>Event.<ept id=\"p1\">**</ept>","pos":[30208,30265],"source":"Dynamics AX has an macro library that is named **Event.**"},{"content":"This macro library contains the directive <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define.DefaultEventPollFrequency(15)<ept id=\"p1\">**</ept>.","pos":[30266,30351],"source":" This macro library contains the directive **\\#define.DefaultEventPollFrequency(15)**."},{"content":"The following code sample shows that the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>macrolib.Event<ept id=\"p1\">**</ept> directive makes the macro <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>DefaultEventPollFrequency<ept id=\"p2\">**</ept> available.","pos":[30352,30482],"source":" The following code sample shows that the **\\#macrolib.Event** directive makes the macro **\\#DefaultEventPollFrequency** available."},{"content":"The following code example shows what happens when you write a <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> for a name that is already the name of a node in the macro library.","pos":[30872,31015],"source":"The following code example shows what happens when you write a **\\#define** for a name that is already the name of a node in the macro library."},{"content":"For this example, there is a node named <bpt id=\"p1\">**</bpt>MacLib23,<ept id=\"p1\">**</ept> and its contents are one <bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p2\">**</ept> as follows:","pos":[31016,31119],"source":" For this example, there is a node named **MacLib23,** and its contents are one **\\#define** as follows:"},{"content":"After a <ph id=\"ph1\">\\#</ph>macrolib directive is issued for <bpt id=\"p1\">**</bpt>MacLib23<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>define<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt><ph id=\"ph3\">\\#</ph>undef<ept id=\"p3\">**</ept> directives have no effect on the <bpt id=\"p4\">**</bpt><ph id=\"ph4\">\\#</ph>macrolib<ept id=\"p4\">**</ept> macro (see output <ph id=\"ph5\">\\_</ph>BB).","pos":[31192,31350],"source":"After a \\#macrolib directive is issued for **MacLib23**, **\\#define** and **\\#undef** directives have no effect on the **\\#macrolib** macro (see output \\_BB)."},{"content":"However, a <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>define<ept id=\"p1\">**</ept> in the contents of a <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\#</ph>macrolib<ept id=\"p2\">**</ept> macro can be overwritten by a subsequent <ph id=\"ph3\">\\#</ph>define or <bpt id=\"p3\">**</bpt><ph id=\"ph4\">\\#</ph>undef<ept id=\"p3\">**</ept> in the code (see output <ph id=\"ph5\">\\_</ph>DD).","pos":[31351,31506],"source":" However, a **\\#define** in the contents of a **\\#macrolib** macro can be overwritten by a subsequent \\#define or **\\#undef** in the code (see output \\_DD)."},{"pos":[32555,32577],"content":"\\#linenumber Directive","linkify":"\\#linenumber Directive","nodes":[{"content":"<ph id=\"ph1\">\\#</ph>linenumber Directive","pos":[0,22],"source":"\\#linenumber Directive"}]},{"content":"You can use the <ph id=\"ph1\">\\#</ph>linenumber directive during your development and debugging of code.","pos":[32578,32663],"source":"You can use the \\#linenumber directive during your development and debugging of code."},{"content":"It is replaced by the physical line number in the code file.","pos":[32664,32724]},{"pos":[32730,32742],"content":"Code example","linkify":"Code example","nodes":[{"content":"Code example","pos":[0,12]}]},{"pos":[32744,32827],"content":"The following X++ code sample shows the behavior of the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>linenumber<ept id=\"p1\">**</ept> directive.","source":"The following X++ code sample shows the behavior of the **\\#linenumber** directive."},{"pos":[33197,33220],"content":"Range (scope) of macros","linkify":"Range (scope) of macros","nodes":[{"content":"Range (scope) of macros","pos":[0,23]}]},{"content":"The range in which a macro can be referenced depends on where the macro is defined.","pos":[33221,33304]},{"content":"In a class, macros that are defined in the parent class can be referenced, but macros defined in a child class cannot be referenced.","pos":[33305,33437]},{"content":"When the precompiler handles a child class, the precompiler first traces the inheritance chain to the most ascendant class.","pos":[33438,33561]},{"content":"The precompiler processes all the directives from the class declaration part of the ascendant class.","pos":[33562,33662]},{"content":"It stores all the macros and their values in its internal tables.","pos":[33663,33728]},{"content":"The precompiler handles the next class in the inheritance chain the same way.","pos":[33729,33806]},{"content":"The result of the directives in each class declaration are applied to the internal tables that are already populated from directives that were found earlier in the inheritance chain.","pos":[33807,33989]},{"content":"When the precompiler reaches the target child class, it again handles the class declaration part.","pos":[33990,34087]},{"content":"However, it next handles each method in a series of separate operations.","pos":[34088,34160]},{"content":"The precompiler updates its internal tables in a way that the state of the tables can be restored as they were before processing of the current method began.","pos":[34161,34318]},{"content":"After the first method is handled, the internal tables are restored before the next method is handled.","pos":[34319,34421]},{"pos":[34428,34466],"content":"The Method is All Contents of the Node","linkify":"The Method is All Contents of the Node","nodes":[{"content":"The Method is All Contents of the Node","pos":[0,38]}]},{"content":"In this context, a method is defined as the contents of a method node in the Application Object Tree (AOT).","pos":[34468,34575]},{"content":"In the AOT, you can expand the Classes node, expand a class node, right-click a method node, and then select Edit.","pos":[34576,34690]},{"content":"Then you can add a line for <ph id=\"ph1\">\\#</ph>define.MyMacro(\"abc\") before the method declaration.","pos":[34691,34773],"source":" Then you can add a line for \\#define.MyMacro(\"abc\") before the method declaration."},{"content":"The precompiler treats this <ph id=\"ph1\">\\#</ph>define directive as part of the method, even though the <ph id=\"ph2\">\\#</ph>define occurs outside the {} block of the method.","pos":[34774,34911],"source":" The precompiler treats this \\#define directive as part of the method, even though the \\#define occurs outside the {} block of the method."},{"pos":[34917,34960],"content":"Class Inheritance and Macro Reference Range","linkify":"Class Inheritance and Macro Reference Range","nodes":[{"content":"Class Inheritance and Macro Reference Range","pos":[0,43]}]},{"content":"The following code example demonstrates the range of macro referencing in class inheritance scenarios.","pos":[34962,35064]},{"content":"The primary line to notice in the method's output is the line labeled ClassC<ph id=\"ph1\">\\_</ph>h.","pos":[35065,35145],"source":" The primary line to notice in the method's output is the line labeled ClassC\\_h."},{"content":"It shows that a macro defined in a grandparent class can be referenced in a method of the grandchild class.","pos":[35146,35253]},{"content":"Another important line in the output is labeled ClassA<ph id=\"ph1\">\\_</ph>k.","pos":[35254,35312],"source":" Another important line in the output is labeled ClassA\\_k."},{"content":"This line shows that a macro defined in a method is not available in other methods.","pos":[35313,35396]},{"content":"ClassA is the base class and it defines several macros in its class declaration.","pos":[35397,35477]},{"content":"Its descendant classes reference these macros.","pos":[35478,35524]},{"content":"The base class also defines a macro inside one of its methods.","pos":[35525,35587]},{"content":"A second method in this class determines the macro is defined out of range and cannot be referenced in the second method.","pos":[35588,35709]},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>undef.MacroRange333<ept id=\"p1\">**</ept> in the method <bpt id=\"p2\">**</bpt>UseOtherMethodMacro<ept id=\"p2\">**</ept> affects the availability of macro <bpt id=\"p3\">**</bpt>MacroRange333<ept id=\"p3\">**</ept> in the rest of that method.","pos":[35710,35857],"source":" The **\\#undef.MacroRange333** in the method **UseOtherMethodMacro** affects the availability of macro **MacroRange333** in the rest of that method."},{"content":"Descendant classes can still reference <bpt id=\"p1\">**</bpt>MacroRange333<ept id=\"p1\">**</ept>.","pos":[35858,35915],"source":" Descendant classes can still reference **MacroRange333**."},{"content":"ClassB extends ClassA and it undefines the macro <bpt id=\"p1\">**</bpt>MacroRangeA<ept id=\"p1\">**</ept> that is defined in its parent class.","pos":[35916,36017],"source":" ClassB extends ClassA and it undefines the macro **MacroRangeA** that is defined in its parent class."},{"content":"This makes the macro unavailable to any class that extends the present class.","pos":[36018,36095]},{"content":"The present class also redefines the macro <bpt id=\"p1\">**</bpt>MacroRangeB<ept id=\"p1\">**</ept> that is defined in its parent class.","pos":[36096,36191],"source":" The present class also redefines the macro **MacroRangeB** that is defined in its parent class."},{"content":"This changes the value of the macro (from positive to negative).","pos":[36192,36256]},{"content":"ClassC extends ClassB and it uses <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\#</ph>ifnot<ept id=\"p1\">**</ept> to demonstrate that it cannot access the <bpt id=\"p2\">**</bpt>MacroRangeA<ept id=\"p2\">**</ept> macro that the base class, ClassInheritanceOfMacrosCBase1, defines.","pos":[36257,36427],"source":" ClassC extends ClassB and it uses **\\#ifnot** to demonstrate that it cannot access the **MacroRangeA** macro that the base class, ClassInheritanceOfMacrosCBase1, defines."},{"content":"The reason is that the mid-level class undefined the macro.","pos":[36428,36487]},{"content":"This class also demonstrates that it can access the macro <bpt id=\"p1\">**</bpt>MacroRange333<ept id=\"p1\">**</ept> that ClassInheritanceOfMacrosCBase1 class defines.","pos":[36488,36614],"source":" This class also demonstrates that it can access the macro **MacroRange333** that ClassInheritanceOfMacrosCBase1 class defines."},{"content":"TestClass contains a method that calls the demonstration methods and displays the results.","pos":[36615,36705]}],"content":"---\n# required metadata\n\ntitle: Macros in X++\ndescription: This topic describes how to create and use macros in X++.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 2016-09-01 19 - 30 - 15\nms.topic: \nms.prod: \nms.service: \nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \n# ms.reviewer: 61\nms.search.scope: AX 7.0.0, Operations\n# ms.tgt_pltfrm: \nms.custom: 189441\nms.assetid: a2de1498-2c9d-4c5d-b396-5c8703a5ef72\nms.search.region: Global\n# ms.search.industry: \nms.author: robinr\nms.dyn365.ops.intro: 01-02-2016\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# Macros in X++\n\nThis topic describes how to create and use macros in X++.\n\nPrecompiler directives are processed before the the code is compiler. The directives declare and handle macros and their values. The directives are removed by the precompiler so that the X++ compiler never encounters them. The X++ compiler only sees the sequence of characters written into the X++ code by the directives.\n\n## \\#define and \\#if directives\nAll precompiler directives and symbols begin with the \\# character. A macro can be defined at any point in the code. The variable can have a value that is a sequence of characters, but it is not required to have a value. The **\\#define** directive tells the precompiler to create the macro variable, including an optional value. The **\\#if** directive tests whether the variable is defined, and optionally, whether it has a specific value. The X++ precompiler directives, the macro names that they define, and the **\\#if** directive value tests are all case-insensitive. However, it is a best practice to begin macro names with an uppercase letter.\n\n### Code example\n\nIn the following code sample, a macro named **MyMacro** is defined. It is not given a value in the **\\#define.MyMacro** definition line. Therefore it behaves as if the value is a zero-length sequence of characters. The **\\#if.MyMacro** statement tests whether **MyMacro** is defined. Because **MyMacro** is defined, the lines of code before the first **\\#endif** are included in the X++ code at the test location. Near the end of the example there is an **\\#ifnot.MyMacro** test. Because **MyMacro** is defined, that test is false and no lines are written into the X++ code. After the precompile phase ends for this method, the **MyMacro** definition goes out of scope and is no longer known to the system.\n\n    static void SimpleDefineIfJob(Args _args)\n    {\n        str sTest = \"Initial value.\";\n        \n        #define.MyMacro // MyMacro is now defined.\n        #if.MyMacro\n            sTest = \"Yes, MyMacro is defined.\";\n            info(sTest);\n        #endif\n        // Notice the non-code sentence line causes no X++ compiler error,\n        // because the X++ compiler never sees it.\n        #ifnot.MyMacro\n            The X++ compiler would reject this sentence.\n            sTest = \"No, MyMacro is not defined.\";\n            info(sTest);\n        #endif\n    /********** Actual output\n    Message (03:46:20 pm)\n    Yes, MyMacro is defined.\n    **********/\n    }\n\n## Precompile and Compile Error Messages\nWhen you are developing code that contains macros, you must understand whether an error message is generated during the precompile or the compile phase. The two key words to look for are:\n\n-   Lexical – This indicates a precompile error.\n-   Syntax – This indicates a compile error.\n\nThe following code example has a lexical error caused by the first closing parenthesis, which marks the end of the directive. Therefore the precompiler is confused by the last two characters, \"\";)\".\n\n    #define.MyMacro1(info(\"Hello\");)\n\nThe following code example has a syntax error caused by using the non-existent **++++** operator. The X++ compiler encounters this operator after **\\#MyMacro2** is replaced by the macro value.The macro definition is correct even though its value is not accepted X++ syntax.\n\n    #define.MyMacro2(++++iTest;) \n    #MyMacro2\n\n## \\#undef directive\nYou can use the **\\#undef** directive to remove a macro definition that exists from a previous **\\#define.** After a macro name has been created by **\\#define** and then removed by **\\#undef,** the macro can be created again by another **\\#define.** **\\#undef** has no effect on macros that are created by the **\\#localmacro** directive. In the following code sample, the macro **MyMacro** is undefined by using the \\#undef directive. The \\#undef occurs between the two \\#if tests for its existence. The output shows only the first \\#if test was true.\n\n    static void UndefMacroJob(Args _args)\n    {\n        #define.MyMacro\n        #if.MyMacro\n            info(\"Macro is defined (1)\");\n        #endif\n        #undef.MyMacro // Removes the macro.\n        #if.MyMacro\n            info(\"Macro is defined (2)\");\n        #endif\n    /************* Actual output\n    Message (10:19:15 am)\n    Macro is defined (1)\n    *************/\n    }\n\n## Use a Macro Value\nYou can define a macro name to have a value. A macro value is a sequence of characters. A macro value is not a string (or **str**) in the formal sense of a data type. You assign a value to a macro by appending the value enclosed in parentheses at the end of a \\#define directive. You can use the macro symbol where you want the value to occur in the X++ code. A macro symbol is the name of the macro with the \\# character added as a prefix. The following code sample shows a macro symbol **\\#MyMacro.** The symbol is replaced by the value of the macro.\n\n    static void MacroWithIntValueJob(Args _args)\n    {\n        int iTest = 8;\n        ;\n        #define.MyMacro(32)\n        // This next #define, which has no value for the macro name,\n        // would not disrupt the value 32 set by the previous #define.\n        //#define.MyMacro\n        // This next #define, which has a different value than 32,\n        // would overwrite the value 32 set by the previous #define.\n        //#define.MyMacro(444)\n        iTest = #MyMacro;\n        info(int2str(iTest));\n    /**********  Actual output\n    Message (04:33:49 pm)\n    32\n    **********/\n    }\n\n## Test a Macro Value\nYou can test a macro to see whether it has a value. You can also test to see whether its value is equal to a specific sequence of characters. These tests enable you to conditionally include lines of code in your X++ program. There is no way you can test whether a defined macro has a value. You can only test whether a specific value matches the value of a macro. As a best practice, any macro name that you define should always have a value, or it should never have a value. When you alternate between these modes, your code becomes difficult to understand. For macros that have a value, you can vary the value when you see fit. In the following code sample, two **\\#if** tests are run to determine whether the macro **MyIntMacro** exists. The **\\#if.MyIntMacro()** test is true. This syntax behaves the same as **\\#if.MyIntMacro.**\n\n    static void TestMacroValue6Job(Args _args)\n    {\n        #define.MyIntMacro(66)\n        // #if tests.\n        #if.MyIntMacro()\n            info(\"A: \" + int2str(#MyIntMacro));\n        #endif\n        #if.MyIntMacro(66)\n            info(\"B: \" + int2str(#MyIntMacro));\n        #endif\n        // #ifNOT tests.\n        #ifNOT.MyIntMacro(7777)\n            info(\"C: \" + int2str(#MyIntMacro));\n        #endif\n        #ifNOT.No_Such_Macro_Name(66)\n            info(\"D: \" + int2str(#MyIntMacro));\n        #endif\n    /****************  Actual output\n    Message (11:24:47 am)\n    A: 66\n    B: 66\n    C: 66\n    D: 66\n    ****************/\n    }\n\nThe following code sample shows the **\\#if.DebugMacro(heavy)** directive that tests the value of the **DebugMacro** macro. If the value is the five character sequence **heavy**, then the test is true.\n\n    static void TestMacroSpecificValue8Job(Args _args)\n    {\n        ;\n        // Uncomment either one of these defines, or neither.\n        //#define.DebugMacro(light) // This line for: light debugging.\n        #define.DebugMacro(heavy) // This line for: heavy debugging.\n        #if.DebugMacro\n            info(\"Starting the job.\");\n        #endif\n        #if.DebugMacro(heavy)\n            info(\"UTC == \"\n                + DateTimeUtil ::toStr\n                    (DateTimeUtil::utcNow()\n                    )\n                );\n        #endif\n        // Do something useful here.\n    /**********  Actual output\n    Message (01:58:12 pm)\n    Starting the job.\n    UTC == 2007-12-05T21:58:12\n    **********/\n    }\n\n## \\#defInc and \\#defDec directives\n**\\#defInc** and **\\#defDec** are the only directives that interpret the value of a macro and they apply apply only to macros that have a value that can be converted to the formal **int** type. The value can only contain numerals. The only non-numeric character allowed is a leading negative sign (-). The integer value is treated as an X++ **int**, not as an **int64**. For macro names that are used by the **\\#defInc** directive, it is important that the **\\#define** directive that creates the macro not reside in a class declaration. The behavior of **\\#defInc** in these cases is unpredictable. Instead, such macros should be defined in only a method. We recommend that the **\\#defInc** and **\\#defDec** directives only be used for macros that have an integer value. The precompiler follows special rules for **\\#defInc** when the macro value is not an integer, or when the value is unusual or extreme. The following table lists the values that **\\#defInc** converts to zero (0) and then increments. When a value is converted to 0 by **\\#defInc,** the original value cannot be recovered, not even by **\\#defDec.**\n\n| Macro value       | Behavior                                                                                                                                                                                               |\n|-------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| (+55)             | The positive sign (+) prefix makes the precompiler treat this as a non-numeric string. The precompiler treats all non-numeric strings as 0 when it handles a **\\#defInc** (or **\\#defDec)** directive. |\n| (\"3\")             | Integers enclosed in quotation marks are treated as 0. The quotation marks are discarded, and these changes persist.                                                                                   |\n| ( )               | A string of spaces is treated as 0, and then incremented.                                                                                                                                              |\n| ()                | A zero-length string is treated as 0, and then incremented, when the value is enclosed in parentheses, as in **\\#define.MyMac().**                                                                     |\n| (Random string.)  | Any non-numeric string of characters is treated as 0, and then incremented.                                                                                                                            |\n| (0x12)            | Hexadecimal numbers are treated as non-numeric strings. Therefore they are converted to 0, and then incremented.                                                                                       |\n| (-44)             | Negative numbers are acceptable, including integers without the negative sign (-).                                                                                                                     |\n| (2147483647)      | The maximum positive **int** value is changed to the minimum negative **int** value by \\#defInc.                                                                                                       |\n| (999888777666555) | Any large number, beyond the capacity of **int** and **int64**. This is treated as the maximum positive **int** value.                                                                                 |\n| (5.8)             | Real numbers are truncated by \\#defDec (and \\#defInc). Subsequent symbol substitution shows that the truncation persists.                                                                              |\n|                   | When no value and no parentheses are provided for the directive \\#define.MyValuelessMacro, the precompiler rejects use of the directive \\#defInc.MyValuelessMacro.                                     |\n\n### Code example\n\nIn the following code sample, the initial value of the macro **CounterMacroA** is a string that can be converted into an integer. The sample shows how the **\\#defInc** and **\\#defDec** directives can be used for this macro name.\n\n    static void SimpleDefINCJob(Args _args)\n    {\n        ;\n        #define.CounterMacroA(1)\n        #defInc.CounterMacroA\n        info(\"mg11: # CounterMacroA == \" + int2str(#CounterMacroA));\n        #if.CounterMacroA(2)\n            info(\"mg12: # if confirms CounterMacroA == 2\");\n        #endif\n        #defDec.CounterMacroA\n        info(\"mg23: # CounterMacroA == \" + int2str(#CounterMacroA));\n        #if.CounterMacroA(1)\n            info(\"mg24: # if confirms CounterMacroA == 1\");\n        #endif\n    /**************  Actual Infolog output\n    Message (12:47:57 pm)\n    mg11: # CounterMacroA == 2\n    mg12: # if confirms CounterMacroA == 2\n    mg23: # CounterMacroA == 1\n    mg24: # if confirms CounterMacroA == 1\n    **************/\n    }\n\n## \\#globaldefine directive\nThe **\\#globaldefine** directive is similar to the **\\#define** directive. The difference is that **\\#define** directives generally take precedence over **\\#globalmacro** directives. This is true regardless of which directive occurs first in the X++ code. A **\\#globaldefine** never overwrites a **\\#define** directive that has both a macro name and a value. A **\\#globaldefine** can overwrite another **\\#globaldefine. **A **\\#define** directive that has only a name does not overwrite a \\#globalmacro that has both a name and a value. It is recommended that you use **\\#define,** and that you do not use **\\#globaldefine.** Use of **\\#globaldefine** can create uncertainty that makes code difficult to maintain. The exact semantics of **\\#globaldefine** cannot be achieved through **\\#if** test directives. By using **\\#if** tests you can avoid overwriting a **\\#define** and a **\\#globaldefine.** But **\\#if** tests cannot distinguish between **\\#define** and **\\#globaldefine** macros. The following code sample is the closest you can come to achieving the **\\#globaldefine** semantic with other directives such as **\\#if.**\n\n    static void IfNotDefineNestGlobalJob (Args _args)\n    {\n        ;\n        #undef.MaybeMac\n        #ifnot.MaybeMac\n            #define.MaybeMac(4444) // Works.\n        #endif\n        #if.MaybeMac\n            info(int2str(#MaybeMac));\n        #endif\n    /**********************  Actual Infolog output\n    Message (07:43:32 pm)\n    4444\n    **********************/\n    }\n\n### Code example\n\nThe following code sample shows a difference in the behavior of **\\#define** and **\\#globaldefine.** Following the code sample is a table explaining the conclusions from the output. The primary test case in the code sample is labeled **12**.\n\n    static void InteractDefineGlobalJob(Args _args)\n    {\n        ;\n        // Pairs of #define - #globaldefine directives (same macro names).\n        #define.11_DEFINEvalue_GLOBALnoval(\"11__DEFINE.\")\n        #globaldefine.11_DEFINEvalue_GLOBALnoval\n        #define.12_DEFINEnoval_GLOBALvalue\n        #globaldefine.12_DEFINEnoval_GLOBALvalue(\"12_GLOBAL.\")\n        #define.13_DEFINEvalue_GLOBALvalue(\"13__DEFINE.\")\n        #globaldefine.13_DEFINEvalue_GLOBALvalue(\"13_GLOBAL.\")\n        // Pairs of #globaldefine - #define directives.\n        #globaldefine.27_GLOBALvalue_DEFINEnoval(\"27_GLOBAL.\")\n        #define.27_GLOBALvalue_DEFINEnoval\n        #globaldefine.28_GLOBALnoval_DEFINEvalue\n        #define.28_GLOBALnoval_DEFINEvalue(\"28__DEFINE.\")\n        #globaldefine.29_GLOBALvalue_DEFINEvalue(\"29_GLOBAL.\")\n        #define.29_GLOBALvalue_DEFINEvalue(\"29__DEFINE.\")\n        // Pairs of same directive types.\n        #define.50_DEFINEvalue_DEFINEnoval(\"50__DEFINE 1.\")\n        #define.50_DEFINEvalue_DEFINEnoval\n        #globaldefine.64_GLOBALvalue_GLOBALnoval(\"64_GLOBAL 1.\")\n        #globaldefine.64_GLOBALvalue_GLOBALnoval\n        #globaldefine.65_GLOBALnoval_GLOBALvalue\n        #globaldefine.65_GLOBALnoval_GLOBALvalue(\"65_GLOBAL 2.\")\n        #globaldefine.66_GLOBALvalue_GLOBALvalue(\"66_GLOBAL 1.\")\n        #globaldefine.66_GLOBALvalue_GLOBALvalue(\"66_GLOBAL 2.\")\n        // Infolog outputs.\n        info(#11_DEFINEvalue_GLOBALnoval);\n        info(#12_DEFINEnoval_GLOBALvalue);\n        info(#13_DEFINEvalue_GLOBALvalue);\n        info(#27_GLOBALvalue_DEFINEnoval);\n        info(#28_GLOBALnoval_DEFINEvalue);\n        info(#29_GLOBALvalue_DEFINEvalue);\n        info(#50_DEFINEvalue_DEFINEnoval);\n        info(#64_GLOBALvalue_GLOBALnoval);\n        info(#65_GLOBALnoval_GLOBALvalue);\n        info(#66_GLOBALvalue_GLOBALvalue);\n    /*****************************  Actual Infolog output\n    Message (09:31:26 pm)\n    11__DEFINE.\n    12_GLOBAL. Shows that #globaldefine overwrites #define when #globaldefine is giving a value to an existing macro that has no value.Test cases 13 and 29 are more common and realistic.\n    13__DEFINE. Shows that #define usually takes precedence over #globaldefine, regardless of which directive occurs first in the X++ code.Test case 12 shows this is not always true.\n    27_GLOBAL.\n    28__DEFINE.\n    29__DEFINE. Shows that #define usually takes precedence over #globaldefine, regardless of which directive occurs first in the X++ code.Test case 12 shows this is not always true.\n    50__DEFINE 1. Shows that a #globaldefine that has a name but no value does not overwrite a #globaldefine that has both a name and a value. The same is true between a pair of #define directives.This resembles test case 12.\n    64_GLOBAL 1. Shows that a #globaldefine that has a name but no value does not overwrite a #globaldefine that has both a name and a value. The same is true between a pair of #define directives.This resembles test case 12.\n    65_GLOBAL 2. Shows that a #globaldefine that has both a name and a value overwrites a previous #globaldefine.\n    66_GLOBAL 2. Shows that a #globaldefine that has both a name and a value overwrites a previous #globaldefine.\n    *****************************/\n    }\n\n## Macro parameters\nYou can define macro values to include parameter symbols. The first parameter symbol is %1, the second is %2, and so on. You pass values for the parameters when you reference the macro symbol name for expansion. Macro parameter values are character sequences of no formal type, and they are comma delimited. There is no way to pass in a comma as part of a parameter value. The number of parameters passed can be less than, greater than, or equal to the number of parameters that the macro value is designed to receive. The system tolerates mismatches in the number of parameters passed. If fewer parameters are passed than the macro expects, each omitted parameter is treated as a zero-length sequence of characters. In the following code sample, **MyMacro** is defined to have a value that contains parameters. Macro substitution symbols are given with parameter values in parentheses.\n\n    static void MacroParameterSubstitutionJob(Args _args)\n    {\n        ;\n        #define.MyMacro(\"One == [%1] ,  Two == [%2]\")\n        // Make parameter substitutions:\n        info(\"AA: \" + #MyMacro(Apple));\n        info(\"BB: \" + #MyMacro(Apple,Banana));\n        info(\"CC: \" + #MyMacro(Apple, Banana, cranberry));\n        info(\"DD: \" + #MyMacro(,Apple,Banana));\n        info(\"EE: \" + #MyMacro());\n        info(\"FF: \" + #MyMacro);\n    /************  Actual Infolog output\n    Message (03:22:07 pm)\n    AA: One == [Apple] ,  Two == []\n    BB: One == [Apple] ,  Two == [Banana]\n    CC: One == [Apple] ,  Two == [ Banana]\n    DD: One == [] ,  Two == [Apple]\n    EE: One == [] ,  Two == []\n    FF: One == [] ,  Two == []\n    ************/\n    }\n\n## \\#localmacro and \\#globalmacro directives\nThe **\\#localmacro** directive is a good choice when you want a macro to have a value that is several lines long, or when your macro value contains a closing parenthesis. The **\\#localmacro** directive is a good choice when you want your macro value to be lines of X++ or SQL code. The **\\#localmacro** directive can be written as **\\#macro.** However, **\\#localmacro** is the recommended term. Both macros have the same behavior. By using the **\\#if** directive, you can test whether a macro name is declared with the **\\#define** directive. However, you cannot test whether the macro name is declared with the **\\#localmacro** directive. Only macros declared by using the **\\#define** directive are affected by the **\\#undef** directive. In a **\\#define** directive, you can specify a name that is already in scope as a **\\#localmacro.** The effect is to discard the **\\#localmacro** and create a **\\#define** macro. This also applies to the opposite sequence, which means that a **\\#localmacro** can redefine a **\\#define.** A **\\#localmacro** (that has both a macro name and a value) always overrides a previous **\\#localmacro** that has the same name. However, you cannot always be sure whether the override occurs when you use **\\#globalmacro.** For this reason we recommend that you do not use **\\#globalmacro. **This same problem occurs with **\\#globaldefine.** The main difference between a **\\#define** macro and a **\\#localmacro** macro is in how their syntax is terminated. The terminators are as follows:\n\n-   **\\#define** – is terminated by– **)**\n-   **\\#localmacro** – is terminated by– **\\#endmacro**\n\n**\\#localmacro** is a better choice for macros with multiple line values. Multiple line values are typically lines of X++ or SQL code. X++ and SQL contain lots of parentheses, and these would prematurely terminate a \\#define. Both **\\#define** and **\\#localmacro** can be declared and terminated on either a single line or on subsequent lines. In practice, the **\\#define** is terminated on the same line that it is declared on. In practice, the **\\#localmacro** is terminated on a subsequent line. Where both macro names and values are supplied, the **\\#globalmacro** directive cannot override the \\#define directive. Also, the **\\#globaldefine** directive cannot override the **\\#localmacro** directive.\n\n### Code examples\n\nThe following code sample shows how to use the **\\#localmacro** directive. It demonstrates that the **\\#undef** directive does not affect **\\#localmacro** macros. It also shows that \\#if tests cannot determine whether a **\\#localmacro** macro has been defined.\n\n    static void LocalMacroJob(Args _args)\n    {\n        ;\n        #localmacro.LMacReportLog\n            print(\"%1  --LM, print.\");\n            info(\"%1  --LM, Infolog.\");\n        #endmacro\n        #LMacReportLog(g11: Hello World )\n        #if.LMacReportLog\n            info(\"The # IF LMacReportLog is true\");\n        #endif\n        #undef.LMacReportLog\n        #LMacReportLog(g22: Greetings World)\n        #localmacro.LMacReportLog\n        #endmacro // No lines for value before this end.\n        #LMacReportLog(g33: Bye Bye) // Not present in the output.\n    /*************  Actual Infolog output\n    Message (03:10:17 pm)\n    g11: Hello World   --LM, Infolog.\n    g22: Greetings World  --LM, Infolog.\n    *************/\n    }\n\nThe following X++ code sample shows that **\\#localmacro** overrides a **\\#globalmacro** of the same macro name, but that **\\#globalmacro** does not override **\\#localmacro.**\n\n    static void GlobalMacroNotOverrideJob(Args _args)\n    {\n        ;\n        //---------  LGMa ,  L then G  ---------\n        #localmacro.LGMa\n            info(\"LGMa: Loc 11\");\n        #endmacro\n        #globalmacro.LGMa\n            info(\"LGMa: Glob 12\");\n        #endmacro\n        #LGMa\n        //---------  LGMb ,  G then L  ---------\n        #globalmacro.LGMb\n            info(\"LGMb: Glob 24\");\n        #endmacro\n        #localmacro.LGMb\n            info(\"LGMb: Loc 25\");\n        #endmacro\n        #LGMb\n    /****************  Actual Infolog output\n    Message (06:39:42 am)\n    LGMa: Loc 11\n    LGMb: Loc 25\n    ****************/\n    }\n\n## Nesting Macro Symbols\nYou can nest precompiler definition directives inside an outer definition directive. The main definition directives are **\\#define** and **\\#localmacro. **The cases for which this topic provides code samples are as follows:\n\n-   Transitive substitution: A **\\#define** macro can have the symbol for another macro as its value. Transitive substitution of the symbol occurs in X++ code.\n-   No transitive substitution: An **\\#if** directive test of a macro value does not perform substitutions.\n-   Macro within a macro: A \\#define directive can be given inside a **\\#localmacro** directive, or a **\\#localmacro** can be inside a **\\#define.**\n\n### Transitive Substitution\n\nIn the following code sample, the value of the first **\\#define** variable includes a symbol (\\#D) of the second **\\#define** variable. This works even though the expansion symbol \\#D occurs before macro **D** is defined.\n\n    static void NestMacroJobA1(Args _args)\n    {\n        ;\n        #define.Cd(\"Cd +: # D == \" + #D)\n        // If not commented out, this next code line would cause the\n        // error message \"The macro does not exist.\", because\n        // #D in the value of #Cd cannot be expanded before it is defined.\n        //info(#Cd);\n        #define.D(\"D\")\n        info(#Cd);\n    /************  Actual Infolog output\n    Message (10:42:13 am)\n    Cd +: # D == D\n    ************/\n    }\n\n### No transitive substitution\n\nThe following code sample tries to determine whether two macro variables have the same value, without specifying what that value might be. The output shows that this determination cannot be made..\n\n    static void NestMacroJobA2(Args _args)\n    {\n        ;\n        #define.A1(5)\n        #define.A2(5)\n        info(\"Status: A1==\" + int2Str(#A1) + \" , A2==\" + int2Str(#A2));\n        #if.A1(#A2)\n            info(\"Yes, symbol substitution does work on # IF test.  Unexpected.\");\n        #endif\n        #ifNOT.A1(#A2)\n            info(\"No, symbol substitution does not work on # IF test.\");\n        #endif\n    /************  Actual Infolog output\n    Message (11:27:38 am)\n    Status: A1==5 , A2==5\n    No, symbol substitution does not work on # IF test.\n    ************/\n    }\n\nThe following code sample shows that the \\#defInc directive does not lead to transitive substitution of symbol values. For more information about the \\#defInc directive, see How to: Use the \\#defInc and \\#defDec Directives. After the \\#defInc.E2 directive, the subsequent output value for \\#E2 shows the value for **E2** is converted to zero (0) by \\#defInc.E2 before it is incremented to one (1). Before the conversion, the value of **E2** was the three characters \\#E2. The output for test case **36** shows the value has been converted to 1.\n\n    static void NestMacroJobA4(Args _args)\n    {\n        ;\n        #define.E1(5)\n        #define.E2(#E1)\n        info(\"11:  # E1 == \" + int2Str(#E1));\n        info(\"12:  # E2 == \" + int2Str(#E2));\n        #defInc.E1\n        info(\" -------\");\n        info(\"23: After Inc.E1,  # E1 == \" + int2Str(#E1));\n        info(\"24: After Inc.E1,  # E2 == \" + int2Str(#E2));\n        #defInc.E2\n        info(\" -------\");\n        info(\"35: After Inc.E2,  # E1 == \" + int2Str(#E1));\n        info(\"36: After Inc.E2,  # E2 == \" + int2Str(#E2));\n    /************  Actual Infolog output\n    Message (02:39:41 pm)\n    11:  # E1 == 5\n    12:  # E2 == 5\n     -------\n    23: After Inc.E1,  # E1 == 6\n    24: After Inc.E1,  # E2 == 6\n     -------\n    35: After Inc.E2,  # E1 == 6\n    36: After Inc.E2,  # E2 == 1\n    ************/\n    }\n\n### Macro within a macro\n\nA **\\#define** directive can be given inside a **\\#localmacro** directive, and a **\\#localmacro** can be inside a \\#define. This is shown in the following code sample.\n\n    static void NestMacroJobB5(Args _args)\n    {\n        int iTest = 31;\n        ;\n        //-------------  J  ---------------\n        #localmacro.LocMacOuterJL\n            #define.DefinInnerJD(5)\n        #endmacro\n        #LocMacOuterJL\n        info(\"J: Directive nesting works if 5 appears: # DefinInnerJD == \"\n                + int2Str(#DefinInnerJD));\n        //-------------  K  ---------------\n        #define.DefinOuterKD(#localmacro.LocMacInnerKL ++iTest; #endmacro)\n        ++iTest; // Result is 32.\n        #DefinOuterKD\n        #LocMacInnerKL\n        info(\"K: Directive nesting works if 33 appears: iTest == \"\n                + int2Str(iTest));\n    /**************  Actual Infolog output\n    Message (11:21:02 am)\n    J: Directive nesting works if 5 appears: # DefinInnerJD == 5\n    K: Directive nesting works if 33 appears: iTest == 33\n    **************/\n    }\n\n## \\#macrolib directive\nIn the Application Explorer under the Macros node, there are many library nodes that contain sets of macro directives. Both **\\#define** and **\\#localmacro** often appear in the contents of these macro libraries. You can use the **\\#macrolib.MyAOTMacroLibrary** to include the contents of a macro library in your X++ code. The **\\#if** and **\\#undef** directives do not apply to **\\#macrolib** names. However, they do apply to **\\#define** directives that are the contents of a **\\#macrolib** macro. The directive **\\#macrolib.MyAOTMacroLibrary** can also be written as **\\#MyAOTMacroLibrary.** The **\\#macrolib** prefix is recommended because it is never ambiguous to a person who later reads the code.\n\n### Create a macro library\n\nTo create a macro library:\n\n1.  In **Solution Explorer,** right-click on the project, select **Add** and then **New item.**\n2.  In the **Add New Item** dialog, select Installed and then **AX Artifacts** in the left pane.\n3.  In the middle pane, select **Macro.**\n4.  Enter a name and click **Add.** Save the macro file and refresh the Application Explorer to find your macro library.\n\n### Code examples\n\nDynamics AX has an macro library that is named **Event.** This macro library contains the directive **\\#define.DefaultEventPollFrequency(15)**. The following code sample shows that the **\\#macrolib.Event** directive makes the macro **\\#DefaultEventPollFrequency** available.\n\n    static void SystemProvidedMacroLibraryJob(Args _args)\n    {\n        ;\n        #macrolib.Event // Contains: #define.DefaultEventPollFrequency(15)\n        info(\"# DefaultEventPollFrequency == \"\n                + int2str(#DefaultEventPollFrequency));\n    /***************  Actual Infolog output\n    Message (06:31:26 pm)\n    # DefaultEventPollFrequency == 15\n    ***************/\n    }\n\nThe following code example shows what happens when you write a **\\#define** for a name that is already the name of a node in the macro library. For this example, there is a node named **MacLib23,** and its contents are one **\\#define** as follows:\n\n    #define.DefinInMacLib23(\"_This is inside AOT macrolib MacLib23.\")\n\nAfter a \\#macrolib directive is issued for **MacLib23**, **\\#define** and **\\#undef** directives have no effect on the **\\#macrolib** macro (see output \\_BB). However, a **\\#define** in the contents of a **\\#macrolib** macro can be overwritten by a subsequent \\#define or **\\#undef** in the code (see output \\_DD).\n\n    static void PrecedenceMacrolibDefineJob(Args _args)\n    {\n        ;\n        #define.MacLib23(\"_11:  Plain #define value for MacLib23, same name as the AOT macrolib macro.\")\n        info(\"_AA: \" + #MacLib23);\n        #macrolib.MacLib23\n        info(\"_BB: \" + #DefinInMacLib23); // Defined inside the macrolib macro.\n        info(\"_CC: \" + #MacLib23); // Output shows plain #define, not the macrolib macro contents.\n        #define.DefinInMacLib23(\"_33:  Plain #define in the job code, overwrite of same macro name defined inside the macrolib macro.\")\n        info(\"_DD: \" + #DefinInMacLib23);\n    /***************************  Actual Infolog output\n    Message (10:53:13 am)\n    _AA: 11:  Plain #define value for MacLib23, same name as the AOT macrolib macro.\n    _BB: This is inside AOT macrolib MacLib23.\n    _CC: 11:  Plain #define value for MacLib23, same name as the AOT macrolib macro.\n    _DD: 33:  Plain #define in the job code, overwrite of same macro name defined inside the macrolib macro.\n    ***************************/\n    }\n\n## \\#linenumber Directive\nYou can use the \\#linenumber directive during your development and debugging of code. It is replaced by the physical line number in the code file.\n\n### Code example\n\nThe following X++ code sample shows the behavior of the **\\#linenumber** directive.\n\n    static void LinenumberPhysicalJob(Args _args)\n    {\n        ;\n        #define.Debug(light)\n        #if.Debug\n            info(\"Physical Line 8: # linenumber == \"\n                + int2Str(#linenumber));\n        #endif\n    /******************  Actual Infolog output\n    Message (08:55:26 pm)\n    Physical Line 8: # linenumber == 8\n    ******************/\n    }\n\n## Range (scope) of macros\nThe range in which a macro can be referenced depends on where the macro is defined. In a class, macros that are defined in the parent class can be referenced, but macros defined in a child class cannot be referenced. When the precompiler handles a child class, the precompiler first traces the inheritance chain to the most ascendant class. The precompiler processes all the directives from the class declaration part of the ascendant class. It stores all the macros and their values in its internal tables. The precompiler handles the next class in the inheritance chain the same way. The result of the directives in each class declaration are applied to the internal tables that are already populated from directives that were found earlier in the inheritance chain. When the precompiler reaches the target child class, it again handles the class declaration part. However, it next handles each method in a series of separate operations. The precompiler updates its internal tables in a way that the state of the tables can be restored as they were before processing of the current method began. After the first method is handled, the internal tables are restored before the next method is handled.\n\n#### The Method is All Contents of the Node\n\nIn this context, a method is defined as the contents of a method node in the Application Object Tree (AOT). In the AOT, you can expand the Classes node, expand a class node, right-click a method node, and then select Edit. Then you can add a line for \\#define.MyMacro(\"abc\") before the method declaration. The precompiler treats this \\#define directive as part of the method, even though the \\#define occurs outside the {} block of the method.\n\n### Class Inheritance and Macro Reference Range\n\nThe following code example demonstrates the range of macro referencing in class inheritance scenarios. The primary line to notice in the method's output is the line labeled ClassC\\_h. It shows that a macro defined in a grandparent class can be referenced in a method of the grandchild class. Another important line in the output is labeled ClassA\\_k. This line shows that a macro defined in a method is not available in other methods. ClassA is the base class and it defines several macros in its class declaration. Its descendant classes reference these macros. The base class also defines a macro inside one of its methods. A second method in this class determines the macro is defined out of range and cannot be referenced in the second method. The **\\#undef.MacroRange333** in the method **UseOtherMethodMacro** affects the availability of macro **MacroRange333** in the rest of that method. Descendant classes can still reference **MacroRange333**. ClassB extends ClassA and it undefines the macro **MacroRangeA** that is defined in its parent class. This makes the macro unavailable to any class that extends the present class. The present class also redefines the macro **MacroRangeB** that is defined in its parent class. This changes the value of the macro (from positive to negative). ClassC extends ClassB and it uses **\\#ifnot** to demonstrate that it cannot access the **MacroRangeA** macro that the base class, ClassInheritanceOfMacrosCBase1, defines. The reason is that the mid-level class undefined the macro. This class also demonstrates that it can access the macro **MacroRange333** that ClassInheritanceOfMacrosCBase1 class defines. TestClass contains a method that calls the demonstration methods and displays the results.\n\n    class ClassA\n    {\n        // Unless disturbed by other directives, these macros can\n        // be referenced by method in this class in child classes.\n        #define.MacroRangeA\n        #define.MacroRangeB(22)\n        #define.MacroRange333(333)\n\n        static void UseMacros()\n        {\n            //  This method shows that a macro that is defined\n            // in the class declaration is in range in every\n            // method in that class.\n            // This method also contains a define for macro\n            // MacroDefInMethodD, and tests outside this\n            // method determine the macro is not in range.\n            ;\n            info(\"ClassA: #MacroRangeB == \" + int2str(#MacroRangeB));\n            #define.MacroDefInMethodD // Cannot be referenced in other methods.\n        }\n\n        static void UseOtherMethodMacro()\n        {\n            // This method shows that the macro MacroDefInMethodD\n            // that was defined in another method in this class\n            // cannot be referenced in this method.\n            // This method contains an #undef of MacroRange333,\n            // yet descendant classes can still reference this macro.\n            #ifnot.MacroDefInMethodD\n            info(\"ClassA_k: This means MacroDefInMethodD is in not range here.\");\n            #endif\n            #undef.MacroRange333\n        }\n    }\n\n\n    class ClassB extends ClassA\n    {\n        // This class declaration makes the macro MacroRangeA\n        // unavailable to methods in this class and child classes.\n        // This class declaration also redefines MacroRangeB for\n        // this class and child classes.\n        #undef.MacroRangeA // Makes unavailable to child classes.\n        #define.MacroRangeB(-22) \n        // Redefining with a different value.\n        static void UseMacros()\n        {\n            // This method shows that the value for #MacroRangeB comes\n            // from its redefinition in this class, instead of from\n            // the definition in the parent class.\n          \n            info(\"ClassB_c: #MacroRangeB == \" + int2str(#MacroRangeB)\n                + \" (Is now negative due to later redefinition.)\");\n        }\n    }\n\n\n    class ClassC extends ClassB\n    {\n        static void UseMacros()\n        {\n            //   This method shows that the #undef in the parent\n            // class overwrites the #define in the grandparent class.\n            //   This method also shows that a macro defined in the\n            // grandparent class is in range in methods on this class.\n            ;\n            #ifnot.MacroRangeA\n            info(\"ClassC_f: MacroRangeA is no longer defined, due to #undef in ClassB.\");\n            #endif\n            info(\"ClassC_h: #MacroRange333 == \" + int2str(#MacroRange333)\n                + \" (Defined in ClassA.)\");\n        }\n    }\n\n\n    class TestClass\n    {\n        static void JobClassesCC(Args _args)\n        {\n            ;\n            ClassA ::UseMacros();\n            ClassA ::UseOtherMethodMacro();\n            ClassB ::UseMacros();\n            ClassC ::UseMacros();\n            /****************  Actual output\n            Message (08:10:59 am)\n            ClassA_a: #MacroRangeB == 22\n            ClassA_k: This means MacroDefInMethodD is not in range here.\n            ClassB_c: #MacroRangeB == -22 (Is now negative due to later redefinition.)\n            ClassC_f: MacroRangeA is no longer defined, due to #undef in child class ClassB.\n            ClassC_h: #MacroRange333 == 333 (Defined in ClassA.)\n            ****************/\n        }\n    }\n\n"}