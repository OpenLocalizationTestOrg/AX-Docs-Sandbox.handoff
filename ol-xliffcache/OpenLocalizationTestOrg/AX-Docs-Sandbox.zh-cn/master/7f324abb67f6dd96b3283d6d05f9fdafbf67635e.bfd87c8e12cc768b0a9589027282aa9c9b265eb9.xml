{"nodes":[{"pos":[32,65],"content":"Contextual data entry for lookups","needQuote":true,"needEscape":true,"nodes":[{"content":"Contextual data entry for lookups","pos":[0,33]}]},{"pos":[79,616],"content":"In data entry scenarios, it is common for a user to attempt to identify an entity in terms of some more descriptive or natural language attribute if that entity is formally identified by a synthetic key, such as a number sequence. The contextual data entry feature allows users to type in either the synthetic key or a more descriptive attribute directly into a lookup field. This page explains how contextual data entry works and also provides implementation details and tips for developers who want their lookups to have this behavior.","needQuote":true,"needEscape":true,"nodes":[{"content":"In data entry scenarios, it is common for a user to attempt to identify an entity in terms of some more descriptive or natural language attribute if that entity is formally identified by a synthetic key, such as a number sequence. The contextual data entry feature allows users to type in either the synthetic key or a more descriptive attribute directly into a lookup field. This page explains how contextual data entry works and also provides implementation details and tips for developers who want their lookups to have this behavior.","pos":[0,537],"nodes":[{"content":"In data entry scenarios, it is common for a user to attempt to identify an entity in terms of some more descriptive or natural language attribute if that entity is formally identified by a synthetic key, such as a number sequence.","pos":[0,230]},{"content":"The contextual data entry feature allows users to type in either the synthetic key or a more descriptive attribute directly into a lookup field.","pos":[231,375]},{"content":"This page explains how contextual data entry works and also provides implementation details and tips for developers who want their lookups to have this behavior.","pos":[376,537]}]}]},{"pos":[1123,1156],"content":"Contextual data entry for lookups","linkify":"Contextual data entry for lookups","nodes":[{"content":"Contextual data entry for lookups","pos":[0,33]}]},{"content":"In data entry scenarios, it is common for a user to attempt to identify an entity in terms of some more descriptive or natural language attribute if that entity is formally identified by a synthetic key, such as a number sequence.","pos":[1158,1388]},{"content":"The contextual data entry feature allows users to type in either the synthetic key or a more descriptive attribute directly into a lookup field.","pos":[1389,1533]},{"content":"This page explains how contextual data entry works and also provides implementation details and tips for developers who want their lookups to have this behavior.","pos":[1534,1695]},{"pos":[1697,1709],"content":"Introduction","linkify":"Introduction","nodes":[{"content":"Introduction","pos":[0,12]}]},{"content":"In data entry scenarios, it is common for a user to attempt to identify an entity in terms of some more descriptive or natural language attribute if that entity is formally identified by a synthetic key, such as a number sequence.","pos":[1724,1954]},{"content":"A user will typically attempt to enter an <bpt id=\"p1\">**</bpt>Account Name<ept id=\"p1\">**</ept> instead of an <bpt id=\"p2\">**</bpt>Account ID<ept id=\"p2\">**</ept> for the <bpt id=\"p3\">**</bpt>Customer Account<ept id=\"p3\">**</ept> when creating a Sales Order.","pos":[1955,2100],"source":" A user will typically attempt to enter an **Account Name** instead of an **Account ID** for the **Customer Account** when creating a Sales Order."},{"content":"This is because most interaction with a customer is done using their actual name instead of some synthetic identifier.","pos":[2101,2219]},{"content":"Unfortunately, any user’s attempt to enter an <bpt id=\"p1\">**</bpt>Account Name<ept id=\"p1\">**</ept> will fail because the <bpt id=\"p2\">**</bpt>Customer account<ept id=\"p2\">**</ept> control’s underlying foreign key relates to a field that is a synthetic key—a number sequence—and Dynamics AX 2012 (and older) will always attempt to validate the entered value directly.","pos":[2220,2512],"source":" Unfortunately, any user’s attempt to enter an **Account Name** will fail because the **Customer account** control’s underlying foreign key relates to a field that is a synthetic key—a number sequence—and Dynamics AX 2012 (and older) will always attempt to validate the entered value directly."},{"content":"Therefore, if the <bpt id=\"p1\">**</bpt>Account ID<ept id=\"p1\">**</ept> was unknown to the user, the user would be forced to perform some type of searching step, such as opening the <bpt id=\"p2\">**</bpt>Customer account<ept id=\"p2\">**</ept> control’s lookup and filtering on the <bpt id=\"p3\">**</bpt>Account Name<ept id=\"p3\">**</ept> column to identify the correct <bpt id=\"p4\">**</bpt>Account ID<ept id=\"p4\">**</ept> (see the image below).","pos":[2513,2800],"source":" Therefore, if the **Account ID** was unknown to the user, the user would be forced to perform some type of searching step, such as opening the **Customer account** control’s lookup and filtering on the **Account Name** column to identify the correct **Account ID** (see the image below)."},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>HowToContextualLookups (3)<ept id=\"p1\">](./media/howtocontextuallookups-3.png)](./media/howtocontextuallookups-3.png)</ept> This user experience is not optimal and is being addressed by data entry efficiency and productivity.","pos":[2801,3010],"source":"[![HowToContextualLookups (3)](./media/howtocontextuallookups-3.png)](./media/howtocontextuallookups-3.png) This user experience is not optimal and is being addressed by data entry efficiency and productivity."},{"content":"The platform adds initial support for contextual data entry, where the system automatically attempts to understand whether the user’s entered data is in the context of the key field or some other more descriptive or well-understood field, and handle it appropriately.","pos":[3011,3278]},{"content":"<bpt id=\"p1\">**</bpt>For the remainder of this document, we’ll generically refer to these types of fields as ID (synthetic) and NAME (descriptive) fields, respectively.<ept id=\"p1\">**</ept>","pos":[3279,3430],"source":"**For the remainder of this document, we’ll generically refer to these types of fields as ID (synthetic) and NAME (descriptive) fields, respectively.**"},{"pos":[3435,3458],"content":"Contextual lookup forms","linkify":"Contextual lookup forms","nodes":[{"content":"Contextual lookup forms","pos":[0,23]}]},{"content":"Just like keyboard data entry, all system generated lookup forms are also now contextual, meaning that filtering and sorting occur in the context of the data the user has entered.","pos":[3459,3638]},{"content":"Using the create a Sales Order scenario as an example, the user will see the lookup shown below if an ID is entered.","pos":[3639,3755]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Customer account lookup form opened in the context of ID<ept id=\"p1\">](./media/howtocontextuallookups-1.png)](./media/howtocontextuallookups-1.png)</ept> If a NAME is entered, then the user will see the following lookup.","pos":[3756,3960],"source":"[![Customer account lookup form opened in the context of ID](./media/howtocontextuallookups-1.png)](./media/howtocontextuallookups-1.png) If a NAME is entered, then the user will see the following lookup."},{"content":"Notice how the NAME column is moved first in the Grid, and how the lookup is sorted and filtered upon when the user’s data is in the context of NAME.","pos":[3961,4110]},{"content":"<ph id=\"ph1\">![</ph>Customer account lookup form opened in the context of NAME<ph id=\"ph2\">](./media/howtocontextuallookups-2.png)</ph>","pos":[4111,4210],"source":"![Customer account lookup form opened in the context of NAME](./media/howtocontextuallookups-2.png)"},{"pos":[4215,4259],"content":"Contextual data entry implementation details","linkify":"Contextual data entry implementation details","nodes":[{"content":"Contextual data entry implementation details","pos":[0,44]}]},{"pos":[4264,4272],"content":"Behavior","linkify":"Behavior","nodes":[{"content":"Behavior","pos":[0,8]}]},{"content":"In the context of the Sales order create scenario mentioned above, the contextual data entry feature will allow the user to be able to freely type in either the ID or NAME without performing any laborious search process.","pos":[4274,4494]},{"content":"In detail, the following behaviors will occur:","pos":[4495,4541]},{"content":"If the user enters a complete ID reference, the value will be taken directly.","pos":[4547,4624]},{"content":"If the user enters a complete and unique NAME reference, the value will be automatically translated into an ID and then processed.","pos":[4629,4759]},{"pos":[4764,5012],"content":"If the user enters a non-complete ID or NAME reference (such as <bpt id=\"p1\">*</bpt>Micro<ept id=\"p1\">*</ept> instead of <bpt id=\"p2\">*</bpt>Microsoft<ept id=\"p2\">*</ept>), but it still uniquely matches either ID or NAME via a BEGINS WITH predicate, then the value will be translated into its complete ID and then processed.","source":"If the user enters a non-complete ID or NAME reference (such as *Micro* instead of *Microsoft*), but it still uniquely matches either ID or NAME via a BEGINS WITH predicate, then the value will be translated into its complete ID and then processed."},{"pos":[5017,5212],"content":"If the user enters a non-complete ID or a non-unique NAME and there are multiple matches, then a <bpt id=\"p1\">*</bpt>disambiguation<ept id=\"p1\">*</ept> lookup will be presented to the user to select which value was actually intended.","source":"If the user enters a non-complete ID or a non-unique NAME and there are multiple matches, then a *disambiguation* lookup will be presented to the user to select which value was actually intended."},{"content":"See Appendix A for more detailed sample scenarios of contextual data entry.","pos":[5214,5289]},{"pos":[5295,5308],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"To maintain functional correctness and reasonable performance, the following constraints were added to the application of the behaviors described in the previous section:","pos":[5310,5480]},{"pos":[5486,5532],"content":"*****Title Field 2*<bpt id=\"p1\">**</bpt> <ept id=\"p1\">**</ept>is the NAME field****.","source":"*****Title Field 2*** **is the NAME field****."},{"content":"The NAME field must either be covered by an index <bpt id=\"p1\">***</bpt>OR<ept id=\"p1\">***</ept> belong to a Table whose <bpt id=\"p2\">*</bpt>Cache Lookup<ept id=\"p2\">*</ept> property is set to <bpt id=\"p3\">*</bpt>EntireTable<ept id=\"p3\">*</ept>.","pos":[5537,5668],"source":"The NAME field must either be covered by an index ***OR*** belong to a Table whose *Cache Lookup* property is set to *EntireTable*."},{"content":"All contextual lookup behavior will be disabled if this requirement is not met for performance reasons.","pos":[5669,5772]},{"content":"<bpt id=\"p1\">**</bpt>NOTE: An index should only be added for NON TRANSACTIONAL tables because of index maintenance costs<ept id=\"p1\">**</ept>.","pos":[5773,5877],"source":"**NOTE: An index should only be added for NON TRANSACTIONAL tables because of index maintenance costs**."},{"content":"Also note that you will <bpt id=\"p1\">**</bpt>likely want to mark this index as non-unique<ept id=\"p1\">**</ept> (Allow Duplicates = Yes).","pos":[5878,5976],"source":" Also note that you will **likely want to mark this index as non-unique** (Allow Duplicates = Yes)."},{"content":"If a control is using a custom lookup form (such as SysTableLookup; FormHelp on an EDT) then the disambiguation behavior described previously will not be turned on by default.","pos":[5981,6156]},{"content":"This is because these custom lookup forms (and even surrounding modified and lookup method overrides) can and will do advanced things such as presenting a dialog, which are not desirable in the context of contextual lookups.","pos":[6157,6381]},{"content":"Handling custom lookup forms requires additional knowledge and will be covered in its own section.","pos":[6383,6481]},{"pos":[6487,6514],"content":"Programming model additions","linkify":"Programming model additions","nodes":[{"content":"Programming model additions","pos":[0,27]}]},{"content":"The behaviors and rules expressed in <bpt id=\"p1\">*</bpt>Listings 1<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>2<ept id=\"p2\">*</ept> are contained primarily by a new X++ class called <bpt id=\"p3\">*</bpt>FormControlAmbiguousReferenceResolver<ept id=\"p3\">*</ept>.","pos":[6516,6664],"source":"The behaviors and rules expressed in *Listings 1* and *2* are contained primarily by a new X++ class called *FormControlAmbiguousReferenceResolver*."},{"content":"<bpt id=\"p1\">*</bpt>FormControlAmbiguousReferenceResolver<ept id=\"p1\">*</ept> uptake in application code will be necessary in more advanced scenarios.","pos":[6665,6777],"source":"*FormControlAmbiguousReferenceResolver* uptake in application code will be necessary in more advanced scenarios."},{"content":"Its use will be described later in the document.","pos":[6778,6826]},{"content":"In addition to the <bpt id=\"p1\">*</bpt>FormControlAmbiguousReferenceResolver<ept id=\"p1\">*</ept> class, a new control override called <bpt id=\"p2\">*</bpt>resolveAmbiguousReference<ept id=\"p2\">*</ept> has been added.","pos":[6827,6966],"source":" In addition to the *FormControlAmbiguousReferenceResolver* class, a new control override called *resolveAmbiguousReference* has been added."},{"content":"R<bpt id=\"p1\">*</bpt>esolveAmbiguousReference<ept id=\"p1\">*</ept> acts as a hook point in the system for translating what the user typed into a value that the system is expecting.","pos":[6967,7108],"source":" R*esolveAmbiguousReference* acts as a hook point in the system for translating what the user typed into a value that the system is expecting."},{"content":"The basic flow is as follows:","pos":[7109,7138]},{"content":"The user enters a value into a control and removes focus.","pos":[7144,7201]},{"content":"An interaction is sent from the client to the server, indicating that a new value has been entered.","pos":[7206,7305]},{"content":"The appropriate command is executed on the server.","pos":[7306,7356]},{"pos":[7361,7554],"content":"Before the command attempts to process the value entered by the user, it makes a call to <bpt id=\"p1\">*</bpt>resolveAmbiguousReference<ept id=\"p1\">*</ept> to give the system a chance to translate the value into the expected domain.","source":"Before the command attempts to process the value entered by the user, it makes a call to *resolveAmbiguousReference* to give the system a chance to translate the value into the expected domain."},{"pos":[7559,7717],"content":"The super implementation of resolveAmbiguousReference creates an instance of <bpt id=\"p1\">*</bpt>FormControlAmbiguousReferenceResolver<ept id=\"p1\">*</ept> which executes the rules described above.","source":"The super implementation of resolveAmbiguousReference creates an instance of *FormControlAmbiguousReferenceResolver* which executes the rules described above."},{"content":"The value returned from <bpt id=\"p1\">*</bpt>resolveAmbiguousReference<ept id=\"p1\">*</ept> is used for the remainder of the command’s execution.","pos":[7719,7824],"source":"The value returned from *resolveAmbiguousReference* is used for the remainder of the command’s execution."},{"content":"Validate() and modified() operate against the returned value.","pos":[7825,7886]},{"pos":[7891,7913],"content":"Standard lookup uptake","linkify":"Standard lookup uptake","nodes":[{"content":"Standard lookup uptake","pos":[0,22]}]},{"pos":[7918,7954],"content":"Add an index that covers TitleField2","linkify":"Add an index that covers TitleField2","nodes":[{"content":"Add an index that covers TitleField2","pos":[0,36]}]},{"content":"<bpt id=\"p1\">*</bpt>TitleField2<ept id=\"p1\">*</ept> defines the default definition of NAME.","pos":[7956,8009],"source":"*TitleField2* defines the default definition of NAME."},{"content":"In order to enable ID and NAME contextual data entry, <bpt id=\"p1\">*</bpt>TitleField2<ept id=\"p1\">*</ept> must be either indexed OR belong to a table with <bpt id=\"p2\">*</bpt>CacheLookup<ept id=\"p2\">*</ept> set to <bpt id=\"p3\">*</bpt>EntireTable<ept id=\"p3\">*</ept>.","pos":[8010,8162],"source":" In order to enable ID and NAME contextual data entry, *TitleField2* must be either indexed OR belong to a table with *CacheLookup* set to *EntireTable*."},{"content":"If the table containing <bpt id=\"p1\">*</bpt>TitleField2<ept id=\"p1\">*</ept> does not yet define an index covering <bpt id=\"p2\">*</bpt>TitleField2<ept id=\"p2\">*</ept> <bpt id=\"p3\">**</bpt>and, importantly, the table does not have a high volume of CUD (Creates/Updates/Deletes<ph id=\"ph1\">\\*</ph>)<ept id=\"p3\">**</ept>, then add a <bpt id=\"p4\">**</bpt>non-unique<ept id=\"p4\">**</ept> index (Allow Duplicates = Yes) covering <bpt id=\"p5\">*</bpt>TitleField2<ept id=\"p5\">*</ept>.","pos":[8163,8429],"source":" If the table containing *TitleField2* does not yet define an index covering *TitleField2* **and, importantly, the table does not have a high volume of CUD (Creates/Updates/Deletes\\*)**, then add a **non-unique** index (Allow Duplicates = Yes) covering *TitleField2*."},{"content":"This will cause the system to start executing the contextual data entry behavior, except for the custom lookup limitation described in the Prerequisites section.","pos":[8430,8591]},{"content":"<ph id=\"ph1\">\\*</ph>Adding an index on high-volume transactional tables may incur a noticeable performance penalty due to index maintenance costs.","pos":[8592,8720],"source":"\\*Adding an index on high-volume transactional tables may incur a noticeable performance penalty due to index maintenance costs."},{"pos":[8726,8784],"content":"Enable disambiguation behavior for custom lookup scenarios","linkify":"Enable disambiguation behavior for custom lookup scenarios","nodes":[{"content":"Enable disambiguation behavior for custom lookup scenarios","pos":[0,58]}]},{"content":"Custom lookup implementations can provide advanced or non-typical behaviors, such as presenting dialogs.","pos":[8786,8890]},{"content":"Therefore, the system disables the default disambiguation behavior when a custom lookup scenario is detected.","pos":[8891,9000]},{"content":"To opt into the default disambiguation behavior, override the <bpt id=\"p1\">*</bpt>resolveAmbiguousReference<ept id=\"p1\">*</ept> method (as shown below) <bpt id=\"p2\">**</bpt>on the control hosting the lookup<ept id=\"p2\">**</ept>.","pos":[9001,9153],"source":" To opt into the default disambiguation behavior, override the *resolveAmbiguousReference* method (as shown below) **on the control hosting the lookup**."},{"content":"Note that the second parameter to the <bpt id=\"p1\">*</bpt>resolveAmbiguousReferenceForControl<ept id=\"p1\">*</ept> call is what overrides the default behavior of not performing disambiguation for custom lookup scenarios.","pos":[9154,9335],"source":" Note that the second parameter to the *resolveAmbiguousReferenceForControl* call is what overrides the default behavior of not performing disambiguation for custom lookup scenarios."},{"pos":[9494,9529],"content":"Make custom lookup forms contextual","linkify":"Make custom lookup forms contextual","nodes":[{"content":"Make custom lookup forms contextual","pos":[0,35]}]},{"content":"As mentioned earlier, all system generated lookup forms automatically consider the context of the data entered into their host control.","pos":[9531,9666]},{"content":"This includes most lookup forms generated via <bpt id=\"p1\">*</bpt>SysTableLookup<ept id=\"p1\">*</ept>.","pos":[9667,9730],"source":" This includes most lookup forms generated via *SysTableLookup*."},{"content":"Modeled custom lookup forms, by their nature, cannot be fully-handled by the system and must be modified to match the behavior and visuals of contextual lookups forms.","pos":[9731,9898]},{"content":"If the data contained by the host control is in the context of ID, then:","pos":[9904,9976]},{"content":"Make the ID column first in the Grid.","pos":[9985,10022]},{"content":"Sort and filter by ID.","pos":[10031,10053]},{"content":"If the data contained by the host control is in the context of NAME, then:","pos":[10059,10133]},{"content":"Make the NAME column first in the Grid,","pos":[10142,10181]},{"content":"Sort and filter by NAME,","pos":[10190,10214]},{"content":"The following scenarios illustrate some custom lookups, along with the recommendation for how to enable contextual data entry in these cases.","pos":[10216,10357]},{"pos":[10364,10433],"content":"Scenario 1: Custom lookup defined via the FormHelp property on an EDT","linkify":"Scenario 1: Custom lookup defined via the FormHelp property on an EDT","nodes":[{"content":"Scenario 1: Custom lookup defined via the FormHelp property on an EDT","pos":[0,69]}]},{"content":"Custom lookups defined via FormHelp (even though modeled) still go through normal kernel-based lookup generation routines.","pos":[10435,10557]},{"content":"Therefore, the kernel still has hooks to make some changes to the lookup form.","pos":[10558,10636]},{"content":"Specifically, the lookup system has enough information to apply the correct filters and sorts; however, it is NOT known which controls should be moved in the lookup's grid.","pos":[10637,10809]},{"content":"(While an educated guess could be made based on bindings, that guess may be incorrect in more advanced lookup form designs.) If your custom lookup form is leveraging the <bpt id=\"p1\">*</bpt>SysTableLookup::filterLookupPreRun<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>SysTableLookup::<ept id=\"p2\">*</ept> <bpt id=\"p3\">*</bpt>filterLookupPostRun<ept id=\"p3\">*</ept> methods, then uptake the (new) optional parameters on <bpt id=\"p4\">*</bpt>filterLookupPostRun<ept id=\"p4\">*</ept> to have the NAME control moved automatically, as shown.","pos":[10811,11194],"source":"  (While an educated guess could be made based on bindings, that guess may be incorrect in more advanced lookup form designs.) If your custom lookup form is leveraging the *SysTableLookup::filterLookupPreRun* and *SysTableLookup::* *filterLookupPostRun* methods, then uptake the (new) optional parameters on *filterLookupPostRun* to have the NAME control moved automatically, as shown."},{"pos":[11770,11946],"content":"If your lookup form isn’t using the <bpt id=\"p1\">*</bpt>SysTableLookup::filterLookup<ph id=\"ph1\">\\*</ph><ept id=\"p1\">*</ept> methods, and you don’t want to uptake those methods, then you can simply add a control move as shown below.","source":"If your lookup form isn’t using the *SysTableLookup::filterLookup\\** methods, and you don’t want to uptake those methods, then you can simply add a control move as shown below."},{"pos":[12602,12665],"content":"Scenario 2: Override of lookup method manually launching a form","linkify":"Scenario 2: Override of lookup method manually launching a form","nodes":[{"content":"Scenario 2: Override of lookup method manually launching a form","pos":[0,63]}]},{"content":"Unlike Scenario 1, lookup forms launched by completely manual mechanisms, such as the class factory, have no kernel hooks.","pos":[12667,12789]},{"content":"Therefore, it is the responsibility of the lookup form to adhere to the contextual data entry behaviors.","pos":[12790,12894]},{"content":"The easiest way to do this is to leverage the SysTableLookup::filterLookup<ph id=\"ph1\">\\*</ph> methods (similar to Scenario 1) except include one additional parameter to indicate that sorting should also be maintained.","pos":[12895,13095],"source":" The easiest way to do this is to leverage the SysTableLookup::filterLookup\\* methods (similar to Scenario 1) except include one additional parameter to indicate that sorting should also be maintained."},{"content":"An example is shown below.","pos":[13096,13122]},{"pos":[13711,13733],"content":"Advanced lookup uptake","linkify":"Advanced lookup uptake","nodes":[{"content":"Advanced lookup uptake","pos":[0,22]}]},{"pos":[13738,13781],"content":"Scenario 1: Overriding ID and NAME bindings","linkify":"Scenario 1: Overriding ID and NAME bindings","nodes":[{"content":"Scenario 1: Overriding ID and NAME bindings","pos":[0,43]}]},{"content":"If you want to use a set of fields other than what is chosen by default, you must manually construct an instance of <bpt id=\"p1\">*</bpt>FormControlAmbiguousReferenceResolver<ept id=\"p1\">*</ept> and provide the optional parameters representing the custom bindings.","pos":[13783,14008],"source":"If you want to use a set of fields other than what is chosen by default, you must manually construct an instance of *FormControlAmbiguousReferenceResolver* and provide the optional parameters representing the custom bindings."},{"content":"This specialized instance must be used in an override of <bpt id=\"p1\">*</bpt>resolveAmbiguousReference<ept id=\"p1\">*</ept> and in a custom lookup form (including <bpt id=\"p2\">*</bpt>SysTableLookup<ept id=\"p2\">*</ept>, which also accepts an instance of <bpt id=\"p3\">*</bpt>FormControlAmbiguousReferenceResolver<ept id=\"p3\">*</ept>).","pos":[14009,14226],"source":" This specialized instance must be used in an override of *resolveAmbiguousReference* and in a custom lookup form (including *SysTableLookup*, which also accepts an instance of *FormControlAmbiguousReferenceResolver*)."},{"content":"A custom binding cannot currently be specified in kernel-generated lookups.","pos":[14227,14302]},{"content":"Methods currently accepting custom ID and NAME bindings:","pos":[14303,14359]},{"content":"FormControlAmbiguousReferenceResolver","pos":[14365,14402]},{"content":"Constructor","pos":[14411,14422]},{"content":"resolveAmbiguousReferenceForControl","pos":[14431,14466]},{"content":"surrogateFKHelperForAlternativeFieldMapping","pos":[14475,14518]},{"content":"isControlValueMappedToAlternativeField","pos":[14527,14565]},{"content":"Here's an end-to-end example of how to provide custom bindings.","pos":[14567,14630]},{"pos":[15689,15724],"content":"Scenario 2: Custom resolution logic","linkify":"Scenario 2: Custom resolution logic","nodes":[{"content":"Scenario 2: Custom resolution logic","pos":[0,35]}]},{"content":"It’s possible to use custom resolution logic by overriding resolveAmbiguousReference and leveraging something other than FormControlAmbiguousReferenceResolver.","pos":[15726,15885]},{"content":"Note that this logic needs to be common to the hosted lookup form so that keyboard and lookup based entry stay in sync.","pos":[15886,16005]},{"pos":[16501,16561],"content":"Appendix  Detailed usage scenarios for contextual data entry","linkify":"Appendix  Detailed usage scenarios for contextual data entry","nodes":[{"content":"Appendix  Detailed usage scenarios for contextual data entry","pos":[0,60]}]},{"content":"For the scenarios, assume there is a table called \"TableA\" with PK field \"ID\" and index field \"Name\", with the FK we're trying to enter that is related to the ID <ph id=\"ph1\">\\[</ph>the user ultimately needs to pick an ID<ph id=\"ph2\">\\]</ph>.","pos":[16562,16768],"source":"For the scenarios, assume there is a table called \"TableA\" with PK field \"ID\" and index field \"Name\", with the FK we're trying to enter that is related to the ID \\[the user ultimately needs to pick an ID\\]."},{"content":"Note that any algorithms that depend on like/begins with are assuming string fields.","pos":[16769,16853]},{"content":"We won't be able to provide high fidelity resolution behavior on, for example, integral types.","pos":[16854,16948]},{"content":"<bpt id=\"p1\">**</bpt>Scenario 1: User enters a valid ID of \"1234\"<ept id=\"p1\">**</ept> The super() implementation of resolveReference first queries against TableA.ID with the appropriate predicate.","pos":[16949,17108],"source":"**Scenario 1: User enters a valid ID of \"1234\"** The super() implementation of resolveReference first queries against TableA.ID with the appropriate predicate."},{"content":"The query finds a single record, and returns the user's entered value to be further processed by validate and modified.","pos":[17109,17228]},{"content":"Validation passes and the user sees \"1234\" in the UI.","pos":[17229,17282]},{"content":"<bpt id=\"p1\">**</bpt>Scenario 2: User enters an invalid ID of \"4321\"<ept id=\"p1\">**</ept> The super() implementation of resolveReference first queries against TableA.ID.","pos":[17283,17414],"source":"**Scenario 2: User enters an invalid ID of \"4321\"** The super() implementation of resolveReference first queries against TableA.ID."},{"content":"The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE \"4321%\").","pos":[17415,17564]},{"content":"Still, no record is found, so \"4321\" is passed through to validation, which fails.","pos":[17565,17647]},{"content":"The user sees \"4321\" in the browser as well as a validation error.","pos":[17648,17714]},{"content":"<bpt id=\"p1\">**</bpt>Scenario 3: User enters a valid Name of \"ACME\"<ept id=\"p1\">**</ept> The super() implementation of resolveReference first queries against TableA.ID.","pos":[17715,17845],"source":"**Scenario 3: User enters a valid Name of \"ACME\"** The super() implementation of resolveReference first queries against TableA.ID."},{"content":"The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE \"ACME%\").","pos":[17846,17995]},{"content":"This query does find a single record (unique reference), so the lookup automatically returns the corresponding TableA.ID.","pos":[17996,18117]},{"content":"Validate and modified continue executing in the context of that value.","pos":[18118,18188]},{"content":"Validation passes, and ultimately the user sees the ID value for ACME in the browser (for example, ACME would switch to 1234 in the browser).","pos":[18189,18330]},{"content":"<bpt id=\"p1\">**</bpt>Scenario 4: User enters an invalid Name of \"ACNE\"<ept id=\"p1\">**</ept> The super() implementation of resolveReference first queries against TableA.ID.","pos":[18331,18464],"source":"**Scenario 4: User enters an invalid Name of \"ACNE\"** The super() implementation of resolveReference first queries against TableA.ID."},{"content":"The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE \"ACNE%\").","pos":[18465,18614]},{"content":"This query does not find any records, so the lookup passes ACNE through to validation, which fails.","pos":[18615,18714]},{"content":"The user sees \"ACNE\" in the browser as well as a validation error.","pos":[18715,18781]},{"content":"<bpt id=\"p1\">**</bpt>Scenario 5: User enters an ambiguous Name of \"ACME\"<ept id=\"p1\">**</ept> In this case, assume there are two records in the database: one with Name \"ACME W\" and another with \"ACME E\".","pos":[18782,18947],"source":"**Scenario 5: User enters an ambiguous Name of \"ACME\"** In this case, assume there are two records in the database: one with Name \"ACME W\" and another with \"ACME E\"."},{"content":"The super() implementation of resolveReference first queries against TableA.ID.","pos":[18948,19027]},{"content":"The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE \"ACME%\").","pos":[19028,19177]},{"content":"This query finds two records, so it cannot make any further assumptions.","pos":[19178,19250]},{"content":"A disambiguation lookup is presented to the user showing \"ACME W\" and \"ACME E\" as choices.","pos":[19251,19341]},{"content":"The user picks \"ACME E\".","pos":[19342,19366]},{"content":"resolveReference then takes the records selected by the user and redirects it to the ID of \"ACME E\".","pos":[19367,19467]},{"content":"Validate and modified continue execution in the context of the ID of \"ACME E\".","pos":[19468,19546]},{"content":"The browser ultimately displays the ID of \"ACME E\" (for example, 1234).","pos":[19547,19618]},{"content":"<bpt id=\"p1\">**</bpt>Scenario 6: User enters an ambiguous Name of \"ACME\" and doesn't make a choice in the disambiguation lookup<ept id=\"p1\">**</ept> In this case, assume there are two records in the database: one with Name \"ACME W\" and another with \"ACME E\".","pos":[19619,19839],"source":"**Scenario 6: User enters an ambiguous Name of \"ACME\" and doesn't make a choice in the disambiguation lookup** In this case, assume there are two records in the database: one with Name \"ACME W\" and another with \"ACME E\"."},{"content":"The super() implementation of resolveReference first queries against TableA.ID.","pos":[19840,19919]},{"content":"The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE \"ACME%\").","pos":[19920,20069]},{"content":"This query finds two records, so it cannot make any further assumptions.","pos":[20070,20142]},{"content":"A disambiguation lookup is presented to the user showing \"ACME W\" and \"ACME E\" as choices.","pos":[20143,20233]},{"content":"The user doesn't make a selection from the lookup.","pos":[20234,20284]},{"content":"Therefore \"ACME\" is passed through to validate and modified.","pos":[20285,20345]},{"content":"Validation fails and the user is presented with a validation failure message.","pos":[20346,20423]},{"content":"The browser still displays a value of \"ACME\".","pos":[20424,20469]},{"content":"<bpt id=\"p1\">**</bpt>Scenario 7: User enters a \"valid\" ID of \"12\" and presents the lookup form<ept id=\"p1\">**</ept> Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE '12%').","pos":[20470,20671],"source":"**Scenario 7: User enters a \"valid\" ID of \"12\" and presents the lookup form** Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE '12%')."},{"content":"The query finds a record and therefore assumes the user must be operating in the context of ID.","pos":[20672,20767]},{"content":"It presents the lookup, filtering and sorting by ID.","pos":[20768,20820]},{"content":"<bpt id=\"p1\">**</bpt>Scenario 8: User enters an invalid ID of \"4321\" and presents the lookup form<ept id=\"p1\">**</ept> Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE '4321%').","pos":[20821,21027],"source":"**Scenario 8: User enters an invalid ID of \"4321\" and presents the lookup form** Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE '4321%')."},{"content":"The query does not find a matching record and therefore assumes the user is entering a Name.","pos":[21028,21120]},{"content":"The lookup is presented as filtered and sorted by Name (no records shown in this case).","pos":[21121,21208]},{"content":"<bpt id=\"p1\">**</bpt>Scenario 9: User enters a \"valid\" Name of \"AC\" and presents the lookup form<ept id=\"p1\">**</ept> Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE 'AC%').","pos":[21209,21412],"source":"**Scenario 9: User enters a \"valid\" Name of \"AC\" and presents the lookup form** Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE 'AC%')."},{"content":"The query does not find a matching record and therefore assumes the user is entering a Name.","pos":[21413,21505]},{"content":"The lookup is presented as filtered (those records matching \"begins with AC\") and sorted by Name in alphabetical order.","pos":[21506,21625]},{"content":"<bpt id=\"p1\">**</bpt>Scenario 10: User enters an invalid Name of \"EM\" and presents the lookup form<ept id=\"p1\">**</ept> Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE 'EM%').","pos":[21626,21831],"source":"**Scenario 10: User enters an invalid Name of \"EM\" and presents the lookup form** Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE 'EM%')."},{"content":"The query does not find a matching record and therefore assumes the user is entering a Name.","pos":[21832,21924]},{"content":"The lookup is presented as filtered and sorted by Name.","pos":[21925,21980]},{"content":"No records are found and therefore the user is presented with an empty lookup.","pos":[21981,22059]}],"content":"---\n# required metadata\n\ntitle: Contextual data entry for lookups\ndescription: In data entry scenarios, it is common for a user to attempt to identify an entity in terms of some more descriptive or natural language attribute if that entity is formally identified by a synthetic key, such as a number sequence. The contextual data entry feature allows users to type in either the synthetic key or a more descriptive attribute directly into a lookup field. This page explains how contextual data entry works and also provides implementation details and tips for developers who want their lookups to have this behavior.\nauthor: jasongre\nmanager: AnnBe\nms.date: 2015-12-02 22 - 43 - 54\nms.topic: article\nms.prod: \nms.service: Dynamics365Operations\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \n# ms.reviewer: 61\nms.search.scope: AX 7.0.0, Operations\n# ms.tgt_pltfrm: \nms.custom: 13631\nms.assetid: 67ae315b-69b8-43fb-b73a-077f3ed8ec33\nms.search.region: Global\n# ms.search.industry: \nms.author: jasongre\nms.dyn365.ops.intro: Feb-16\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# Contextual data entry for lookups\n\nIn data entry scenarios, it is common for a user to attempt to identify an entity in terms of some more descriptive or natural language attribute if that entity is formally identified by a synthetic key, such as a number sequence. The contextual data entry feature allows users to type in either the synthetic key or a more descriptive attribute directly into a lookup field. This page explains how contextual data entry works and also provides implementation details and tips for developers who want their lookups to have this behavior.\n\nIntroduction\n------------\n\nIn data entry scenarios, it is common for a user to attempt to identify an entity in terms of some more descriptive or natural language attribute if that entity is formally identified by a synthetic key, such as a number sequence. A user will typically attempt to enter an **Account Name** instead of an **Account ID** for the **Customer Account** when creating a Sales Order. This is because most interaction with a customer is done using their actual name instead of some synthetic identifier. Unfortunately, any user’s attempt to enter an **Account Name** will fail because the **Customer account** control’s underlying foreign key relates to a field that is a synthetic key—a number sequence—and Dynamics AX 2012 (and older) will always attempt to validate the entered value directly. Therefore, if the **Account ID** was unknown to the user, the user would be forced to perform some type of searching step, such as opening the **Customer account** control’s lookup and filtering on the **Account Name** column to identify the correct **Account ID** (see the image below). [![HowToContextualLookups (3)](./media/howtocontextuallookups-3.png)](./media/howtocontextuallookups-3.png) This user experience is not optimal and is being addressed by data entry efficiency and productivity. The platform adds initial support for contextual data entry, where the system automatically attempts to understand whether the user’s entered data is in the context of the key field or some other more descriptive or well-understood field, and handle it appropriately. **For the remainder of this document, we’ll generically refer to these types of fields as ID (synthetic) and NAME (descriptive) fields, respectively.**\n\n## Contextual lookup forms\nJust like keyboard data entry, all system generated lookup forms are also now contextual, meaning that filtering and sorting occur in the context of the data the user has entered. Using the create a Sales Order scenario as an example, the user will see the lookup shown below if an ID is entered. [![Customer account lookup form opened in the context of ID](./media/howtocontextuallookups-1.png)](./media/howtocontextuallookups-1.png) If a NAME is entered, then the user will see the following lookup. Notice how the NAME column is moved first in the Grid, and how the lookup is sorted and filtered upon when the user’s data is in the context of NAME. ![Customer account lookup form opened in the context of NAME](./media/howtocontextuallookups-2.png)\n\n## Contextual data entry implementation details\n### Behavior\n\nIn the context of the Sales order create scenario mentioned above, the contextual data entry feature will allow the user to be able to freely type in either the ID or NAME without performing any laborious search process. In detail, the following behaviors will occur:\n\n1.  If the user enters a complete ID reference, the value will be taken directly.\n2.  If the user enters a complete and unique NAME reference, the value will be automatically translated into an ID and then processed.\n3.  If the user enters a non-complete ID or NAME reference (such as *Micro* instead of *Microsoft*), but it still uniquely matches either ID or NAME via a BEGINS WITH predicate, then the value will be translated into its complete ID and then processed.\n4.  If the user enters a non-complete ID or a non-unique NAME and there are multiple matches, then a *disambiguation* lookup will be presented to the user to select which value was actually intended.\n\nSee Appendix A for more detailed sample scenarios of contextual data entry.\n\n### Prerequisites\n\nTo maintain functional correctness and reasonable performance, the following constraints were added to the application of the behaviors described in the previous section:\n\n1.  *****Title Field 2*** **is the NAME field****.\n2.  The NAME field must either be covered by an index ***OR*** belong to a Table whose *Cache Lookup* property is set to *EntireTable*. All contextual lookup behavior will be disabled if this requirement is not met for performance reasons. **NOTE: An index should only be added for NON TRANSACTIONAL tables because of index maintenance costs**. Also note that you will **likely want to mark this index as non-unique** (Allow Duplicates = Yes).\n3.  If a control is using a custom lookup form (such as SysTableLookup; FormHelp on an EDT) then the disambiguation behavior described previously will not be turned on by default. This is because these custom lookup forms (and even surrounding modified and lookup method overrides) can and will do advanced things such as presenting a dialog, which are not desirable in the context of contextual lookups.\n\nHandling custom lookup forms requires additional knowledge and will be covered in its own section.\n\n### Programming model additions\n\nThe behaviors and rules expressed in *Listings 1* and *2* are contained primarily by a new X++ class called *FormControlAmbiguousReferenceResolver*. *FormControlAmbiguousReferenceResolver* uptake in application code will be necessary in more advanced scenarios. Its use will be described later in the document. In addition to the *FormControlAmbiguousReferenceResolver* class, a new control override called *resolveAmbiguousReference* has been added. R*esolveAmbiguousReference* acts as a hook point in the system for translating what the user typed into a value that the system is expecting. The basic flow is as follows:\n\n1.  The user enters a value into a control and removes focus.\n2.  An interaction is sent from the client to the server, indicating that a new value has been entered. The appropriate command is executed on the server.\n3.  Before the command attempts to process the value entered by the user, it makes a call to *resolveAmbiguousReference* to give the system a chance to translate the value into the expected domain.\n4.  The super implementation of resolveAmbiguousReference creates an instance of *FormControlAmbiguousReferenceResolver* which executes the rules described above.\n\nThe value returned from *resolveAmbiguousReference* is used for the remainder of the command’s execution. Validate() and modified() operate against the returned value.\n\n## Standard lookup uptake\n### Add an index that covers TitleField2\n\n*TitleField2* defines the default definition of NAME. In order to enable ID and NAME contextual data entry, *TitleField2* must be either indexed OR belong to a table with *CacheLookup* set to *EntireTable*. If the table containing *TitleField2* does not yet define an index covering *TitleField2* **and, importantly, the table does not have a high volume of CUD (Creates/Updates/Deletes\\*)**, then add a **non-unique** index (Allow Duplicates = Yes) covering *TitleField2*. This will cause the system to start executing the contextual data entry behavior, except for the custom lookup limitation described in the Prerequisites section. \\*Adding an index on high-volume transactional tables may incur a noticeable performance penalty due to index maintenance costs.\n\n### Enable disambiguation behavior for custom lookup scenarios\n\nCustom lookup implementations can provide advanced or non-typical behaviors, such as presenting dialogs. Therefore, the system disables the default disambiguation behavior when a custom lookup scenario is detected. To opt into the default disambiguation behavior, override the *resolveAmbiguousReference* method (as shown below) **on the control hosting the lookup**. Note that the second parameter to the *resolveAmbiguousReferenceForControl* call is what overrides the default behavior of not performing disambiguation for custom lookup scenarios.\n\n    public str resolveAmbiguousReference()\n    {\n        FormControlAmbiguousReferenceResolver::resolveAmbiguousReferenceForControl (this, true);\n    }\n\n### Make custom lookup forms contextual\n\nAs mentioned earlier, all system generated lookup forms automatically consider the context of the data entered into their host control. This includes most lookup forms generated via *SysTableLookup*. Modeled custom lookup forms, by their nature, cannot be fully-handled by the system and must be modified to match the behavior and visuals of contextual lookups forms.\n\n1.  If the data contained by the host control is in the context of ID, then:\n    1.  Make the ID column first in the Grid.\n    2.  Sort and filter by ID.\n\n2.  If the data contained by the host control is in the context of NAME, then:\n    1.  Make the NAME column first in the Grid,\n    2.  Sort and filter by NAME,\n\nThe following scenarios illustrate some custom lookups, along with the recommendation for how to enable contextual data entry in these cases.\n\n#### Scenario 1: Custom lookup defined via the FormHelp property on an EDT\n\nCustom lookups defined via FormHelp (even though modeled) still go through normal kernel-based lookup generation routines. Therefore, the kernel still has hooks to make some changes to the lookup form. Specifically, the lookup system has enough information to apply the correct filters and sorts; however, it is NOT known which controls should be moved in the lookup's grid.  (While an educated guess could be made based on bindings, that guess may be incorrect in more advanced lookup form designs.) If your custom lookup form is leveraging the *SysTableLookup::filterLookupPreRun* and *SysTableLookup::* *filterLookupPostRun* methods, then uptake the (new) optional parameters on *filterLookupPostRun* to have the NAME control moved automatically, as shown.\n\n    public class MyCustomLookupForm extends FormRun\n    {\n        public void run()\n        {\n            FormStringControl lookupHostControl = SysTableLookup::getCallerStringControl(this.args());\n            boolean isFiltered = SysTableLookup::filterLookupPreRun(lookupHostControl, ID_Control, FormDataSourceToFilter);\n\n            super();\n\n            SysTableLookup::filterLookupPostRun(isFiltered, lookupHostControl.text(), ID_Control, FormDataSourceToFilter, \n                new FormControlAmbiguousReferenceResolver(callingControl), NAME_Control);\n        }\n    }\n\nIf your lookup form isn’t using the *SysTableLookup::filterLookup\\** methods, and you don’t want to uptake those methods, then you can simply add a control move as shown below.\n\n    public class MyCustomLookupForm extends FormRun\n    {\n        public void init()\n        {\n            super();\n            this.applyControlOrdering();\n        }\n\n        private void applyControlOrdering()\n        {\n            FormControl callerControl = SysTableLookup::getCallerControl(this.args());\n            if (FormControlAmbiguousReferenceResolver::isControlValueMappedToAlternativeField(callerControl))\n            {\n                Grid.moveControl(ID_Control.id(), NAME_control.id());\n            }\n            else\n            {\n                Grid.moveControl(NAME_Control.id(), ID_Control.id());\n            }\n        }\n    }\n\n#### Scenario 2: Override of lookup method manually launching a form\n\nUnlike Scenario 1, lookup forms launched by completely manual mechanisms, such as the class factory, have no kernel hooks. Therefore, it is the responsibility of the lookup form to adhere to the contextual data entry behaviors. The easiest way to do this is to leverage the SysTableLookup::filterLookup\\* methods (similar to Scenario 1) except include one additional parameter to indicate that sorting should also be maintained. An example is shown below.\n\n    public class MyCustomLookupForm extends FormRun\n    {\n        public void run()\n        {\n            FormStringControl lookupHostControl = SysTableLookup::getCallerStringControl(this.args());\n            boolean isFiltered = SysTableLookup::filterLookupPreRun(lookupHostControl, ID_Control, FormDataSourceToFilter);\n\n            super();\n\n            SysTableLookup::filterLookupPostRun(isFiltered, lookupHostControl.text(), ID_Control, FormDataSourceToFilter, \n                new FormControlAmbiguousReferenceResolver(callingControl), NAME_Control, true);\n            }\n    }\n\n## Advanced lookup uptake\n### Scenario 1: Overriding ID and NAME bindings\n\nIf you want to use a set of fields other than what is chosen by default, you must manually construct an instance of *FormControlAmbiguousReferenceResolver* and provide the optional parameters representing the custom bindings. This specialized instance must be used in an override of *resolveAmbiguousReference* and in a custom lookup form (including *SysTableLookup*, which also accepts an instance of *FormControlAmbiguousReferenceResolver*). A custom binding cannot currently be specified in kernel-generated lookups. Methods currently accepting custom ID and NAME bindings:\n\n1.  FormControlAmbiguousReferenceResolver\n    -   Constructor\n    -   resolveAmbiguousReferenceForControl\n    -   surrogateFKHelperForAlternativeFieldMapping\n    -   isControlValueMappedToAlternativeField\n\nHere's an end-to-end example of how to provide custom bindings.\n\n    [Control Hosting Lookup]\n    public str resolveAmbiguousReference()\n    {\n        return FormControlAmbiguousReferenceResolver::resolveAmbiguousReferenceForControl(\n            this, true, AbsoluteFieldBinding::construct(IDField, Table), \n            AbsoluteFieldBinding::construct(SomeOtherNAMEField, Table));\n    }\n\n    [Custom Lookup Form]\n    public class MyCustomLookupForm extends FormRun\n    {\n        public void run()\n        {\n            FormStringControl lookupHostControl = SysTableLookup::getCallerStringControl(this.args());\n            boolean isFiltered = SysTableLookup::filterLookupPreRun(lookupHostControl, ID_Control, FormDataSourceToFilter);\n\n            super();\n\n            SysTableLookup::filterLookupPostRun(isFiltered, lookupHostControl.text(), ID_Control, FormDataSourceToFilter, \n                new FormControlAmbiguousReferenceResolver(callingControl, AbsoluteFieldBinding::construct(IDField, Table),\n                AbsoluteFieldBinding::construct(SomeOtherNAMEField, Table)), NAME_Control, true);\n        }\n    }\n\n### Scenario 2: Custom resolution logic\n\nIt’s possible to use custom resolution logic by overriding resolveAmbiguousReference and leveraging something other than FormControlAmbiguousReferenceResolver. Note that this logic needs to be common to the hosted lookup form so that keyboard and lookup based entry stay in sync.\n\n    public str resolveAmbiguousReference()\n    {\n        // In this sample, allow “looser” data entry by simply picking the first record that matches, if any.\n        CLI_Job _job;\n        str mappedValue = this.text();\n        if (strLen(mappedValue) > 0)\n        {\n            select firstonly _job order by _job.Title where _job.Title like mappedValue + “*”;\n        }\n\n        if (_job.RecId)\n        {\n            mappedValue = _job.Title;\n        }\n\n        return mappedValue;\n    }\n\n## Appendix  Detailed usage scenarios for contextual data entry\nFor the scenarios, assume there is a table called \"TableA\" with PK field \"ID\" and index field \"Name\", with the FK we're trying to enter that is related to the ID \\[the user ultimately needs to pick an ID\\]. Note that any algorithms that depend on like/begins with are assuming string fields. We won't be able to provide high fidelity resolution behavior on, for example, integral types. **Scenario 1: User enters a valid ID of \"1234\"** The super() implementation of resolveReference first queries against TableA.ID with the appropriate predicate. The query finds a single record, and returns the user's entered value to be further processed by validate and modified. Validation passes and the user sees \"1234\" in the UI. **Scenario 2: User enters an invalid ID of \"4321\"** The super() implementation of resolveReference first queries against TableA.ID. The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE \"4321%\"). Still, no record is found, so \"4321\" is passed through to validation, which fails. The user sees \"4321\" in the browser as well as a validation error. **Scenario 3: User enters a valid Name of \"ACME\"** The super() implementation of resolveReference first queries against TableA.ID. The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE \"ACME%\"). This query does find a single record (unique reference), so the lookup automatically returns the corresponding TableA.ID. Validate and modified continue executing in the context of that value. Validation passes, and ultimately the user sees the ID value for ACME in the browser (for example, ACME would switch to 1234 in the browser). **Scenario 4: User enters an invalid Name of \"ACNE\"** The super() implementation of resolveReference first queries against TableA.ID. The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE \"ACNE%\"). This query does not find any records, so the lookup passes ACNE through to validation, which fails. The user sees \"ACNE\" in the browser as well as a validation error. **Scenario 5: User enters an ambiguous Name of \"ACME\"** In this case, assume there are two records in the database: one with Name \"ACME W\" and another with \"ACME E\". The super() implementation of resolveReference first queries against TableA.ID. The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE \"ACME%\"). This query finds two records, so it cannot make any further assumptions. A disambiguation lookup is presented to the user showing \"ACME W\" and \"ACME E\" as choices. The user picks \"ACME E\". resolveReference then takes the records selected by the user and redirects it to the ID of \"ACME E\". Validate and modified continue execution in the context of the ID of \"ACME E\". The browser ultimately displays the ID of \"ACME E\" (for example, 1234). **Scenario 6: User enters an ambiguous Name of \"ACME\" and doesn't make a choice in the disambiguation lookup** In this case, assume there are two records in the database: one with Name \"ACME W\" and another with \"ACME E\". The super() implementation of resolveReference first queries against TableA.ID. The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE \"ACME%\"). This query finds two records, so it cannot make any further assumptions. A disambiguation lookup is presented to the user showing \"ACME W\" and \"ACME E\" as choices. The user doesn't make a selection from the lookup. Therefore \"ACME\" is passed through to validate and modified. Validation fails and the user is presented with a validation failure message. The browser still displays a value of \"ACME\". **Scenario 7: User enters a \"valid\" ID of \"12\" and presents the lookup form** Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE '12%'). The query finds a record and therefore assumes the user must be operating in the context of ID. It presents the lookup, filtering and sorting by ID. **Scenario 8: User enters an invalid ID of \"4321\" and presents the lookup form** Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE '4321%'). The query does not find a matching record and therefore assumes the user is entering a Name. The lookup is presented as filtered and sorted by Name (no records shown in this case). **Scenario 9: User enters a \"valid\" Name of \"AC\" and presents the lookup form** Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE 'AC%'). The query does not find a matching record and therefore assumes the user is entering a Name. The lookup is presented as filtered (those records matching \"begins with AC\") and sorted by Name in alphabetical order. **Scenario 10: User enters an invalid Name of \"EM\" and presents the lookup form** Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE 'EM%'). The query does not find a matching record and therefore assumes the user is entering a Name. The lookup is presented as filtered and sorted by Name. No records are found and therefore the user is presented with an empty lookup.\n\n"}