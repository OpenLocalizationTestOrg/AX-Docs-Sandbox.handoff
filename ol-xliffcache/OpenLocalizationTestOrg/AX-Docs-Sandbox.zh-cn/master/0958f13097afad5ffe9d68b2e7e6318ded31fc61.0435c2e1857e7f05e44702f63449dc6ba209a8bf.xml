{"nodes":[{"pos":[32,52],"content":"LINQ provider for C#","needQuote":true,"needEscape":true,"nodes":[{"content":"LINQ provider for C","pos":[0,19]}]},{"pos":[66,145],"content":"This article discusses the LINQ provider that is part of Microsoft Dynamics AX.","needQuote":true,"needEscape":true,"nodes":[{"content":"This article discusses the LINQ provider that is part of Microsoft Dynamics AX.","pos":[0,79]}]},{"pos":[657,677],"content":"LINQ provider for C#","linkify":"LINQ provider for C#","nodes":[{"content":"LINQ provider for C","pos":[0,19]}]},{"content":"This article discusses the LINQ provider that is part of Microsoft Dynamics AX.","pos":[679,758]},{"content":"LINQ (Language Integrated Query) is a set of classes and methods that enable you to access data that is stored in a variety of places and formats.","pos":[760,906]},{"content":"The LINQ framework is the standard for accessing data in managed languages.","pos":[907,982]},{"content":"LINQ presents to programmers a unified and consistent API for data access from heterogeneous data sources, such as:","pos":[983,1098]},{"content":"In-memory object graphs","pos":[1104,1127]},{"content":"Active Directory entries","pos":[1132,1156]},{"content":"Flickr pictures and XML","pos":[1161,1184]},{"content":"SQL Server","pos":[1189,1199]},{"content":"Dynamics AX includes a LINQ provider, which allows the user to access Dynamics AX business data by using .NET managed languages.","pos":[1201,1329]},{"pos":[1334,1379],"content":"Two syntactical mechanisms for accessing LINQ","linkify":"Two syntactical mechanisms for accessing LINQ","nodes":[{"content":"Two syntactical mechanisms for accessing LINQ","pos":[0,45]}]},{"content":"There are two syntactical approaches for using LINQ, as described in the following table.","pos":[1380,1469]},{"pos":[1542,1549],"content":"<bpt id=\"p1\">**</bpt>X++<ept id=\"p1\">**</ept>","source":"**X++**"},{"pos":[1634,1658],"content":"<bpt id=\"p1\">**</bpt>C<ph id=\"ph1\">\\#</ph> and Visual Basic<ept id=\"p1\">**</ept>","source":"**C\\# and Visual Basic**"},{"pos":[1754,1794],"content":"<bpt id=\"p1\">**</bpt>LINQ by standard method call syntax.<ept id=\"p1\">**</ept>","source":"**LINQ by standard method call syntax.**"},{"content":"Impractical.","pos":[1823,1835]},{"content":"Language support for generics is vital for LINQ and is not supported in X++.","pos":[1836,1912]},{"content":"Available, requires lambda syntax.","pos":[1915,1949]},{"pos":[1954,2020],"content":"<bpt id=\"p1\">**</bpt>LINQ by specialized syntax that is understood by the compiler.<ept id=\"p1\">**</ept>","source":"**LINQ by specialized syntax that is understood by the compiler.**"},{"content":"Not available.","pos":[2023,2037]},{"content":"Available, easier to use.","pos":[2115,2140]},{"content":"There are two syntactic mechanisms for accessing the LINQ provider in C<ph id=\"ph1\">\\#</ph> (or in Visual Basic):","pos":[2153,2248],"source":"There are two syntactic mechanisms for accessing the LINQ provider in C\\# (or in Visual Basic):"},{"content":"By standard, or fluent, method call syntax.","pos":[2254,2297]},{"content":"By specialized syntax that the C<ph id=\"ph1\">\\#</ph> compiler has been enhanced to understand as equivalent to the LINQ method calls.","pos":[2302,2417],"source":"By specialized syntax that the C\\# compiler has been enhanced to understand as equivalent to the LINQ method calls."},{"content":"(Such syntax is sometimes called “syntactic sugar”.)","pos":[2418,2470]},{"content":"This topic is going to review each syntactic mechanism for LINQ, starting with the easier specialized syntax.","pos":[2472,2581]},{"pos":[2586,2619],"content":"LINQ by specialized syntax in C\\#","linkify":"LINQ by specialized syntax in C\\#","nodes":[{"content":"LINQ by specialized syntax in C<ph id=\"ph1\">\\#</ph>","pos":[0,33],"source":"LINQ by specialized syntax in C\\#"}]},{"content":"Some .NET languages understand specialized syntax for LINQ as an alternative that is easier for us to write.","pos":[2620,2728]},{"content":"C<ph id=\"ph1\">\\#</ph> is one such language.","pos":[2729,2754],"source":" C\\# is one such language."},{"content":"<bpt id=\"p1\">***</bpt>Note about var:<ept id=\"p1\">***</ept> To use LINQ in C<ph id=\"ph1\">\\#</ph>, you must understand the C<ph id=\"ph2\">\\#</ph> keyword <bpt id=\"p2\">**</bpt>var<ept id=\"p2\">**</ept>, which is used to declare variables.","pos":[2755,2877],"source":"***Note about var:*** To use LINQ in C\\#, you must understand the C\\# keyword **var**, which is used to declare variables."},{"content":"The var keyword tells the compiler to figure out the data type of the variable by what is assigned to the variable.","pos":[2878,2993]},{"content":"This feature is now also available in X++.","pos":[2994,3036]},{"content":"The type is implicit in the source code, and the type is settled and unvarying after the compilation completes.","pos":[3037,3148]},{"pos":[3154,3179],"content":"Comparing X++ to C\\# LINQ","linkify":"Comparing X++ to C\\# LINQ","nodes":[{"content":"Comparing X++ to C<ph id=\"ph1\">\\#</ph> LINQ","pos":[0,25],"source":"Comparing X++ to C\\# LINQ"}]},{"content":"The X++ language supports the useful and easy to use <ph id=\"ph1\">`while select`</ph> statement.","pos":[3181,3259],"source":"The X++ language supports the useful and easy to use `while select` statement."},{"content":"This lest you compare the X++ <ph id=\"ph1\">`while select`</ph> syntax to the specialized C<ph id=\"ph2\">\\#</ph> LINQ syntax.","pos":[3260,3347],"source":" This lest you compare the X++ `while select` syntax to the specialized C\\# LINQ syntax."},{"content":"First, here is the X++ sample.","pos":[3348,3378]},{"content":"Next is an equivalent query in C<ph id=\"ph1\">\\#</ph> with the specialized LINQ syntax.","pos":[3669,3737],"source":"Next is an equivalent query in C\\# with the specialized LINQ syntax."},{"pos":[4343,4410],"content":"LINQ query in C\\# by method syntax, using the lambda operator =&gt;","linkify":"LINQ query in C\\# by method syntax, using the lambda operator =&gt;","nodes":[{"content":"LINQ query in C<ph id=\"ph1\">\\#</ph> by method syntax, using the lambda operator =<ph id=\"ph2\">&amp;gt;</ph>","pos":[0,67],"source":"LINQ query in C\\# by method syntax, using the lambda operator =&gt;"}]},{"content":"Next is another use of LINQ in C<ph id=\"ph1\">\\#</ph>, except this time the more standard syntax is used to call the LINQ API.","pos":[4411,4518],"source":"Next is another use of LINQ in C\\#, except this time the more standard syntax is used to call the LINQ API."},{"content":"The approach also involves use of the lambda operator <bpt id=\"p1\">**</bpt><ph id=\"ph1\">=</ph><ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">**</ept>.","pos":[4519,4583],"source":" The approach also involves use of the lambda operator **=&gt;**."},{"content":"The following C<ph id=\"ph1\">\\#</ph> query is functionally equivalent to the preceding C<ph id=\"ph2\">\\#</ph> query.","pos":[4584,4662],"source":" The following C\\# query is functionally equivalent to the preceding C\\# query."},{"content":"There's a good match between the <ph id=\"ph1\">`while select`</ph> syntax used in X++ and the specialized LINQ syntax in C<ph id=\"ph2\">\\#</ph> (Visual Basic has particularly good LINQ syntax).","pos":[5069,5224],"source":"There's a good match between the `while select` syntax used in X++ and the specialized LINQ syntax in C\\# (Visual Basic has particularly good LINQ syntax)."},{"content":"It's evident that the specialized LINQ syntax is actually very useful in expressing joins, but the specialized syntax built into the C<ph id=\"ph1\">\\#</ph> compiler doesn't handle the extensions provided by Dynamics AX.","pos":[5225,5425],"source":" It's evident that the specialized LINQ syntax is actually very useful in expressing joins, but the specialized syntax built into the C\\# compiler doesn't handle the extensions provided by Dynamics AX."},{"pos":[5431,5472],"content":"Limitation of the specialized LINQ syntax","linkify":"Limitation of the specialized LINQ syntax","nodes":[{"content":"Limitation of the specialized LINQ syntax","pos":[0,41]}]},{"content":"A limitation of the specialized LINQ syntax is that is can't be augmented with extensions to the LINQ provider.","pos":[5474,5585]},{"content":"In contrast, standard syntax of method calls plus the lambda operator can be extended as needed.","pos":[5586,5682]},{"content":"For instance, the LINQ framework provides a method for cross-company hints that can't be expressed in the special syntax for LINQ in C<ph id=\"ph1\">\\#</ph>. Fortunately, due to the ability to compose queries, this limitation need not be a major problem.","pos":[5683,5917],"source":" For instance, the LINQ framework provides a method for cross-company hints that can't be expressed in the special syntax for LINQ in C\\#. Fortunately, due to the ability to compose queries, this limitation need not be a major problem."},{"content":"Calls to esoteric LINQ methods can be appended to the specialized LINQ syntax.","pos":[5918,5996]},{"content":"The following C<ph id=\"ph1\">\\#</ph> code shows this being done for the <bpt id=\"p1\">**</bpt>crosscompany<ept id=\"p1\">**</ept> method.","pos":[5997,6074],"source":" The following C\\# code shows this being done for the **crosscompany** method."},{"pos":[6406,6426],"content":"LINQ query execution","linkify":"LINQ query execution","nodes":[{"content":"LINQ query execution","pos":[0,20]}]},{"content":"The code generated for a LINQ query builds a tree at run time.","pos":[6427,6489]},{"content":"When the results of the query are required, this tree is passed to the backend that will interpret it, and will provide the data as expressed in the query.","pos":[6490,6645]},{"content":"The X++ compiler also builds a tree to express the query, but the X++ compiler has intimate knowledge about the capabilities of the database backend.","pos":[6646,6795]},{"content":"This has several important implications as described in the following subsections.","pos":[6796,6878]},{"pos":[6884,6935],"content":"Inability to diagnose problems at LINQ compile-time","linkify":"Inability to diagnose problems at LINQ compile-time","nodes":[{"content":"Inability to diagnose problems at LINQ compile-time","pos":[0,51]}]},{"content":"The C<ph id=\"ph1\">\\#</ph> compiler is largely unable to foresee and diagnose errors that will occur at run time due to the inability of the backend to process an incompatible LINQ query.","pos":[6937,7105],"source":"The C\\# compiler is largely unable to foresee and diagnose errors that will occur at run time due to the inability of the backend to process an incompatible LINQ query."},{"content":"For instance, in the following C<ph id=\"ph1\">\\#</ph> code block, the specialized LINQ syntax is valid according to the C<ph id=\"ph2\">\\#</ph> compiler.","pos":[7106,7220],"source":" For instance, in the following C\\# code block, the specialized LINQ syntax is valid according to the C\\# compiler."},{"content":"Yet at run time, an error would occur.","pos":[7221,7259]},{"content":"This query can't be handled by the current data layer, and while no errors are diagnosed at compile time, an error would occur at run time.","pos":[7495,7634]},{"pos":[7640,7669],"content":"Performance penalty with LINQ","linkify":"Performance penalty with LINQ","nodes":[{"content":"Performance penalty with LINQ","pos":[0,29]}]},{"content":"There is an overhead penalty paid at run time, when analysis of the tree occurs, and a suitable access language is generated.","pos":[7671,7796]},{"content":"As we might expect, the performance penalty is incurred when analyzing the LINQ expression tree.","pos":[7797,7893]},{"content":"The time required at run time to actually fetch the data doesn't vary much between C<ph id=\"ph1\">\\#</ph> and LINQ versus X++ with <ph id=\"ph2\">`while select`</ph>.","pos":[7894,8021],"source":" The time required at run time to actually fetch the data doesn't vary much between C\\# and LINQ versus X++ with `while select`."},{"content":"Our preliminary numbers show that the beginning-to-end performance of the query is about three times longer with C<ph id=\"ph1\">\\#</ph> LINQ, compared to X++ <ph id=\"ph2\">`while select`</ph>, when very few records are fetched.","pos":[8022,8211],"source":" Our preliminary numbers show that the beginning-to-end performance of the query is about three times longer with C\\# LINQ, compared to X++ `while select`, when very few records are fetched."},{"content":"But when many records are fetched, the total times are about the same between C<ph id=\"ph1\">\\#</ph> and X++.","pos":[8212,8302],"source":" But when many records are fetched, the total times are about the same between C\\# and X++."},{"content":"The conclusion is that it takes much longer to fetch a lot of records than it takes to analyze the language tree.","pos":[8303,8416]},{"pos":[8422,8451],"content":"Query composability with LINQ","linkify":"Query composability with LINQ","nodes":[{"content":"Query composability with LINQ","pos":[0,29]}]},{"content":"The model that's provided by LINQ allows queries to be composed of subqueries.","pos":[8453,8531]},{"content":"The X++ language can't cleanly provide this feature.","pos":[8532,8584]},{"content":"To understand this, consider the following C<ph id=\"ph1\">\\#</ph> LINQ code.","pos":[8585,8642],"source":" To understand this, consider the following C\\# LINQ code."},{"content":"A flag is passed to a method to control the ordering of data results.","pos":[8643,8712]},{"pos":[9253,9283],"content":"Set based operations with LINQ","linkify":"Set based operations with LINQ","nodes":[{"content":"Set based operations with LINQ","pos":[0,30]}]},{"content":"LINQ queries can be applied for CRUD operations.","pos":[9285,9333]},{"content":"But the model for updating, deleting, and inserting records isn't useful for the expression of set based operations.","pos":[9334,9450]},{"content":"For a future release of Dynamics AX, we're working on extensions to add to the LINQ model that will translate into set based operations.","pos":[9451,9587]},{"pos":[9589,9597],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9608,9671],"content":"<bpt id=\"p1\">[</bpt>Programming language support<ept id=\"p1\">](programming-language-support.md)</ept>","source":"[Programming language support](programming-language-support.md)"},{"pos":[9673,9723],"content":"<bpt id=\"p1\">[</bpt>Technical Concepts Guide<ept id=\"p1\">](developer-home-page.md)</ept>","source":"[Technical Concepts Guide](developer-home-page.md)"}],"content":"---\n# required metadata\n\ntitle: LINQ provider for C#\ndescription: This article discusses the LINQ provider that is part of Microsoft Dynamics AX.\nauthor: pvillads\nmanager: AnnBe\nms.date: 2015-12-13 01 - 58 - 12\nms.topic: article\nms.prod: \nms.service: Dynamics365Operations\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: annbe\nms.search.scope: AX 7.0.0, Operations\n# ms.tgt_pltfrm: \nms.custom: 26751\nms.assetid: 8bd10c93-9d5e-49d7-b20f-7f804e16e76c\nms.search.region: Global\n# ms.search.industry: \nms.author: pvillads\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# LINQ provider for C#\n\nThis article discusses the LINQ provider that is part of Microsoft Dynamics AX.\n\nLINQ (Language Integrated Query) is a set of classes and methods that enable you to access data that is stored in a variety of places and formats. The LINQ framework is the standard for accessing data in managed languages. LINQ presents to programmers a unified and consistent API for data access from heterogeneous data sources, such as:\n\n-   In-memory object graphs\n-   Active Directory entries\n-   Flickr pictures and XML\n-   SQL Server\n\nDynamics AX includes a LINQ provider, which allows the user to access Dynamics AX business data by using .NET managed languages.\n\n## Two syntactical mechanisms for accessing LINQ\nThere are two syntactical approaches for using LINQ, as described in the following table.\n\n|                                                                    | **X++**                                                                                   | **C\\# and Visual Basic**           |\n|-----------------|-----------------------|------------------------------------|\n| **LINQ by standard method call syntax.**                           | Impractical. Language support for generics is vital for LINQ and is not supported in X++. | Available, requires lambda syntax. |\n| **LINQ by specialized syntax that is understood by the compiler.** | Not available.                                                                            | Available, easier to use.          |\n\nThere are two syntactic mechanisms for accessing the LINQ provider in C\\# (or in Visual Basic):\n\n-   By standard, or fluent, method call syntax.\n-   By specialized syntax that the C\\# compiler has been enhanced to understand as equivalent to the LINQ method calls. (Such syntax is sometimes called “syntactic sugar”.)\n\nThis topic is going to review each syntactic mechanism for LINQ, starting with the easier specialized syntax.\n\n## LINQ by specialized syntax in C\\#\nSome .NET languages understand specialized syntax for LINQ as an alternative that is easier for us to write. C\\# is one such language. ***Note about var:*** To use LINQ in C\\#, you must understand the C\\# keyword **var**, which is used to declare variables. The var keyword tells the compiler to figure out the data type of the variable by what is assigned to the variable. This feature is now also available in X++. The type is implicit in the source code, and the type is settled and unvarying after the compilation completes.\n\n### Comparing X++ to C\\# LINQ\n\nThe X++ language supports the useful and easy to use `while select` statement. This lest you compare the X++ `while select` syntax to the specialized C\\# LINQ syntax. First, here is the X++ sample.\n\n    CustTable ct;     // X++, traditional while select.\n    CustTrans trans;\n\n    while select * from ct\n        where ct.AccountNum >= ‘4000’\n        join RecId from trans\n        where trans.RecId == ct.RecId\n        order by ct.AccountNum desc\n    {\n        print ct.AccountNum;\n    }\n\nNext is an equivalent query in C\\# with the specialized LINQ syntax.\n\n    // Get access to the data provider:       // C#, with specialized LINQ syntax.\n    var provider = new QueryProvider(null);\n\n    var customers = new QueryCollection(provider);\n    var customerTransactions = new QueryCollection(provider);\n\n    var query = from ct in customers\n                from trans in customerTransactions\n                where ct.AccountNum >= “4000”\n                where trans.AccountNum == ct.AccountNum\n                orderby ct.AccountNum descending\n                select ct;\n\n    foreach (var ct in query)\n    {\n        System.Console.WriteLine(ct.AccountNum);\n    }\n\n## LINQ query in C\\# by method syntax, using the lambda operator =&gt;\nNext is another use of LINQ in C\\#, except this time the more standard syntax is used to call the LINQ API. The approach also involves use of the lambda operator **=&gt;**. The following C\\# query is functionally equivalent to the preceding C\\# query.\n\n    var query = customers\n        .Where(c => string.Compare(c.AccountNum, \"4000\") >= 0)\n        .Join(customers, \n              primary => primary.AccountNum,\n              foreign => foreign.AccountNum,\n              (primary, foreign) => new { P = primary, F = foreign })\n        .OrderBy(primaryAndForeign => primaryAndForeign.P.AccountNum)\n        .Select(primaryAndForeign => primaryAndForeign.P);\n\nThere's a good match between the `while select` syntax used in X++ and the specialized LINQ syntax in C\\# (Visual Basic has particularly good LINQ syntax). It's evident that the specialized LINQ syntax is actually very useful in expressing joins, but the specialized syntax built into the C\\# compiler doesn't handle the extensions provided by Dynamics AX.\n\n### Limitation of the specialized LINQ syntax\n\nA limitation of the specialized LINQ syntax is that is can't be augmented with extensions to the LINQ provider. In contrast, standard syntax of method calls plus the lambda operator can be extended as needed. For instance, the LINQ framework provides a method for cross-company hints that can't be expressed in the special syntax for LINQ in C\\#. Fortunately, due to the ability to compose queries, this limitation need not be a major problem. Calls to esoteric LINQ methods can be appended to the specialized LINQ syntax. The following C\\# code shows this being done for the **crosscompany** method.\n\n    var query = (from ct in customers\n                from trans in customerTransactions\n                where ct.AccountNum >= “4000”\n                where trans.AccountNum == ct.AccountNum\n                orderby ct.AccountNum descending\n                select ct).crosscompany();      // C#, mixing LINQ syntax mechanisms.\n\n## LINQ query execution\nThe code generated for a LINQ query builds a tree at run time. When the results of the query are required, this tree is passed to the backend that will interpret it, and will provide the data as expressed in the query. The X++ compiler also builds a tree to express the query, but the X++ compiler has intimate knowledge about the capabilities of the database backend. This has several important implications as described in the following subsections.\n\n### Inability to diagnose problems at LINQ compile-time\n\nThe C\\# compiler is largely unable to foresee and diagnose errors that will occur at run time due to the inability of the backend to process an incompatible LINQ query. For instance, in the following C\\# code block, the specialized LINQ syntax is valid according to the C\\# compiler. Yet at run time, an error would occur.\n\n    var customerQuery = from c in db.Customers    // C#\n                        where (from o in db.Orders\n                        where o.ShipCountry == “Germany”\n                        select o.CustomerID).Contains(c.CustomerID);\n\nThis query can't be handled by the current data layer, and while no errors are diagnosed at compile time, an error would occur at run time.\n\n### Performance penalty with LINQ\n\nThere is an overhead penalty paid at run time, when analysis of the tree occurs, and a suitable access language is generated. As we might expect, the performance penalty is incurred when analyzing the LINQ expression tree. The time required at run time to actually fetch the data doesn't vary much between C\\# and LINQ versus X++ with `while select`. Our preliminary numbers show that the beginning-to-end performance of the query is about three times longer with C\\# LINQ, compared to X++ `while select`, when very few records are fetched. But when many records are fetched, the total times are about the same between C\\# and X++. The conclusion is that it takes much longer to fetch a lot of records than it takes to analyze the language tree.\n\n### Query composability with LINQ\n\nThe model that's provided by LINQ allows queries to be composed of subqueries. The X++ language can't cleanly provide this feature. To understand this, consider the following C\\# LINQ code. A flag is passed to a method to control the ordering of data results.\n\n    private IEnumerable RichCustomers(bool orderByName)    // C#\n    {\n        // Create a query for the rich customers. Note carefully\n        // that no data is fetched when this is executed.\n        var q = from c in customers where c.AmountMst > 1000000.0m select c;\n\n        if (orderByName)\n        {\n            // Add the order by clause to the existing query.\n            // Still no data is yet fetched.\n            return q.OrderBy(c => c.AccountNum);\n        }\n        else\n        {\n            return q;\n        }\n    }\n\n### Set based operations with LINQ\n\nLINQ queries can be applied for CRUD operations. But the model for updating, deleting, and inserting records isn't useful for the expression of set based operations. For a future release of Dynamics AX, we're working on extensions to add to the LINQ model that will translate into set based operations.\n\nSee also\n--------\n\n[Programming language support](programming-language-support.md)\n\n[Technical Concepts Guide](developer-home-page.md)\n\n"}