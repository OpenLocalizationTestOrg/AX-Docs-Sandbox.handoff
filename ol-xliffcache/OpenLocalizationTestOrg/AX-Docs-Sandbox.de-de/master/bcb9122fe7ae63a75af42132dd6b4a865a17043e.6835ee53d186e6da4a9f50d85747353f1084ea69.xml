{"nodes":[{"pos":[32,65],"content":"Class extensions | Microsoft Docs","needQuote":true,"needEscape":true,"nodes":[{"content":"Class extensions | Microsoft Docs","pos":[0,33]}]},{"pos":[79,139],"content":"This article describes the new class extension model in X++.","needQuote":true,"needEscape":true,"nodes":[{"content":"This article describes the new class extension model in X++.","pos":[0,60]}]},{"pos":[565,581],"content":"Class extensions","linkify":"Class extensions","nodes":[{"content":"Class extensions","pos":[0,16]}]},{"content":"Because over-layering is a very intrusive feature, we recommend that you not use it – at least not for cloud solutions.","pos":[583,702]},{"content":"The alternative to over-layering is extension.","pos":[703,749]},{"content":"Extension lets you extend existing artifacts in a new model.","pos":[750,810]},{"content":"Extensions are easier to maintain, but the amount of extension that can be done during customization is limited.","pos":[811,923]},{"content":"There are rich ways to extend the metadata.","pos":[924,967]},{"content":"For example, you can add new fields to a table.","pos":[968,1015]},{"content":"This article describes how X++ code can be extended, so that you can add methods and state to artifacts that are defined in other models without recompiling those models.","pos":[1016,1186]},{"content":"A similar code extension mechanism already exists for X++ and is modeled after the corresponding feature in C<ph id=\"ph1\">\\#</ph>. Under this mechanism, a class can be designated as an extension class through a naming convention and by hosting public static methods.","pos":[1187,1435],"source":" A similar code extension mechanism already exists for X++ and is modeled after the corresponding feature in C\\#. Under this mechanism, a class can be designated as an extension class through a naming convention and by hosting public static methods."},{"content":"In the existing feature, the type of the first argument that is passed to the extension method is the type to extend.","pos":[1436,1553]},{"content":"What this article describes is the next step in that direction, which offers a more capable and natural extension story.","pos":[1554,1674]},{"content":"In objected-oriented programming, the term <bpt id=\"p1\">*</bpt>extend<ept id=\"p1\">*</ept> has a well-defined meaning.","pos":[1675,1754],"source":" In objected-oriented programming, the term *extend* has a well-defined meaning."},{"content":"If we say, \"class B extends class A,\" we mean that B inherits from A, and the usual object-oriented rules are implied.","pos":[1755,1873]},{"content":"In fact, this term is even used in the X++ syntax that is used in class declarations to express this relationship.","pos":[1874,1988]},{"content":"At the same time, we use the term <bpt id=\"p1\">*</bpt>extension<ept id=\"p1\">*</ept> to talk about metadata that has contributions from several models.","pos":[1989,2101],"source":" At the same time, we use the term *extension* to talk about metadata that has contributions from several models."},{"content":"To avoid overloading the term <bpt id=\"p1\">*</bpt>extend<ept id=\"p1\">*</ept>, we will instead use the term <bpt id=\"p2\">*</bpt>class augmentation<ept id=\"p2\">*</ept> to designate the relationship between a class A in a base model and a class B in a model that depends on it, where B provides additional functionality to class A in the context of that model.","pos":[2102,2383],"source":" To avoid overloading the term *extend*, we will instead use the term *class augmentation* to designate the relationship between a class A in a base model and a class B in a model that depends on it, where B provides additional functionality to class A in the context of that model."},{"content":"Nevertheless, we will also continue to use the term <bpt id=\"p1\">*</bpt>extension class<ept id=\"p1\">*</ept>, because it's prevalent.","pos":[2384,2478],"source":" Nevertheless, we will also continue to use the term *extension class*, because it's prevalent."},{"pos":[2483,2510],"content":"The effective class concept","linkify":"The effective class concept","nodes":[{"content":"The effective class concept","pos":[0,27]}]},{"content":"It's useful to have a term for a class that consists of the public members of the augmented artifact and all the public members of all the class extensions that augment that artifact.","pos":[2511,2694]},{"content":"This class is called the effective class in a given model.","pos":[2695,2753]},{"content":"The following illustration shows an artifact, <bpt id=\"p1\">**</bpt>MyArtifact<ept id=\"p1\">**</ept>, that is defined in a base model, <bpt id=\"p2\">**</bpt>MyModel<ept id=\"p2\">**</ept>, and two dependent models that have extension classes for <bpt id=\"p3\">**</bpt>MyArtifact<ept id=\"p3\">**</ept>.","pos":[2754,2934],"source":" The following illustration shows an artifact, **MyArtifact**, that is defined in a base model, **MyModel**, and two dependent models that have extension classes for **MyArtifact**."},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Artifact MyArtifact that is defined in base model MyModel, and two dependent models that have extension classes for MyArtifact<ept id=\"p1\">](media/Extensions-11.png)](media/Extensions-11.png)</ept> In this example, the effective class is the class in the extension models that contains all the original methods and all the public artifacts from the extension classes.","pos":[2935,3286],"source":"[![Artifact MyArtifact that is defined in base model MyModel, and two dependent models that have extension classes for MyArtifact](media/Extensions-11.png)](media/Extensions-11.png) In this example, the effective class is the class in the extension models that contains all the original methods and all the public artifacts from the extension classes."},{"content":"The effective class isn't the same in every model, because it includes only the class extensions that are defined in a given model.","pos":[3287,3418]},{"content":"The following illustration shows the effective class of <bpt id=\"p1\">**</bpt>MyArtifact<ept id=\"p1\">**</ept> in the <bpt id=\"p2\">**</bpt>MyExtensionModel<ept id=\"p2\">**</ept> model.","pos":[3419,3524],"source":" The following illustration shows the effective class of **MyArtifact** in the **MyExtensionModel** model."},{"content":"![Effective class of MyArtifact in MyExtensionModel] We will describe class extensions by using a class that is named <bpt id=\"p1\">**</bpt>MyClass<ept id=\"p1\">**</ept> in a model that is named <bpt id=\"p2\">**</bpt>MyModel<ept id=\"p2\">**</ept>.","pos":[3525,3692],"source":" ![Effective class of MyArtifact in MyExtensionModel] We will describe class extensions by using a class that is named **MyClass** in a model that is named **MyModel**."},{"pos":[3831,4024],"content":"We can add new methods and state to <bpt id=\"p1\">**</bpt>MyClass<ept id=\"p1\">**</ept> by introducing an extension class in the extension model (<bpt id=\"p2\">**</bpt>MyExtensionModel<ept id=\"p2\">**</ept>) that builds on top of (that is, has a dependency on) <bpt id=\"p3\">**</bpt>MyModel<ept id=\"p3\">**</ept>.","source":"We can add new methods and state to **MyClass** by introducing an extension class in the extension model (**MyExtensionModel**) that builds on top of (that is, has a dependency on) **MyModel**."},{"pos":[4029,4057],"content":"Extension class declarations","linkify":"Extension class declarations","nodes":[{"content":"Extension class declarations","pos":[0,28]}]},{"content":"Extension classes are classes that are adorned with the <bpt id=\"p1\">**</bpt>ExtensionOf<ept id=\"p1\">**</ept> attribute and that also have a name that has the <bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\_</ph>Extension<ept id=\"p2\">**</ept> suffix.","pos":[4058,4202],"source":"Extension classes are classes that are adorned with the **ExtensionOf** attribute and that also have a name that has the **\\_Extension** suffix."},{"content":"(This restriction on the naming might be removed later.) The name of the extension class is otherwise unimportant.","pos":[4203,4317]},{"content":"The class augments the artifact that is specified in the <bpt id=\"p1\">**</bpt>ExtensionOf<ept id=\"p1\">**</ept> attribute, as shown in the following example.","pos":[4318,4436],"source":" The class augments the artifact that is specified in the **ExtensionOf** attribute, as shown in the following example."},{"content":"Because the classes are instantiated by the runtime system, it's not meaningful to derive from the extension class.","pos":[4569,4684]},{"content":"Therefore, the extension class must be marked as <bpt id=\"p1\">**</bpt>final<ept id=\"p1\">**</ept>.","pos":[4685,4744],"source":" Therefore, the extension class must be marked as **final**."},{"content":"The <bpt id=\"p1\">**</bpt>classStr<ept id=\"p1\">**</ept> compile-time function must be used and has two purposes:","pos":[4745,4818],"source":" The **classStr** compile-time function must be used and has two purposes:"},{"pos":[4824,4895],"content":"It produces a compilation error if the <bpt id=\"p1\">**</bpt>MyClass<ept id=\"p1\">**</ept> class doesn't exist.","source":"It produces a compilation error if the **MyClass** class doesn't exist."},{"content":"The compile-time function that is used tells the compiler what kind of artifact is augmented.","pos":[4900,4993]},{"content":"Artifact names by themselves don't uniquely identify a given artifact to augment.","pos":[4994,5075]},{"content":"For example, forms can have the same names as tables, classes, and enums.","pos":[5076,5149]},{"content":"Any number of extension classes can augment a given artifact in a particular model.","pos":[5151,5234]},{"content":"Extension classes are never referenced directly by the programmer, only by the runtime system.","pos":[5235,5329]},{"pos":[5334,5361],"content":"Extension class inheritance","linkify":"Extension class inheritance","nodes":[{"content":"Extension class inheritance","pos":[0,27]}]},{"content":"Any class that inherits from an augmented class also inherits the effective class.","pos":[5362,5444]},{"content":"In other words, the classes that inherit from a class that has extensions inherit the methods that are defined in the extension classes.","pos":[5445,5581]},{"pos":[5586,5598],"content":"Constructors","linkify":"Constructors","nodes":[{"content":"Constructors","pos":[0,12]}]},{"content":"X++ supports both instance constructors and static constructors.","pos":[5599,5663]},{"pos":[5669,5690],"content":"Instance constructors","linkify":"Instance constructors","nodes":[{"content":"Instance constructors","pos":[0,21]}]},{"content":"The instance constructor is the method that is named <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept>.","pos":[5692,5753],"source":"The instance constructor is the method that is named **new**."},{"content":"The instance constructor that is defined in an extension class can't have parameters.","pos":[5754,5839]},{"content":"Instances of the extension classes are created, and the runtime system calls their constructors as required by the usage scenario.","pos":[5840,5970]},{"content":"These constructors are never explicitly called by your code.","pos":[5971,6031]},{"content":"Constructors are useful for initializing the state of the extension objects.","pos":[6032,6108]},{"content":"It's guaranteed that the constructor that is provided in an extension class will be called one time before any instance method or the instance state on the extension class is accessed.","pos":[6109,6293]},{"content":"However, if no such references are made, the constructor isn't called.","pos":[6294,6364]},{"pos":[6370,6389],"content":"Static constructors","linkify":"Static constructors","nodes":[{"content":"Static constructors","pos":[0,19]}]},{"content":"Static constructors are the parameter-less static methods that are named <bpt id=\"p1\">**</bpt>typenew<ept id=\"p1\">**</ept>.","pos":[6391,6476],"source":"Static constructors are the parameter-less static methods that are named **typenew**."},{"content":"Static constructors can be defined on extension classes.","pos":[6477,6533]},{"content":"It's guaranteed that the runtime system will call the constructor before the first reference to the extension type.","pos":[6534,6649]},{"content":"You can't assume any particular order of invocation for static construction among a set of extensions.","pos":[6650,6752]},{"pos":[6757,6764],"content":"Methods","linkify":"Methods","nodes":[{"content":"Methods","pos":[0,7]}]},{"content":"The public methods that are defined in extension classes provide additional functionality to the augmented class in the context of the model where the extension class is defined.","pos":[6765,6943]},{"content":"Only public methods are exposed in this way.","pos":[6944,6988]},{"content":"You can define private methods to help implement the public methods, but those private methods aren't part of the effective class.","pos":[6989,7119]},{"content":"Because extension classes are final, methods can't be marked as <bpt id=\"p1\">**</bpt>protected<ept id=\"p1\">**</ept>.","pos":[7120,7198],"source":" Because extension classes are final, methods can't be marked as **protected**."},{"pos":[7204,7220],"content":"Instance methods","linkify":"Instance methods","nodes":[{"content":"Instance methods","pos":[0,16]}]},{"pos":[7222,7336],"content":"The following example defines an extension method that is named <bpt id=\"p1\">**</bpt>ExtensionMethod<ept id=\"p1\">**</ept> and that augments <bpt id=\"p2\">**</bpt>MyClass<ept id=\"p2\">**</ept>.","source":"The following example defines an extension method that is named **ExtensionMethod** and that augments **MyClass**."},{"content":"The public instance method (<bpt id=\"p1\">**</bpt>ExtensionMethod<ept id=\"p1\">**</ept>) is defined in the extension class.","pos":[7533,7616],"source":"The public instance method (**ExtensionMethod**) is defined in the extension class."},{"content":"Therefore, it's available just as if it were defined in <bpt id=\"p1\">**</bpt>MyClass<ept id=\"p1\">**</ept> in the context of the model where the extension class is defined.","pos":[7617,7750],"source":" Therefore, it's available just as if it were defined in **MyClass** in the context of the model where the extension class is defined."},{"content":"The following example shows how to call the method in the model.","pos":[7751,7815]},{"content":"Note that the instance method that is defined in the extension class is used as an instance method on the augmented artifact.","pos":[7882,8007]},{"content":"An extension method can access public members only from the artifact that it augments.","pos":[8008,8094]},{"content":"This behavior is by design.","pos":[8095,8122]},{"content":"No artifact should be able to interact directly with state and methods that are explicitly hidden through the <bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>internal<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>protected<ept id=\"p3\">**</ept> keywords.","pos":[8123,8286],"source":" No artifact should be able to interact directly with state and methods that are explicitly hidden through the **private**, **internal**, or **protected** keywords."},{"content":"Otherwise, direct interaction with explicitly hidden state and methods could cause malfunction by invalidating key implementation assumptions in those artifacts.","pos":[8287,8448]},{"content":"Methods and statements in the method body can use the <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> keyword.","pos":[8449,8520],"source":" Methods and statements in the method body can use the **this** keyword."},{"content":"In this context, the type of <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> is the effective class of the augmented artifact.","pos":[8521,8608],"source":" In this context, the type of **this** is the effective class of the augmented artifact."},{"pos":[8614,8628],"content":"Static methods","linkify":"Static methods","nodes":[{"content":"Static methods","pos":[0,14]}]},{"content":"Methods that are defined as public and static in the extension class are available as static methods on the artifact that is augmented.","pos":[8630,8765]},{"content":"The following example shows how to call the method in the model.","pos":[9084,9148]},{"content":"A static method can access the public static methods and state in the effective class of the augmented artifact.","pos":[9202,9314]},{"content":"As an interesting side effect, static extension methods on the <bpt id=\"p1\">**</bpt>Global<ept id=\"p1\">**</ept> class become available in the language as functions, which are available without any prefix.","pos":[9315,9481],"source":" As an interesting side effect, static extension methods on the **Global** class become available in the language as functions, which are available without any prefix."},{"pos":[9486,9491],"content":"State","linkify":"State","nodes":[{"content":"State","pos":[0,5]}]},{"content":"In addition to providing static and instance methods to an artifact, you can add instance state and static state.","pos":[9492,9605]},{"pos":[9611,9625],"content":"Instance state","linkify":"Instance state","nodes":[{"content":"Instance state","pos":[0,14]}]},{"content":"Instance state, which is state that pertains to a particular instance of an artifact, can be specified on extension classes.","pos":[9627,9751]},{"content":"The following example defines a state that is named <bpt id=\"p1\">**</bpt>state<ept id=\"p1\">**</ept>.","pos":[9752,9814],"source":" The following example defines a state that is named **state**."},{"pos":[9973,10035],"content":"The following example shows how to use <bpt id=\"p1\">**</bpt>state<ept id=\"p1\">**</ept> in your code.","source":"The following example shows how to use **state** in your code."},{"pos":[10091,10103],"content":"Static state","linkify":"Static state","nodes":[{"content":"Static state","pos":[0,12]}]},{"content":"Static state applies to the type instead of an instance of the type.","pos":[10105,10173]},{"content":"The following example shows a static extension state.","pos":[10174,10227]}],"content":"---\n# required metadata\n\ntitle: Class extensions | Microsoft Docs\ndescription: This article describes the new class extension model in X++.\nauthor: annbe\nmanager: AnnBe\nms.date: 2016-06-08 15:54:26\nms.topic: article\nms.prod: \nms.service: Dynamics365Operations\nms.technology: \n\n# optional metadata\n\n# keywords: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \n# ms.reviewer: \nms.suite: Released- Dynamics AX platform update 1\n# ms.tgt_pltfrm: \nms.custom: 89563\nms.assetid: 5d547d6c-a174-47ee-9247-0ba9b3107d00\n# ms.region: \n# ms.industry: \nms.author: pvillads\n\n---\n\n# Class extensions\n\nBecause over-layering is a very intrusive feature, we recommend that you not use it – at least not for cloud solutions. The alternative to over-layering is extension. Extension lets you extend existing artifacts in a new model. Extensions are easier to maintain, but the amount of extension that can be done during customization is limited. There are rich ways to extend the metadata. For example, you can add new fields to a table. This article describes how X++ code can be extended, so that you can add methods and state to artifacts that are defined in other models without recompiling those models. A similar code extension mechanism already exists for X++ and is modeled after the corresponding feature in C\\#. Under this mechanism, a class can be designated as an extension class through a naming convention and by hosting public static methods. In the existing feature, the type of the first argument that is passed to the extension method is the type to extend. What this article describes is the next step in that direction, which offers a more capable and natural extension story. In objected-oriented programming, the term *extend* has a well-defined meaning. If we say, \"class B extends class A,\" we mean that B inherits from A, and the usual object-oriented rules are implied. In fact, this term is even used in the X++ syntax that is used in class declarations to express this relationship. At the same time, we use the term *extension* to talk about metadata that has contributions from several models. To avoid overloading the term *extend*, we will instead use the term *class augmentation* to designate the relationship between a class A in a base model and a class B in a model that depends on it, where B provides additional functionality to class A in the context of that model. Nevertheless, we will also continue to use the term *extension class*, because it's prevalent.\n\n## The effective class concept\nIt's useful to have a term for a class that consists of the public members of the augmented artifact and all the public members of all the class extensions that augment that artifact. This class is called the effective class in a given model. The following illustration shows an artifact, **MyArtifact**, that is defined in a base model, **MyModel**, and two dependent models that have extension classes for **MyArtifact**. [![Artifact MyArtifact that is defined in base model MyModel, and two dependent models that have extension classes for MyArtifact](media/Extensions-11.png)](media/Extensions-11.png) In this example, the effective class is the class in the extension models that contains all the original methods and all the public artifacts from the extension classes. The effective class isn't the same in every model, because it includes only the class extensions that are defined in a given model. The following illustration shows the effective class of **MyArtifact** in the **MyExtensionModel** model. ![Effective class of MyArtifact in MyExtensionModel] We will describe class extensions by using a class that is named **MyClass** in a model that is named **MyModel**.\n\n    class MyClass\n    {\n        public int mycState;\n        public str mycMethod(int arg)\n        {\n            // ...\n        }\n    }\n\nWe can add new methods and state to **MyClass** by introducing an extension class in the extension model (**MyExtensionModel**) that builds on top of (that is, has a dependency on) **MyModel**.\n\n## Extension class declarations\nExtension classes are classes that are adorned with the **ExtensionOf** attribute and that also have a name that has the **\\_Extension** suffix. (This restriction on the naming might be removed later.) The name of the extension class is otherwise unimportant. The class augments the artifact that is specified in the **ExtensionOf** attribute, as shown in the following example.\n\n    [ExtensionOf(classStr(MyClass))]\n    final class MyClass_Extension\n    {\n        private void new()\n        {\n        }\n    }\n\nBecause the classes are instantiated by the runtime system, it's not meaningful to derive from the extension class. Therefore, the extension class must be marked as **final**. The **classStr** compile-time function must be used and has two purposes:\n\n-   It produces a compilation error if the **MyClass** class doesn't exist.\n-   The compile-time function that is used tells the compiler what kind of artifact is augmented. Artifact names by themselves don't uniquely identify a given artifact to augment. For example, forms can have the same names as tables, classes, and enums.\n\nAny number of extension classes can augment a given artifact in a particular model. Extension classes are never referenced directly by the programmer, only by the runtime system.\n\n## Extension class inheritance\nAny class that inherits from an augmented class also inherits the effective class. In other words, the classes that inherit from a class that has extensions inherit the methods that are defined in the extension classes.\n\n## Constructors\nX++ supports both instance constructors and static constructors.\n\n### Instance constructors\n\nThe instance constructor is the method that is named **new**. The instance constructor that is defined in an extension class can't have parameters. Instances of the extension classes are created, and the runtime system calls their constructors as required by the usage scenario. These constructors are never explicitly called by your code. Constructors are useful for initializing the state of the extension objects. It's guaranteed that the constructor that is provided in an extension class will be called one time before any instance method or the instance state on the extension class is accessed. However, if no such references are made, the constructor isn't called.\n\n### Static constructors\n\nStatic constructors are the parameter-less static methods that are named **typenew**. Static constructors can be defined on extension classes. It's guaranteed that the runtime system will call the constructor before the first reference to the extension type. You can't assume any particular order of invocation for static construction among a set of extensions.\n\n## Methods\nThe public methods that are defined in extension classes provide additional functionality to the augmented class in the context of the model where the extension class is defined. Only public methods are exposed in this way. You can define private methods to help implement the public methods, but those private methods aren't part of the effective class. Because extension classes are final, methods can't be marked as **protected**.\n\n### Instance methods\n\nThe following example defines an extension method that is named **ExtensionMethod** and that augments **MyClass**.\n\n    [ExtensionOf(classStr(MyClass))]\n    final class MyClass_Extension\n    {\n        private void new()\n        {\n        }\n        public int ExtensionMethod(int arg)\n        {\n        }\n    }\n\nThe public instance method (**ExtensionMethod**) is defined in the extension class. Therefore, it's available just as if it were defined in **MyClass** in the context of the model where the extension class is defined. The following example shows how to call the method in the model.\n\n    MyClass c = new MyClass();\n    print c.ExtensionMethod(32);\n\nNote that the instance method that is defined in the extension class is used as an instance method on the augmented artifact. An extension method can access public members only from the artifact that it augments. This behavior is by design. No artifact should be able to interact directly with state and methods that are explicitly hidden through the **private**, **internal**, or **protected** keywords. Otherwise, direct interaction with explicitly hidden state and methods could cause malfunction by invalidating key implementation assumptions in those artifacts. Methods and statements in the method body can use the **this** keyword. In this context, the type of **this** is the effective class of the augmented artifact.\n\n### Static methods\n\nMethods that are defined as public and static in the extension class are available as static methods on the artifact that is augmented.\n\n    [ExtensionOf(classStr(MyClass))]\n    final class MyClass_Extension\n    {\n        private void new()\n        {\n        }\n        public int method1(int arg)\n        {\n        }\n        public static real CelsiusToFahrenheit(real celsius)\n        {\n            return (celsius * 9.0 / 5.0) + 32.0;\n        }\n    }\n\nThe following example shows how to call the method in the model.\n\n    var temp = MyClass::CelsiusToFahrenheit(20.0);\n\nA static method can access the public static methods and state in the effective class of the augmented artifact. As an interesting side effect, static extension methods on the **Global** class become available in the language as functions, which are available without any prefix.\n\n## State\nIn addition to providing static and instance methods to an artifact, you can add instance state and static state.\n\n### Instance state\n\nInstance state, which is state that pertains to a particular instance of an artifact, can be specified on extension classes. The following example defines a state that is named **state**.\n\n    [ExtensionOf(classStr(MyClass))]\n    final class MyClass_Extension\n    {\n        public int state;\n        private void new()\n        {\n        }\n    }\n\nThe following example shows how to use **state** in your code.\n\n    MyClass c = new MyClass();\n    c.state = 12;\n\n### Static state\n\nStatic state applies to the type instead of an instance of the type. The following example shows a static extension state.\n\n    [ExtensionOf(classStr(MyClass))]\n    final class MyClass_Extension\n    {\n        public int state;\n        public static int staticState;\n        static void TypeNew()\n        {\n            staticState = 77;\n        }\n    }\n\n"}