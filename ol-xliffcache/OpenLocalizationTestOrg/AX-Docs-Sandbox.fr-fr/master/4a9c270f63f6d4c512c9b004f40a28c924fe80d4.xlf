<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-bf14093" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4a9c270f63f6d4c512c9b004f40a28c924fe80d4</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dev-itpro\dev-reference\xpp-data-query.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">do-not-translate</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05bb590fb112b83308bf7a98441ed0997a9b6701</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">43a12207c1570942a422ca2012739d9b777bad57</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>X++ data selection and manipulation | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>This topic describes the X++ language support for data selection and manipulation.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>X++ data selection and manipulation</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This topic describes the X++ language support for data selection and manipulation.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can use SQL statements either interactively or within source code, to access and retrieve data that is stored in the database.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You use the following statements for data manipulation:</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>select:<ept id="p1">**</ept> selects the data that you want to modify.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>insert:<ept id="p1">**</ept> adds one or more new records into a table.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>update:<ept id="p1">**</ept> modifies data in existing table records.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>delete:<ept id="p1">**</ept> removes existing records from a table.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Before any data can be changed, you must select the data for update for update by using a <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>select forUpdate<ept id="p1">**</ept> command selects records exclusively for update.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>insert<ept id="p1">**</ept>, <bpt id="p2">**</bpt>update<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>delete<ept id="p3">**</ept> methods perform operations on only one record at a time.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>array insert<ept id="p1">**</ept>, <bpt id="p2">**</bpt>insert<ph id="ph1">\_</ph>recordset<ept id="p2">**</ept>, <bpt id="p3">**</bpt>RecordInsertList,<ept id="p3">**</ept> and <bpt id="p4">**</bpt>update<ph id="ph2">\_</ph>recordset<ept id="p4">**</ept> statements perform operations on multiple records at a time.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>select statement</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement fetches or manipulates data from the database.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>All <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statements use a table variable to fetch records.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This variable must be declared before a <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement can be executed.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement only fetches one record, or field.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To fetch additional records, you can use the <bpt id="p1">**</bpt>next<ept id="p1">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>next<ept id="p1">**</ept> statement fetches the next record in the table.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt>next<ept id="p1">**</ept> without a preceding <bpt id="p2">**</bpt>select<ept id="p2">**</ept> command, an error occurs.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Do not use <bpt id="p1">**</bpt>next<ept id="p1">**</ept> with the <bpt id="p2">**</bpt>firstOnly<ept id="p2">**</ept> find option.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If you need to traverse a number of records, it is more appropriate to use a <bpt id="p1">**</bpt>while<ept id="p1">**</ept> <bpt id="p2">**</bpt>select<ept id="p2">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The results of a <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement are returned in a table buffer variable.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If you use a field list in the <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement, only those fields are available in the table variable.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>If you use aggregate functions, such as <bpt id="p1">**</bpt>sum<ept id="p1">**</ept> or <bpt id="p2">**</bpt>count<ept id="p2">**</ept>, the results are returned in the fields that you perform the <bpt id="p3">**</bpt>sum<ept id="p3">**</ept> or <bpt id="p4">**</bpt>count<ept id="p4">**</ept> over.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You can only count, average, or sum the integer and real fields.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>select statement syntax</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>SelectStatement<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>select<ept id="p1">**</ept> <bpt id="p2">*</bpt>Parameters<ept id="p2">*</ept></source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Parameters<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt><ph id="ph1">\[</ph> <ph id="ph2">\[</ph><ept id="p1">**</ept>  <bpt id="p2">*</bpt>FindOptions<ept id="p2">*</ept>  <bpt id="p3">**</bpt><ph id="ph3">\]</ph><ept id="p3">**</ept> <bpt id="p4">**</bpt><ph id="ph4">\[</ph><ept id="p4">**</ept>  <bpt id="p5">*</bpt>FieldList<ept id="p5">*</ept>  <bpt id="p6">**</bpt>from <ph id="ph5">\]</ph> <ph id="ph6">\]</ph><ept id="p6">**</ept> <bpt id="p7">*</bpt>TableBufferVariable<ept id="p7">*</ept> <bpt id="p8">**</bpt><ph id="ph7">\[</ph><ept id="p8">**</ept> <bpt id="p9">*</bpt>IndexClause<ept id="p9">*</ept> <bpt id="p10">**</bpt><ph id="ph8">\]</ph><ept id="p10">**</ept> <bpt id="p11">**</bpt><ph id="ph9">\[</ph><ept id="p11">**</ept>  <bpt id="p12">*</bpt>Options<ept id="p12">*</ept>  <bpt id="p13">**</bpt><ph id="ph10">\]</ph><ept id="p13">**</ept> <bpt id="p14">**</bpt><ph id="ph11">\[</ph><ept id="p14">**</ept>  <bpt id="p15">*</bpt>WhereClause<ept id="p15">*</ept>  <bpt id="p16">**</bpt><ph id="ph12">\]</ph><ept id="p16">**</ept> <bpt id="p17">**</bpt><ph id="ph13">\[</ph><ept id="p17">**</ept>  <bpt id="p18">*</bpt>JoinClause<ept id="p18">*</ept>  <bpt id="p19">**</bpt><ph id="ph14">\]</ph><ept id="p19">**</ept></source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>FindOptions<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>crossCompany<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>reverse<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>firstFast<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\[</ph> <bpt id="p1">**</bpt>firstOnly<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>firstOnly10<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>firstOnly100<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>firstOnly1000<ept id="p1">**</ept> <ph id="ph1">\]</ph></source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>forUpdate<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>noFetch<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\[</ph><bpt id="p1">**</bpt>forcePlaceholders<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>forceLiterals<ept id="p1">**</ept><ph id="ph1">\]</ph></source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>forceselectorder<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>forceNestedLoop<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>repeatableRead<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>validTimeState<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>FieldList<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Field<ept id="p1">*</ept>  <bpt id="p2">**</bpt>{ ,<ept id="p2">**</ept>  <bpt id="p3">*</bpt>Field<ept id="p3">*</ept>  <bpt id="p4">**</bpt>}<ept id="p4">**</ept></source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Field<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Aggregate<ept id="p1">*</ept>  <bpt id="p2">**</bpt>(<ept id="p2">**</ept>  <bpt id="p3">*</bpt>FieldIdentifier<ept id="p3">*</ept>  **)</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt><bpt id="p2">*</bpt>  <ept id="p2">*</ept>FieldIdentifier<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Aggregate<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>sum<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>avg<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>minof<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>maxof<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>count<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Options<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt><ph id="ph1">\[</ph> order by<ept id="p1">**</ept> , <bpt id="p2">**</bpt>group by ,<ept id="p2">**</ept>  <bpt id="p3">*</bpt>FieldIdentifier<ept id="p3">*</ept>  <bpt id="p4">**</bpt><ph id="ph2">\[</ph> asc<ept id="p4">**</ept></source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>desc <ph id="ph1">\]</ph> { ,<ept id="p1">**</ept>  <bpt id="p2">*</bpt>FieldIdentifier<ept id="p2">*</ept>  <bpt id="p3">**</bpt><ph id="ph2">\[</ph> asc<ept id="p3">**</ept></source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>desc <ph id="ph1">\]</ph> }<ph id="ph2">\]</ph><ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt><ph id="ph1">\[</ph><ept id="p1">**</ept>  <bpt id="p2">*</bpt>IndexClause<ept id="p2">*</ept>  <bpt id="p3">**</bpt><ph id="ph2">\]</ph><ept id="p3">**</ept></source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>IndexClause<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>index<ept id="p1">**</ept>  <bpt id="p2">*</bpt>IndexName<ept id="p2">*</ept></source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>index hint<ept id="p1">**</ept>  <bpt id="p2">*</bpt>IndexName<ept id="p2">*</ept></source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>WhereClause<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>where<ept id="p1">**</ept>  <bpt id="p2">*</bpt>Expression<ept id="p2">*</ept></source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>JoinClause<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\[</ph><bpt id="p1">**</bpt>exists<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>notexists<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>outer<ept id="p1">**</ept> <ph id="ph1">\]</ph> <bpt id="p2">**</bpt>join<ept id="p2">**</ept>  <bpt id="p3">*</bpt>Parameters<ept id="p3">*</ept></source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Keywords used in the select statement</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Keyword</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>asc<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>An option on the <bpt id="p1">**</bpt>order by<ept id="p1">**</ept> or <bpt id="p2">**</bpt>group by<ept id="p2">**</ept> clause to specify an ascending sort.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>If neither asc or desc is specified, then the sort is ascending.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>avg<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Returns the average of the fields.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>count<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Rreturns the number of records.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>crossCompany<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Returns data for all companies that the user is authorized to read from.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>container<ept id="p1">**</ept> can be added to reduce the number of companies involved.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>desc<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>An option on the <bpt id="p1">**</bpt>order by<ept id="p1">**</ept> or <bpt id="p2">**</bpt>group by<ept id="p2">**</ept> clause to specify a descending sort.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>If neither asc or desc is specified, then the sort is ascending.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>exists<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>A method that returns a Boolean value and a <bpt id="p1">**</bpt>join<ept id="p1">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>firstFast<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>A priority hint.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The first row appears more quickly but the total return time for this option might be slower.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>firstFast<ept id="p1">**</ept> hint is automatically issued from all forms.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>firstOnly<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Speeds up the fetch by returning only the first row.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>firstOnly10<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The same as <bpt id="p1">**</bpt>firstOnly<ept id="p1">**</ept>, except returns 10 rows instead of one.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>firstOnly100<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The same as <bpt id="p1">**</bpt>firstOnly<ept id="p1">**</ept>, except returns 100 rows instead of one.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>firstOnly1000<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The same as <bpt id="p1">**</bpt>firstOnly<ept id="p1">**</ept>, except returns 1000 rows instead of one.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>forceLiterals<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Instructs the kernel to reveal the actual values that are used in <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clauses to the Microsoft SQL Server database at the time of optimization.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>forceLiterals<ept id="p1">**</ept> and <bpt id="p2">**</bpt>forcePlaceholders<ept id="p2">**</ept> are mutually exclusive.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>You should not to use the <bpt id="p1">**</bpt>forceLiterals<ept id="p1">**</ept> keyword in <bpt id="p2">**</bpt>select<ept id="p2">**</ept> statements, because it could expose code to an SQL injection security threat.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>forceNestedLoop<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Forces the Microsoft SQL Server database to use a nested-loop algorithm to process a particular SQL statement containing a join algorithm.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>This means that a record from the first table is fetched before any records from the second table are fetched.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Typically, other join algorithms, such as hash-joins and merge-joins, would be considered.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>This keyword is often combined with the <bpt id="p1">**</bpt>forceSelectOrder<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>forcePlaceholders<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Instructs the kernel not to reveal the actual values used in <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clauses to the SQL Server database at the time of optimization.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This is the default in all statements that are not <bpt id="p1">**</bpt>join<ept id="p1">**</ept> statements.The advantage of using this keyword is that the kernel can reuse the access plan for other similar statements with other search values.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The disadvantage is that the access plan is computed without taking into consideration that data distribution might not be even.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The access plan is an on-average access plan.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>forcePlaceholders<ept id="p1">**</ept> and <bpt id="p2">**</bpt>forceLiterals<ept id="p2">**</ept> are mutually exclusive.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>forceSelectOrder<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Forces the SQL Server database to access the tables in a join in the specified order.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>If two tables are joined, the first table in the statement is always accessed first.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>This keyword is often combined with <bpt id="p1">**</bpt>forceNestedLoop.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>forUpdate<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Selects records exclusively for update.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Depending on the underlying database, the records may be locked for other users.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>group by<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Instructs the database to group selected records by fields.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>index<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Instructs the database to sort the selected records as defined by the index.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>index hint<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Gives the database a hint to use this index to sort the selected records as defined by the index.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The database can ignore the hint.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>A wrong index hint can have a big performance impact.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Index hints should only be applied to SQL statements that do not have dynamic <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clauses or <bpt id="p2">**</bpt>order by<ept id="p2">**</ept> clauses, and where the effect of the hint can be verified.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>join<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Used to join tables on a column that is common to both tables.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The join criteria are specified in where clause because there is no <bpt id="p1">**</bpt>on<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Reduces the number of SQL statements that are needed if you want to loop through a table and update transactions in a related table.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>For example, if you process 500 records in a table, and want to update related records in another table, and use a nested <bpt id="p1">**</bpt>while select<ept id="p1">**</ept> to do this, there will be 501 trips to the database.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>If you use a <bpt id="p1">**</bpt>join<ept id="p1">**</ept>, there will be a single trip to the database.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>maxof<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Returns the maximum of the fields.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>minof<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Returns the minimum of the fields.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>noFetch<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Indicates that no records are to be fetched at present.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>This is typically used when the result of the select is passed on to another application object, for example, a query that performs the actual fetch.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>notExists<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Is chosen only if there are no posts.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>optimisticLock<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Forces a statement to run with optimistic concurrency control even if a different value is set on the table.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>order by<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Instructs the database to sort the selected records by fields in <bpt id="p1">**</bpt>order by<ept id="p1">**</ept> list.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>outer<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Returns all rows from the first-named table, including rows that have no match in the second-named table.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>This is a left outer join, although there is no <bpt id="p1">**</bpt>left<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>There is no right outer join.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>pessimisticLock<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Forces a statement to run with pessimistic concurrency control even if a different value is set on the table.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>repeatableRead<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Specifies that no other transactions can modify data that has been read by logic inside the current transaction, until after the current transaction completes.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>An explicit transaction completes at either <bpt id="p1">**</bpt>ttsAbort<ept id="p1">**</ept> or at the outermost <bpt id="p2">**</bpt>ttsCommit<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>For a stand-alone <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement, the transaction duration is the duration of <bpt id="p2">**</bpt>select<ept id="p2">**</ept> command.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>However, the database sometimes enforces the equivalent of <bpt id="p1">**</bpt>repeatableRead<ept id="p1">**</ept> in individual <bpt id="p2">**</bpt>select<ept id="p2">**</ept> statements even without this keyword appearing in your code (depending on how the database decides to scan the tables).</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>For more information, see the documentation for the underlying relational database product.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>reverse<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Records are returned in reverse order.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>sum<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Returns the sum of the fields.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Can be used to sum all accounts, order lines, and so on.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>validTimeState<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Filters rows from a table that has its <bpt id="p1">**</bpt>ValidTimeStateFieldType<ept id="p1">**</ept> property set to a value other than <bpt id="p2">**</bpt>None.<ept id="p2">**</ept></source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Keyword code examples</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>select statement examples</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The following examples demonstrate how you can use the <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>join code example</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>This code example shows how an inner <bpt id="p1">**</bpt>join<ept id="p1">**</ept> can be performed as part of an SQL <bpt id="p2">**</bpt>select<ept id="p2">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The example also shows an order by clause that has each field qualified by a table name.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>This enables you to control how the retrieved records are sorted by using only one order by clause.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>group by and order by code example</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>This code example shows that the fields in the <bpt id="p1">**</bpt>group by<ept id="p1">**</ept> clause can be qualified with a table name.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>There can be multiple <bpt id="p1">**</bpt>group by<ept id="p1">**</ept> clauses instead of just one.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The fields can be qualified by table name in only one <bpt id="p1">**</bpt>group by<ept id="p1">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Use of table name qualifiers is recommended.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>order by<ept id="p1">**</ept> clause follows the same syntax patterns that group by follows.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>If provided, both clauses must appear after the <bpt id="p1">**</bpt>join<ept id="p1">**</ept> (or <bpt id="p2">**</bpt>from<ept id="p2">**</ept>) clause, and both must appear before the <bpt id="p3">**</bpt>where<ept id="p3">**</ept> clause that might exist on the same <bpt id="p4">**</bpt>join<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>It is recommended that all group by and order by and <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clauses appear immediately after the last <bpt id="p2">**</bpt>join<ept id="p2">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>select statement with an outer join</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement supports filtering an <bpt id="p2">**</bpt>outer join<ept id="p2">**</ept> in the <bpt id="p3">**</bpt>where<ept id="p3">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>join<ept id="p1">**</ept> clause of standard SQL there is an <bpt id="p2">**</bpt>on<ept id="p2">**</ept> keyword for filter criteria, but that isn't supported in X++.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>An inner join rejects all table rows that fail to match a row in the other joined table.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>But an outer join includes rows from the first table even though there is no matching row in the other joined table.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Default values are substituted for the data that could not be obtained from a matching row in the other joined table.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>You can filter an outer join at the equivalent of an <bpt id="p1">**</bpt>on<ept id="p1">**</ept> clause that is part of the <bpt id="p2">**</bpt>join<ept id="p2">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>For an inner join there is no behavioral difference between filtering on an <bpt id="p1">**</bpt>on<ept id="p1">**</ept> clause versus on the <bpt id="p2">**</bpt>where<ept id="p2">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>select statement code example</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>This code example is based on two tables.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The field types and example data are included.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>There is a 1-to-many relationship between the <bpt id="p1">**</bpt>SalesOrder<ept id="p1">**</ept> parent table and the <bpt id="p2">**</bpt>SalesOrderLine<ept id="p2">**</ept> child table.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>There are 0 or more rows in the <bpt id="p1">**</bpt>SalesOrderLine<ept id="p1">**</ept> table for each row in the <bpt id="p2">**</bpt>SalesOrder<ept id="p2">**</ept> table.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>There are two rows in the <bpt id="p1">**</bpt>SalesOrder<ept id="p1">**</ept> table.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>SalesOrderID<ept id="p1">**</ept> (integer, primary key)</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>DateAdded<ept id="p1">**</ept> (date)</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>2010-01-01</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>2</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>2010-02-02</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>SalesOrderLine<ept id="p1">**</ept> table contains a foreign key field, named <bpt id="p2">**</bpt>SalesOrderID<ept id="p2">**</ept>, that references the primary key column of the <bpt id="p3">**</bpt>SalesOrder<ept id="p3">**</ept> table.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>SalesOrderID<ept id="p1">**</ept> value <bpt id="p2">**</bpt>2<ept id="p2">**</ept> does not occur in the data for <bpt id="p3">**</bpt>SalesOrderLine<ept id="p3">**</ept> table.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>SalesOrderLineID<ept id="p1">**</ept> (string, primary key)</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Quantity<ept id="p1">**</ept> (integer)</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>SalesOrderID<ept id="p1">**</ept> (integer, foreign key)</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>AA</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>BB</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>67</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>CC</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>66</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The code example has a <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement that reads the tables which are described in the previous section.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement includes a left <bpt id="p2">**</bpt>outer join<ept id="p2">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The join criteria and the data filter are both on the <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The output from the code example is also in this section.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The second record in the output has a <bpt id="p1">**</bpt>SalesOrderID<ept id="p1">**</ept> value of 2.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>That value of 2 is not present in the <bpt id="p1">**</bpt>SalesOrderLine<ept id="p1">**</ept> table.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Therefore, some of the fields in the second record have default values, namely 0 for an integer and a zero length string for a string.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>while select statements</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>while select<ept id="p1">**</ept> statements are used to handle data.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>They are the most widely used form of the select statement.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>while select<ept id="p1">**</ept> loops over many records (meeting certain criteria) and can execute a statement on each record.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>When you perform data manipulation by using the <bpt id="p1">**</bpt>while select<ept id="p1">**</ept> statement, you would typically do this in a transaction to ensure data integrity.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The results of a <bpt id="p1">**</bpt>while select<ept id="p1">**</ept> statement are returned in a table buffer variable.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>If you use a field list in the <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement, only those fields are available in the table variable.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>If you use aggregate functions such as <bpt id="p1">**</bpt>sum<ept id="p1">**</ept> or <bpt id="p2">**</bpt>count<ept id="p2">**</ept>, the results are returned in the fields you perform the <bpt id="p3">**</bpt>sum<ept id="p3">**</ept> or <bpt id="p4">**</bpt>count<ept id="p4">**</ept> over.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>You can only count, average, or sum the integer and real fields.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The syntax of a <bpt id="p1">**</bpt>while select<ept id="p1">**</ept> statement resembles that of a <bpt id="p2">**</bpt>select<ept id="p2">**</ept> statement except that it is preceded by <bpt id="p3">**</bpt>while select<ept id="p3">**</ept> instead of <bpt id="p4">**</bpt>select<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement itself is executed only one time, immediately before the first iteration of the statements in the loop.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Any Boolean expressions (such as <bpt id="p1">**</bpt>iCounter <ph id="ph1">&amp;lt;</ph> 1<ept id="p1">**</ept>) added to the <bpt id="p2">**</bpt>while select<ept id="p2">**</ept> are tested only one time.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>This differs from how the <bpt id="p1">**</bpt>while<ept id="p1">**</ept> statement behaves in languages such as C++ and C<ph id="ph1">\#</ph>. For example, the following loop could iterate more than one time.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>while select code example</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>This prints the name reference and telephone number of customers in <bpt id="p1">**</bpt>CustTable<ept id="p1">**</ept> who have an account number within a specified range.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>while select Code Example</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>This code example uses the <bpt id="p1">**</bpt>forUpdate<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Deleting a set of records</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>You can use a <bpt id="p1">**</bpt>while select<ept id="p1">**</ept> statement to loop over a set of records that meet some criteria and perform an action on each record.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>One such action is to <bpt id="p1">**</bpt>delete<ept id="p1">**</ept> a set of records.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>You can achieve the same effect using the <bpt id="p1">**</bpt>delete<ph id="ph1">\_</ph>from<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>select statements on fields</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>You can use a <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement in a lookup on a field.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Following a <bpt id="p1">**</bpt>select statement<ept id="p1">**</ept> that fetches a record in a table, you can write <bpt id="p2">**</bpt>.fieldName<ept id="p2">**</ept> to reference a field in the table.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>These <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statements must be used in expressions.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>There is a difference between a <bpt id="p1">**</bpt>normal<ept id="p1">**</ept> <bpt id="p2">**</bpt>select<ept id="p2">**</ept> statement and a <bpt id="p3">**</bpt>field select<ept id="p3">**</ept> statement:</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>field select<ept id="p1">**</ept> statement operates directly on a table.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>normal select<ept id="p1">**</ept> statement operates on a table buffer variable.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>select field code example</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Aggregate functions: differences between X++ and SQL</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>In industry standard SQL, a database query can contain <bpt id="p1">**</bpt>aggregate functions<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Examples of such functions include <bpt id="p1">**</bpt>count(RecID)<ept id="p1">**</ept> and <bpt id="p2">**</bpt>sum(columnA)<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>When an aggregate function is used but no rows match the <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clause, a row must be returned to hold the result of the aggregates.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>The one returned row shows the value 0 (zero) for the <bpt id="p1">**</bpt>count<ept id="p1">**</ept> function, and shows <bpt id="p2">**</bpt>null<ept id="p2">**</ept> for the <bpt id="p3">**</bpt>sum<ept id="p3">**</ept> function.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>X++ does not support the concept of null values for the database.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Therefore, when the <bpt id="p1">**</bpt>sum<ept id="p1">**</ept> function would return null, no row is returned to the user.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Also, each data type has a specific value that is treated like a null value in certain circumstances.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>index and order by keywords in select statements</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>You use the <bpt id="p1">**</bpt>order by<ept id="p1">**</ept> keyword in your <bpt id="p2">**</bpt>select<ept id="p2">**</ept> statements to order the data that's returned.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>index<ept id="p1">**</ept> hint keywords to specify that a particular index should be used in the query and to sort the selected records as defined by the index.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Indexes optimize the selection of records.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Combine the index hint keyword with an order by expression to select records in a specific order.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>If you want the sorted output in reverse order, use the <bpt id="p1">**</bpt>reverse<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>If a table index has been disabled by setting the index's <bpt id="p1">**</bpt>Enabled<ept id="p1">**</ept> property to No, the <bpt id="p2">**</bpt>select<ept id="p2">**</ept> statement that references the index is still valid.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>However, the database can't use the index as a hint for how to sort the data, because the index doesn't exist in the database.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The following table is an overview of how to use the index hint and order by keywords in <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statements.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Task</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Use</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Select records where the order isn't significant.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>select ..<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>where ...<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Select records where the order is significant.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>select ..<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>order by ...<ept id="p1">**</ept> <bpt id="p2">**</bpt>where ...<ept id="p2">**</ept></source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Select records and force a specific index to be used.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>select ..<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>index hint ...<ept id="p1">**</ept> <bpt id="p2">**</bpt>where ...<ept id="p2">**</ept></source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Select records where the order is significant and force a specific index to be used.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>select ..<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>index hint ...<ept id="p1">**</ept> <bpt id="p2">**</bpt>order by ...<ept id="p2">**</ept> <bpt id="p3">**</bpt>where ...<ept id="p3">**</ept></source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>index and order by code example</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>To select the transactions from the salestable based on a range of customers and due dates, use the following code.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>index hint</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>To use <bpt id="p1">**</bpt>index hint<ept id="p1">**</ept> in queries you must first specify the use of hints on the server using the following procedure.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Open Start <ph id="ph1">&amp;gt;</ph> Administrative Tools <ph id="ph2">&amp;gt;</ph> Microsoft Dynamics AX Server Configuration and select the Database Tuning tab.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>Select Allow INDEX hints in queries and click OK.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>A message box prompting you to restart the AOS service appears.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>Click Yes to restart the AOS service.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Index hints won't be enabled until the service is restarted.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>When an <bpt id="p1">**</bpt>index hint<ept id="p1">**</ept> in a <bpt id="p2">**</bpt>select<ept id="p2">**</ept> statement refers to a non-clustered index and the <bpt id="p3">**</bpt>where<ept id="p3">**</ept> clause contains only the fields that are found in a clustered index on the same table, the clustered index is used instead of the index specified in the hint.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>For example, if you run <bpt id="p1">**</bpt>sp<ph id="ph1">\_</ph>helpindex InventTable<ept id="p1">**</ept> in SQL Server Management Studio, you see that the <bpt id="p2">**</bpt>InventTable<ept id="p2">**</ept> has a clustered index on the <bpt id="p3">**</bpt>DataAreaId<ept id="p3">**</ept> and <bpt id="p4">**</bpt>ItemId<ept id="p4">**</ept> columns and a non-clustered index on the <bpt id="p5">**</bpt>DataAreaId, ItemProductId,<ept id="p5">**</ept> and <bpt id="p6">**</bpt>ItemType<ept id="p6">**</ept> columns.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Index name</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Key columns</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>I<ph id="ph1">\_</ph>175ITEMIDX</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>Clustered, unique, primary key located on PRIMARY</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>DATAAREAID, ITEMID</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>I<ph id="ph1">\_</ph>175PRODUCTIDX</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Nonclustered located on PRIMARY</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>DATAAREAID, ITEMPRODUCTID, ITEMTYPE</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>In the following code the clustered index will be used instead of the non-clustered index specified by <bpt id="p1">**</bpt>index hint<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Write a select statement as an expression</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>You can use a <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement as an expression.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>This is called an <bpt id="p1">**</bpt>expression select<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>A table buffer variable cannot be used in an expression select statement.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>The name of the table must be used in the <bpt id="p1">**</bpt>from<ept id="p1">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>One limitation of expression selects is that the <bpt id="p1">**</bpt>join<ept id="p1">**</ept> keyword is not supported in an expression join.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>expression select code examples</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement inside the parentheses returns one row.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>The only column that can be populated with data is the column that is named in the <bpt id="p1">**</bpt>select<ept id="p1">**</ept> clause before the <bpt id="p2">**</bpt>from<ept id="p2">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>The name of that one column is used after the closing parenthesis to reference the data value: <bpt id="p1">**</bpt>).AccountNum;<ept id="p1">**</ept>.This test case returns a maximum of one row because it uses the <bpt id="p2">**</bpt>firstonly<ept id="p2">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>However, the value that is assigned to <bpt id="p1">**</bpt>sAccountNum<ept id="p1">**</ept> is the same even if the <bpt id="p2">**</bpt>firstonly<ept id="p2">**</ept> keyword is omitted.The <bpt id="p3">**</bpt>where<ept id="p3">**</ept> clause in this example serves no purpose other than to show that the <bpt id="p4">**</bpt>where<ept id="p4">**</ept> clause must occur after the <bpt id="p5">**</bpt>order by<ept id="p5">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>The table name cannot be used to qualify a field name in the <bpt id="p1">**</bpt>order by<ept id="p1">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>This is a simpler way to achieve the same result as the previous example.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>/<ph id="ph1">\*</ph><ph id="ph2">\*</ph><ph id="ph3">\*</ph><ph id="ph4">\*</ph><ph id="ph5">\*</ph><ph id="ph6">\*</ph><ph id="ph7">\*</ph><ph id="ph8">\*</ph><ph id="ph9">\*</ph> Actual Infolog output Test<ph id="ph10">\_</ph>1.a: 4507Test<ph id="ph11">\_</ph>1.b: 4507 <ph id="ph12">\*</ph><ph id="ph13">\*</ph><ph id="ph14">\*</ph><ph id="ph15">\*</ph><ph id="ph16">\*</ph><ph id="ph17">\*</ph><ph id="ph18">\*</ph><ph id="ph19">\*</ph><ph id="ph20">\*</ph><ph id="ph21">/</ph></source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>The following example includes a <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>In a <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clause, the table name must be used as a qualifier of the field.Here the <bpt id="p2">**</bpt>maxof<ept id="p2">**</ept> aggregate function is used, and the field <bpt id="p3">**</bpt>RecId<ept id="p3">**</ept> is mentioned in the function.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>The field that is mentioned in the aggregate function must be the same field name that is used to reference the data value after the closing parenthesis.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Otherwise, empty data is returned.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>The following example demonstrates that a field name, here <bpt id="p1">**</bpt>RecId<ept id="p1">**</ept>, is used to reference a data value that is not a <bpt id="p2">**</bpt>RecId<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>count<ept id="p1">**</ept> aggregate function does not return a <bpt id="p2">**</bpt>RecId<ept id="p2">**</ept> value.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>RecId<ept id="p1">**</ept> field is ordinarily used with the <bpt id="p2">**</bpt>count<ept id="p2">**</ept> function.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>join<ept id="p1">**</ept> keyword is not supported in expression selects.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a subselect.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>But expression selects do not support subselects that are equivalent to a standard inner join.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>For instance, the following code example does not compile.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>The problem is that it mentions two tables inside one expression select, namely inside the subselect.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>This code example shows that a subselect is supported, but only in a limited way.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>update method</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>update<ept id="p1">**</ept> table method updates the current record with the contents of the buffer.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>It also updates the appropriate system fields.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clause is optional.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>When used, the <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clause specifies a condition for <bpt id="p2">**</bpt>update<ept id="p2">**</ept> to test while processing each row of the table.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>Only those rows that test <bpt id="p1">**</bpt>true<ept id="p1">**</ept> against the condition are updated with the new values.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>update<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept> is a record-set based operator that updates multiple records at once.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>To override the behavior of <bpt id="p1">**</bpt>update<ept id="p1">**</ept>, use the doUpdate method.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>The example selects the table <bpt id="p1">**</bpt>custTable<ept id="p1">**</ept> for update.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Any records with the AccountNum equal to 4000 are updated (in this case only one).</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>CreditMax<ept id="p1">**</ept> field is changed to 5000.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>doUpdate method</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>doUpdate<ept id="p1">**</ept> method updates the current record with the contents of the buffer.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>This method also updates the appropriate system fields.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>doUpdate<ept id="p1">**</ept> method should be used when the update method on the table is to be bypassed.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>The syntax for a <bpt id="p1">**</bpt>doUpdate<ept id="p1">**</ept> table method is <bpt id="p2">**</bpt>void doUpdate()<ept id="p2">**</ept> In the following example, <bpt id="p3">**</bpt>CreditMax<ept id="p3">**</ept> is increased by 1000.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>delete method</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>delete<ept id="p1">**</ept> table method deletes the current record from the database.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>To use this method, specify which rows are to be deleted by using a <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>Records are then removed, one at a time, from the specified table.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>delete<ph id="ph1">\_</ph>from<ept id="p1">**</ept> is a record-setbased operator, which simultaneously removes multiple records.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>delete<ept id="p1">**</ept> method can be overridden, for example, to add extra validation before records are deleted.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>If you override the <bpt id="p1">**</bpt>delete<ept id="p1">**</ept> method, the original version of the <bpt id="p2">**</bpt>delete<ept id="p2">**</ept> method can be executed instead by calling the <bpt id="p3">**</bpt>doDelete<ept id="p3">**</ept> method.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>It is equivalent to calling <bpt id="p1">**</bpt>super()<ept id="p1">**</ept> in the <bpt id="p2">**</bpt>delete<ept id="p2">**</ept> method; <bpt id="p3">**</bpt>doDelete<ept id="p3">**</ept> executes the base version of the <bpt id="p4">**</bpt>delete<ept id="p4">**</ept> method.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>In the following example, all the records in the <bpt id="p1">**</bpt>MyTable<ept id="p1">**</ept> table that satisfy the <bpt id="p2">**</bpt>where<ept id="p2">**</ept> clause criterion (any record with an Account number equal to 1000) are deleted from the database.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>These records are deleted one at a time.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>doDelete method</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>doDelete<ept id="p1">**</ept> table method works similar to the <bpt id="p2">**</bpt>delete<ept id="p2">**</ept> table method because it deletes the current record from the database.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>doDelete<ept id="p1">**</ept> method if the delete table method has been overridden, and you want to use the original version of the <bpt id="p2">**</bpt>delete<ept id="p2">**</ept> method.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>doDelete<ept id="p1">**</ept> method executes the base version of the <bpt id="p2">**</bpt>delete<ept id="p2">**</ept> method instead of the overridden version, which is equivalent to executing <bpt id="p3">**</bpt>super() <ept id="p3">**</ept>in the <bpt id="p4">**</bpt>delete<ept id="p4">**</ept> method.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>This code example deletes all records in the myTable table that have an account number that is greater than or equal to 200.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>insert method</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>insert<ept id="p1">**</ept> method updates one record at a time.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>To insert multiple records at a time, use array inserts, <bpt id="p1">**</bpt>insert<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept>, or <bpt id="p2">**</bpt>RecordSortedList.insertDatabase<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>To override the behavior of the <bpt id="p1">**</bpt>insert<ept id="p1">**</ept> method, use the <bpt id="p2">**</bpt>doInsert<ept id="p2">**</ept> method.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>xRecord .insert<ept id="p1">**</ept> method generates values for <bpt id="p2">**</bpt>RecId<ept id="p2">**</ept> and system fields, and then inserts the contents of the buffer into the database.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>The method operated as follows:</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Only the specified columns of those rows selected by the query are inserted into the named table.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>The columns of the table being copied from and those of the table being copied to must be type compatible.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>If the columns of both tables match in type and order, the column-list may be omitted from the <bpt id="p1">**</bpt>insert<ept id="p1">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>insert code example: insert a new record</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>The following code example inserts a new record into the <bpt id="p1">**</bpt>CustTable<ept id="p1">**</ept> table, with the <bpt id="p2">**</bpt>AccountNum<ept id="p2">**</ept> set to 5000 and the <bpt id="p3">**</bpt>Name<ept id="p3">**</ept> set to MyCompany (other fields in the record will be blank).</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>insert code example: transaction and duplicate key</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>The following example shows how you can catch a <bpt id="p1">**</bpt>DuplicateKeyException<ept id="p1">**</ept> in the context of an explicit transaction.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>The exception is thrown when a call to <bpt id="p1">**</bpt>xRecord .insert<ept id="p1">**</ept> fails because of a duplication of an existing unique value.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>In the catch block, your code can take corrective action, or it can log the error for later analysis.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>Then your code can continue without losing all the pending work of the transaction.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>You cannot catch a duplicate key exception caused by a set based operation such as <bpt id="p1">**</bpt>insert<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>This example depends on two tables <bpt id="p1">**</bpt>TableNumberA<ept id="p1">**</ept> and <bpt id="p2">**</bpt>TableNumberB<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Each has one mandatory Integer field, named <bpt id="p1">**</bpt>NumberAKey<ept id="p1">**</ept> and <bpt id="p2">**</bpt>NumberBKey<ept id="p2">**</ept> respectively.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Each of these key fields has a unique indexed defined on it.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>TableNumberA<ept id="p1">**</ept> table must have at least one record in it.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>doInsert method</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>doInsert<ept id="p1">**</ept> method generates values for the <bpt id="p2">**</bpt>RecId<ept id="p2">**</ept> field and other system fields, and then inserts the contents of the buffer into the database.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>This operation is used when the insert method on the table is to be bypassed.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>In the following example, a new record is inserted with the name <bpt id="p1">**</bpt>Warren Langer<ept id="p1">**</ept> in the name field and the value 100 in the value field.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Transactional integrity</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">**</bpt>integrity of transactions<ept id="p1">**</ept> is not ensured, it may lead to data corruption, or, at best, poor scalability with reference to concurrent users on the system.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>There are two internal checking features to help ensure the integrity of transactions: the <bpt id="p1">**</bpt>forUpdate<ept id="p1">**</ept> check and the <bpt id="p2">**</bpt>tssLevel<ept id="p2">**</ept> check.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>forUpdate check<ept id="p1">**</ept> ensures that no record can be updated or deleted if the record has not first been selected for update.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>A record can be selected for update, either by using the <bpt id="p1">**</bpt>forUpdate<ept id="p1">**</ept> keyword in the <bpt id="p2">**</bpt>select<ept id="p2">**</ept> statement, or by using the <bpt id="p3">**</bpt>selectForUpdate<ept id="p3">**</ept> method on tables.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>ttsLevel check<ept id="p1">**</ept> ensures that no record can be updated or deleted except from within the same transaction scope as it was selected for update.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>Integrity is ensured by using the following statements:</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>ttsBegin<ept id="p1">**</ept>: marks the beginning of a transaction.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>This ensures data integrity, and guarantees that all updates performed until the transaction ends (by <bpt id="p1">**</bpt>ttsCommit<ept id="p1">**</ept> or <bpt id="p2">**</bpt>ttsAbort<ept id="p2">**</ept>) are consistent (all or none).</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>ttsCommit<ept id="p1">**</ept>: marks the successful end of a transaction.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>This ends and commits a transaction.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>Dynamics 365 for Operations guarantees that a committed transaction will be performed according to intentions.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>ttsAbort<ept id="p1">**</ept>: allows you to explicitly discard all changes in the current transaction.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>As a result, the database is rolled back to the initial state where nothing will have been changed.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>Typically, you will use this if you have detected that the user wants to break the current job.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>Using <bpt id="p1">**</bpt>ttsAbort<ept id="p1">**</ept> ensures that the database is consistent.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>It is usually better to use exception handling instead of <bpt id="p1">**</bpt>ttsAbort<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>throw<ept id="p1">**</ept> statement automatically aborts the current transaction.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Statements between <bpt id="p1">**</bpt>ttsBegin<ept id="p1">**</ept> and <bpt id="p2">**</bpt>ttsCommit<ept id="p2">**</ept> may include one or more transaction blocks as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>In such cases, nothing is actually committed until the successful exit from the final <bpt id="p1">**</bpt>ttsCommit<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>The following example selects a set of records and updates the <bpt id="p1">**</bpt>NameAlias<ept id="p1">**</ept> field.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>Examples of code rejected by the two transaction integrity checks</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>In this example, the first failure is because the <bpt id="p1">**</bpt>forupdate<ept id="p1">**</ept> keyword is missing.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>The second failure is because the update is in another transaction scope rather than the one that the record was selected in <bpt id="p1">**</bpt>ttsCommit<ept id="p1">**</ept> for update.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>Speeding up SQL operations</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>The following constructs allow you to insert, update, or delete multiple records.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>Using these constructs reduces communication between the application and the database, and it increases performance.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>In some situations, record-set operations can fall back to record-by-record operations.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>Construct</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>RecordSortedList<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>Allows you to insert multiple records in one database trip.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>RecordSortedList<ept id="p1">**</ept> construct when you want a subset of data from a particular table, and when you want it sorted in an order that does not currently exist as an index.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>RecordInsertList<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Allows you to insert multiple records in one database trip.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>RecordInsertList<ept id="p1">**</ept> construct when you do not need to sort the data.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>insert<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Allows you to copy multiple records from one or more tables directly into another table on a single database trip.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>update<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>Allows you to update multiple rows in a table on a single database trip.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>delete<ph id="ph1">\_</ph>from<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>Allows you to delete multiple records from the database on a single database trip.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>insert<ph id="ph1">\_</ph>recordset</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>insert<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept> copies data from one or more tables directly into one resulting destination table on a single server trip.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>Using <bpt id="p1">**</bpt>insert<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept> is faster than using an array insert.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>However, array inserts are more flexible if you want to handle the data before you insert it.</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>insert<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept> is a record-set-based operator, which performs operations on multiple records at a time.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>However, it can fall back to record-by-record operations in many situations.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>insert<ph id="ph1">\_</ph>recordset Syntax</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>ListOfFields<ept id="p1">*</ept> in the destination table must match the list of fields in the source tables.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>Data is transferred in the order that it appears in the list of fields.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>Fields in the destination table that are not present in the list of fields are assigned zero-values as in other areas.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>System fields, including <bpt id="p1">**</bpt>RecId<ept id="p1">**</ept>, are assigned transparently by the kernel in the destination table.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>insert<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept>  <bpt id="p2">*</bpt>DestinationTable<ept id="p2">*</ept>  <bpt id="p3">**</bpt>(<ept id="p3">**</ept>  <bpt id="p4">*</bpt>ListOfFields<ept id="p4">*</ept>  <bpt id="p5">**</bpt>)<ept id="p5">**</ept> <bpt id="p6">**</bpt>select<ept id="p6">**</ept>  <bpt id="p7">*</bpt>ListOfFields1<ept id="p7">*</ept>  <bpt id="p8">**</bpt>from<ept id="p8">**</ept>  <bpt id="p9">*</bpt>SourceTable<ept id="p9">*</ept>  <bpt id="p10">**</bpt><ph id="ph2">\[</ph> where<ept id="p10">**</ept>  <bpt id="p11">*</bpt>WhereClause<ept id="p11">*</ept>  <bpt id="p12">**</bpt><ph id="ph3">\]</ph><ept id="p12">**</ept> <bpt id="p13">**</bpt><ph id="ph4">\[</ph> join<ept id="p13">**</ept>  <bpt id="p14">*</bpt>ListOfFields2<ept id="p14">*</ept>  <bpt id="p15">**</bpt>from<ept id="p15">**</ept>  <bpt id="p16">*</bpt>JoinedSourceTable<ept id="p16">*</ept> <bpt id="p17">**</bpt><ph id="ph5">\[</ph> where<ept id="p17">**</ept>  <bpt id="p18">*</bpt>JoinedWhereClause<ept id="p18">*</ept>  <bpt id="p19">**</bpt><ph id="ph6">\]</ph><ph id="ph7">\]</ph><ept id="p19">**</ept></source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>Code example: insert data from another table</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>The records, <bpt id="p1">**</bpt>myNum<ept id="p1">**</ept> and <bpt id="p2">**</bpt>mySum<ept id="p2">**</ept>, are retrieved from the table <bpt id="p3">**</bpt>anotherTable<ept id="p3">**</ept> and inserted into the table <bpt id="p4">**</bpt>myTable<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The records are grouped according to <bpt id="p1">**</bpt>myNum<ept id="p1">**</ept>, and only the <bpt id="p2">**</bpt>myNum<ept id="p2">**</ept> records with a value less than or equal to 100 are included in the insertion.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>Code example: insert data from variables</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>This code example shows that the <bpt id="p1">**</bpt>insert<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept> statement can insert data that is provided in variables.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>In this example, the keyword <bpt id="p1">**</bpt>firstonly<ept id="p1">**</ept> is used so that only one row is inserted.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Literals, such as <bpt id="p1">**</bpt>128<ept id="p1">**</ept> or <bpt id="p2">**</bpt>"this literal string"<ept id="p2">**</ept>, cannot be used as a source of data to be inserted.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>Code example: insert data using a join</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>The following code example shows a <bpt id="p1">**</bpt>join<ept id="p1">**</ept> of three tables on an <bpt id="p2">**</bpt>insert<ph id="ph1">\_</ph>recordset<ept id="p2">**</ept> statement that has a sub-<bpt id="p3">**</bpt>select<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>Also, a <bpt id="p1">**</bpt>while<ept id="p1">**</ept> <bpt id="p2">**</bpt>select<ept id="p2">**</ept> statement with a similar join is shown.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>A variable is used to supply the inserted value for one column.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>str<ept id="p1">**</ept> variable must be declared with a length that is less than or equal to the maximum length of the corresponding database field.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>In this example, there is an <bpt id="p1">**</bpt>insert<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept> statement for <bpt id="p2">**</bpt>tabEmplProj5<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>One of the target fields is named <bpt id="p1">**</bpt>Description<ept id="p1">**</ept>, and the field's data comes from the local variable <bpt id="p2">**</bpt>sDescriptionVariable<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>When the configuration key for the <bpt id="p1">**</bpt>Description<ept id="p1">**</ept> field is turned off, the <bpt id="p2">**</bpt>insert<ph id="ph1">\_</ph>recordset<ept id="p2">**</ept> still succeeds.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>The system ignores both the <bpt id="p1">**</bpt>Description<ept id="p1">**</ept> field and the variable <bpt id="p2">**</bpt>sDescriptionVariable<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>This is an example of <bpt id="p1">**</bpt>configuration key automation<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>Configuration key automation is when the system can automatically adjust the behavior of an <bpt id="p1">**</bpt>insert<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept> statement that inserts into fields that have their configuration key turned off.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>update<ph id="ph1">\_</ph>recordset</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>update<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept> statement enables you to update multiple rows in a single trip to the server.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>This means that certain tasks may have improved performance by using the power of the SQL server.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>****update<ph id="ph1">\_</ph>recordset**** resembles <bpt id="p1">**</bpt>delete<ph id="ph2">\_</ph>from<ept id="p1">**</ept> in X++ and <bpt id="p2">**</bpt>update set<ept id="p2">**</ept> in SQL.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>It works on the database server-side on an SQL-style record-set, instead of retrieving each record separately by fetching, changing, and updating.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">**</bpt>update<ept id="p1">**</ept> method is overridden, the implementation falls back to a classic looping construction, updating records one by one just as <bpt id="p2">**</bpt>delete<ph id="ph1">\_</ph>from<ept id="p2">**</ept> does for deletions.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>This also means that the construction works on temporary tables, and whole-table-cached tables by using the looping construction.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>Code example: update based on a calculated value</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>This example updates the table <bpt id="p1">**</bpt>myTableBuffer<ept id="p1">**</ept> and increments the value in <bpt id="p2">**</bpt>field1<ept id="p2">**</ept> by ten percent in all records in the table.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>Code example: update using a where clause</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>This example updates the table <bpt id="p1">**</bpt>myTable<ept id="p1">**</ept> in all records where <bpt id="p2">**</bpt>field1<ept id="p2">**</ept> has the value 0.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>field1<ept id="p1">**</ept> is assigned the new value 1; <bpt id="p2">**</bpt>field2<ept id="p2">**</ept> is assigned the value of the sum of <bpt id="p3">**</bpt>fieldX<ept id="p3">**</ept> and <bpt id="p4">**</bpt>fieldY<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>This example updates multiple fields at the same time, and it updates only those rows that satisfy the <bpt id="p1">**</bpt>where<ept id="p1">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>Code example: updating joined tables</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>This example shows that the <bpt id="p1">**</bpt>update<ph id="ph1">\_</ph>recordset<ept id="p1">**</ept> statement supports the joining of several tables.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>Data from the joined tables can be used to assign values to fields in the table that is being updated.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>delete<ph id="ph1">\_</ph>from</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>You can delete multiple records from a database table by using a <bpt id="p1">**</bpt>delete<ph id="ph1">\_</ph>from<ept id="p1">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>This can be more efficient and faster than deleting one record at a time by using the <bpt id="p1">**</bpt>xRecord .delete<ept id="p1">**</ept> method in a loop.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>If you have overridden the delete method, the system interprets the <bpt id="p1">**</bpt>delete<ph id="ph1">\_</ph>from<ept id="p1">**</ept> statement into code that calls the <bpt id="p2">**</bpt>delete<ept id="p2">**</ept> method one time for each row that is deleted.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>Code example: efficiently delete records using delete<ph id="ph1">\_</ph>from</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>The following code example is an efficient way to delete multiple records.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>Code example: inefficiently delete records using forUpdate</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>The following code example is inefficient.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>It issues a separate SQL delete call to the database server for each record.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>xRecord<ept id="p1">**</ept> <bpt id="p2">**</bpt>.delete<ept id="p2">**</ept> method never deletes more than one record per call.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>Code example: delete with an inner join</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>Inner joins are not supported on the <bpt id="p1">**</bpt>delete<ph id="ph1">\_</ph>from<ept id="p1">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>Therefore you cannot use the unmodified <bpt id="p1">**</bpt>join<ept id="p1">**</ept> keyword on the <bpt id="p2">**</bpt>delete<ph id="ph1">\_</ph>from<ept id="p2">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>However, there are other ways to logically accomplish an inner join.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>This example shows the new and old techniques for achieving inner join logic through a sequence of statements.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>Code example: delete with notexists join keyword</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">**</bpt>notexists join<ept id="p1">**</ept> keyword pair in a <bpt id="p2">**</bpt>delete<ph id="ph1">\_</ph>from<ept id="p2">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>delete<ph id="ph1">\_</ph>from<ept id="p1">**</ept> statements in the following code example are efficient.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>notexists join<ept id="p1">**</ept> clause enables the <bpt id="p2">**</bpt>delete<ph id="ph1">\_</ph>from<ept id="p2">**</ept> statement to delete a specific set of rows.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>In this example the <bpt id="p1">**</bpt>delete<ph id="ph1">\_</ph>from<ept id="p1">**</ept> statement removes all the parent order header rows for which there are no child order line rows.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>You can also use the <bpt id="p1">**</bpt>exists join<ept id="p1">**</ept> clause on the <bpt id="p2">**</bpt>delete<ph id="ph1">\_</ph>from<ept id="p2">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>Maintain fast SQL operations</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>There are situations where record-set operations can be converted to slower record-by-record operations.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>The following table identifies these situations.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>DELETE<ph id="ph1">\_</ph>FROM</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>UPDATE<ph id="ph1">\_</ph>RECORDSET</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>INSERT<ph id="ph1">\_</ph>RECORDSET</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>ARRAY<ph id="ph1">\_</ph>INSERT</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Use ... to override</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>Non-SQL tables</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>Delete actions</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>skipDeleteActions<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>Database log enabled</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>skipDatabaseLog<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>Overridden method</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>skipDataMethods<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>Alerts set up for table</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>skipEvents<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>ValidTimeStateFieldType property not equal to None on a table</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>You may explicitly skip or ignore one or more things that would adversely impact performance by using the items shown in the far right column.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>If for some reason one of the previously mentioned SQL operations is downgraded to a record-by-record operation, all of the <bpt id="p1">**</bpt>skip<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>settings are also ignored.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">**</bpt>insert<ept id="p1">**</ept> method on <bpt id="p2">**</bpt>myTable<ept id="p2">**</ept> is executed in the following example even though it is explicitly stated that this method should be skipped if <bpt id="p3">**</bpt>myTable<ept id="p3">**</ept> has a container or memo field defined.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>