{"nodes":[{"pos":[32,107],"content":"Commerce runtime and Retail Server extensibility scenarios | Microsoft Docs","needQuote":true,"needEscape":true,"nodes":[{"content":"Commerce runtime and Retail Server extensibility scenarios | Microsoft Docs","pos":[0,75]}]},{"pos":[121,449],"content":"This article describes various ways that you can extend the commerce runtime (CRT) and Retail Server. It explains the concept of extension properties, and shows how to add them to a CRT entity both with and without persistence. It also shows how to add an action to a Retail Server controller and add a controller for an entity.","needQuote":true,"needEscape":true,"nodes":[{"content":"This article describes various ways that you can extend the commerce runtime (CRT) and Retail Server. It explains the concept of extension properties, and shows how to add them to a CRT entity both with and without persistence. It also shows how to add an action to a Retail Server controller and add a controller for an entity.","pos":[0,328],"nodes":[{"content":"This article describes various ways that you can extend the commerce runtime (CRT) and Retail Server.","pos":[0,101]},{"content":"It explains the concept of extension properties, and shows how to add them to a CRT entity both with and without persistence.","pos":[102,227]},{"content":"It also shows how to add an action to a Retail Server controller and add a controller for an entity.","pos":[228,328]}]}]},{"pos":[862,920],"content":"Commerce runtime and Retail Server extensibility scenarios","linkify":"Commerce runtime and Retail Server extensibility scenarios","nodes":[{"content":"Commerce runtime and Retail Server extensibility scenarios","pos":[0,58]}]},{"pos":[922,964],"content":"Using extension properties on CRT entities","linkify":"Using extension properties on CRT entities","nodes":[{"content":"Using extension properties on CRT entities","pos":[0,42]}]},{"content":"One way to add new data to an existing commerce runtime (CRT) entity is to use extension properties.","pos":[1009,1109]},{"content":"Extension properties are key-value pairs on the entity.","pos":[1110,1165]},{"content":"By default, these key-value pairs aren't persisted into the database.","pos":[1166,1235]},{"content":"Extension properties provide the easiest and, it can be argued, the most useful way to extend entities.","pos":[1236,1339]},{"content":"You should always try to use this pattern first, unless something prevents you from using it.","pos":[1340,1433]},{"content":"Although you can use polymorphism/inheritance to add simple data members to entities, this approach usually causes more issues than it solves.","pos":[1434,1576]},{"content":"(Nevertheless, this approach might be required for specific cases.) To add an extension property, you must use this syntax.","pos":[1577,1700]},{"content":"To enable the property to be read later, you can use this syntax.","pos":[1761,1826]},{"pos":[1908,1967],"content":"Using extension properties on CRT entities with persistence","linkify":"Using extension properties on CRT entities with persistence","nodes":[{"content":"Using extension properties on CRT entities with persistence","pos":[0,59]}]},{"content":"Any extension property that you add to an entity stays in memory for the lifetime of the object.","pos":[1968,2064]},{"content":"Additionally, the extension property travels across application boundaries.","pos":[2065,2140]},{"content":"For example, if you add an extension property in Retail Modern POS and then call Retail Server/the CRT, the key-value pair is also available in that process.","pos":[2141,2298]},{"content":"Additionally, if that entity is sent to Microsoft Dynamics 365 for Operations during a Commerce Data Exchange: Real-time Service (RTS) call, the key-value pair is also available in the Dynamics 365 for Operations process.","pos":[2299,2520]},{"content":"However, as we mentioned earlier, it isn't persisted by default.","pos":[2521,2585]},{"content":"If you must persist an extension property, you must do data modeling to help guarantee that you make the right design choices about where the data should reside.","pos":[2586,2747]},{"content":"You can use a new column in the same table, you can use a new table and a join, or you can use another approach.","pos":[2748,2860]},{"content":"The recommended approach is to use a new table and a join.","pos":[2861,2919]},{"content":"This approach fits most requirements well.","pos":[2920,2962]},{"content":"For this approach, the customizer must learn where all “writes” occur and update the SQL code (stored procedures), and must also learn where all the “reads” occur and update that SQL code (SQL view).","pos":[2963,3162]},{"content":"The EmailPreference sample provides a good end-to-end example.","pos":[3163,3225]},{"content":"In that sample, a single SQL view and a single SQL stored procedure are changed via customization.","pos":[3226,3324]},{"content":"It's important to note that new SQL objects must have the correct role permissions granted.","pos":[3325,3416]},{"content":"For example, a new table that must be included in Commerce Data Exchange (CDX) synchronization jobs must be granted access by DataSyncUsersRole.","pos":[3417,3561]},{"content":"For other roles that are available, inspect the main SQL script in the Retail Sdk<ph id=\"ph1\">\\\\</ph>Database folder.","pos":[3562,3661],"source":" For other roles that are available, inspect the main SQL script in the Retail Sdk\\\\Database folder."},{"content":"Finally, the SQL update script for your customization must be registered in the Customization.settings file for the Retail software development kit (SDK).","pos":[4311,4465]},{"pos":[4471,4531],"content":"Using extension properties on CRT request and response types","linkify":"Using extension properties on CRT request and response types","nodes":[{"content":"Using extension properties on CRT request and response types","pos":[0,60]}]},{"content":"Like entities, request and response types can be extended.","pos":[4533,4591]},{"pos":[4860,4925],"content":"Implementing a new CRT service that handles multiple new requests","linkify":"Implementing a new CRT service that handles multiple new requests","nodes":[{"content":"Implementing a new CRT service that handles multiple new requests","pos":[0,65]}]},{"content":"It's a typical case to implement a new CRT service.","pos":[4927,4978]},{"content":"First, you must create new request and response classes.","pos":[4979,5035]},{"pos":[5042,5083],"content":"Creating the request and response classes","linkify":"Creating the request and response classes","nodes":[{"content":"Creating the request and response classes","pos":[0,41]}]},{"pos":[5085,5207],"content":"For serialization to work, the new request type must implement the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\[</ph>DataContract<ph id=\"ph2\">\\]</ph><ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt><ph id=\"ph3\">\\[</ph>DataMember<ph id=\"ph4\">\\]</ph><ept id=\"p2\">**</ept> attributes.","source":"For serialization to work, the new request type must implement the **\\[DataContract\\]** and **\\[DataMember\\]** attributes."},{"content":"The new response type resembles the request type.","pos":[5599,5648]},{"content":"Next, you must create a new CRT service that uses the request and response types.","pos":[5944,6025]},{"pos":[6032,6058],"content":"Creating a new CRT service","linkify":"Creating a new CRT service","nodes":[{"content":"Creating a new CRT service","pos":[0,26]}]},{"content":"Implement the new service.","pos":[6064,6090]},{"content":"Implement two members of the interface.","pos":[6158,6197]},{"content":"The <bpt id=\"p1\">**</bpt>SupportedRequestTypes<ept id=\"p1\">**</ept> member returns a list of all requests that this service can handle.","pos":[6198,6295],"source":" The **SupportedRequestTypes** member returns a list of all requests that this service can handle."},{"content":"The execute method is the method that the CRT calls for you if a request for this service is run.","pos":[6296,6393]},{"content":"In the commerceRuntime.Config file, update the <bpt id=\"p1\">**</bpt>composition<ept id=\"p1\">**</ept> section (or the equivalent section) to register this service.","pos":[6680,6804],"source":"In the commerceRuntime.Config file, update the **composition** section (or the equivalent section) to register this service."},{"content":"Note that you can register single types or all types from an assembly.","pos":[6805,6875]},{"content":"The CommerceRuntime engine will find all IRequestHandler derived types.","pos":[6876,6947]},{"content":"Optional: Use the CommerceRuntime Test Host to do a test run of your service.","pos":[6952,7029]},{"pos":[7035,7099],"content":"Implementing a new CRT service that handles a single new request","linkify":"Implementing a new CRT service that handles a single new request","nodes":[{"content":"Implementing a new CRT service that handles a single new request","pos":[0,64]}]},{"content":"It’s slightly easier to create a single-request service.","pos":[7101,7157]},{"content":"Registration is done as described in the previous procedure.","pos":[7224,7284]},{"pos":[7290,7376],"content":"Implementing a new CRT service that overrides the functionality of an existing request","linkify":"Implementing a new CRT service that overrides the functionality of an existing request","nodes":[{"content":"Implementing a new CRT service that overrides the functionality of an existing request","pos":[0,86]}]},{"content":"In some cases, the request and response types are sufficient, but the service implementation must be changed.","pos":[7378,7487]},{"content":"If some new data must be transmitted, you can also extend entity, request, or response objects by using extension properties.","pos":[7488,7613]},{"content":"In this scenario, you can create the service as described earlier and use the existing IRequestHandler types.","pos":[7614,7723]},{"content":"Additionally, registration in the commerceRuntime.Config file must precede registration of the service that should be overridden.","pos":[7724,7853]},{"content":"This registration order is important because of the way that the Managed Extensibility Framework (MEF) loads the extension dynamic-link libraries (DLLs).","pos":[7854,8007]},{"content":"The types that are higher in the file win.","pos":[8008,8050]},{"pos":[8056,8117],"content":"Implementing a new CRT entity and using it in new CRT service","linkify":"Implementing a new CRT entity and using it in new CRT service","nodes":[{"content":"Implementing a new CRT entity and using it in new CRT service","pos":[0,61]}]},{"content":"Any new entity must be of the <bpt id=\"p1\">**</bpt>CommerceEntity<ept id=\"p1\">**</ept> type.","pos":[8119,8173],"source":"Any new entity must be of the **CommerceEntity** type."},{"content":"When you use this type, lots of low-level functionality is automatically handled for you.","pos":[8174,8263]},{"content":"The following example, which is taken from the StoreHours sample, shows how to create an entity that is bound to the database table.","pos":[8264,8396]},{"content":"This is the usual case.","pos":[8397,8420]},{"content":"When you want to use the new entity in a service, the process is straightforward.","pos":[9598,9679]},{"content":"As described earlier, you create a new service as a derived IRequestHandler.","pos":[9680,9756]},{"content":"Then either use or return the new entity.","pos":[9757,9798]},{"content":"The following example shows how to read the entity from the database and return it as part of the response.","pos":[9799,9906]},{"content":"For the preceding example, the CRT runtime engine automatically makes a query to the channel database via the registered data adapter.","pos":[10647,10781]},{"content":"It queries a type that has the name <bpt id=\"p1\">**</bpt>crt.ISVRetailStoreHoursView<ept id=\"p1\">**</ept>, and generates a <bpt id=\"p2\">**</bpt>where<ept id=\"p2\">**</ept> clause and columns as specified in the code.","pos":[10782,10921],"source":" It queries a type that has the name **crt.ISVRetailStoreHoursView**, and generates a **where** clause and columns as specified in the code."},{"content":"The customizer is responsible for providing the SQL objects as part of the customization.","pos":[10922,11011]},{"pos":[11017,11077],"content":"Adding pre-triggers and post-triggers for a specific request","linkify":"Adding pre-triggers and post-triggers for a specific request","nodes":[{"content":"Adding pre-triggers and post-triggers for a specific request","pos":[0,60]}]},{"content":"In some cases, some processing must be done before or after a request is handled.","pos":[11079,11160]},{"content":"There are two hooks that can be used to run additional code.","pos":[11161,11221]},{"content":"These hooks are called pre-triggers and post-triggers.","pos":[11222,11276]},{"content":"Follow these steps to create new triggers and associate them with a request.","pos":[11277,11353]},{"content":"Create a new trigger class that implements IRequestTrigger.","pos":[11359,11418]},{"pos":[11498,11614],"content":"In the <bpt id=\"p1\">**</bpt>IRequest.SupportedRequestTypes<ept id=\"p1\">**</ept> property, return the list of requests that this trigger should be run for.","source":"In the **IRequest.SupportedRequestTypes** property, return the list of requests that this trigger should be run for."},{"content":"Implement the functions that are called before and after the request.","pos":[11803,11872]},{"content":"Register the class in the commerceRuntime.Config file.","pos":[11983,12037]},{"pos":[12042,12079],"content":"Retail Server extensibility scenarios","linkify":"Retail Server extensibility scenarios","nodes":[{"content":"Retail Server extensibility scenarios","pos":[0,37]}]},{"pos":[12084,12135],"content":"Adding a new ODATA action to an existing controller","linkify":"Adding a new ODATA action to an existing controller","nodes":[{"content":"Adding a new ODATA action to an existing controller","pos":[0,51]}]},{"content":"In the easiest scenario, you must add a new application programming interface (API) for a slightly different use case.","pos":[12137,12255]},{"content":"To make this scenario work, you can add the new action through inheritance.","pos":[12256,12331]},{"content":"For any changes to the APIs to Retail Server, you must follow these steps.","pos":[12332,12406]},{"content":"Implement the new action or controller.","pos":[12412,12451]},{"content":"Override the requirements of the model factory to add the new corresponding metadata.","pos":[12456,12541]},{"content":"The following example, which is taken from the Retail SDK, shows how to extend an existing controller so that it has a POST action.","pos":[12543,12674]},{"content":"Next, override the model factory.","pos":[13696,13729]},{"content":"Before clients can use this new customization, you must adjust the build system to generate the Retail Server proxy code for the new model factory.","pos":[14152,14299]},{"content":"This configuration step is done in the build system.","pos":[14300,14352]},{"content":"Finally, you must adjust the web.config file.","pos":[14353,14398]},{"content":"You must complete this step in the packaging project for Retail Server in the SDK.","pos":[14399,14481]},{"content":"If local tests will be done, you can also optionally complete this step on the local development topology machine that is used for testing.","pos":[14482,14621]},{"pos":[14627,14671],"content":"Adding a new simple controller for an entity","linkify":"Adding a new simple controller for an entity","nodes":[{"content":"Adding a new simple controller for an entity","pos":[0,44]}]},{"content":"Suppose that you have a simple entity and require a controller to fetch the data.","pos":[14673,14754]},{"content":"For an example, see the StoreHours sample in the Retail SDK.","pos":[14755,14815]},{"content":"A new Retail Server controller makes sense, and all the low-level work is done in the CRT (new entity, request, response, and service).","pos":[14816,14951]},{"content":"To create a new controller, you derive from CommerceController.","pos":[14952,15015]},{"content":"An example is shown here.","pos":[15016,15041]},{"content":"The controller name is important and must match the name of the entity.","pos":[15042,15113]},{"pos":[16249,16368],"content":"For new entities, you must also override the factory’s <bpt id=\"p1\">**</bpt>BuildEntitySets()<ept id=\"p1\">**</ept> method, as shown in the following example.","source":"For new entities, you must also override the factory’s **BuildEntitySets()** method, as shown in the following example."},{"pos":[16986,17044],"content":"How to call the new retail server API from MPOS/Cloud POS:","linkify":"How to call the new retail server API from MPOS/Cloud POS:","nodes":[{"content":"How to call the new retail server API from MPOS/Cloud POS:","pos":[0,58]}]},{"content":"Before calling the new retail server API please make sure you have performed the below steps:","pos":[17046,17139]},{"pos":[17145,17284],"content":"Register your new retail server extension in Retail server web.config file:  <ph id=\"ph1\">&amp;lt;</ph>add source=\"assembly\" value=\"<bpt id=\"p1\">**</bpt>Your assembly name<ept id=\"p1\">**</ept>\" /<ph id=\"ph2\">&amp;gt;</ph>","source":"Register your new retail server extension in Retail server web.config file:  &lt;add source=\"assembly\" value=\"**Your assembly name**\" /&gt;"},{"content":"Add the new retail server extension in the Customization.settings file.","pos":[17289,17360]},{"content":"You can find this file in RetailSdk<ph id=\"ph1\">\\\\</ph>BuildTools<ph id=\"ph2\">&amp;lt;</ph>RetailServerLibraryPathForProxyGeneration Condition=\"'$(RetailServerLibraryPathForProxyGeneration)' == ''\"<ph id=\"ph3\">&amp;gt;</ph>$(SdkReferencesPath)<ph id=\"ph4\">\\\\</ph><bpt id=\"p1\">**</bpt>Your assembly name.dll<ept id=\"p1\">**</ept><ph id=\"ph5\">&amp;lt;</ph>/RetailServerLibraryPathForProxyGeneration<ph id=\"ph6\">&amp;gt;</ph> <ph id=\"ph7\">&amp;lt;</ph>/PropertyGroup<ph id=\"ph8\">&amp;gt;</ph>","pos":[17361,17643],"source":" You can find this file in RetailSdk\\\\BuildTools&lt;RetailServerLibraryPathForProxyGeneration Condition=\"'$(RetailServerLibraryPathForProxyGeneration)' == ''\"&gt;$(SdkReferencesPath)\\\\**Your assembly name.dll**&lt;/RetailServerLibraryPathForProxyGeneration&gt; &lt;/PropertyGroup&gt;"},{"content":"Drop both the CRT and Retail server extension dlls into the retail server bin folder.","pos":[17648,17733]},{"content":"If you have any CRT extension releated to the new retail server api then update that information in commerceRuntime configuration file under retail server bin folder.","pos":[17734,17900]},{"pos":[17905,17967],"content":"<ph id=\"ph1\">&amp;lt;</ph>add source=\"assembly\" value=\"<bpt id=\"p1\">**</bpt>Your assembly name<ept id=\"p1\">**</ept>\" /<ph id=\"ph2\">&amp;gt;</ph>","source":"&lt;add source=\"assembly\" value=\"**Your assembly name**\" /&gt;"},{"content":"Use inetmgr to browse to the retail server metadata and verify whether your entity is exposed in the xml.","pos":[17972,18077]},{"content":"Compile and build the mpos/Cloud POS to regenerate the proxy.","pos":[18082,18143]},{"content":"During compile mpos regenerates all the entities defined in the retail server metadata, so that you can call the new entities using the commerce context like below:","pos":[18144,18308]},{"pos":[18315,18336],"content":"Cross loyalty sample:","linkify":"Cross loyalty sample:","nodes":[{"content":"Cross loyalty sample:","pos":[0,21]}]},{"pos":[18523,18542],"content":"Store hours sample:","linkify":"Store hours sample:","nodes":[{"content":"Store hours sample:","pos":[0,19]}]},{"content":"Please refer the retail SDK POS.Extension.CrossloaylySample and POS.Extension.SToreHoursSample sample projects for more details on how to call the new retail server api in mpos.","pos":[18734,18911]}],"content":"---\n# required metadata\n\ntitle: Commerce runtime and Retail Server extensibility scenarios | Microsoft Docs\ndescription: This article describes various ways that you can extend the commerce runtime (CRT) and Retail Server. It explains the concept of extension properties, and shows how to add them to a CRT entity both with and without persistence. It also shows how to add an action to a Retail Server controller and add a controller for an entity.\nauthor: annbe\nmanager: AnnBe\nms.date: 2016-07-27 23:41:57\nms.topic: article\nms.prod: \nms.service: Dynamics365Operations\nms.technology: \n\n# optional metadata\n\n# keywords: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: 61\nms.suite: Released- Dynamics AX 7.0.0\n# ms.tgt_pltfrm: \nms.custom: 104593\nms.assetid: 1b072f3f-b5c2-4f0c-b93b-837909cbff7f\n# ms.region: \n# ms.industry: \nms.author: josaw1\n\n---\n\n# Commerce runtime and Retail Server extensibility scenarios\n\nUsing extension properties on CRT entities\n------------------------------------------\n\nOne way to add new data to an existing commerce runtime (CRT) entity is to use extension properties. Extension properties are key-value pairs on the entity. By default, these key-value pairs aren't persisted into the database. Extension properties provide the easiest and, it can be argued, the most useful way to extend entities. You should always try to use this pattern first, unless something prevents you from using it. Although you can use polymorphism/inheritance to add simple data members to entities, this approach usually causes more issues than it solves. (Nevertheless, this approach might be required for specific cases.) To add an extension property, you must use this syntax.\n\n    entity.SetProperty(\"EXTENSION_PROPERTY_ADDED\", true);\n\nTo enable the property to be read later, you can use this syntax.\n\n    bool? property = (bool?)entity.GetProperty(\"EXTENSION_PROPERTY_ADDED\");\n\n## Using extension properties on CRT entities with persistence\nAny extension property that you add to an entity stays in memory for the lifetime of the object. Additionally, the extension property travels across application boundaries. For example, if you add an extension property in Retail Modern POS and then call Retail Server/the CRT, the key-value pair is also available in that process. Additionally, if that entity is sent to Microsoft Dynamics 365 for Operations during a Commerce Data Exchange: Real-time Service (RTS) call, the key-value pair is also available in the Dynamics 365 for Operations process. However, as we mentioned earlier, it isn't persisted by default. If you must persist an extension property, you must do data modeling to help guarantee that you make the right design choices about where the data should reside. You can use a new column in the same table, you can use a new table and a join, or you can use another approach. The recommended approach is to use a new table and a join. This approach fits most requirements well. For this approach, the customizer must learn where all “writes” occur and update the SQL code (stored procedures), and must also learn where all the “reads” occur and update that SQL code (SQL view). The EmailPreference sample provides a good end-to-end example. In that sample, a single SQL view and a single SQL stored procedure are changed via customization. It's important to note that new SQL objects must have the correct role permissions granted. For example, a new table that must be included in Commerce Data Exchange (CDX) synchronization jobs must be granted access by DataSyncUsersRole. For other roles that are available, inspect the main SQL script in the Retail Sdk\\\\Database folder.\n\n    IF (SELECT OBJECT_ID('ax.RETAILCUSTPREFERENCE')) IS NULL \n    BEGIN\n        CREATE TABLE [ax].[RETAILCUSTPREFERENCE](\n        // removed . . . \n        ) ON [PRIMARY]\n        // removed . . . \n    END\n    GO\n\n    -- grant Read/Insert/Update/Delete permission to DataSyncUserRole so CDX can function\n    GRANT SELECT ON OBJECT::[ax].[RETAILCUSTPREFERENCE] TO [DataSyncUsersRole]\n    GO\n    GRANT INSERT ON OBJECT::[ax].[RETAILCUSTPREFERENCE] TO [DataSyncUsersRole]\n    GO\n    GRANT UPDATE ON OBJECT::[ax].[RETAILCUSTPREFERENCE] TO [DataSyncUsersRole]\n    GO\n    GRANT DELETE ON OBJECT::[ax].[RETAILCUSTPREFERENCE] TO [DataSyncUsersRole]\n    GO\n\nFinally, the SQL update script for your customization must be registered in the Customization.settings file for the Retail software development kit (SDK).\n\n### Using extension properties on CRT request and response types\n\nLike entities, request and response types can be extended.\n\n    request.SetProperty(\"BoolPropertyName\", true);\n    response.SetProperty(\"BoolPropertyName2\", true);\n\n    bool? BoolPropertyName = (bool?)request.GetProperty(\"BoolPropertyName\");\n    bool? BoolPropertyName2 = (bool?)response.GetProperty(\"BoolPropertyName2\");\n\n### Implementing a new CRT service that handles multiple new requests\n\nIt's a typical case to implement a new CRT service. First, you must create new request and response classes.\n\n#### Creating the request and response classes\n\nFor serialization to work, the new request type must implement the **\\[DataContract\\]** and **\\[DataMember\\]** attributes.\n\n    using System.Runtime.Serialization;\n    using Microsoft.Dynamics.Commerce.Runtime.Messages;\n\n    [DataContract]\n    public sealed class GetStoreHoursDataRequest : Request\n    {\n        public GetStoreHoursDataRequest(string storeNumber)\n        {\n            this.StoreNumber = storeNumber;\n        }\n\n        [DataMember]\n        public string StoreNumber { get; private set; }\n    }\n\nThe new response type resembles the request type.\n\n    [DataContract]\n    public sealed class GetStoreHoursDataResponse : Response\n    {\n        public GetStoreHoursDataResponse(PagedResult dayHours)\n        {\n            this.DayHours = dayHours;\n        }\n\n        [DataMember]\n        public PagedResult DayHours { get; private set; }\n    }\n\nNext, you must create a new CRT service that uses the request and response types.\n\n#### Creating a new CRT service\n\n1.  Implement the new service.\n\n        public class StoreHoursDataService : IRequestHandler\n\n2.  Implement two members of the interface. The **SupportedRequestTypes** member returns a list of all requests that this service can handle. The execute method is the method that the CRT calls for you if a request for this service is run.\n\n        public IEnumerable SupportedRequestTypes\n        {\n            get\n            {\n                return new[]\n                {\n                typeof(GetStoreHoursDataRequest),\n                };\n            }\n        }\n\n        public Response Execute(Request request);\n\n3.  In the commerceRuntime.Config file, update the **composition** section (or the equivalent section) to register this service. Note that you can register single types or all types from an assembly. The CommerceRuntime engine will find all IRequestHandler derived types.\n4.  Optional: Use the CommerceRuntime Test Host to do a test run of your service.\n\n### Implementing a new CRT service that handles a single new request\n\nIt’s slightly easier to create a single-request service.\n\n    public class CrossLoyaltyCardService : SingleRequestHandler\n\nRegistration is done as described in the previous procedure.\n\n### Implementing a new CRT service that overrides the functionality of an existing request\n\nIn some cases, the request and response types are sufficient, but the service implementation must be changed. If some new data must be transmitted, you can also extend entity, request, or response objects by using extension properties. In this scenario, you can create the service as described earlier and use the existing IRequestHandler types. Additionally, registration in the commerceRuntime.Config file must precede registration of the service that should be overridden. This registration order is important because of the way that the Managed Extensibility Framework (MEF) loads the extension dynamic-link libraries (DLLs). The types that are higher in the file win.\n\n### Implementing a new CRT entity and using it in new CRT service\n\nAny new entity must be of the **CommerceEntity** type. When you use this type, lots of low-level functionality is automatically handled for you. The following example, which is taken from the StoreHours sample, shows how to create an entity that is bound to the database table. This is the usual case.\n\n    public class StoreDayHours : CommerceEntity\n    {\n        private const string DayColumn = \"DAY\";\n        private const string OpenTimeColumn = \"OPENTIME\";\n        private const string CloseTimeColumn = \"CLOSINGTIME\";\n        private const string IdColumn = \"RECID\";\n\n        public StoreDayHours()\n            : base(\"StoreDayHours\")\n        {\n        }\n\n        [DataMember]\n        [Column(DayColumn)]\n        public int DayOfWeek\n        {\n            get { return (int)this[DayColumn]; }\n            set { this[DayColumn] = value; }\n        }\n\n        [DataMember]\n        [Column(OpenTimeColumn)]\n        public int OpenTime\n        {\n            get { return (int)this[OpenTimeColumn]; }\n            set { this[OpenTimeColumn] = value; }\n        }\n\n        [DataMember]\n        [Column(CloseTimeColumn)]\n        public int CloseTime\n        {\n            get { return (int)this[CloseTimeColumn]; }\n            set { this[CloseTimeColumn] = value; }\n        }\n\n        [Key]\n        [DataMember]\n        [Column(IdColumn)]\n        public long Id\n        {\n            get { return (long)this[IdColumn]; }\n            set { this[IdColumn] = value; }\n        }\n    }\n\nWhen you want to use the new entity in a service, the process is straightforward. As described earlier, you create a new service as a derived IRequestHandler. Then either use or return the new entity. The following example shows how to read the entity from the database and return it as part of the response.\n\n    private GetStoreHoursDataResponse GetStoreDayHours(GetStoreHoursDataRequest request)\n    {\n        ThrowIf.Null(request, \"request\");\n        using (DatabaseContext databaseContext = new DatabaseContext(request.RequestContext))\n        {\n            var query = new SqlPagedQuery(request.QueryResultSettings)\n            {\n                DatabaseSchema = \"crt\",\n                Select = new ColumnSet(\"DAY\", \"OPENTIME\", \"CLOSINGTIME\", \"RECID\"),\n                From = \"ISVRETAILSTOREHOURSVIEW\",\n                Where = \"STORENUMBER = @storeNumber\",\n            };\n\n            query.Parameters[\"@storeNumber\"] = request.StoreNumber;\n            return new GetStoreHoursDataResponse(databaseContext.ReadEntity(query));\n        }\n    }\n\nFor the preceding example, the CRT runtime engine automatically makes a query to the channel database via the registered data adapter. It queries a type that has the name **crt.ISVRetailStoreHoursView**, and generates a **where** clause and columns as specified in the code. The customizer is responsible for providing the SQL objects as part of the customization.\n\n### Adding pre-triggers and post-triggers for a specific request\n\nIn some cases, some processing must be done before or after a request is handled. There are two hooks that can be used to run additional code. These hooks are called pre-triggers and post-triggers. Follow these steps to create new triggers and associate them with a request.\n\n1.  Create a new trigger class that implements IRequestTrigger.\n\n        public class GetCrossLoyaltyCardRequestTrigger : IRequestTrigger\n\n2.  In the **IRequest.SupportedRequestTypes** property, return the list of requests that this trigger should be run for.\n\n        public IEnumerable SupportedRequestTypes\n        {\n            get\n            {\n                return new[] { typeof(GetCrossLoyaltyCardRequest) };\n            }\n        }\n\n3.  Implement the functions that are called before and after the request.\n\n        void OnExecuted(Request request, Response response);\n        void OnExecuting(Request request);\n\n4.  Register the class in the commerceRuntime.Config file.\n\n## Retail Server extensibility scenarios\n### Adding a new ODATA action to an existing controller\n\nIn the easiest scenario, you must add a new application programming interface (API) for a slightly different use case. To make this scenario work, you can add the new action through inheritance. For any changes to the APIs to Retail Server, you must follow these steps.\n\n1.  Implement the new action or controller.\n2.  Override the requirements of the model factory to add the new corresponding metadata.\n\nThe following example, which is taken from the Retail SDK, shows how to extend an existing controller so that it has a POST action.\n\n    public class MyCustomersController : CustomersController\n    {\n        [HttpPost]\n        [CommerceAuthorization(AllowedRetailRoles = new string[] { CommerceRoles.Customer, CommerceRoles.Employee })]\n        public decimal GetCrossLoyaltyCardDiscountAction(ODataActionParameters parameters)\n        {\n            if (parameters == null)\n            {\n                throw new ArgumentNullException(\"parameters\");\n            }\n\n            var runtime = CommerceRuntimeManager.CreateRuntime(this.CommercePrincipal);\n            string loyaltyCardNumber = (string)parameters[\"LoyaltyCardNumber\"];\n\n            GetCrossLoyaltyCardResponse resp = runtime.Execute(new GetCrossLoyaltyCardRequest(loyaltyCardNumber), null);\n\n            string logMessage = \"GetCrossLoyaltyCardAction successfully handled with card number '{0}'. Returned discount '{1}'.\";\n            RetailLogger.Log.ExtendedInformationalEvent(logMessage, loyaltyCardNumber, resp.Discount.ToString());\n            return resp.Discount;\n        }\n    }\n\nNext, override the model factory.\n\n    [Export(typeof(IEdmModelFactory))]\n    [ComVisible(false)]\n    public class CustomizedEdmModelFactory : CommerceModelFactory\n    {\n        protected override void BuildActions()\n        {\n            base.BuildActions();\n            var var1 = CommerceModelFactory.BindEntitySetAction(\"GetCrossLoyaltyCardDiscountAction\");\n            var1.Parameter(\"LoyaltyCardNumber\");\n            var1.Returns();\n        }\n    }\n\nBefore clients can use this new customization, you must adjust the build system to generate the Retail Server proxy code for the new model factory. This configuration step is done in the build system. Finally, you must adjust the web.config file. You must complete this step in the packaging project for Retail Server in the SDK. If local tests will be done, you can also optionally complete this step on the local development topology machine that is used for testing.\n\n### Adding a new simple controller for an entity\n\nSuppose that you have a simple entity and require a controller to fetch the data. For an example, see the StoreHours sample in the Retail SDK. A new Retail Server controller makes sense, and all the low-level work is done in the CRT (new entity, request, response, and service). To create a new controller, you derive from CommerceController. An example is shown here. The controller name is important and must match the name of the entity.\n\n    [ComVisible(false)]\n    public class StoreHoursController : CommerceController\n    {\n        public override string ControllerName\n        {\n            get { return \"StoreHours\"; }\n        }\n\n        [HttpPost]\n        [CommerceAuthorization(AllowedRetailRoles = new string[] { CommerceRoles.Anonymous, CommerceRoles.Customer, CommerceRoles.Device, CommerceRoles.Employee })]\n        public System.Web.OData.PageResult GetStoreDaysByStore(ODataActionParameters parameters)\n        {\n            if (parameters == null)\n            {\n                throw new ArgumentNullException(\"parameters\");\n            }\n\n            var runtime = CommerceRuntimeManager.CreateRuntime(this.CommercePrincipal);\n\n            QueryResultSettings queryResultSettings = QueryResultSettings.SingleRecord;\n            queryResultSettings.Paging = new PagingInfo(10);\n\n            var request = new GetStoreHoursDataRequest((string)parameters[\"StoreNumber\"]) { QueryResultSettings = queryResultSettings };\n            PagedResult hours = runtime.Execute(request, null).DayHours;\n            return this.ProcessPagedResults(hours);\n        }\n    }\n\nFor new entities, you must also override the factory’s **BuildEntitySets()** method, as shown in the following example.\n\n    [Export(typeof(IEdmModelFactory))]\n    [ComVisible(false)]\n    public class CustomizedEdmModelFactory : CommerceModelFactory\n    {\n        protected override void BuildActions()\n        {\n            base.BuildActions();\n            var action = CommerceModelFactory.BindEntitySetAction(\"GetStoreDaysByStore\");\n            action.Parameter(\"StoreNumber\");\n            action.ReturnsCollectionFromEntitySet(\"StoreHours\");\n        }\n\n        protected override void BuildEntitySets()\n        {\n            base.BuildEntitySets();\n            CommerceModelFactory.BuildEntitySet(\"StoreHours\");\n        }\n    }\n\n### How to call the new retail server API from MPOS/Cloud POS:\n\nBefore calling the new retail server API please make sure you have performed the below steps:\n\n1.  Register your new retail server extension in Retail server web.config file:  &lt;add source=\"assembly\" value=\"**Your assembly name**\" /&gt;\n2.  Add the new retail server extension in the Customization.settings file. You can find this file in RetailSdk\\\\BuildTools&lt;RetailServerLibraryPathForProxyGeneration Condition=\"'$(RetailServerLibraryPathForProxyGeneration)' == ''\"&gt;$(SdkReferencesPath)\\\\**Your assembly name.dll**&lt;/RetailServerLibraryPathForProxyGeneration&gt; &lt;/PropertyGroup&gt;\n3.  Drop both the CRT and Retail server extension dlls into the retail server bin folder. If you have any CRT extension releated to the new retail server api then update that information in commerceRuntime configuration file under retail server bin folder.\n4.  &lt;add source=\"assembly\" value=\"**Your assembly name**\" /&gt;\n5.  Use inetmgr to browse to the retail server metadata and verify whether your entity is exposed in the xml.\n6.  Compile and build the mpos/Cloud POS to regenerate the proxy. During compile mpos regenerates all the entities defined in the retail server metadata, so that you can call the new entities using the commerce context like below:\n\n#### Cross loyalty sample:\n\n    var request: Commerce.Proxy.Common.IDataServiceRequest = this._context.customers().getCrossLoyaltyCardDiscountAction(loyaltyCardNumber);\n    return request.execute<number>();\n\n#### Store hours sample:\n\n    var request: Commerce.Proxy.Common.IDataServiceRequest = this._context.storeHours().getStoreDaysByStore(storeId);\n    return request.execute<Commerce.Proxy.Entities.StoreDayHours[]>();\n\nPlease refer the retail SDK POS.Extension.CrossloaylySample and POS.Extension.SToreHoursSample sample projects for more details on how to call the new retail server api in mpos.\n\n"}