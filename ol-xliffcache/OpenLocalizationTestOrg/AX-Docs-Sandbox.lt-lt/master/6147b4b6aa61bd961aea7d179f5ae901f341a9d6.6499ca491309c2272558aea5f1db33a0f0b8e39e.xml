{"content":"---\n# required metadata\n\ntitle: Control extensibility\ndescription: This article describes the architecture that lets developers extend the user interface and also define new user interface patterns. \nauthor: RobinARH\nmanager: AnnBe\nms.date: 04/04/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \n# ms.reviewer: 61\nms.search.scope: AX 7.0.0, Operations\n# ms.tgt_pltfrm: \nms.custom: 27461\nms.assetid: f03f1fc6-4f8f-4f42-8e38-5ecba8eac413\nms.search.region: Global\n# ms.search.industry: \nms.author: shshabazz\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# Control extensibility\n\n[!include[banner](../includes/banner.md)]\n\n\nThis article describes the architecture that lets developers extend the user interface and also define new user interface patterns. \n\nYou can extend the existing application user interface (UI) and can also define entirely new UI patterns to create compelling new user experiences. By using modern tools such as HTML5, CSS3, and jQuery, developers can define customized visualizations of business data and drastically enhance the program's interaction patterns.\n\n## Serverside architecture\nThe Control Extensibility Framework takes advantage of the existing and familiar X++ language for developing server-side data access and business logic. There are no artificial restrictions on the code that developers write to build extensible controls. Instead, developers can declaratively define the modeling experience and the run-time behavior through a set of X++ class and method attributes. A developer defines one class for the design-time behavior (the X++ Build Class) and one class for the run-time behavior (the X++ RunTime class).\n\n-   In the X++ Build Class, attributes enable the definition of design-time behaviors such as custom properties in the property sheet, the addition of child controls, and extra modeling components.\n-   In the X++ Runtime Class, attributes are used to define the run-time properties and commands that the extensible control will access from the client. The X++ Runtime Class consumes the X++ Build Class to initialize the run-time properties, based on the values and data bindings that are specified in the property sheet.\n\n## Clientside architecture\nThe client-side behavior for the control is defined by using HTML and JavaScript. In the context of a Model-View-ViewModel architecture, the HTML for the control comprises the View, and the JavaScript comprises the ViewModel. The Control Extensibility Framework provides an HTML-based binding syntax that enables elements in the HTML View to be bound to data fields and properties in the JavaScript ViewModel. In addition, the framework enables visualization behavior to be defined based on conditional expressions or logical evaluations that can react to changes in ViewModel properties or business data. The JavaScript ViewModel is automatically generated at run time, based on the properties and commands that are defined in the X++ runtime for the control. This automatically generated ViewModel lets a developer define an HTML View that consumes the properties and commands that are defined in X++. If a developer wants additional client-side properties and commands, or wants to implement visualization behavior that can't be declaratively defined in the HTML View, he or she can extend the automatically generated ViewModel. The developer can take advantage of the JavaScript framework in conjunction with the powerful jQuery library.\n\n## Control extensibility architecture overview\nThe following diagram shows the artifacts that are involved and their relation to each other. [![Control extensibility architecture](./media/extensibilitycontrolarchitecture.png)](./media/extensibilitycontrolarchitecture.png)\n\n\n\n\n\n","nodes":[{"pos":[32,53],"content":"Control extensibility","needQuote":true,"needEscape":true,"nodes":[{"content":"Control extensibility","pos":[0,21]}]},{"pos":[67,198],"content":"This article describes the architecture that lets developers extend the user interface and also define new user interface patterns.","needQuote":true,"needEscape":true,"nodes":[{"content":"This article describes the architecture that lets developers extend the user interface and also define new user interface patterns.","pos":[0,131]}]},{"pos":[697,718],"content":"Control extensibility","linkify":"Control extensibility","nodes":[{"content":"Control extensibility","pos":[0,21]}]},{"content":"This article describes the architecture that lets developers extend the user interface and also define new user interface patterns.","pos":[764,895]},{"content":"You can extend the existing application user interface (UI) and can also define entirely new UI patterns to create compelling new user experiences.","pos":[898,1045]},{"content":"By using modern tools such as HTML5, CSS3, and jQuery, developers can define customized visualizations of business data and drastically enhance the program's interaction patterns.","pos":[1046,1225]},{"pos":[1230,1253],"content":"Serverside architecture","linkify":"Serverside architecture","nodes":[{"content":"Serverside architecture","pos":[0,23]}]},{"content":"The Control Extensibility Framework takes advantage of the existing and familiar X++ language for developing server-side data access and business logic.","pos":[1254,1406]},{"content":"There are no artificial restrictions on the code that developers write to build extensible controls.","pos":[1407,1507]},{"content":"Instead, developers can declaratively define the modeling experience and the run-time behavior through a set of X++ class and method attributes.","pos":[1508,1652]},{"content":"A developer defines one class for the design-time behavior (the X++ Build Class) and one class for the run-time behavior (the X++ RunTime class).","pos":[1653,1798]},{"content":"In the X++ Build Class, attributes enable the definition of design-time behaviors such as custom properties in the property sheet, the addition of child controls, and extra modeling components.","pos":[1804,1997]},{"content":"In the X++ Runtime Class, attributes are used to define the run-time properties and commands that the extensible control will access from the client.","pos":[2002,2151]},{"content":"The X++ Runtime Class consumes the X++ Build Class to initialize the run-time properties, based on the values and data bindings that are specified in the property sheet.","pos":[2152,2321]},{"pos":[2326,2349],"content":"Clientside architecture","linkify":"Clientside architecture","nodes":[{"content":"Clientside architecture","pos":[0,23]}]},{"content":"The client-side behavior for the control is defined by using HTML and JavaScript.","pos":[2350,2431]},{"content":"In the context of a Model-View-ViewModel architecture, the HTML for the control comprises the View, and the JavaScript comprises the ViewModel.","pos":[2432,2575]},{"content":"The Control Extensibility Framework provides an HTML-based binding syntax that enables elements in the HTML View to be bound to data fields and properties in the JavaScript ViewModel.","pos":[2576,2759]},{"content":"In addition, the framework enables visualization behavior to be defined based on conditional expressions or logical evaluations that can react to changes in ViewModel properties or business data.","pos":[2760,2955]},{"content":"The JavaScript ViewModel is automatically generated at run time, based on the properties and commands that are defined in the X++ runtime for the control.","pos":[2956,3110]},{"content":"This automatically generated ViewModel lets a developer define an HTML View that consumes the properties and commands that are defined in X++.","pos":[3111,3253]},{"content":"If a developer wants additional client-side properties and commands, or wants to implement visualization behavior that can't be declaratively defined in the HTML View, he or she can extend the automatically generated ViewModel.","pos":[3254,3481]},{"content":"The developer can take advantage of the JavaScript framework in conjunction with the powerful jQuery library.","pos":[3482,3591]},{"pos":[3596,3639],"content":"Control extensibility architecture overview","linkify":"Control extensibility architecture overview","nodes":[{"content":"Control extensibility architecture overview","pos":[0,43]}]},{"content":"The following diagram shows the artifacts that are involved and their relation to each other.","pos":[3640,3733]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Control extensibility architecture<ept id=\"p1\">](./media/extensibilitycontrolarchitecture.png)](./media/extensibilitycontrolarchitecture.png)</ept>","pos":[3734,3865],"source":"[![Control extensibility architecture](./media/extensibilitycontrolarchitecture.png)](./media/extensibilitycontrolarchitecture.png)"}]}