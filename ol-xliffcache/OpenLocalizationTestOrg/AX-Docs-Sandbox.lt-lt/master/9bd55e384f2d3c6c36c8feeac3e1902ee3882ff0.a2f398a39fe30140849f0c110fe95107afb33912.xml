{"nodes":[{"pos":[32,60],"content":"Programming language support","needQuote":true,"needEscape":true,"nodes":[{"content":"Programming language support","pos":[0,28]}]},{"pos":[74,168],"content":"This topic reviews the changes made to the compiler for Microsoft Dynamics 365 for Operations.","needQuote":true,"needEscape":true,"nodes":[{"content":"This topic reviews the changes made to the compiler for Microsoft Dynamics 365 for Operations.","pos":[0,94]}]},{"pos":[675,703],"content":"Programming language support","linkify":"Programming language support","nodes":[{"content":"Programming language support","pos":[0,28]}]},{"content":"This topic reviews the changes made to the compiler for Microsoft Dynamics 365 for Operations.","pos":[705,799]},{"content":"For Microsoft Dynamics 365 for Operations, the X++ compiler has been rewritten.","pos":[801,880]},{"content":"No backward-incompatible changes have been introduced to X++ except where required by structural changes to the product.","pos":[881,1001]},{"content":"A few language enhancements have been added.","pos":[1002,1046]},{"content":"A new X++ best practice tool has also been implemented, which allows the addition of user-defined custom rules.","pos":[1047,1158]},{"pos":[1163,1213],"content":"No more pcode, everything is in .NET Framework CIL","linkify":"No more pcode, everything is in .NET Framework CIL","nodes":[{"content":"No more pcode, everything is in .NET Framework CIL","pos":[0,50]}]},{"content":"Through Microsoft Dynamics AX 2012, X++ source code was compiled into p-code, which was understood by the interpreter at run time.","pos":[1214,1344]},{"content":"Optionally, you could then compile the p-code into Microsoft .NET CIL (Common Intermediate Language).","pos":[1345,1446]},{"content":"CIL is what the .NET compilers for C<ph id=\"ph1\">\\#</ph> and Visual Basic generate.","pos":[1447,1512],"source":" CIL is what the .NET compilers for C\\# and Visual Basic generate."},{"content":"However, X++ CIL code was usable only in limited cases, mainly for code executed in services and batch jobs.","pos":[1513,1621]},{"content":"The new X++ compiler generates CIL only.","pos":[1622,1662]},{"content":"There is no more p-code.","pos":[1663,1687]},{"content":"The following tools that worked with p-code are now obsolete and have been removed from Dynamics AX and replaced by .NET tools:","pos":[1688,1815]},{"content":"The X++ compiler that generated p-code.","pos":[1821,1860]},{"content":"The special compiler that input p-code and generated .NET CIL.","pos":[1865,1927]},{"content":"The run time interpreter of p-code including its deterministic garbage collector.","pos":[1932,2013]},{"content":"The Dynamics AX Debugger.","pos":[2018,2043]},{"content":"The Dynamics AX Code Profiler, which helped find performance bottlenecks.","pos":[2048,2121]},{"content":"The AX .NET Business Connector for external applications that interoperated with Dynamics AX.","pos":[2126,2219]},{"content":"There are important benefits to X++ code running exclusively as .NET CIL, including:","pos":[2221,2305]},{"content":"CIL runs much faster in most scenarios.","pos":[2311,2350]},{"content":"In cases where there are many method calls, and a lot of algorithmic content (as opposed to database access), you can expect significant performance improvements.","pos":[2351,2513]},{"content":"It's easier to write application logic in other managed languages.","pos":[2522,2588]},{"content":"There's no longer any need for the AX .NET Business Connector or managed proxies, because the assemblies can be consumed directly.","pos":[2597,2727]},{"content":"The preferred way of consuming business logic externally is by using services.","pos":[2736,2814]},{"content":"CIL can efficiently reference classes that are available in other .NET assembly DLL files, without the run time reflection-based overhead that burdened the p-code interpreter.","pos":[2819,2994]},{"content":"CIL can be operated on by the many .NET tools.","pos":[2999,3045]},{"pos":[3050,3069],"content":"Unit of compilation","linkify":"Unit of compilation","nodes":[{"content":"Unit of compilation","pos":[0,19]}]},{"content":"Previous versions of Microsoft Dynamics AX could compile X++ at the level of an individual method.","pos":[3070,3168]},{"content":"Thus if a compilation of a class found an error in one method of the class, the methods that did compile correctly were still runnable.","pos":[3169,3304]},{"content":"In the standard compilation unit now is the same as for other .NET languages such as C<ph id=\"ph1\">\\#</ph>. If any method in a model element (class, form, query etc.) fails to compile, the whole compilation fails.","pos":[3305,3500],"source":" In the standard compilation unit now is the same as for other .NET languages such as C\\#. If any method in a model element (class, form, query etc.) fails to compile, the whole compilation fails."},{"pos":[3505,3524],"content":"Enhancements to X++","linkify":"Enhancements to X++","nodes":[{"content":"Enhancements to X++","pos":[0,19]}]},{"content":"X++ is now a first-class citizen in the .NET world.","pos":[3525,3576]},{"content":"Therefore we are adding to X++ several constructs that are available in C<ph id=\"ph1\">\\#</ph> and other mainstream .NET languages.","pos":[3577,3689],"source":" Therefore we are adding to X++ several constructs that are available in C\\# and other mainstream .NET languages."},{"content":"The changes are generally non-intrusive.","pos":[3690,3730]},{"content":"In fact, very few changes have been made to the syntax and semantics of existing X++ code.","pos":[3731,3821]},{"content":"Most of these additions are in the following list:","pos":[3822,3872]},{"content":"The <ph id=\"ph1\">`finally`</ph> keyword is now available to follow the <ph id=\"ph2\">`try`</ph> and <ph id=\"ph3\">`catch`</ph> keywords.","pos":[3878,3958],"source":"The `finally` keyword is now available to follow the `try` and `catch` keywords."},{"content":"The semantics are identical to the semantics in C<ph id=\"ph1\">\\#</ph>. The statements provided in the finally clause are executed irrespective of whether the try block threw any exceptions.","pos":[3959,4130],"source":" The semantics are identical to the semantics in C\\#. The statements provided in the finally clause are executed irrespective of whether the try block threw any exceptions."},{"content":"The <ph id=\"ph1\">`using`</ph> keyword has been added as shorthand for referencing .NET namespaces.","pos":[4135,4215],"source":"The `using` keyword has been added as shorthand for referencing .NET namespaces."},{"content":"The following code example illustrates two ways of utilizing the using keyword to reference namespaces:","pos":[4216,4319]},{"content":"You can now initialize a class's field in the field's declaration statement.","pos":[4780,4856]},{"content":"This is illustrated twice in the previous code example.","pos":[4857,4912]},{"content":"You can declare variables in smaller scopes, not just at the start of methods.","pos":[4917,4995]},{"pos":[5000,5113],"content":"The <ph id=\"ph1\">`var`</ph> keyword is available as a shortcut that allows the compiler to infer the type of the declared variable.","source":"The `var` keyword is available as a shortcut that allows the compiler to infer the type of the declared variable."},{"content":"A class's fields can now be static.","pos":[5118,5153]},{"content":"In previous versions, only instance fields were allowed.","pos":[5154,5210]},{"content":"A class can now have one static constructor.","pos":[5215,5259]},{"content":"In previous versions, only instance constructors were available.","pos":[5260,5324]},{"content":"The following X++ code example shows the syntax for a static constructor, through the new keyword typenew.","pos":[5325,5431]},{"content":"An attribute decoration, such as on a class or a method, can now omit the suffix of the attribute name if the suffix is <ph id=\"ph1\">`Attribute`</ph>.","pos":[5836,5968],"source":"An attribute decoration, such as on a class or a method, can now omit the suffix of the attribute name if the suffix is `Attribute`."},{"content":"So the X++ joins the C<ph id=\"ph1\">\\#</ph> in allowing <ph id=\"ph2\">`[MyFavorite]`</ph> instead of requiring <ph id=\"ph3\">`[MyFavoriteAttribute]`</ph>.","pos":[5969,6066],"source":" So the X++ joins the C\\# in allowing `[MyFavorite]` instead of requiring `[MyFavoriteAttribute]`."},{"content":"A delegate can now be defined in a table, form, or query, and not just in a class.","pos":[6071,6153]},{"content":"Attributes are now applied to the handlers of delegates and methods, to map the handlers to those targets.","pos":[6158,6264]},{"content":"Classes can now be nested in X++ source code.","pos":[6269,6314]},{"content":"Nested classes are available only inside forms (such as a class that extends FormRun) to represent controls, data sources, or data fields.","pos":[6315,6453]},{"pos":[6458,6493],"content":"Backwardincompatible changes to X++","linkify":"Backwardincompatible changes to X++","nodes":[{"content":"Backwardincompatible changes to X++","pos":[0,35]}]},{"content":"There are a few changes to X++ that require corresponding changes in legacy custom X++ source code.","pos":[6494,6593]},{"content":"Most of these changes are in the following list:","pos":[6594,6642]},{"content":"The following keywords are no longer part of the X++ language, and their use causes compilation errors:","pos":[6648,6751]},{"content":"In legacy X++, it was possible to designate a method to run either on the client or the server.","pos":[6810,6905]},{"content":"This is no longer possible.","pos":[6906,6933]},{"content":"All compiled X++ code is executed as .NET CIL on the server.","pos":[6934,6994]},{"content":"There is no longer any X++ code that is evaluated at the client site or in the browser, therefore, the two keywords, <bpt id=\"p1\">*</bpt>client<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>server<ept id=\"p2\">*</ept>, are now ignored.","pos":[6995,7151],"source":" There is no longer any X++ code that is evaluated at the client site or in the browser, therefore, the two keywords, *client* and *server*, are now ignored."},{"content":"Their use doesn't cause a compile error, but they should not be used in any new X++ code.","pos":[7152,7241]},{"content":"In Microsoft Dynamics AX 2012, there were a few areas where X++ behaved differently when compiled to p-code versus CIL.","pos":[7246,7365]},{"content":"In Dynamics 365 for Operations, all these areas behave as they did in CIL in Microsoft Dynamics AX 2012.","pos":[7366,7470]},{"content":"The significant behavioral differences between X++ p-code versus X+ as CIL were as follows:","pos":[7471,7562]},{"content":"In CIL, the <ph id=\"ph1\">`real `</ph>data type is represented as <ph id=\"ph2\">`System.Decimal`</ph>.","pos":[7571,7635],"source":"In CIL, the `real `data type is represented as `System.Decimal`."},{"content":"This means the range and precision for each <ph id=\"ph1\">`real`</ph> is different than it was under p-code.","pos":[7636,7725],"source":" This means the range and precision for each `real` is different than it was under p-code."},{"content":"This change was already in effect in Microsoft Dynamics AX 2012 when .NET CIL was run.","pos":[7726,7812]},{"content":"An assignment of one entire array to another was performed in value in p-code mode, but it's performed by reference in CIL mode.","pos":[7821,7949]},{"pos":[7958,8064],"content":"CIL helper methods such as <ph id=\"ph1\">`Global::runClassMethodIL`</ph> have been removed, since they're no longer relevant.","source":"CIL helper methods such as `Global::runClassMethodIL` have been removed, since they're no longer relevant."},{"content":"There is no concept of a job, in the sense of <bpt id=\"p1\">**</bpt>AOT<ept id=\"p1\">**</ept> <ph id=\"ph1\">&amp;gt;</ph> <bpt id=\"p2\">**</bpt>Jobs<ept id=\"p2\">**</ept> <ph id=\"ph2\">&amp;gt;</ph> <bpt id=\"p3\">**</bpt>MyJob<ept id=\"p3\">**</ept>.","pos":[8069,8152],"source":"There is no concept of a job, in the sense of **AOT** &gt; **Jobs** &gt; **MyJob**."},{"content":"To quickly and easily run an X++ method, you can still add in a <ph id=\"ph1\">`static Main`</ph> method to a class, and then set the class as the startup object form for the project in Microsoft Visual Studio.","pos":[8153,8343],"source":" To quickly and easily run an X++ method, you can still add in a `static Main` method to a class, and then set the class as the startup object form for the project in Microsoft Visual Studio."},{"content":"When the project is run, the <ph id=\"ph1\">`Main`</ph> method will be run.","pos":[8344,8399],"source":" When the project is run, the `Main` method will be run."},{"pos":[8402,8410],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[8421,8505],"content":"<bpt id=\"p1\">[</bpt>Dynamics AX LINQ Provider for use in C#<ept id=\"p1\">](https://ax.help.dynamics.com/en/?p=185911)</ept>","source":"[Dynamics AX LINQ Provider for use in C#](https://ax.help.dynamics.com/en/?p=185911)"},{"pos":[8507,8560],"content":"<bpt id=\"p1\">[</bpt>Technical Concepts Guide<ept id=\"p1\">](developer-landing-page.md)</ept>","source":"[Technical Concepts Guide](developer-landing-page.md)"}],"content":"---\n# required metadata\n\ntitle: Programming language support\ndescription: This topic reviews the changes made to the compiler for Microsoft Dynamics 365 for Operations.\nauthor: pvillads\nmanager: AnnBe\nms.date: 2015-12-13 01 - 58 - 36\nms.topic: article\nms.prod: \nms.service: Dynamics365Operations\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \n# ms.reviewer: 61\nms.search.scope: AX 7.0.0, Operations\n# ms.tgt_pltfrm: \nms.custom: 26781\nms.assetid: 1485cf4d-c509-4aad-b828-b037841b740d\nms.search.region: Global\n# ms.search.industry: \nms.author: pvillads\nms.dyn365.ops.intro: Feb-16\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# Programming language support\n\nThis topic reviews the changes made to the compiler for Microsoft Dynamics 365 for Operations.\n\nFor Microsoft Dynamics 365 for Operations, the X++ compiler has been rewritten. No backward-incompatible changes have been introduced to X++ except where required by structural changes to the product. A few language enhancements have been added. A new X++ best practice tool has also been implemented, which allows the addition of user-defined custom rules.\n\n## No more pcode, everything is in .NET Framework CIL\nThrough Microsoft Dynamics AX 2012, X++ source code was compiled into p-code, which was understood by the interpreter at run time. Optionally, you could then compile the p-code into Microsoft .NET CIL (Common Intermediate Language). CIL is what the .NET compilers for C\\# and Visual Basic generate. However, X++ CIL code was usable only in limited cases, mainly for code executed in services and batch jobs. The new X++ compiler generates CIL only. There is no more p-code. The following tools that worked with p-code are now obsolete and have been removed from Dynamics AX and replaced by .NET tools:\n\n-   The X++ compiler that generated p-code.\n-   The special compiler that input p-code and generated .NET CIL.\n-   The run time interpreter of p-code including its deterministic garbage collector.\n-   The Dynamics AX Debugger.\n-   The Dynamics AX Code Profiler, which helped find performance bottlenecks.\n-   The AX .NET Business Connector for external applications that interoperated with Dynamics AX.\n\nThere are important benefits to X++ code running exclusively as .NET CIL, including:\n\n-   CIL runs much faster in most scenarios. In cases where there are many method calls, and a lot of algorithmic content (as opposed to database access), you can expect significant performance improvements.\n    -   It's easier to write application logic in other managed languages.\n    -   There's no longer any need for the AX .NET Business Connector or managed proxies, because the assemblies can be consumed directly.\n    -   The preferred way of consuming business logic externally is by using services.\n-   CIL can efficiently reference classes that are available in other .NET assembly DLL files, without the run time reflection-based overhead that burdened the p-code interpreter.\n-   CIL can be operated on by the many .NET tools.\n\n## Unit of compilation\nPrevious versions of Microsoft Dynamics AX could compile X++ at the level of an individual method. Thus if a compilation of a class found an error in one method of the class, the methods that did compile correctly were still runnable. In the standard compilation unit now is the same as for other .NET languages such as C\\#. If any method in a model element (class, form, query etc.) fails to compile, the whole compilation fails.\n\n## Enhancements to X++\nX++ is now a first-class citizen in the .NET world. Therefore we are adding to X++ several constructs that are available in C\\# and other mainstream .NET languages. The changes are generally non-intrusive. In fact, very few changes have been made to the syntax and semantics of existing X++ code. Most of these additions are in the following list:\n\n-   The `finally` keyword is now available to follow the `try` and `catch` keywords. The semantics are identical to the semantics in C\\#. The statements provided in the finally clause are executed irrespective of whether the try block threw any exceptions.\n-   The `using` keyword has been added as shorthand for referencing .NET namespaces. The following code example illustrates two ways of utilizing the using keyword to reference namespaces:\n\n        using SysColl = System.Collections;  // SysColl is an alias for the whole namespace.\n        using           System.CodeDom;      // Contains the class named CodeComment.\n\n        public class MyClass2\n        {\n            static SysColl.ArrayList arrayList = new SysColl.ArrayList(); // Initialized on declaration.\n            CodeComment codeComment          = new CodeComment(\"I am a comment.\");\n\n            // More X++ code here.\n        }\n\n-   You can now initialize a class's field in the field's declaration statement. This is illustrated twice in the previous code example.\n-   You can declare variables in smaller scopes, not just at the start of methods.\n-   The `var` keyword is available as a shortcut that allows the compiler to infer the type of the declared variable.\n-   A class's fields can now be static. In previous versions, only instance fields were allowed.\n-   A class can now have one static constructor. In previous versions, only instance constructors were available. The following X++ code example shows the syntax for a static constructor, through the new keyword typenew.\n\n        .    public class MyClass4\n            {\n                static utcdatetime utcInitialized3;  // Static variable member.\n                static void typenew()                // Static constructor member. 'typenew' is a new keyword.\n                {\n                utcInitialized3 = DateTimeUtil::utcNow(); // Static variable referenced without class name.\n                }\n            }\n\n-   An attribute decoration, such as on a class or a method, can now omit the suffix of the attribute name if the suffix is `Attribute`. So the X++ joins the C\\# in allowing `[MyFavorite]` instead of requiring `[MyFavoriteAttribute]`.\n-   A delegate can now be defined in a table, form, or query, and not just in a class.\n-   Attributes are now applied to the handlers of delegates and methods, to map the handlers to those targets.\n-   Classes can now be nested in X++ source code. Nested classes are available only inside forms (such as a class that extends FormRun) to represent controls, data sources, or data fields.\n\n## Backwardincompatible changes to X++\nThere are a few changes to X++ that require corresponding changes in legacy custom X++ source code. Most of these changes are in the following list:\n\n-   The following keywords are no longer part of the X++ language, and their use causes compilation errors:\n    -   `changeSite`\n    -   `pause`\n    -   `window`\n-   In legacy X++, it was possible to designate a method to run either on the client or the server. This is no longer possible. All compiled X++ code is executed as .NET CIL on the server. There is no longer any X++ code that is evaluated at the client site or in the browser, therefore, the two keywords, *client* and *server*, are now ignored. Their use doesn't cause a compile error, but they should not be used in any new X++ code.\n-   In Microsoft Dynamics AX 2012, there were a few areas where X++ behaved differently when compiled to p-code versus CIL. In Dynamics 365 for Operations, all these areas behave as they did in CIL in Microsoft Dynamics AX 2012. The significant behavioral differences between X++ p-code versus X+ as CIL were as follows:\n    -   In CIL, the `real `data type is represented as `System.Decimal`. This means the range and precision for each `real` is different than it was under p-code. This change was already in effect in Microsoft Dynamics AX 2012 when .NET CIL was run.\n    -   An assignment of one entire array to another was performed in value in p-code mode, but it's performed by reference in CIL mode.\n    -   CIL helper methods such as `Global::runClassMethodIL` have been removed, since they're no longer relevant.\n-   There is no concept of a job, in the sense of **AOT** &gt; **Jobs** &gt; **MyJob**. To quickly and easily run an X++ method, you can still add in a `static Main` method to a class, and then set the class as the startup object form for the project in Microsoft Visual Studio. When the project is run, the `Main` method will be run.\n\n\nSee also\n--------\n\n[Dynamics AX LINQ Provider for use in C#](https://ax.help.dynamics.com/en/?p=185911)\n\n[Technical Concepts Guide](developer-landing-page.md)\n\n"}