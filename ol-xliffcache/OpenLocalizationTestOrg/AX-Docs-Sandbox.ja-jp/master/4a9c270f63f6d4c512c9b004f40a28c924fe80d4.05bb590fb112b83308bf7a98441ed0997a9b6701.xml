{"nodes":[{"pos":[32,84],"content":"X++ data selection and manipulation | Microsoft Docs","needQuote":true,"needEscape":true,"nodes":[{"content":"X++ data selection and manipulation | Microsoft Docs","pos":[0,52]}]},{"pos":[98,180],"content":"This topic describes the X++ language support for data selection and manipulation.","needQuote":true,"needEscape":true,"nodes":[{"content":"This topic describes the X++ language support for data selection and manipulation.","pos":[0,82]}]},{"pos":[600,635],"content":"X++ data selection and manipulation","linkify":"X++ data selection and manipulation","nodes":[{"content":"X++ data selection and manipulation","pos":[0,35]}]},{"content":"This topic describes the X++ language support for data selection and manipulation.","pos":[637,719]},{"content":"You can use SQL statements either interactively or within source code, to access and retrieve data that is stored in the database.","pos":[721,851]},{"content":"You use the following statements for data manipulation:","pos":[852,907]},{"pos":[913,966],"content":"<bpt id=\"p1\">**</bpt>select:<ept id=\"p1\">**</ept> selects the data that you want to modify.","source":"**select:** selects the data that you want to modify."},{"pos":[971,1025],"content":"<bpt id=\"p1\">**</bpt>insert:<ept id=\"p1\">**</ept> adds one or more new records into a table.","source":"**insert:** adds one or more new records into a table."},{"pos":[1030,1082],"content":"<bpt id=\"p1\">**</bpt>update:<ept id=\"p1\">**</ept> modifies data in existing table records.","source":"**update:** modifies data in existing table records."},{"pos":[1087,1137],"content":"<bpt id=\"p1\">**</bpt>delete:<ept id=\"p1\">**</ept> removes existing records from a table.","source":"**delete:** removes existing records from a table."},{"content":"Before any data can be changed, you must select the data for update for update by using a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement.","pos":[1139,1250],"source":"Before any data can be changed, you must select the data for update for update by using a **select** statement."},{"content":"The <bpt id=\"p1\">**</bpt>select forUpdate<ept id=\"p1\">**</ept> command selects records exclusively for update.","pos":[1251,1323],"source":" The **select forUpdate** command selects records exclusively for update."},{"content":"The <bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>update<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>delete<ept id=\"p3\">**</ept> methods perform operations on only one record at a time.","pos":[1324,1423],"source":" The **insert**, **update**, and **delete** methods perform operations on only one record at a time."},{"content":"The <bpt id=\"p1\">**</bpt>array insert<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>RecordInsertList,<ept id=\"p3\">**</ept> and <bpt id=\"p4\">**</bpt>update<ph id=\"ph2\">\\_</ph>recordset<ept id=\"p4\">**</ept> statements perform operations on multiple records at a time.","pos":[1424,1577],"source":" The **array insert**, **insert\\_recordset**, **RecordInsertList,** and **update\\_recordset** statements perform operations on multiple records at a time."},{"pos":[1582,1598],"content":"select statement","linkify":"select statement","nodes":[{"content":"select statement","pos":[0,16]}]},{"content":"The <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement fetches or manipulates data from the database.","pos":[1599,1670],"source":"The **select** statement fetches or manipulates data from the database."},{"content":"All <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statements use a table variable to fetch records.","pos":[1671,1735],"source":" All **select** statements use a table variable to fetch records."},{"content":"This variable must be declared before a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement can be executed.","pos":[1736,1813],"source":" This variable must be declared before a **select** statement can be executed."},{"content":"The <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement only fetches one record, or field.","pos":[1814,1873],"source":" The **select** statement only fetches one record, or field."},{"content":"To fetch additional records, you can use the <bpt id=\"p1\">**</bpt>next<ept id=\"p1\">**</ept> statement.","pos":[1874,1938],"source":" To fetch additional records, you can use the **next** statement."},{"content":"The <bpt id=\"p1\">**</bpt>next<ept id=\"p1\">**</ept> statement fetches the next record in the table.","pos":[1939,1999],"source":" The **next** statement fetches the next record in the table."},{"content":"If you use <bpt id=\"p1\">**</bpt>next<ept id=\"p1\">**</ept> without a preceding <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> command, an error occurs.","pos":[2000,2076],"source":" If you use **next** without a preceding **select** command, an error occurs."},{"content":"Do not use <bpt id=\"p1\">**</bpt>next<ept id=\"p1\">**</ept> with the <bpt id=\"p2\">**</bpt>firstOnly<ept id=\"p2\">**</ept> find option.","pos":[2077,2132],"source":" Do not use **next** with the **firstOnly** find option."},{"content":"If you need to traverse a number of records, it is more appropriate to use a <bpt id=\"p1\">**</bpt>while<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement.","pos":[2133,2241],"source":" If you need to traverse a number of records, it is more appropriate to use a **while** **select** statement."},{"content":"The results of a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement are returned in a table buffer variable.","pos":[2242,2320],"source":" The results of a **select** statement are returned in a table buffer variable."},{"content":"If you use a field list in the <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement, only those fields are available in the table variable.","pos":[2321,2428],"source":" If you use a field list in the **select** statement, only those fields are available in the table variable."},{"content":"If you use aggregate functions, such as <bpt id=\"p1\">**</bpt>sum<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>count<ept id=\"p2\">**</ept>, the results are returned in the fields that you perform the <bpt id=\"p3\">**</bpt>sum<ept id=\"p3\">**</ept> or <bpt id=\"p4\">**</bpt>count<ept id=\"p4\">**</ept> over.","pos":[2429,2577],"source":" If you use aggregate functions, such as **sum** or **count**, the results are returned in the fields that you perform the **sum** or **count** over."},{"content":"You can only count, average, or sum the integer and real fields.","pos":[2578,2642]},{"pos":[2647,2670],"content":"select statement syntax","linkify":"select statement syntax","nodes":[{"content":"select statement syntax","pos":[0,23]}]},{"pos":[3315,3332],"content":"<bpt id=\"p1\">*</bpt>SelectStatement<ept id=\"p1\">*</ept>","source":"*SelectStatement*"},{"pos":[3341,3364],"content":"<bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>Parameters<ept id=\"p2\">*</ept>","source":"**select** *Parameters*"},{"pos":[3636,3648],"content":"<bpt id=\"p1\">*</bpt>Parameters<ept id=\"p1\">*</ept>","source":"*Parameters*"},{"pos":[3662,3865],"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\[</ph> <ph id=\"ph2\">\\[</ph><ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>FindOptions<ept id=\"p2\">*</ept>  <bpt id=\"p3\">**</bpt><ph id=\"ph3\">\\]</ph><ept id=\"p3\">**</ept> <bpt id=\"p4\">**</bpt><ph id=\"ph4\">\\[</ph><ept id=\"p4\">**</ept>  <bpt id=\"p5\">*</bpt>FieldList<ept id=\"p5\">*</ept>  <bpt id=\"p6\">**</bpt>from <ph id=\"ph5\">\\]</ph> <ph id=\"ph6\">\\]</ph><ept id=\"p6\">**</ept> <bpt id=\"p7\">*</bpt>TableBufferVariable<ept id=\"p7\">*</ept> <bpt id=\"p8\">**</bpt><ph id=\"ph7\">\\[</ph><ept id=\"p8\">**</ept> <bpt id=\"p9\">*</bpt>IndexClause<ept id=\"p9\">*</ept> <bpt id=\"p10\">**</bpt><ph id=\"ph8\">\\]</ph><ept id=\"p10\">**</ept> <bpt id=\"p11\">**</bpt><ph id=\"ph9\">\\[</ph><ept id=\"p11\">**</ept>  <bpt id=\"p12\">*</bpt>Options<ept id=\"p12\">*</ept>  <bpt id=\"p13\">**</bpt><ph id=\"ph10\">\\]</ph><ept id=\"p13\">**</ept> <bpt id=\"p14\">**</bpt><ph id=\"ph11\">\\[</ph><ept id=\"p14\">**</ept>  <bpt id=\"p15\">*</bpt>WhereClause<ept id=\"p15\">*</ept>  <bpt id=\"p16\">**</bpt><ph id=\"ph12\">\\]</ph><ept id=\"p16\">**</ept> <bpt id=\"p17\">**</bpt><ph id=\"ph13\">\\[</ph><ept id=\"p17\">**</ept>  <bpt id=\"p18\">*</bpt>JoinClause<ept id=\"p18\">*</ept>  <bpt id=\"p19\">**</bpt><ph id=\"ph14\">\\]</ph><ept id=\"p19\">**</ept>","source":"**\\[ \\[**  *FindOptions*  **\\]** **\\[**  *FieldList*  **from \\] \\]** *TableBufferVariable* **\\[** *IndexClause* **\\]** **\\[**  *Options*  **\\]** **\\[**  *WhereClause*  **\\]** **\\[**  *JoinClause*  **\\]**"},{"pos":[3957,3970],"content":"<bpt id=\"p1\">*</bpt>FindOptions<ept id=\"p1\">*</ept>","source":"*FindOptions*"},{"pos":[3983,3999],"content":"<bpt id=\"p1\">**</bpt>crossCompany<ept id=\"p1\">**</ept>","source":"**crossCompany**"},{"pos":[4002,4013],"content":"<bpt id=\"p1\">**</bpt>reverse<ept id=\"p1\">**</ept>","source":"**reverse**"},{"pos":[4016,4029],"content":"<bpt id=\"p1\">**</bpt>firstFast<ept id=\"p1\">**</ept>","source":"**firstFast**"},{"pos":[4032,4048],"content":"<ph id=\"ph1\">\\[</ph> <bpt id=\"p1\">**</bpt>firstOnly<ept id=\"p1\">**</ept>","source":"\\[ **firstOnly**"},{"pos":[4051,4066],"content":"<bpt id=\"p1\">**</bpt>firstOnly10<ept id=\"p1\">**</ept>","source":"**firstOnly10**"},{"pos":[4069,4085],"content":"<bpt id=\"p1\">**</bpt>firstOnly100<ept id=\"p1\">**</ept>","source":"**firstOnly100**"},{"pos":[4088,4108],"content":"<bpt id=\"p1\">**</bpt>firstOnly1000<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\]</ph>","source":"**firstOnly1000** \\]"},{"pos":[4111,4124],"content":"<bpt id=\"p1\">**</bpt>forUpdate<ept id=\"p1\">**</ept>","source":"**forUpdate**"},{"pos":[4127,4138],"content":"<bpt id=\"p1\">**</bpt>noFetch<ept id=\"p1\">**</ept>","source":"**noFetch**"},{"pos":[4141,4164],"content":"<ph id=\"ph1\">\\[</ph><bpt id=\"p1\">**</bpt>forcePlaceholders<ept id=\"p1\">**</ept>","source":"\\[**forcePlaceholders**"},{"pos":[4167,4186],"content":"<bpt id=\"p1\">**</bpt>forceLiterals<ept id=\"p1\">**</ept><ph id=\"ph1\">\\]</ph>","source":"**forceLiterals**\\]"},{"pos":[4189,4209],"content":"<bpt id=\"p1\">**</bpt>forceselectorder<ept id=\"p1\">**</ept>","source":"**forceselectorder**"},{"pos":[4212,4231],"content":"<bpt id=\"p1\">**</bpt>forceNestedLoop<ept id=\"p1\">**</ept>","source":"**forceNestedLoop**"},{"pos":[4234,4252],"content":"<bpt id=\"p1\">**</bpt>repeatableRead<ept id=\"p1\">**</ept>","source":"**repeatableRead**"},{"pos":[4255,4273],"content":"<bpt id=\"p1\">**</bpt>validTimeState<ept id=\"p1\">**</ept>","source":"**validTimeState**"},{"pos":[4278,4289],"content":"<bpt id=\"p1\">*</bpt>FieldList<ept id=\"p1\">*</ept>","source":"*FieldList*"},{"pos":[4304,4336],"content":"<bpt id=\"p1\">*</bpt>Field<ept id=\"p1\">*</ept>  <bpt id=\"p2\">**</bpt>{ ,<ept id=\"p2\">**</ept>  <bpt id=\"p3\">*</bpt>Field<ept id=\"p3\">*</ept>  <bpt id=\"p4\">**</bpt>}<ept id=\"p4\">**</ept>","source":"*Field*  **{ ,**  *Field*  **}**"},{"pos":[4599,4606],"content":"<bpt id=\"p1\">*</bpt>Field<ept id=\"p1\">*</ept>","source":"*Field*"},{"pos":[4625,4667],"content":"<bpt id=\"p1\">*</bpt>Aggregate<ept id=\"p1\">*</ept>  <bpt id=\"p2\">**</bpt>(<ept id=\"p2\">**</ept>  <bpt id=\"p3\">*</bpt>FieldIdentifier<ept id=\"p3\">*</ept>  **)","source":"*Aggregate*  **(**  *FieldIdentifier*  **)"},{"pos":[4669,4690],"content":"<bpt id=\"p1\">*</bpt><bpt id=\"p2\">*</bpt>  <ept id=\"p2\">*</ept>FieldIdentifier<ept id=\"p1\">*</ept>","source":"**  *FieldIdentifier*"},{"pos":[4920,4931],"content":"<bpt id=\"p1\">*</bpt>Aggregate<ept id=\"p1\">*</ept>","source":"*Aggregate*"},{"pos":[4946,4953],"content":"<bpt id=\"p1\">**</bpt>sum<ept id=\"p1\">**</ept>","source":"**sum**"},{"pos":[4956,4963],"content":"<bpt id=\"p1\">**</bpt>avg<ept id=\"p1\">**</ept>","source":"**avg**"},{"pos":[4966,4975],"content":"<bpt id=\"p1\">**</bpt>minof<ept id=\"p1\">**</ept>","source":"**minof**"},{"pos":[4978,4987],"content":"<bpt id=\"p1\">**</bpt>maxof<ept id=\"p1\">**</ept>","source":"**maxof**"},{"pos":[4990,4999],"content":"<bpt id=\"p1\">**</bpt>count<ept id=\"p1\">**</ept>","source":"**count**"},{"pos":[5241,5250],"content":"<bpt id=\"p1\">*</bpt>Options<ept id=\"p1\">*</ept>","source":"*Options*"},{"pos":[5267,5330],"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\[</ph> order by<ept id=\"p1\">**</ept> , <bpt id=\"p2\">**</bpt>group by ,<ept id=\"p2\">**</ept>  <bpt id=\"p3\">*</bpt>FieldIdentifier<ept id=\"p3\">*</ept>  <bpt id=\"p4\">**</bpt><ph id=\"ph2\">\\[</ph> asc<ept id=\"p4\">**</ept>","source":"**\\[ order by** , **group by ,**  *FieldIdentifier*  **\\[ asc**"},{"pos":[5333,5379],"content":"<bpt id=\"p1\">**</bpt>desc <ph id=\"ph1\">\\]</ph> { ,<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>FieldIdentifier<ept id=\"p2\">*</ept>  <bpt id=\"p3\">**</bpt><ph id=\"ph2\">\\[</ph> asc<ept id=\"p3\">**</ept>","source":"**desc \\] { ,**  *FieldIdentifier*  **\\[ asc**"},{"pos":[5382,5397],"content":"<bpt id=\"p1\">**</bpt>desc <ph id=\"ph1\">\\]</ph> }<ph id=\"ph2\">\\]</ph><ept id=\"p1\">**</ept>","source":"**desc \\] }\\]**"},{"pos":[5400,5429],"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\[</ph><ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>IndexClause<ept id=\"p2\">*</ept>  <bpt id=\"p3\">**</bpt><ph id=\"ph2\">\\]</ph><ept id=\"p3\">**</ept>","source":"**\\[**  *IndexClause*  **\\]**"},{"pos":[5562,5575],"content":"<bpt id=\"p1\">*</bpt>IndexClause<ept id=\"p1\">*</ept>","source":"*IndexClause*"},{"pos":[5588,5610],"content":"<bpt id=\"p1\">**</bpt>index<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>IndexName<ept id=\"p2\">*</ept>","source":"**index**  *IndexName*"},{"pos":[5613,5640],"content":"<bpt id=\"p1\">**</bpt>index hint<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>IndexName<ept id=\"p2\">*</ept>","source":"**index hint**  *IndexName*"},{"pos":[5883,5896],"content":"<bpt id=\"p1\">*</bpt>WhereClause<ept id=\"p1\">*</ept>","source":"*WhereClause*"},{"pos":[5909,5932],"content":"<bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>Expression<ept id=\"p2\">*</ept>","source":"**where**  *Expression*"},{"pos":[6204,6216],"content":"<bpt id=\"p1\">*</bpt>JoinClause<ept id=\"p1\">*</ept>","source":"*JoinClause*"},{"pos":[6230,6242],"content":"<ph id=\"ph1\">\\[</ph><bpt id=\"p1\">**</bpt>exists<ept id=\"p1\">**</ept>","source":"\\[**exists**"},{"pos":[6245,6258],"content":"<bpt id=\"p1\">**</bpt>notexists<ept id=\"p1\">**</ept>","source":"**notexists**"},{"pos":[6261,6296],"content":"<bpt id=\"p1\">**</bpt>outer<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\]</ph> <bpt id=\"p2\">**</bpt>join<ept id=\"p2\">**</ept>  <bpt id=\"p3\">*</bpt>Parameters<ept id=\"p3\">*</ept>","source":"**outer** \\] **join**  *Parameters*"},{"pos":[6528,6565],"content":"Keywords used in the select statement","linkify":"Keywords used in the select statement","nodes":[{"content":"Keywords used in the select statement","pos":[0,37]}]},{"content":"Keyword","pos":[6569,6576]},{"content":"Description","pos":[6593,6604]},{"pos":[7967,7974],"content":"<bpt id=\"p1\">**</bpt>asc<ept id=\"p1\">**</ept>","source":"**asc**"},{"content":"An option on the <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>group by<ept id=\"p2\">**</ept> clause to specify an ascending sort.","pos":[7991,8073],"source":"An option on the **order by** or **group by** clause to specify an ascending sort."},{"content":"If neither asc or desc is specified, then the sort is ascending.","pos":[8074,8138]},{"pos":[8666,8673],"content":"<bpt id=\"p1\">**</bpt>avg<ept id=\"p1\">**</ept>","source":"**avg**"},{"content":"Returns the average of the fields.","pos":[8690,8724]},{"pos":[9365,9374],"content":"<bpt id=\"p1\">**</bpt>count<ept id=\"p1\">**</ept>","source":"**count**"},{"content":"Rreturns the number of records.","pos":[9389,9420]},{"pos":[10064,10080],"content":"<bpt id=\"p1\">**</bpt>crossCompany<ept id=\"p1\">**</ept>","source":"**crossCompany**"},{"content":"Returns data for all companies that the user is authorized to read from.","pos":[10088,10160]},{"content":"A <bpt id=\"p1\">**</bpt>container<ept id=\"p1\">**</ept> can be added to reduce the number of companies involved.","pos":[10161,10233],"source":" A **container** can be added to reduce the number of companies involved."},{"pos":[10763,10771],"content":"<bpt id=\"p1\">**</bpt>desc<ept id=\"p1\">**</ept>","source":"**desc**"},{"content":"An option on the <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>group by<ept id=\"p2\">**</ept> clause to specify a descending sort.","pos":[10787,10869],"source":"An option on the **order by** or **group by** clause to specify a descending sort."},{"content":"If neither asc or desc is specified, then the sort is ascending.","pos":[10870,10934]},{"pos":[11462,11472],"content":"<bpt id=\"p1\">**</bpt>exists<ept id=\"p1\">**</ept>","source":"**exists**"},{"pos":[11486,11546],"content":"A method that returns a Boolean value and a <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> clause.","source":"A method that returns a Boolean value and a **join** clause."},{"pos":[12161,12174],"content":"<bpt id=\"p1\">**</bpt>firstFast<ept id=\"p1\">**</ept>","source":"**firstFast**"},{"content":"A priority hint.","pos":[12185,12201]},{"content":"The first row appears more quickly but the total return time for this option might be slower.","pos":[12202,12295]},{"content":"The <bpt id=\"p1\">**</bpt>firstFast<ept id=\"p1\">**</ept> hint is automatically issued from all forms.","pos":[12296,12358],"source":" The **firstFast** hint is automatically issued from all forms."},{"pos":[12860,12873],"content":"<bpt id=\"p1\">**</bpt>firstOnly<ept id=\"p1\">**</ept>","source":"**firstOnly**"},{"content":"Speeds up the fetch by returning only the first row.","pos":[12884,12936]},{"pos":[13559,13574],"content":"<bpt id=\"p1\">**</bpt>firstOnly10<ept id=\"p1\">**</ept>","source":"**firstOnly10**"},{"pos":[13583,13648],"content":"The same as <bpt id=\"p1\">**</bpt>firstOnly<ept id=\"p1\">**</ept>, except returns 10 rows instead of one.","source":"The same as **firstOnly**, except returns 10 rows instead of one."},{"pos":[14258,14274],"content":"<bpt id=\"p1\">**</bpt>firstOnly100<ept id=\"p1\">**</ept>","source":"**firstOnly100**"},{"pos":[14282,14348],"content":"The same as <bpt id=\"p1\">**</bpt>firstOnly<ept id=\"p1\">**</ept>, except returns 100 rows instead of one.","source":"The same as **firstOnly**, except returns 100 rows instead of one."},{"pos":[14957,14974],"content":"<bpt id=\"p1\">**</bpt>firstOnly1000<ept id=\"p1\">**</ept>","source":"**firstOnly1000**"},{"pos":[14981,15048],"content":"The same as <bpt id=\"p1\">**</bpt>firstOnly<ept id=\"p1\">**</ept>, except returns 1000 rows instead of one.","source":"The same as **firstOnly**, except returns 1000 rows instead of one."},{"pos":[15656,15673],"content":"<bpt id=\"p1\">**</bpt>forceLiterals<ept id=\"p1\">**</ept>","source":"**forceLiterals**"},{"content":"Instructs the kernel to reveal the actual values that are used in <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clauses to the Microsoft SQL Server database at the time of optimization.","pos":[15680,15829],"source":"Instructs the kernel to reveal the actual values that are used in **where** clauses to the Microsoft SQL Server database at the time of optimization."},{"content":"<bpt id=\"p1\">**</bpt>forceLiterals<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>forcePlaceholders<ept id=\"p2\">**</ept> are mutually exclusive.","pos":[15830,15897],"source":"**forceLiterals** and **forcePlaceholders** are mutually exclusive."},{"content":"You should not to use the <bpt id=\"p1\">**</bpt>forceLiterals<ept id=\"p1\">**</ept> keyword in <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statements, because it could expose code to an SQL injection security threat.","pos":[15898,16041],"source":" You should not to use the **forceLiterals** keyword in **select** statements, because it could expose code to an SQL injection security threat."},{"pos":[16355,16374],"content":"<bpt id=\"p1\">**</bpt>forceNestedLoop<ept id=\"p1\">**</ept>","source":"**forceNestedLoop**"},{"content":"Forces the Microsoft SQL Server database to use a nested-loop algorithm to process a particular SQL statement containing a join algorithm.","pos":[16379,16517]},{"content":"This means that a record from the first table is fetched before any records from the second table are fetched.","pos":[16518,16628]},{"content":"Typically, other join algorithms, such as hash-joins and merge-joins, would be considered.","pos":[16629,16719]},{"content":"This keyword is often combined with the <bpt id=\"p1\">**</bpt>forceSelectOrder<ept id=\"p1\">**</ept> keyword.","pos":[16720,16789],"source":" This keyword is often combined with the **forceSelectOrder** keyword."},{"pos":[17054,17075],"content":"<bpt id=\"p1\">**</bpt>forcePlaceholders<ept id=\"p1\">**</ept>","source":"**forcePlaceholders**"},{"content":"Instructs the kernel not to reveal the actual values used in <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clauses to the SQL Server database at the time of optimization.","pos":[17078,17212],"source":"Instructs the kernel not to reveal the actual values used in **where** clauses to the SQL Server database at the time of optimization."},{"content":"This is the default in all statements that are not <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> statements.The advantage of using this keyword is that the kernel can reuse the access plan for other similar statements with other search values.","pos":[17213,17419],"source":" This is the default in all statements that are not **join** statements.The advantage of using this keyword is that the kernel can reuse the access plan for other similar statements with other search values."},{"content":"The disadvantage is that the access plan is computed without taking into consideration that data distribution might not be even.","pos":[17420,17548]},{"content":"The access plan is an on-average access plan.","pos":[17549,17594]},{"content":"<bpt id=\"p1\">**</bpt>forcePlaceholders<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>forceLiterals<ept id=\"p2\">**</ept> are mutually exclusive.","pos":[17595,17662],"source":"**forcePlaceholders** and **forceLiterals** are mutually exclusive."},{"pos":[17753,17773],"content":"<bpt id=\"p1\">**</bpt>forceSelectOrder<ept id=\"p1\">**</ept>","source":"**forceSelectOrder**"},{"content":"Forces the SQL Server database to access the tables in a join in the specified order.","pos":[17777,17862]},{"content":"If two tables are joined, the first table in the statement is always accessed first.","pos":[17863,17947]},{"content":"This keyword is often combined with <bpt id=\"p1\">**</bpt>forceNestedLoop.<ept id=\"p1\">**</ept>","pos":[17948,18004],"source":" This keyword is often combined with **forceNestedLoop.**"},{"pos":[18452,18465],"content":"<bpt id=\"p1\">**</bpt>forUpdate<ept id=\"p1\">**</ept>","source":"**forUpdate**"},{"content":"Selects records exclusively for update.","pos":[18476,18515]},{"content":"Depending on the underlying database, the records may be locked for other users.","pos":[18516,18596]},{"pos":[19151,19163],"content":"<bpt id=\"p1\">**</bpt>group by<ept id=\"p1\">**</ept>","source":"**group by**"},{"content":"Instructs the database to group selected records by fields.","pos":[19175,19234]},{"pos":[19850,19859],"content":"<bpt id=\"p1\">**</bpt>index<ept id=\"p1\">**</ept>","source":"**index**"},{"content":"Instructs the database to sort the selected records as defined by the index.","pos":[19874,19950]},{"pos":[20549,20563],"content":"<bpt id=\"p1\">**</bpt>index hint<ept id=\"p1\">**</ept>","source":"**index hint**"},{"content":"Gives the database a hint to use this index to sort the selected records as defined by the index.","pos":[20573,20670]},{"content":"The database can ignore the hint.","pos":[20671,20704]},{"content":"A wrong index hint can have a big performance impact.","pos":[20705,20758]},{"content":"Index hints should only be applied to SQL statements that do not have dynamic <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clauses or <bpt id=\"p2\">**</bpt>order by<ept id=\"p2\">**</ept> clauses, and where the effect of the hint can be verified.","pos":[20759,20929],"source":" Index hints should only be applied to SQL statements that do not have dynamic **where** clauses or **order by** clauses, and where the effect of the hint can be verified."},{"pos":[21248,21256],"content":"<bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept>","source":"**join**"},{"content":"Used to join tables on a column that is common to both tables.","pos":[21272,21334]},{"content":"The join criteria are specified in where clause because there is no <bpt id=\"p1\">**</bpt>on<ept id=\"p1\">**</ept>.","pos":[21335,21410],"source":" The join criteria are specified in where clause because there is no **on**."},{"content":"Reduces the number of SQL statements that are needed if you want to loop through a table and update transactions in a related table.","pos":[21411,21543]},{"content":"For example, if you process 500 records in a table, and want to update related records in another table, and use a nested <bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> to do this, there will be 501 trips to the database.","pos":[21544,21735],"source":" For example, if you process 500 records in a table, and want to update related records in another table, and use a nested **while select** to do this, there will be 501 trips to the database."},{"content":"If you use a <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept>, there will be a single trip to the database.","pos":[21736,21803],"source":" If you use a **join**, there will be a single trip to the database."},{"pos":[21947,21956],"content":"<bpt id=\"p1\">**</bpt>maxof<ept id=\"p1\">**</ept>","source":"**maxof**"},{"content":"Returns the maximum of the fields.","pos":[21971,22005]},{"pos":[22646,22655],"content":"<bpt id=\"p1\">**</bpt>minof<ept id=\"p1\">**</ept>","source":"**minof**"},{"content":"Returns the minimum of the fields.","pos":[22670,22704]},{"pos":[23345,23356],"content":"<bpt id=\"p1\">**</bpt>noFetch<ept id=\"p1\">**</ept>","source":"**noFetch**"},{"content":"Indicates that no records are to be fetched at present.","pos":[23369,23424]},{"content":"This is typically used when the result of the select is passed on to another application object, for example, a query that performs the actual fetch.","pos":[23425,23574]},{"pos":[24044,24057],"content":"<bpt id=\"p1\">**</bpt>notExists<ept id=\"p1\">**</ept>","source":"**notExists**"},{"content":"Is chosen only if there are no posts.","pos":[24068,24105]},{"pos":[24743,24761],"content":"<bpt id=\"p1\">**</bpt>optimisticLock<ept id=\"p1\">**</ept>","source":"**optimisticLock**"},{"content":"Forces a statement to run with optimistic concurrency control even if a different value is set on the table.","pos":[24767,24875]},{"pos":[25442,25454],"content":"<bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept>","source":"**order by**"},{"pos":[25466,25549],"content":"Instructs the database to sort the selected records by fields in <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> list.","source":"Instructs the database to sort the selected records by fields in **order by** list."},{"pos":[26141,26150],"content":"<bpt id=\"p1\">**</bpt>outer<ept id=\"p1\">**</ept>","source":"**outer**"},{"content":"Returns all rows from the first-named table, including rows that have no match in the second-named table.","pos":[26165,26270]},{"content":"This is a left outer join, although there is no <bpt id=\"p1\">**</bpt>left<ept id=\"p1\">**</ept>.","pos":[26271,26328],"source":" This is a left outer join, although there is no **left**."},{"content":"There is no right outer join.","pos":[26329,26358]},{"pos":[26840,26859],"content":"<bpt id=\"p1\">**</bpt>pessimisticLock<ept id=\"p1\">**</ept>","source":"**pessimisticLock**"},{"content":"Forces a statement to run with pessimistic concurrency control even if a different value is set on the table.","pos":[26864,26973]},{"pos":[27539,27557],"content":"<bpt id=\"p1\">**</bpt>repeatableRead<ept id=\"p1\">**</ept>","source":"**repeatableRead**"},{"content":"Specifies that no other transactions can modify data that has been read by logic inside the current transaction, until after the current transaction completes.","pos":[27563,27722]},{"content":"An explicit transaction completes at either <bpt id=\"p1\">**</bpt>ttsAbort<ept id=\"p1\">**</ept> or at the outermost <bpt id=\"p2\">**</bpt>ttsCommit<ept id=\"p2\">**</ept>.","pos":[27723,27814],"source":" An explicit transaction completes at either **ttsAbort** or at the outermost **ttsCommit**."},{"content":"For a stand-alone <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement, the transaction duration is the duration of <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> command.","pos":[27815,27918],"source":" For a stand-alone **select** statement, the transaction duration is the duration of **select** command."},{"content":"However, the database sometimes enforces the equivalent of <bpt id=\"p1\">**</bpt>repeatableRead<ept id=\"p1\">**</ept> in individual <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statements even without this keyword appearing in your code (depending on how the database decides to scan the tables).","pos":[27919,28141],"source":" However, the database sometimes enforces the equivalent of **repeatableRead** in individual **select** statements even without this keyword appearing in your code (depending on how the database decides to scan the tables)."},{"content":"For more information, see the documentation for the underlying relational database product.","pos":[28142,28233]},{"pos":[28238,28249],"content":"<bpt id=\"p1\">**</bpt>reverse<ept id=\"p1\">**</ept>","source":"**reverse**"},{"content":"Records are returned in reverse order.","pos":[28262,28300]},{"pos":[28937,28944],"content":"<bpt id=\"p1\">**</bpt>sum<ept id=\"p1\">**</ept>","source":"**sum**"},{"content":"Returns the sum of the fields.","pos":[28961,28991]},{"content":"Can be used to sum all accounts, order lines, and so on.","pos":[28992,29048]},{"pos":[29636,29654],"content":"<bpt id=\"p1\">**</bpt>validTimeState<ept id=\"p1\">**</ept>","source":"**validTimeState**"},{"pos":[29660,29771],"content":"Filters rows from a table that has its <bpt id=\"p1\">**</bpt>ValidTimeStateFieldType<ept id=\"p1\">**</ept> property set to a value other than <bpt id=\"p2\">**</bpt>None.<ept id=\"p2\">**</ept>","source":"Filters rows from a table that has its **ValidTimeStateFieldType** property set to a value other than **None.**"},{"pos":[30339,30360],"content":"Keyword code examples","linkify":"Keyword code examples","nodes":[{"content":"Keyword code examples","pos":[0,21]}]},{"pos":[36338,36363],"content":"select statement examples","linkify":"select statement examples","nodes":[{"content":"select statement examples","pos":[0,25]}]},{"pos":[36364,36440],"content":"The following examples demonstrate how you can use the <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement.","source":"The following examples demonstrate how you can use the **select** statement."},{"pos":[38707,38724],"content":"join code example","linkify":"join code example","nodes":[{"content":"join code example","pos":[0,17]}]},{"content":"This code example shows how an inner <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> can be performed as part of an SQL <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement.","pos":[38726,38828],"source":"This code example shows how an inner **join** can be performed as part of an SQL **select** statement."},{"content":"The example also shows an order by clause that has each field qualified by a table name.","pos":[38829,38917]},{"content":"This enables you to control how the retrieved records are sorted by using only one order by clause.","pos":[38918,39017]},{"pos":[40459,40493],"content":"group by and order by code example","linkify":"group by and order by code example","nodes":[{"content":"group by and order by code example","pos":[0,34]}]},{"content":"This code example shows that the fields in the <bpt id=\"p1\">**</bpt>group by<ept id=\"p1\">**</ept> clause can be qualified with a table name.","pos":[40495,40597],"source":"This code example shows that the fields in the **group by** clause can be qualified with a table name."},{"content":"There can be multiple <bpt id=\"p1\">**</bpt>group by<ept id=\"p1\">**</ept> clauses instead of just one.","pos":[40598,40661],"source":" There can be multiple **group by** clauses instead of just one."},{"content":"The fields can be qualified by table name in only one <bpt id=\"p1\">**</bpt>group by<ept id=\"p1\">**</ept> clause.","pos":[40662,40736],"source":" The fields can be qualified by table name in only one **group by** clause."},{"content":"Use of table name qualifiers is recommended.","pos":[40737,40781]},{"content":"The <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> clause follows the same syntax patterns that group by follows.","pos":[40782,40861],"source":" The **order by** clause follows the same syntax patterns that group by follows."},{"content":"If provided, both clauses must appear after the <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> (or <bpt id=\"p2\">**</bpt>from<ept id=\"p2\">**</ept>) clause, and both must appear before the <bpt id=\"p3\">**</bpt>where<ept id=\"p3\">**</ept> clause that might exist on the same <bpt id=\"p4\">**</bpt>join<ept id=\"p4\">**</ept>.","pos":[40862,41028],"source":" If provided, both clauses must appear after the **join** (or **from**) clause, and both must appear before the **where** clause that might exist on the same **join**."},{"content":"It is recommended that all group by and order by and <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clauses appear immediately after the last <bpt id=\"p2\">**</bpt>join<ept id=\"p2\">**</ept> clause.","pos":[41029,41150],"source":" It is recommended that all group by and order by and **where** clauses appear immediately after the last **join** clause."},{"pos":[42352,42387],"content":"select statement with an outer join","linkify":"select statement with an outer join","nodes":[{"content":"select statement with an outer join","pos":[0,35]}]},{"content":"The <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement supports filtering an <bpt id=\"p2\">**</bpt>outer join<ept id=\"p2\">**</ept> in the <bpt id=\"p3\">**</bpt>where<ept id=\"p3\">**</ept> clause.","pos":[42389,42475],"source":"The **select** statement supports filtering an **outer join** in the **where** clause."},{"content":"In the <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> clause of standard SQL there is an <bpt id=\"p2\">**</bpt>on<ept id=\"p2\">**</ept> keyword for filter criteria, but that isn't supported in X++.","pos":[42476,42595],"source":" In the **join** clause of standard SQL there is an **on** keyword for filter criteria, but that isn't supported in X++."},{"content":"An inner join rejects all table rows that fail to match a row in the other joined table.","pos":[42596,42684]},{"content":"But an outer join includes rows from the first table even though there is no matching row in the other joined table.","pos":[42685,42801]},{"content":"Default values are substituted for the data that could not be obtained from a matching row in the other joined table.","pos":[42802,42919]},{"content":"You can filter an outer join at the equivalent of an <bpt id=\"p1\">**</bpt>on<ept id=\"p1\">**</ept> clause that is part of the <bpt id=\"p2\">**</bpt>join<ept id=\"p2\">**</ept> clause.","pos":[42920,43023],"source":" You can filter an outer join at the equivalent of an **on** clause that is part of the **join** clause."},{"content":"For an inner join there is no behavioral difference between filtering on an <bpt id=\"p1\">**</bpt>on<ept id=\"p1\">**</ept> clause versus on the <bpt id=\"p2\">**</bpt>where<ept id=\"p2\">**</ept> clause.","pos":[43024,43145],"source":" For an inner join there is no behavioral difference between filtering on an **on** clause versus on the **where** clause."},{"pos":[43152,43181],"content":"select statement code example","linkify":"select statement code example","nodes":[{"content":"select statement code example","pos":[0,29]}]},{"content":"This code example is based on two tables.","pos":[43183,43224]},{"content":"The field types and example data are included.","pos":[43225,43271]},{"content":"There is a 1-to-many relationship between the <bpt id=\"p1\">**</bpt>SalesOrder<ept id=\"p1\">**</ept> parent table and the <bpt id=\"p2\">**</bpt>SalesOrderLine<ept id=\"p2\">**</ept> child table.","pos":[43272,43385],"source":" There is a 1-to-many relationship between the **SalesOrder** parent table and the **SalesOrderLine** child table."},{"content":"There are 0 or more rows in the <bpt id=\"p1\">**</bpt>SalesOrderLine<ept id=\"p1\">**</ept> table for each row in the <bpt id=\"p2\">**</bpt>SalesOrder<ept id=\"p2\">**</ept> table.","pos":[43386,43484],"source":" There are 0 or more rows in the **SalesOrderLine** table for each row in the **SalesOrder** table."},{"content":"There are two rows in the <bpt id=\"p1\">**</bpt>SalesOrder<ept id=\"p1\">**</ept> table.","pos":[43485,43532],"source":" There are two rows in the **SalesOrder** table."},{"pos":[43536,43575],"content":"<bpt id=\"p1\">**</bpt>SalesOrderID<ept id=\"p1\">**</ept> (integer, primary key)","source":"**SalesOrderID** (integer, primary key)"},{"pos":[43578,43598],"content":"<bpt id=\"p1\">**</bpt>DateAdded<ept id=\"p1\">**</ept> (date)","source":"**DateAdded** (date)"},{"content":"1","pos":[43670,43671]},{"content":"2010-01-01","pos":[43712,43722]},{"content":"2","pos":[43737,43738]},{"content":"2010-02-02","pos":[43779,43789]},{"content":"The <bpt id=\"p1\">**</bpt>SalesOrderLine<ept id=\"p1\">**</ept> table contains a foreign key field, named <bpt id=\"p2\">**</bpt>SalesOrderID<ept id=\"p2\">**</ept>, that references the primary key column of the <bpt id=\"p3\">**</bpt>SalesOrder<ept id=\"p3\">**</ept> table.","pos":[43803,43953],"source":"The **SalesOrderLine** table contains a foreign key field, named **SalesOrderID**, that references the primary key column of the **SalesOrder** table."},{"content":"The <bpt id=\"p1\">**</bpt>SalesOrderID<ept id=\"p1\">**</ept> value <bpt id=\"p2\">**</bpt>2<ept id=\"p2\">**</ept> does not occur in the data for <bpt id=\"p3\">**</bpt>SalesOrderLine<ept id=\"p3\">**</ept> table.","pos":[43954,44043],"source":" The **SalesOrderID** value **2** does not occur in the data for **SalesOrderLine** table."},{"pos":[44047,44089],"content":"<bpt id=\"p1\">**</bpt>SalesOrderLineID<ept id=\"p1\">**</ept> (string, primary key)","source":"**SalesOrderLineID** (string, primary key)"},{"pos":[44092,44114],"content":"<bpt id=\"p1\">**</bpt>Quantity<ept id=\"p1\">**</ept> (integer)","source":"**Quantity** (integer)"},{"pos":[44117,44156],"content":"<bpt id=\"p1\">**</bpt>SalesOrderID<ept id=\"p1\">**</ept> (integer, foreign key)","source":"**SalesOrderID** (integer, foreign key)"},{"content":"AA","pos":[44275,44277]},{"content":"32","pos":[44320,44322]},{"content":"1","pos":[44345,44346]},{"content":"BB","pos":[44389,44391]},{"content":"67","pos":[44434,44436]},{"content":"1","pos":[44459,44460]},{"content":"CC","pos":[44503,44505]},{"content":"66","pos":[44548,44550]},{"content":"1","pos":[44573,44574]},{"content":"The code example has a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement that reads the tables which are described in the previous section.","pos":[44616,44726],"source":"The code example has a **select** statement that reads the tables which are described in the previous section."},{"content":"The <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement includes a left <bpt id=\"p2\">**</bpt>outer join<ept id=\"p2\">**</ept> clause.","pos":[44727,44790],"source":" The **select** statement includes a left **outer join** clause."},{"content":"The join criteria and the data filter are both on the <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause.","pos":[44791,44862],"source":" The join criteria and the data filter are both on the **where** clause."},{"content":"The output from the code example is also in this section.","pos":[44863,44920]},{"content":"The second record in the output has a <bpt id=\"p1\">**</bpt>SalesOrderID<ept id=\"p1\">**</ept> value of 2.","pos":[44921,44987],"source":" The second record in the output has a **SalesOrderID** value of 2."},{"content":"That value of 2 is not present in the <bpt id=\"p1\">**</bpt>SalesOrderLine<ept id=\"p1\">**</ept> table.","pos":[44988,45051],"source":" That value of 2 is not present in the **SalesOrderLine** table."},{"content":"Therefore, some of the fields in the second record have default values, namely 0 for an integer and a zero length string for a string.","pos":[45052,45186]},{"pos":[46452,46475],"content":"while select statements","linkify":"while select statements","nodes":[{"content":"while select statements","pos":[0,23]}]},{"content":"<bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> statements are used to handle data.","pos":[46476,46528],"source":"**while select** statements are used to handle data."},{"content":"They are the most widely used form of the select statement.","pos":[46529,46588]},{"content":"<bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> loops over many records (meeting certain criteria) and can execute a statement on each record.","pos":[46589,46700],"source":"**while select** loops over many records (meeting certain criteria) and can execute a statement on each record."},{"content":"When you perform data manipulation by using the <bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> statement, you would typically do this in a transaction to ensure data integrity.","pos":[46701,46847],"source":" When you perform data manipulation by using the **while select** statement, you would typically do this in a transaction to ensure data integrity."},{"content":"The results of a <bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> statement are returned in a table buffer variable.","pos":[46848,46932],"source":" The results of a **while select** statement are returned in a table buffer variable."},{"content":"If you use a field list in the <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement, only those fields are available in the table variable.","pos":[46933,47040],"source":" If you use a field list in the **select** statement, only those fields are available in the table variable."},{"content":"If you use aggregate functions such as <bpt id=\"p1\">**</bpt>sum<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>count<ept id=\"p2\">**</ept>, the results are returned in the fields you perform the <bpt id=\"p3\">**</bpt>sum<ept id=\"p3\">**</ept> or <bpt id=\"p4\">**</bpt>count<ept id=\"p4\">**</ept> over.","pos":[47041,47183],"source":" If you use aggregate functions such as **sum** or **count**, the results are returned in the fields you perform the **sum** or **count** over."},{"content":"You can only count, average, or sum the integer and real fields.","pos":[47184,47248]},{"content":"The syntax of a <bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> statement resembles that of a <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement except that it is preceded by <bpt id=\"p3\">**</bpt>while select<ept id=\"p3\">**</ept> instead of <bpt id=\"p4\">**</bpt>select<ept id=\"p4\">**</ept>.","pos":[47249,47402],"source":" The syntax of a **while select** statement resembles that of a **select** statement except that it is preceded by **while select** instead of **select**."},{"content":"The <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement itself is executed only one time, immediately before the first iteration of the statements in the loop.","pos":[47403,47531],"source":" The **select** statement itself is executed only one time, immediately before the first iteration of the statements in the loop."},{"content":"Any Boolean expressions (such as <bpt id=\"p1\">**</bpt>iCounter <ph id=\"ph1\">&amp;lt;</ph> 1<ept id=\"p1\">**</ept>) added to the <bpt id=\"p2\">**</bpt>while select<ept id=\"p2\">**</ept> are tested only one time.","pos":[47532,47641],"source":" Any Boolean expressions (such as **iCounter &lt; 1**) added to the **while select** are tested only one time."},{"content":"This differs from how the <bpt id=\"p1\">**</bpt>while<ept id=\"p1\">**</ept> statement behaves in languages such as C++ and C<ph id=\"ph1\">\\#</ph>. For example, the following loop could iterate more than one time.","pos":[47642,47795],"source":" This differs from how the **while** statement behaves in languages such as C++ and C\\#. For example, the following loop could iterate more than one time."},{"pos":[48220,48245],"content":"while select code example","linkify":"while select code example","nodes":[{"content":"while select code example","pos":[0,25]}]},{"pos":[48247,48381],"content":"This prints the name reference and telephone number of customers in <bpt id=\"p1\">**</bpt>CustTable<ept id=\"p1\">**</ept> who have an account number within a specified range.","source":"This prints the name reference and telephone number of customers in **CustTable** who have an account number within a specified range."},{"pos":[49019,49044],"content":"while select Code Example","linkify":"while select Code Example","nodes":[{"content":"while select Code Example","pos":[0,25]}]},{"pos":[49046,49095],"content":"This code example uses the <bpt id=\"p1\">**</bpt>forUpdate<ept id=\"p1\">**</ept> keyword.","source":"This code example uses the **forUpdate** keyword."},{"pos":[49983,50008],"content":"Deleting a set of records","linkify":"Deleting a set of records","nodes":[{"content":"Deleting a set of records","pos":[0,25]}]},{"content":"You can use a <bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> statement to loop over a set of records that meet some criteria and perform an action on each record.","pos":[50010,50142],"source":"You can use a **while select** statement to loop over a set of records that meet some criteria and perform an action on each record."},{"content":"One such action is to <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> a set of records.","pos":[50143,50193],"source":" One such action is to **delete** a set of records."},{"content":"For example:","pos":[50194,50206]},{"pos":[50379,50446],"content":"You can achieve the same effect using the <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> keyword.","source":"You can achieve the same effect using the **delete\\_from** keyword."},{"pos":[50576,50603],"content":"select statements on fields","linkify":"select statements on fields","nodes":[{"content":"select statements on fields","pos":[0,27]}]},{"content":"You can use a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement in a lookup on a field.","pos":[50605,50663],"source":"You can use a **select** statement in a lookup on a field."},{"content":"Following a <bpt id=\"p1\">**</bpt>select statement<ept id=\"p1\">**</ept> that fetches a record in a table, you can write <bpt id=\"p2\">**</bpt>.fieldName<ept id=\"p2\">**</ept> to reference a field in the table.","pos":[50664,50794],"source":" Following a **select statement** that fetches a record in a table, you can write **.fieldName** to reference a field in the table."},{"content":"These <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statements must be used in expressions.","pos":[50795,50851],"source":" These **select** statements must be used in expressions."},{"content":"There is a difference between a <bpt id=\"p1\">**</bpt>normal<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement and a <bpt id=\"p3\">**</bpt>field select<ept id=\"p3\">**</ept> statement:","pos":[50852,50949],"source":" There is a difference between a **normal** **select** statement and a **field select** statement:"},{"pos":[50955,51015],"content":"The <bpt id=\"p1\">**</bpt>field select<ept id=\"p1\">**</ept> statement operates directly on a table.","source":"The **field select** statement operates directly on a table."},{"pos":[51020,51088],"content":"The <bpt id=\"p1\">**</bpt>normal select<ept id=\"p1\">**</ept> statement operates on a table buffer variable.","source":"The **normal select** statement operates on a table buffer variable."},{"pos":[51094,51119],"content":"select field code example","linkify":"select field code example","nodes":[{"content":"select field code example","pos":[0,25]}]},{"pos":[51549,51601],"content":"Aggregate functions: differences between X++ and SQL","linkify":"Aggregate functions: differences between X++ and SQL","nodes":[{"content":"Aggregate functions: differences between X++ and SQL","pos":[0,52]}]},{"content":"In industry standard SQL, a database query can contain <bpt id=\"p1\">**</bpt>aggregate functions<ept id=\"p1\">**</ept>.","pos":[51603,51682],"source":"In industry standard SQL, a database query can contain **aggregate functions**."},{"content":"Examples of such functions include <bpt id=\"p1\">**</bpt>count(RecID)<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>sum(columnA)<ept id=\"p2\">**</ept>.","pos":[51683,51756],"source":" Examples of such functions include **count(RecID)** and **sum(columnA)**."},{"content":"When an aggregate function is used but no rows match the <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause, a row must be returned to hold the result of the aggregates.","pos":[51757,51892],"source":" When an aggregate function is used but no rows match the **where** clause, a row must be returned to hold the result of the aggregates."},{"content":"The one returned row shows the value 0 (zero) for the <bpt id=\"p1\">**</bpt>count<ept id=\"p1\">**</ept> function, and shows <bpt id=\"p2\">**</bpt>null<ept id=\"p2\">**</ept> for the <bpt id=\"p3\">**</bpt>sum<ept id=\"p3\">**</ept> function.","pos":[51893,52011],"source":" The one returned row shows the value 0 (zero) for the **count** function, and shows **null** for the **sum** function."},{"content":"X++ does not support the concept of null values for the database.","pos":[52012,52077]},{"content":"Therefore, when the <bpt id=\"p1\">**</bpt>sum<ept id=\"p1\">**</ept> function would return null, no row is returned to the user.","pos":[52078,52165],"source":" Therefore, when the **sum** function would return null, no row is returned to the user."},{"content":"Also, each data type has a specific value that is treated like a null value in certain circumstances.","pos":[52166,52267]},{"pos":[52273,52321],"content":"index and order by keywords in select statements","linkify":"index and order by keywords in select statements","nodes":[{"content":"index and order by keywords in select statements","pos":[0,48]}]},{"content":"You use the <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> keyword in your <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statements to order the data that's returned.","pos":[52323,52420],"source":"You use the **order by** keyword in your **select** statements to order the data that's returned."},{"content":"Use the <bpt id=\"p1\">**</bpt>index<ept id=\"p1\">**</ept> hint keywords to specify that a particular index should be used in the query and to sort the selected records as defined by the index.","pos":[52421,52573],"source":" Use the **index** hint keywords to specify that a particular index should be used in the query and to sort the selected records as defined by the index."},{"content":"Indexes optimize the selection of records.","pos":[52574,52616]},{"content":"Combine the index hint keyword with an order by expression to select records in a specific order.","pos":[52617,52714]},{"content":"If you want the sorted output in reverse order, use the <bpt id=\"p1\">**</bpt>reverse<ept id=\"p1\">**</ept> keyword.","pos":[52715,52791],"source":" If you want the sorted output in reverse order, use the **reverse** keyword."},{"content":"If a table index has been disabled by setting the index's <bpt id=\"p1\">**</bpt>Enabled<ept id=\"p1\">**</ept> property to No, the <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement that references the index is still valid.","pos":[52792,52944],"source":" If a table index has been disabled by setting the index's **Enabled** property to No, the **select** statement that references the index is still valid."},{"content":"However, the database can't use the index as a hint for how to sort the data, because the index doesn't exist in the database.","pos":[52945,53071]},{"content":"The following table is an overview of how to use the index hint and order by keywords in <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statements.","pos":[53072,53183],"source":" The following table is an overview of how to use the index hint and order by keywords in **select** statements."},{"content":"Task","pos":[53187,53191]},{"content":"Use","pos":[53274,53277]},{"content":"Select records where the order isn't significant.","pos":[53497,53546]},{"content":"<bpt id=\"p1\">**</bpt>select ..<ept id=\"p1\">**</ept>","pos":[53584,53597],"source":"**select ..**"},{"content":"<bpt id=\"p1\">**</bpt>where ...<ept id=\"p1\">**</ept>","pos":[53598,53611],"source":"**where ...**"},{"content":"Select records where the order is significant.","pos":[53652,53698]},{"content":"<bpt id=\"p1\">**</bpt>select ..<ept id=\"p1\">**</ept>","pos":[53739,53752],"source":"**select ..**"},{"content":"<bpt id=\"p1\">**</bpt>order by ...<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>where ...<ept id=\"p2\">**</ept>","pos":[53753,53783],"source":"**order by ...** **where ...**"},{"content":"Select records and force a specific index to be used.","pos":[53807,53860]},{"content":"<bpt id=\"p1\">**</bpt>select ..<ept id=\"p1\">**</ept>","pos":[53894,53907],"source":"**select ..**"},{"content":"<bpt id=\"p1\">**</bpt>index hint ...<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>where ...<ept id=\"p2\">**</ept>","pos":[53908,53940],"source":"**index hint ...** **where ...**"},{"content":"Select records where the order is significant and force a specific index to be used.","pos":[53962,54046]},{"content":"<bpt id=\"p1\">**</bpt>select ..<ept id=\"p1\">**</ept>","pos":[54049,54062],"source":"**select ..**"},{"content":"<bpt id=\"p1\">**</bpt>index hint ...<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>order by ...<ept id=\"p2\">**</ept> <bpt id=\"p3\">**</bpt>where ...<ept id=\"p3\">**</ept>","pos":[54063,54112],"source":"**index hint ...** **order by ...** **where ...**"},{"pos":[54120,54151],"content":"index and order by code example","linkify":"index and order by code example","nodes":[{"content":"index and order by code example","pos":[0,31]}]},{"content":"To select the transactions from the salestable based on a range of customers and due dates, use the following code.","pos":[54153,54268]},{"pos":[54592,54602],"content":"index hint","linkify":"index hint","nodes":[{"content":"index hint","pos":[0,10]}]},{"pos":[54604,54721],"content":"To use <bpt id=\"p1\">**</bpt>index hint<ept id=\"p1\">**</ept> in queries you must first specify the use of hints on the server using the following procedure.","source":"To use **index hint** in queries you must first specify the use of hints on the server using the following procedure."},{"content":"Open Start <ph id=\"ph1\">&amp;gt;</ph> Administrative Tools <ph id=\"ph2\">&amp;gt;</ph> Microsoft Dynamics AX Server Configuration and select the Database Tuning tab.","pos":[54727,54847],"source":"Open Start &gt; Administrative Tools &gt; Microsoft Dynamics AX Server Configuration and select the Database Tuning tab."},{"content":"Select Allow INDEX hints in queries and click OK.","pos":[54852,54901]},{"content":"A message box prompting you to restart the AOS service appears.","pos":[54906,54969]},{"content":"Click Yes to restart the AOS service.","pos":[54970,55007]},{"content":"Index hints won't be enabled until the service is restarted.","pos":[55008,55068]},{"content":"When an <bpt id=\"p1\">**</bpt>index hint<ept id=\"p1\">**</ept> in a <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement refers to a non-clustered index and the <bpt id=\"p3\">**</bpt>where<ept id=\"p3\">**</ept> clause contains only the fields that are found in a clustered index on the same table, the clustered index is used instead of the index specified in the hint.","pos":[55070,55327],"source":"When an **index hint** in a **select** statement refers to a non-clustered index and the **where** clause contains only the fields that are found in a clustered index on the same table, the clustered index is used instead of the index specified in the hint."},{"content":"For example, if you run <bpt id=\"p1\">**</bpt>sp<ph id=\"ph1\">\\_</ph>helpindex InventTable<ept id=\"p1\">**</ept> in SQL Server Management Studio, you see that the <bpt id=\"p2\">**</bpt>InventTable<ept id=\"p2\">**</ept> has a clustered index on the <bpt id=\"p3\">**</bpt>DataAreaId<ept id=\"p3\">**</ept> and <bpt id=\"p4\">**</bpt>ItemId<ept id=\"p4\">**</ept> columns and a non-clustered index on the <bpt id=\"p5\">**</bpt>DataAreaId, ItemProductId,<ept id=\"p5\">**</ept> and <bpt id=\"p6\">**</bpt>ItemType<ept id=\"p6\">**</ept> columns.","pos":[55328,55604],"source":" For example, if you run **sp\\_helpindex InventTable** in SQL Server Management Studio, you see that the **InventTable** has a clustered index on the **DataAreaId** and **ItemId** columns and a non-clustered index on the **DataAreaId, ItemProductId,** and **ItemType** columns."},{"content":"Index name","pos":[55608,55618]},{"content":"Description","pos":[55627,55638]},{"content":"Key columns","pos":[55679,55690]},{"content":"I<ph id=\"ph1\">\\_</ph>175ITEMIDX","pos":[55830,55843],"source":"I\\_175ITEMIDX"},{"content":"Clustered, unique, primary key located on PRIMARY","pos":[55849,55898]},{"content":"DATAAREAID, ITEMID","pos":[55901,55919]},{"content":"I<ph id=\"ph1\">\\_</ph>175PRODUCTIDX","pos":[55941,55957],"source":"I\\_175PRODUCTIDX"},{"content":"Nonclustered located on PRIMARY","pos":[55960,55991]},{"content":"DATAAREAID, ITEMPRODUCTID, ITEMTYPE","pos":[56012,56047]},{"pos":[56051,56169],"content":"In the following code the clustered index will be used instead of the non-clustered index specified by <bpt id=\"p1\">**</bpt>index hint<ept id=\"p1\">**</ept>.","source":"In the following code the clustered index will be used instead of the non-clustered index specified by **index hint**."},{"pos":[56352,56393],"content":"Write a select statement as an expression","linkify":"Write a select statement as an expression","nodes":[{"content":"Write a select statement as an expression","pos":[0,41]}]},{"content":"You can use a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement as an expression.","pos":[56395,56447],"source":"You can use a **select** statement as an expression."},{"content":"This is called an <bpt id=\"p1\">**</bpt>expression select<ept id=\"p1\">**</ept>.","pos":[56448,56488],"source":" This is called an **expression select**."},{"content":"A table buffer variable cannot be used in an expression select statement.","pos":[56489,56562]},{"content":"The name of the table must be used in the <bpt id=\"p1\">**</bpt>from<ept id=\"p1\">**</ept> clause.","pos":[56563,56621],"source":" The name of the table must be used in the **from** clause."},{"content":"One limitation of expression selects is that the <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> keyword is not supported in an expression join.","pos":[56622,56727],"source":" One limitation of expression selects is that the **join** keyword is not supported in an expression join."},{"pos":[56733,56764],"content":"expression select code examples","linkify":"expression select code examples","nodes":[{"content":"expression select code examples","pos":[0,31]}]},{"content":"The <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement inside the parentheses returns one row.","pos":[56766,56830],"source":"The **select** statement inside the parentheses returns one row."},{"content":"The only column that can be populated with data is the column that is named in the <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> clause before the <bpt id=\"p2\">**</bpt>from<ept id=\"p2\">**</ept> clause.","pos":[56831,56959],"source":" The only column that can be populated with data is the column that is named in the **select** clause before the **from** clause."},{"content":"The name of that one column is used after the closing parenthesis to reference the data value: <bpt id=\"p1\">**</bpt>).AccountNum;<ept id=\"p1\">**</ept>.This test case returns a maximum of one row because it uses the <bpt id=\"p2\">**</bpt>firstonly<ept id=\"p2\">**</ept> keyword.","pos":[56960,57159],"source":" The name of that one column is used after the closing parenthesis to reference the data value: **).AccountNum;**.This test case returns a maximum of one row because it uses the **firstonly** keyword."},{"content":"However, the value that is assigned to <bpt id=\"p1\">**</bpt>sAccountNum<ept id=\"p1\">**</ept> is the same even if the <bpt id=\"p2\">**</bpt>firstonly<ept id=\"p2\">**</ept> keyword is omitted.The <bpt id=\"p3\">**</bpt>where<ept id=\"p3\">**</ept> clause in this example serves no purpose other than to show that the <bpt id=\"p4\">**</bpt>where<ept id=\"p4\">**</ept> clause must occur after the <bpt id=\"p5\">**</bpt>order by<ept id=\"p5\">**</ept> clause.","pos":[57160,57413],"source":" However, the value that is assigned to **sAccountNum** is the same even if the **firstonly** keyword is omitted.The **where** clause in this example serves no purpose other than to show that the **where** clause must occur after the **order by** clause."},{"content":"The table name cannot be used to qualify a field name in the <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> clause.","pos":[57414,57495],"source":" The table name cannot be used to qualify a field name in the **order by** clause."},{"content":"This is a simpler way to achieve the same result as the previous example.","pos":[57782,57855]},{"content":"/<ph id=\"ph1\">\\*</ph><ph id=\"ph2\">\\*</ph><ph id=\"ph3\">\\*</ph><ph id=\"ph4\">\\*</ph><ph id=\"ph5\">\\*</ph><ph id=\"ph6\">\\*</ph><ph id=\"ph7\">\\*</ph><ph id=\"ph8\">\\*</ph><ph id=\"ph9\">\\*</ph> Actual Infolog output Test<ph id=\"ph10\">\\_</ph>1.a: 4507Test<ph id=\"ph11\">\\_</ph>1.b: 4507 <ph id=\"ph12\">\\*</ph><ph id=\"ph13\">\\*</ph><ph id=\"ph14\">\\*</ph><ph id=\"ph15\">\\*</ph><ph id=\"ph16\">\\*</ph><ph id=\"ph17\">\\*</ph><ph id=\"ph18\">\\*</ph><ph id=\"ph19\">\\*</ph><ph id=\"ph20\">\\*</ph><ph id=\"ph21\">/</ph>","pos":[57856,57948],"source":" /\\*\\*\\*\\*\\*\\*\\*\\*\\* Actual Infolog output Test\\_1.a: 4507Test\\_1.b: 4507 \\*\\*\\*\\*\\*\\*\\*\\*\\*/"},{"content":"The following example includes a <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause.","pos":[58135,58185],"source":"The following example includes a **where** clause."},{"content":"In a <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause, the table name must be used as a qualifier of the field.Here the <bpt id=\"p2\">**</bpt>maxof<ept id=\"p2\">**</ept> aggregate function is used, and the field <bpt id=\"p3\">**</bpt>RecId<ept id=\"p3\">**</ept> is mentioned in the function.","pos":[58186,58365],"source":" In a **where** clause, the table name must be used as a qualifier of the field.Here the **maxof** aggregate function is used, and the field **RecId** is mentioned in the function."},{"content":"The field that is mentioned in the aggregate function must be the same field name that is used to reference the data value after the closing parenthesis.","pos":[58366,58519]},{"content":"Otherwise, empty data is returned.","pos":[58520,58554]},{"content":"The following example demonstrates that a field name, here <bpt id=\"p1\">**</bpt>RecId<ept id=\"p1\">**</ept>, is used to reference a data value that is not a <bpt id=\"p2\">**</bpt>RecId<ept id=\"p2\">**</ept>.","pos":[58856,58984],"source":"The following example demonstrates that a field name, here **RecId**, is used to reference a data value that is not a **RecId**."},{"content":"The <bpt id=\"p1\">**</bpt>count<ept id=\"p1\">**</ept> aggregate function does not return a <bpt id=\"p2\">**</bpt>RecId<ept id=\"p2\">**</ept> value.","pos":[58985,59052],"source":" The **count** aggregate function does not return a **RecId** value."},{"content":"The <bpt id=\"p1\">**</bpt>RecId<ept id=\"p1\">**</ept> field is ordinarily used with the <bpt id=\"p2\">**</bpt>count<ept id=\"p2\">**</ept> function.","pos":[59053,59120],"source":" The **RecId** field is ordinarily used with the **count** function."},{"content":"The <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> keyword is not supported in expression selects.","pos":[59414,59474],"source":"The **join** keyword is not supported in expression selects."},{"content":"The following example demonstrates a subselect.","pos":[59475,59522]},{"content":"But expression selects do not support subselects that are equivalent to a standard inner join.","pos":[59523,59617]},{"content":"For instance, the following code example does not compile.","pos":[59618,59676]},{"content":"The problem is that it mentions two tables inside one expression select, namely inside the subselect.","pos":[59677,59778]},{"content":"This code example shows that a subselect is supported, but only in a limited way.","pos":[59779,59860]},{"pos":[60404,60417],"content":"update method","linkify":"update method","nodes":[{"content":"update method","pos":[0,13]}]},{"content":"The <bpt id=\"p1\">**</bpt>update<ept id=\"p1\">**</ept> table method updates the current record with the contents of the buffer.","pos":[60418,60505],"source":"The **update** table method updates the current record with the contents of the buffer."},{"content":"It also updates the appropriate system fields.","pos":[60506,60552]},{"content":"The <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause is optional.","pos":[60553,60586],"source":" The **where** clause is optional."},{"content":"When used, the <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause specifies a condition for <bpt id=\"p2\">**</bpt>update<ept id=\"p2\">**</ept> to test while processing each row of the table.","pos":[60587,60703],"source":" When used, the **where** clause specifies a condition for **update** to test while processing each row of the table."},{"content":"Only those rows that test <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> against the condition are updated with the new values.","pos":[60704,60793],"source":" Only those rows that test **true** against the condition are updated with the new values."},{"content":"<bpt id=\"p1\">**</bpt>update<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> is a record-set based operator that updates multiple records at once.","pos":[60794,60885],"source":"**update\\_recordset** is a record-set based operator that updates multiple records at once."},{"content":"To override the behavior of <bpt id=\"p1\">**</bpt>update<ept id=\"p1\">**</ept>, use the doUpdate method.","pos":[60886,60950],"source":" To override the behavior of **update**, use the doUpdate method."},{"content":"The example selects the table <bpt id=\"p1\">**</bpt>custTable<ept id=\"p1\">**</ept> for update.","pos":[60951,61006],"source":" The example selects the table **custTable** for update."},{"content":"Any records with the AccountNum equal to 4000 are updated (in this case only one).","pos":[61007,61089]},{"content":"The <bpt id=\"p1\">**</bpt>CreditMax<ept id=\"p1\">**</ept> field is changed to 5000.","pos":[61090,61133],"source":" The **CreditMax** field is changed to 5000."},{"pos":[61357,61372],"content":"doUpdate method","linkify":"doUpdate method","nodes":[{"content":"doUpdate method","pos":[0,15]}]},{"content":"The <bpt id=\"p1\">**</bpt>doUpdate<ept id=\"p1\">**</ept> method updates the current record with the contents of the buffer.","pos":[61373,61456],"source":"The **doUpdate** method updates the current record with the contents of the buffer."},{"content":"This method also updates the appropriate system fields.","pos":[61457,61512]},{"content":"The <bpt id=\"p1\">**</bpt>doUpdate<ept id=\"p1\">**</ept> method should be used when the update method on the table is to be bypassed.","pos":[61513,61606],"source":" The **doUpdate** method should be used when the update method on the table is to be bypassed."},{"content":"The syntax for a <bpt id=\"p1\">**</bpt>doUpdate<ept id=\"p1\">**</ept> table method is <bpt id=\"p2\">**</bpt>void doUpdate()<ept id=\"p2\">**</ept> In the following example, <bpt id=\"p3\">**</bpt>CreditMax<ept id=\"p3\">**</ept> is increased by 1000.","pos":[61607,61734],"source":" The syntax for a **doUpdate** table method is **void doUpdate()** In the following example, **CreditMax** is increased by 1000."},{"pos":[62045,62058],"content":"delete method","linkify":"delete method","nodes":[{"content":"delete method","pos":[0,13]}]},{"content":"The <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> table method deletes the current record from the database.","pos":[62059,62132],"source":"The **delete** table method deletes the current record from the database."},{"content":"To use this method, specify which rows are to be deleted by using a <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause.","pos":[62133,62218],"source":" To use this method, specify which rows are to be deleted by using a **where** clause."},{"content":"Records are then removed, one at a time, from the specified table.","pos":[62219,62285]},{"content":"<bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> is a record-setbased operator, which simultaneously removes multiple records.","pos":[62286,62381],"source":"**delete\\_from** is a record-setbased operator, which simultaneously removes multiple records."},{"content":"The <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> method can be overridden, for example, to add extra validation before records are deleted.","pos":[62382,62487],"source":" The **delete** method can be overridden, for example, to add extra validation before records are deleted."},{"content":"If you override the <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> method, the original version of the <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> method can be executed instead by calling the <bpt id=\"p3\">**</bpt>doDelete<ept id=\"p3\">**</ept> method.","pos":[62488,62632],"source":" If you override the **delete** method, the original version of the **delete** method can be executed instead by calling the **doDelete** method."},{"content":"It is equivalent to calling <bpt id=\"p1\">**</bpt>super()<ept id=\"p1\">**</ept> in the <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> method; <bpt id=\"p3\">**</bpt>doDelete<ept id=\"p3\">**</ept> executes the base version of the <bpt id=\"p4\">**</bpt>delete<ept id=\"p4\">**</ept> method.","pos":[62633,62763],"source":" It is equivalent to calling **super()** in the **delete** method; **doDelete** executes the base version of the **delete** method."},{"content":"In the following example, all the records in the <bpt id=\"p1\">**</bpt>MyTable<ept id=\"p1\">**</ept> table that satisfy the <bpt id=\"p2\">**</bpt>where<ept id=\"p2\">**</ept> clause criterion (any record with an Account number equal to 1000) are deleted from the database.","pos":[62764,62955],"source":" In the following example, all the records in the **MyTable** table that satisfy the **where** clause criterion (any record with an Account number equal to 1000) are deleted from the database."},{"content":"These records are deleted one at a time.","pos":[62956,62996]},{"pos":[63147,63162],"content":"doDelete method","linkify":"doDelete method","nodes":[{"content":"doDelete method","pos":[0,15]}]},{"content":"The <bpt id=\"p1\">**</bpt>doDelete<ept id=\"p1\">**</ept> table method works similar to the <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> table method because it deletes the current record from the database.","pos":[63163,63294],"source":"The **doDelete** table method works similar to the **delete** table method because it deletes the current record from the database."},{"content":"Use the <bpt id=\"p1\">**</bpt>doDelete<ept id=\"p1\">**</ept> method if the delete table method has been overridden, and you want to use the original version of the <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> method.","pos":[63295,63437],"source":" Use the **doDelete** method if the delete table method has been overridden, and you want to use the original version of the **delete** method."},{"content":"The <bpt id=\"p1\">**</bpt>doDelete<ept id=\"p1\">**</ept> method executes the base version of the <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> method instead of the overridden version, which is equivalent to executing <bpt id=\"p3\">**</bpt>super() <ept id=\"p3\">**</ept>in the <bpt id=\"p4\">**</bpt>delete<ept id=\"p4\">**</ept> method.","pos":[63438,63618],"source":" The **doDelete** method executes the base version of the **delete** method instead of the overridden version, which is equivalent to executing **super() **in the **delete** method."},{"content":"This code example deletes all records in the myTable table that have an account number that is greater than or equal to 200.","pos":[63619,63743]},{"pos":[63895,63908],"content":"insert method","linkify":"insert method","nodes":[{"content":"insert method","pos":[0,13]}]},{"content":"The <bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept> method updates one record at a time.","pos":[63909,63960],"source":"The **insert** method updates one record at a time."},{"content":"To insert multiple records at a time, use array inserts, <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept>, or <bpt id=\"p2\">**</bpt>RecordSortedList.insertDatabase<ept id=\"p2\">**</ept>.","pos":[63961,64080],"source":" To insert multiple records at a time, use array inserts, **insert\\_recordset**, or **RecordSortedList.insertDatabase**."},{"content":"To override the behavior of the <bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept> method, use the <bpt id=\"p2\">**</bpt>doInsert<ept id=\"p2\">**</ept> method.","pos":[64081,64160],"source":" To override the behavior of the **insert** method, use the **doInsert** method."},{"content":"The <bpt id=\"p1\">**</bpt>xRecord .insert<ept id=\"p1\">**</ept> method generates values for <bpt id=\"p2\">**</bpt>RecId<ept id=\"p2\">**</ept> and system fields, and then inserts the contents of the buffer into the database.","pos":[64161,64304],"source":" The **xRecord .insert** method generates values for **RecId** and system fields, and then inserts the contents of the buffer into the database."},{"content":"The method operated as follows:","pos":[64305,64336]},{"content":"Only the specified columns of those rows selected by the query are inserted into the named table.","pos":[64342,64439]},{"content":"The columns of the table being copied from and those of the table being copied to must be type compatible.","pos":[64444,64550]},{"pos":[64555,64668],"content":"If the columns of both tables match in type and order, the column-list may be omitted from the <bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept> clause.","source":"If the columns of both tables match in type and order, the column-list may be omitted from the **insert** clause."},{"pos":[64674,64714],"content":"insert code example: insert a new record","linkify":"insert code example: insert a new record","nodes":[{"content":"insert code example: insert a new record","pos":[0,40]}]},{"pos":[64716,64907],"content":"The following code example inserts a new record into the <bpt id=\"p1\">**</bpt>CustTable<ept id=\"p1\">**</ept> table, with the <bpt id=\"p2\">**</bpt>AccountNum<ept id=\"p2\">**</ept> set to 5000 and the <bpt id=\"p3\">**</bpt>Name<ept id=\"p3\">**</ept> set to MyCompany (other fields in the record will be blank).","source":"The following code example inserts a new record into the **CustTable** table, with the **AccountNum** set to 5000 and the **Name** set to MyCompany (other fields in the record will be blank)."},{"pos":[65059,65109],"content":"insert code example: transaction and duplicate key","linkify":"insert code example: transaction and duplicate key","nodes":[{"content":"insert code example: transaction and duplicate key","pos":[0,50]}]},{"content":"The following example shows how you can catch a <bpt id=\"p1\">**</bpt>DuplicateKeyException<ept id=\"p1\">**</ept> in the context of an explicit transaction.","pos":[65111,65227],"source":"The following example shows how you can catch a **DuplicateKeyException** in the context of an explicit transaction."},{"content":"The exception is thrown when a call to <bpt id=\"p1\">**</bpt>xRecord .insert<ept id=\"p1\">**</ept> fails because of a duplication of an existing unique value.","pos":[65228,65346],"source":" The exception is thrown when a call to **xRecord .insert** fails because of a duplication of an existing unique value."},{"content":"In the catch block, your code can take corrective action, or it can log the error for later analysis.","pos":[65347,65448]},{"content":"Then your code can continue without losing all the pending work of the transaction.","pos":[65449,65532]},{"content":"You cannot catch a duplicate key exception caused by a set based operation such as <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept>.","pos":[65533,65638],"source":" You cannot catch a duplicate key exception caused by a set based operation such as **insert\\_recordset**."},{"content":"This example depends on two tables <bpt id=\"p1\">**</bpt>TableNumberA<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>TableNumberB<ept id=\"p2\">**</ept>.","pos":[65639,65712],"source":" This example depends on two tables **TableNumberA** and **TableNumberB**."},{"content":"Each has one mandatory Integer field, named <bpt id=\"p1\">**</bpt>NumberAKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>NumberBKey<ept id=\"p2\">**</ept> respectively.","pos":[65713,65804],"source":" Each has one mandatory Integer field, named **NumberAKey** and **NumberBKey** respectively."},{"content":"Each of these key fields has a unique indexed defined on it.","pos":[65805,65865]},{"content":"The <bpt id=\"p1\">**</bpt>TableNumberA<ept id=\"p1\">**</ept> table must have at least one record in it.","pos":[65866,65929],"source":" The **TableNumberA** table must have at least one record in it."},{"pos":[68236,68251],"content":"doInsert method","linkify":"doInsert method","nodes":[{"content":"doInsert method","pos":[0,15]}]},{"content":"The <bpt id=\"p1\">**</bpt>doInsert<ept id=\"p1\">**</ept> method generates values for the <bpt id=\"p2\">**</bpt>RecId<ept id=\"p2\">**</ept> field and other system fields, and then inserts the contents of the buffer into the database.","pos":[68252,68404],"source":"The **doInsert** method generates values for the **RecId** field and other system fields, and then inserts the contents of the buffer into the database."},{"content":"This operation is used when the insert method on the table is to be bypassed.","pos":[68405,68482]},{"content":"In the following example, a new record is inserted with the name <bpt id=\"p1\">**</bpt>Warren Langer<ept id=\"p1\">**</ept> in the name field and the value 100 in the value field.","pos":[68483,68621],"source":" In the following example, a new record is inserted with the name **Warren Langer** in the name field and the value 100 in the value field."},{"pos":[68741,68764],"content":"Transactional integrity","linkify":"Transactional integrity","nodes":[{"content":"Transactional integrity","pos":[0,23]}]},{"content":"If the <bpt id=\"p1\">**</bpt>integrity of transactions<ept id=\"p1\">**</ept> is not ensured, it may lead to data corruption, or, at best, poor scalability with reference to concurrent users on the system.","pos":[68765,68929],"source":"If the **integrity of transactions** is not ensured, it may lead to data corruption, or, at best, poor scalability with reference to concurrent users on the system."},{"content":"There are two internal checking features to help ensure the integrity of transactions: the <bpt id=\"p1\">**</bpt>forUpdate<ept id=\"p1\">**</ept> check and the <bpt id=\"p2\">**</bpt>tssLevel<ept id=\"p2\">**</ept> check.","pos":[68930,69068],"source":" There are two internal checking features to help ensure the integrity of transactions: the **forUpdate** check and the **tssLevel** check."},{"content":"A <bpt id=\"p1\">**</bpt>forUpdate check<ept id=\"p1\">**</ept> ensures that no record can be updated or deleted if the record has not first been selected for update.","pos":[69069,69193],"source":" A **forUpdate check** ensures that no record can be updated or deleted if the record has not first been selected for update."},{"content":"A record can be selected for update, either by using the <bpt id=\"p1\">**</bpt>forUpdate<ept id=\"p1\">**</ept> keyword in the <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement, or by using the <bpt id=\"p3\">**</bpt>selectForUpdate<ept id=\"p3\">**</ept> method on tables.","pos":[69194,69355],"source":" A record can be selected for update, either by using the **forUpdate** keyword in the **select** statement, or by using the **selectForUpdate** method on tables."},{"content":"A <bpt id=\"p1\">**</bpt>ttsLevel check<ept id=\"p1\">**</ept> ensures that no record can be updated or deleted except from within the same transaction scope as it was selected for update.","pos":[69356,69502],"source":" A **ttsLevel check** ensures that no record can be updated or deleted except from within the same transaction scope as it was selected for update."},{"content":"Integrity is ensured by using the following statements:","pos":[69503,69558]},{"content":"<bpt id=\"p1\">**</bpt>ttsBegin<ept id=\"p1\">**</ept>: marks the beginning of a transaction.","pos":[69564,69615],"source":"**ttsBegin**: marks the beginning of a transaction."},{"content":"This ensures data integrity, and guarantees that all updates performed until the transaction ends (by <bpt id=\"p1\">**</bpt>ttsCommit<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>ttsAbort<ept id=\"p2\">**</ept>) are consistent (all or none).","pos":[69616,69778],"source":" This ensures data integrity, and guarantees that all updates performed until the transaction ends (by **ttsCommit** or **ttsAbort**) are consistent (all or none)."},{"content":"<bpt id=\"p1\">**</bpt>ttsCommit<ept id=\"p1\">**</ept>: marks the successful end of a transaction.","pos":[69783,69840],"source":"**ttsCommit**: marks the successful end of a transaction."},{"content":"This ends and commits a transaction.","pos":[69841,69877]},{"content":"Dynamics 365 for Operations guarantees that a committed transaction will be performed according to intentions.","pos":[69878,69988]},{"content":"<bpt id=\"p1\">**</bpt>ttsAbort<ept id=\"p1\">**</ept>: allows you to explicitly discard all changes in the current transaction.","pos":[69993,70079],"source":"**ttsAbort**: allows you to explicitly discard all changes in the current transaction."},{"content":"As a result, the database is rolled back to the initial state where nothing will have been changed.","pos":[70080,70179]},{"content":"Typically, you will use this if you have detected that the user wants to break the current job.","pos":[70180,70275]},{"content":"Using <bpt id=\"p1\">**</bpt>ttsAbort<ept id=\"p1\">**</ept> ensures that the database is consistent.","pos":[70276,70335],"source":" Using **ttsAbort** ensures that the database is consistent."},{"content":"It is usually better to use exception handling instead of <bpt id=\"p1\">**</bpt>ttsAbort<ept id=\"p1\">**</ept>.","pos":[70337,70408],"source":"It is usually better to use exception handling instead of **ttsAbort**."},{"content":"The <bpt id=\"p1\">**</bpt>throw<ept id=\"p1\">**</ept> statement automatically aborts the current transaction.","pos":[70409,70478],"source":" The **throw** statement automatically aborts the current transaction."},{"content":"Statements between <bpt id=\"p1\">**</bpt>ttsBegin<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>ttsCommit<ept id=\"p2\">**</ept> may include one or more transaction blocks as shown in the following example.","pos":[70479,70606],"source":" Statements between **ttsBegin** and **ttsCommit** may include one or more transaction blocks as shown in the following example."},{"content":"In such cases, nothing is actually committed until the successful exit from the final <bpt id=\"p1\">**</bpt>ttsCommit<ept id=\"p1\">**</ept>.","pos":[70607,70707],"source":" In such cases, nothing is actually committed until the successful exit from the final **ttsCommit**."},{"pos":[70824,70907],"content":"The following example selects a set of records and updates the <bpt id=\"p1\">**</bpt>NameAlias<ept id=\"p1\">**</ept> field.","source":"The following example selects a set of records and updates the **NameAlias** field."},{"pos":[71103,71168],"content":"Examples of code rejected by the two transaction integrity checks","linkify":"Examples of code rejected by the two transaction integrity checks","nodes":[{"content":"Examples of code rejected by the two transaction integrity checks","pos":[0,65]}]},{"content":"In this example, the first failure is because the <bpt id=\"p1\">**</bpt>forupdate<ept id=\"p1\">**</ept> keyword is missing.","pos":[71170,71253],"source":"In this example, the first failure is because the **forupdate** keyword is missing."},{"content":"The second failure is because the update is in another transaction scope rather than the one that the record was selected in <bpt id=\"p1\">**</bpt>ttsCommit<ept id=\"p1\">**</ept> for update.","pos":[71254,71404],"source":" The second failure is because the update is in another transaction scope rather than the one that the record was selected in **ttsCommit** for update."},{"pos":[71735,71761],"content":"Speeding up SQL operations","linkify":"Speeding up SQL operations","nodes":[{"content":"Speeding up SQL operations","pos":[0,26]}]},{"content":"The following constructs allow you to insert, update, or delete multiple records.","pos":[71762,71843]},{"content":"Using these constructs reduces communication between the application and the database, and it increases performance.","pos":[71844,71960]},{"content":"In some situations, record-set operations can fall back to record-by-record operations.","pos":[71961,72048]},{"content":"Construct","pos":[72052,72061]},{"content":"Description","pos":[72076,72087]},{"pos":[72584,72604],"content":"<bpt id=\"p1\">**</bpt>RecordSortedList<ept id=\"p1\">**</ept>","source":"**RecordSortedList**"},{"content":"Allows you to insert multiple records in one database trip.","pos":[72608,72667]},{"content":"Use the <bpt id=\"p1\">**</bpt>RecordSortedList<ept id=\"p1\">**</ept> construct when you want a subset of data from a particular table, and when you want it sorted in an order that does not currently exist as an index.","pos":[72668,72845],"source":" Use the **RecordSortedList** construct when you want a subset of data from a particular table, and when you want it sorted in an order that does not currently exist as an index."},{"pos":[72850,72870],"content":"<bpt id=\"p1\">**</bpt>RecordInsertList<ept id=\"p1\">**</ept>","source":"**RecordInsertList**"},{"content":"Allows you to insert multiple records in one database trip.","pos":[72874,72933]},{"content":"Use the <bpt id=\"p1\">**</bpt>RecordInsertList<ept id=\"p1\">**</ept> construct when you do not need to sort the data.","pos":[72934,73011],"source":" Use the **RecordInsertList** construct when you do not need to sort the data."},{"pos":[73116,73137],"content":"<bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept>","source":"**insert\\_recordset**"},{"content":"Allows you to copy multiple records from one or more tables directly into another table on a single database trip.","pos":[73140,73254]},{"pos":[73382,73403],"content":"<bpt id=\"p1\">**</bpt>update<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept>","source":"**update\\_recordset**"},{"content":"Allows you to update multiple rows in a table on a single database trip.","pos":[73406,73478]},{"pos":[73648,73664],"content":"<bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept>","source":"**delete\\_from**"},{"content":"Allows you to delete multiple records from the database on a single database trip.","pos":[73672,73754]},{"pos":[73916,73933],"content":"insert\\_recordset","linkify":"insert\\_recordset","nodes":[{"content":"insert<ph id=\"ph1\">\\_</ph>recordset","pos":[0,17],"source":"insert\\_recordset"}]},{"content":"<bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> copies data from one or more tables directly into one resulting destination table on a single server trip.","pos":[73934,74062],"source":"**insert\\_recordset** copies data from one or more tables directly into one resulting destination table on a single server trip."},{"content":"Using <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> is faster than using an array insert.","pos":[74063,74128],"source":" Using **insert\\_recordset** is faster than using an array insert."},{"content":"However, array inserts are more flexible if you want to handle the data before you insert it.","pos":[74129,74222]},{"content":"<bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> is a record-set-based operator, which performs operations on multiple records at a time.","pos":[74223,74333],"source":"**insert\\_recordset** is a record-set-based operator, which performs operations on multiple records at a time."},{"content":"However, it can fall back to record-by-record operations in many situations.","pos":[74334,74410]},{"pos":[74416,74440],"content":"insert\\_recordset Syntax","linkify":"insert\\_recordset Syntax","nodes":[{"content":"insert<ph id=\"ph1\">\\_</ph>recordset Syntax","pos":[0,24],"source":"insert\\_recordset Syntax"}]},{"content":"The <bpt id=\"p1\">*</bpt>ListOfFields<ept id=\"p1\">*</ept> in the destination table must match the list of fields in the source tables.","pos":[74442,74537],"source":"The *ListOfFields* in the destination table must match the list of fields in the source tables."},{"content":"Data is transferred in the order that it appears in the list of fields.","pos":[74538,74609]},{"content":"Fields in the destination table that are not present in the list of fields are assigned zero-values as in other areas.","pos":[74610,74728]},{"content":"System fields, including <bpt id=\"p1\">**</bpt>RecId<ept id=\"p1\">**</ept>, are assigned transparently by the kernel in the destination table.","pos":[74729,74831],"source":" System fields, including **RecId**, are assigned transparently by the kernel in the destination table."},{"content":"<bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>DestinationTable<ept id=\"p2\">*</ept>  <bpt id=\"p3\">**</bpt>(<ept id=\"p3\">**</ept>  <bpt id=\"p4\">*</bpt>ListOfFields<ept id=\"p4\">*</ept>  <bpt id=\"p5\">**</bpt>)<ept id=\"p5\">**</ept> <bpt id=\"p6\">**</bpt>select<ept id=\"p6\">**</ept>  <bpt id=\"p7\">*</bpt>ListOfFields1<ept id=\"p7\">*</ept>  <bpt id=\"p8\">**</bpt>from<ept id=\"p8\">**</ept>  <bpt id=\"p9\">*</bpt>SourceTable<ept id=\"p9\">*</ept>  <bpt id=\"p10\">**</bpt><ph id=\"ph2\">\\[</ph> where<ept id=\"p10\">**</ept>  <bpt id=\"p11\">*</bpt>WhereClause<ept id=\"p11\">*</ept>  <bpt id=\"p12\">**</bpt><ph id=\"ph3\">\\]</ph><ept id=\"p12\">**</ept> <bpt id=\"p13\">**</bpt><ph id=\"ph4\">\\[</ph> join<ept id=\"p13\">**</ept>  <bpt id=\"p14\">*</bpt>ListOfFields2<ept id=\"p14\">*</ept>  <bpt id=\"p15\">**</bpt>from<ept id=\"p15\">**</ept>  <bpt id=\"p16\">*</bpt>JoinedSourceTable<ept id=\"p16\">*</ept> <bpt id=\"p17\">**</bpt><ph id=\"ph5\">\\[</ph> where<ept id=\"p17\">**</ept>  <bpt id=\"p18\">*</bpt>JoinedWhereClause<ept id=\"p18\">*</ept>  <bpt id=\"p19\">**</bpt><ph id=\"ph6\">\\]</ph><ph id=\"ph7\">\\]</ph><ept id=\"p19\">**</ept>","pos":[74832,75097],"source":"**insert\\_recordset**  *DestinationTable*  **(**  *ListOfFields*  **)** **select**  *ListOfFields1*  **from**  *SourceTable*  **\\[ where**  *WhereClause*  **\\]** **\\[ join**  *ListOfFields2*  **from**  *JoinedSourceTable* **\\[ where**  *JoinedWhereClause*  **\\]\\]**"},{"pos":[75103,75147],"content":"Code example: insert data from another table","linkify":"Code example: insert data from another table","nodes":[{"content":"Code example: insert data from another table","pos":[0,44]}]},{"content":"The records, <bpt id=\"p1\">**</bpt>myNum<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>mySum<ept id=\"p2\">**</ept>, are retrieved from the table <bpt id=\"p3\">**</bpt>anotherTable<ept id=\"p3\">**</ept> and inserted into the table <bpt id=\"p4\">**</bpt>myTable<ept id=\"p4\">**</ept>.","pos":[75149,75273],"source":"The records, **myNum** and **mySum**, are retrieved from the table **anotherTable** and inserted into the table **myTable**."},{"content":"The records are grouped according to <bpt id=\"p1\">**</bpt>myNum<ept id=\"p1\">**</ept>, and only the <bpt id=\"p2\">**</bpt>myNum<ept id=\"p2\">**</ept> records with a value less than or equal to 100 are included in the insertion.","pos":[75274,75422],"source":" The records are grouped according to **myNum**, and only the **myNum** records with a value less than or equal to 100 are included in the insertion."},{"pos":[75600,75640],"content":"Code example: insert data from variables","linkify":"Code example: insert data from variables","nodes":[{"content":"Code example: insert data from variables","pos":[0,40]}]},{"content":"This code example shows that the <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement can insert data that is provided in variables.","pos":[75642,75753],"source":"This code example shows that the **insert\\_recordset** statement can insert data that is provided in variables."},{"content":"In this example, the keyword <bpt id=\"p1\">**</bpt>firstonly<ept id=\"p1\">**</ept> is used so that only one row is inserted.","pos":[75754,75838],"source":" In this example, the keyword **firstonly** is used so that only one row is inserted."},{"content":"Literals, such as <bpt id=\"p1\">**</bpt>128<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>\"this literal string\"<ept id=\"p2\">**</ept>, cannot be used as a source of data to be inserted.","pos":[75839,75945],"source":" Literals, such as **128** or **\"this literal string\"**, cannot be used as a source of data to be inserted."},{"pos":[76557,76595],"content":"Code example: insert data using a join","linkify":"Code example: insert data using a join","nodes":[{"content":"Code example: insert data using a join","pos":[0,38]}]},{"content":"The following code example shows a <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> of three tables on an <bpt id=\"p2\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p2\">**</ept> statement that has a sub-<bpt id=\"p3\">**</bpt>select<ept id=\"p3\">**</ept>.","pos":[76597,76721],"source":"The following code example shows a **join** of three tables on an **insert\\_recordset** statement that has a sub-**select**."},{"content":"Also, a <bpt id=\"p1\">**</bpt>while<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement with a similar join is shown.","pos":[76722,76790],"source":" Also, a **while** **select** statement with a similar join is shown."},{"content":"A variable is used to supply the inserted value for one column.","pos":[76791,76854]},{"content":"The <bpt id=\"p1\">**</bpt>str<ept id=\"p1\">**</ept> variable must be declared with a length that is less than or equal to the maximum length of the corresponding database field.","pos":[76855,76992],"source":" The **str** variable must be declared with a length that is less than or equal to the maximum length of the corresponding database field."},{"content":"In this example, there is an <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement for <bpt id=\"p2\">**</bpt>tabEmplProj5<ept id=\"p2\">**</ept>.","pos":[76993,77075],"source":" In this example, there is an **insert\\_recordset** statement for **tabEmplProj5**."},{"content":"One of the target fields is named <bpt id=\"p1\">**</bpt>Description<ept id=\"p1\">**</ept>, and the field's data comes from the local variable <bpt id=\"p2\">**</bpt>sDescriptionVariable<ept id=\"p2\">**</ept>.","pos":[77076,77203],"source":" One of the target fields is named **Description**, and the field's data comes from the local variable **sDescriptionVariable**."},{"content":"When the configuration key for the <bpt id=\"p1\">**</bpt>Description<ept id=\"p1\">**</ept> field is turned off, the <bpt id=\"p2\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p2\">**</ept> still succeeds.","pos":[77204,77317],"source":" When the configuration key for the **Description** field is turned off, the **insert\\_recordset** still succeeds."},{"content":"The system ignores both the <bpt id=\"p1\">**</bpt>Description<ept id=\"p1\">**</ept> field and the variable <bpt id=\"p2\">**</bpt>sDescriptionVariable<ept id=\"p2\">**</ept>.","pos":[77318,77410],"source":" The system ignores both the **Description** field and the variable **sDescriptionVariable**."},{"content":"This is an example of <bpt id=\"p1\">**</bpt>configuration key automation<ept id=\"p1\">**</ept>.","pos":[77411,77466],"source":" This is an example of **configuration key automation**."},{"content":"Configuration key automation is when the system can automatically adjust the behavior of an <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement that inserts into fields that have their configuration key turned off.","pos":[77467,77661],"source":" Configuration key automation is when the system can automatically adjust the behavior of an **insert\\_recordset** statement that inserts into fields that have their configuration key turned off."},{"pos":[79413,79430],"content":"update\\_recordset","linkify":"update\\_recordset","nodes":[{"content":"update<ph id=\"ph1\">\\_</ph>recordset","pos":[0,17],"source":"update\\_recordset"}]},{"content":"The <bpt id=\"p1\">**</bpt>update<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement enables you to update multiple rows in a single trip to the server.","pos":[79431,79534],"source":"The **update\\_recordset** statement enables you to update multiple rows in a single trip to the server."},{"content":"This means that certain tasks may have improved performance by using the power of the SQL server.","pos":[79535,79632]},{"content":"****update<ph id=\"ph1\">\\_</ph>recordset**** resembles <bpt id=\"p1\">**</bpt>delete<ph id=\"ph2\">\\_</ph>from<ept id=\"p1\">**</ept> in X++ and <bpt id=\"p2\">**</bpt>update set<ept id=\"p2\">**</ept> in SQL.","pos":[79633,79719],"source":" ****update\\_recordset**** resembles **delete\\_from** in X++ and **update set** in SQL."},{"content":"It works on the database server-side on an SQL-style record-set, instead of retrieving each record separately by fetching, changing, and updating.","pos":[79720,79866]},{"content":"If the <bpt id=\"p1\">**</bpt>update<ept id=\"p1\">**</ept> method is overridden, the implementation falls back to a classic looping construction, updating records one by one just as <bpt id=\"p2\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p2\">**</ept> does for deletions.","pos":[79867,80044],"source":" If the **update** method is overridden, the implementation falls back to a classic looping construction, updating records one by one just as **delete\\_from** does for deletions."},{"content":"This also means that the construction works on temporary tables, and whole-table-cached tables by using the looping construction.","pos":[80045,80174]},{"pos":[80180,80228],"content":"Code example: update based on a calculated value","linkify":"Code example: update based on a calculated value","nodes":[{"content":"Code example: update based on a calculated value","pos":[0,48]}]},{"pos":[80230,80361],"content":"This example updates the table <bpt id=\"p1\">**</bpt>myTableBuffer<ept id=\"p1\">**</ept> and increments the value in <bpt id=\"p2\">**</bpt>field1<ept id=\"p2\">**</ept> by ten percent in all records in the table.","source":"This example updates the table **myTableBuffer** and increments the value in **field1** by ten percent in all records in the table."},{"pos":[80466,80507],"content":"Code example: update using a where clause","linkify":"Code example: update using a where clause","nodes":[{"content":"Code example: update using a where clause","pos":[0,41]}]},{"content":"This example updates the table <bpt id=\"p1\">**</bpt>myTable<ept id=\"p1\">**</ept> in all records where <bpt id=\"p2\">**</bpt>field1<ept id=\"p2\">**</ept> has the value 0.","pos":[80509,80600],"source":"This example updates the table **myTable** in all records where **field1** has the value 0."},{"content":"<bpt id=\"p1\">**</bpt>field1<ept id=\"p1\">**</ept> is assigned the new value 1; <bpt id=\"p2\">**</bpt>field2<ept id=\"p2\">**</ept> is assigned the value of the sum of <bpt id=\"p3\">**</bpt>fieldX<ept id=\"p3\">**</ept> and <bpt id=\"p4\">**</bpt>fieldY<ept id=\"p4\">**</ept>.","pos":[80601,80714],"source":"**field1** is assigned the new value 1; **field2** is assigned the value of the sum of **fieldX** and **fieldY**."},{"content":"This example updates multiple fields at the same time, and it updates only those rows that satisfy the <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause.","pos":[80715,80835],"source":" This example updates multiple fields at the same time, and it updates only those rows that satisfy the **where** clause."},{"pos":[80992,81028],"content":"Code example: updating joined tables","linkify":"Code example: updating joined tables","nodes":[{"content":"Code example: updating joined tables","pos":[0,36]}]},{"content":"This example shows that the <bpt id=\"p1\">**</bpt>update<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement supports the joining of several tables.","pos":[81030,81129],"source":"This example shows that the **update\\_recordset** statement supports the joining of several tables."},{"content":"Data from the joined tables can be used to assign values to fields in the table that is being updated.","pos":[81130,81232]},{"pos":[81781,81793],"content":"delete\\_from","linkify":"delete\\_from","nodes":[{"content":"delete<ph id=\"ph1\">\\_</ph>from","pos":[0,12],"source":"delete\\_from"}]},{"content":"You can delete multiple records from a database table by using a <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> statement.","pos":[81794,81886],"source":"You can delete multiple records from a database table by using a **delete\\_from** statement."},{"content":"This can be more efficient and faster than deleting one record at a time by using the <bpt id=\"p1\">**</bpt>xRecord .delete<ept id=\"p1\">**</ept> method in a loop.","pos":[81887,82010],"source":" This can be more efficient and faster than deleting one record at a time by using the **xRecord .delete** method in a loop."},{"content":"If you have overridden the delete method, the system interprets the <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> statement into code that calls the <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> method one time for each row that is deleted.","pos":[82011,82187],"source":" If you have overridden the delete method, the system interprets the **delete\\_from** statement into code that calls the **delete** method one time for each row that is deleted."},{"pos":[82193,82252],"content":"Code example: efficiently delete records using delete\\_from","linkify":"Code example: efficiently delete records using delete\\_from","nodes":[{"content":"Code example: efficiently delete records using delete<ph id=\"ph1\">\\_</ph>from","pos":[0,59],"source":"Code example: efficiently delete records using delete\\_from"}]},{"content":"The following code example is an efficient way to delete multiple records.","pos":[82254,82328]},{"pos":[82514,82572],"content":"Code example: inefficiently delete records using forUpdate","linkify":"Code example: inefficiently delete records using forUpdate","nodes":[{"content":"Code example: inefficiently delete records using forUpdate","pos":[0,58]}]},{"content":"The following code example is inefficient.","pos":[82574,82616]},{"content":"It issues a separate SQL delete call to the database server for each record.","pos":[82617,82693]},{"content":"The <bpt id=\"p1\">**</bpt>xRecord<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>.delete<ept id=\"p2\">**</ept> method never deletes more than one record per call.","pos":[82694,82773],"source":" The **xRecord** **.delete** method never deletes more than one record per call."},{"pos":[83103,83142],"content":"Code example: delete with an inner join","linkify":"Code example: delete with an inner join","nodes":[{"content":"Code example: delete with an inner join","pos":[0,39]}]},{"content":"Inner joins are not supported on the <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> statement.","pos":[83144,83208],"source":"Inner joins are not supported on the **delete\\_from** statement."},{"content":"Therefore you cannot use the unmodified <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> keyword on the <bpt id=\"p2\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p2\">**</ept> statement.","pos":[83209,83300],"source":" Therefore you cannot use the unmodified **join** keyword on the **delete\\_from** statement."},{"content":"However, there are other ways to logically accomplish an inner join.","pos":[83301,83369]},{"content":"This example shows the new and old techniques for achieving inner join logic through a sequence of statements.","pos":[83370,83480]},{"pos":[84890,84938],"content":"Code example: delete with notexists join keyword","linkify":"Code example: delete with notexists join keyword","nodes":[{"content":"Code example: delete with notexists join keyword","pos":[0,48]}]},{"content":"You can use the <bpt id=\"p1\">**</bpt>notexists join<ept id=\"p1\">**</ept> keyword pair in a <bpt id=\"p2\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p2\">**</ept> statement.","pos":[84940,85020],"source":"You can use the **notexists join** keyword pair in a **delete\\_from** statement."},{"content":"The <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> statements in the following code example are efficient.","pos":[85021,85097],"source":" The **delete\\_from** statements in the following code example are efficient."},{"content":"The <bpt id=\"p1\">**</bpt>notexists join<ept id=\"p1\">**</ept> clause enables the <bpt id=\"p2\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p2\">**</ept> statement to delete a specific set of rows.","pos":[85098,85200],"source":" The **notexists join** clause enables the **delete\\_from** statement to delete a specific set of rows."},{"content":"In this example the <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> statement removes all the parent order header rows for which there are no child order line rows.","pos":[85201,85334],"source":" In this example the **delete\\_from** statement removes all the parent order header rows for which there are no child order line rows."},{"content":"You can also use the <bpt id=\"p1\">**</bpt>exists join<ept id=\"p1\">**</ept> clause on the <bpt id=\"p2\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p2\">**</ept> statement.","pos":[85335,85413],"source":" You can also use the **exists join** clause on the **delete\\_from** statement."},{"pos":[88808,88836],"content":"Maintain fast SQL operations","linkify":"Maintain fast SQL operations","nodes":[{"content":"Maintain fast SQL operations","pos":[0,28]}]},{"content":"There are situations where record-set operations can be converted to slower record-by-record operations.","pos":[88837,88941]},{"content":"The following table identifies these situations.","pos":[88942,88990]},{"content":"DELETE<ph id=\"ph1\">\\_</ph>FROM","pos":[89058,89070],"source":"DELETE\\_FROM"},{"content":"UPDATE<ph id=\"ph1\">\\_</ph>RECORDSET","pos":[89073,89090],"source":"UPDATE\\_RECORDSET"},{"content":"INSERT<ph id=\"ph1\">\\_</ph>RECORDSET","pos":[89093,89110],"source":"INSERT\\_RECORDSET"},{"content":"ARRAY<ph id=\"ph1\">\\_</ph>INSERT","pos":[89113,89126],"source":"ARRAY\\_INSERT"},{"content":"Use ... to override","pos":[89129,89148]},{"content":"Non-SQL tables","pos":[89316,89330]},{"content":"Yes","pos":[89380,89383]},{"content":"Yes","pos":[89395,89398]},{"content":"Yes","pos":[89415,89418]},{"content":"Yes","pos":[89435,89438]},{"content":"Not applicable","pos":[89451,89465]},{"content":"Delete actions","pos":[89477,89491]},{"content":"Yes","pos":[89541,89544]},{"content":"No","pos":[89556,89558]},{"content":"No","pos":[89576,89578]},{"content":"No","pos":[89596,89598]},{"pos":[89612,89633],"content":"<bpt id=\"p1\">**</bpt>skipDeleteActions<ept id=\"p1\">**</ept>","source":"**skipDeleteActions**"},{"content":"Database log enabled","pos":[89638,89658]},{"content":"Yes","pos":[89702,89705]},{"content":"Yes","pos":[89717,89720]},{"content":"Yes","pos":[89737,89740]},{"content":"No","pos":[89757,89759]},{"pos":[89773,89792],"content":"<bpt id=\"p1\">**</bpt>skipDatabaseLog<ept id=\"p1\">**</ept>","source":"**skipDatabaseLog**"},{"content":"Overridden method","pos":[89799,89816]},{"content":"Yes","pos":[89863,89866]},{"content":"Yes","pos":[89878,89881]},{"content":"Yes","pos":[89898,89901]},{"content":"Yes","pos":[89918,89921]},{"pos":[89934,89953],"content":"<bpt id=\"p1\">**</bpt>skipDataMethods<ept id=\"p1\">**</ept>","source":"**skipDataMethods**"},{"content":"Alerts set up for table","pos":[89960,89983]},{"content":"Yes","pos":[90024,90027]},{"content":"Yes","pos":[90039,90042]},{"content":"Yes","pos":[90059,90062]},{"content":"No","pos":[90079,90081]},{"pos":[90095,90109],"content":"<bpt id=\"p1\">**</bpt>skipEvents<ept id=\"p1\">**</ept>","source":"**skipEvents**"},{"content":"ValidTimeStateFieldType property not equal to None on a table","pos":[90121,90182]},{"content":"Yes","pos":[90185,90188]},{"content":"Yes","pos":[90200,90203]},{"content":"Yes","pos":[90220,90223]},{"content":"Yes","pos":[90240,90243]},{"content":"Not applicable","pos":[90256,90270]},{"content":"You may explicitly skip or ignore one or more things that would adversely impact performance by using the items shown in the far right column.","pos":[90281,90423]},{"content":"If for some reason one of the previously mentioned SQL operations is downgraded to a record-by-record operation, all of the <bpt id=\"p1\">**</bpt>skip<ept id=\"p1\">**</ept>","pos":[90424,90557],"source":" If for some reason one of the previously mentioned SQL operations is downgraded to a record-by-record operation, all of the **skip**"},{"content":"settings are also ignored.","pos":[90558,90584]},{"content":"For example, the <bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept> method on <bpt id=\"p2\">**</bpt>myTable<ept id=\"p2\">**</ept> is executed in the following example even though it is explicitly stated that this method should be skipped if <bpt id=\"p3\">**</bpt>myTable<ept id=\"p3\">**</ept> has a container or memo field defined.","pos":[90585,90796],"source":" For example, the **insert** method on **myTable** is executed in the following example even though it is explicitly stated that this method should be skipped if **myTable** has a container or memo field defined."}],"content":"---\n# required metadata\n\ntitle: X++ data selection and manipulation | Microsoft Docs\ndescription: This topic describes the X++ language support for data selection and manipulation.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 2016-08-27 00:35:54\nms.topic: article\nms.prod: \nms.service: Dynamics365Operations\nms.technology: \n\n# optional metadata\n\n# keywords: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: 61\nms.suite: Released- Dynamics AX 7.0.0\n# ms.tgt_pltfrm: \nms.custom: 150273\nms.assetid: c6c42cb9-5390-4099-ad42-aa7c6895c48e\nms.region: Global\n# ms.industry: \nms.author: robinr\n\n---\n\n# X++ data selection and manipulation\n\nThis topic describes the X++ language support for data selection and manipulation.\n\nYou can use SQL statements either interactively or within source code, to access and retrieve data that is stored in the database. You use the following statements for data manipulation:\n\n-   **select:** selects the data that you want to modify.\n-   **insert:** adds one or more new records into a table.\n-   **update:** modifies data in existing table records.\n-   **delete:** removes existing records from a table.\n\nBefore any data can be changed, you must select the data for update for update by using a **select** statement. The **select forUpdate** command selects records exclusively for update. The **insert**, **update**, and **delete** methods perform operations on only one record at a time. The **array insert**, **insert\\_recordset**, **RecordInsertList,** and **update\\_recordset** statements perform operations on multiple records at a time.\n\n## select statement\nThe **select** statement fetches or manipulates data from the database. All **select** statements use a table variable to fetch records. This variable must be declared before a **select** statement can be executed. The **select** statement only fetches one record, or field. To fetch additional records, you can use the **next** statement. The **next** statement fetches the next record in the table. If you use **next** without a preceding **select** command, an error occurs. Do not use **next** with the **firstOnly** find option. If you need to traverse a number of records, it is more appropriate to use a **while** **select** statement. The results of a **select** statement are returned in a table buffer variable. If you use a field list in the **select** statement, only those fields are available in the table variable. If you use aggregate functions, such as **sum** or **count**, the results are returned in the fields that you perform the **sum** or **count** over. You can only count, average, or sum the integer and real fields.\n\n## select statement syntax\n|                   |     |                                                                                                                                                                                                                                                                                                    |\n|-------------------|-----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| *SelectStatement* | =   | **select** *Parameters*                                                                                                                                                                                                                                                                            |\n| *Parameters*      |     | **\\[ \\[**  *FindOptions*  **\\]** **\\[**  *FieldList*  **from \\] \\]** *TableBufferVariable* **\\[** *IndexClause* **\\]** **\\[**  *Options*  **\\]** **\\[**  *WhereClause*  **\\]** **\\[**  *JoinClause*  **\\]**                                                                                        |\n| *FindOptions*     | =   | **crossCompany** | **reverse** | **firstFast** | \\[ **firstOnly** | **firstOnly10** | **firstOnly100** | **firstOnly1000** \\] | **forUpdate** | **noFetch** | \\[**forcePlaceholders** | **forceLiterals**\\] | **forceselectorder** | **forceNestedLoop** | **repeatableRead** | **validTimeState** |\n| *FieldList*       | =   | *Field*  **{ ,**  *Field*  **}** | **\\***                                                                                                                                                                                                                                                          |\n| *Field*           | =   | *Aggregate*  **(**  *FieldIdentifier*  **) |**  *FieldIdentifier*                                                                                                                                                                                                                                  |\n| *Aggregate*       | =   | **sum** | **avg** | **minof** | **maxof** | **count**                                                                                                                                                                                                                                              |\n| *Options*         | =   | **\\[ order by** , **group by ,**  *FieldIdentifier*  **\\[ asc** | **desc \\] { ,**  *FieldIdentifier*  **\\[ asc** | **desc \\] }\\]** | **\\[**  *IndexClause*  **\\]**                                                                                                                                 |\n| *IndexClause*     | =   | **index**  *IndexName* | **index hint**  *IndexName*                                                                                                                                                                                                                                               |\n| *WhereClause*     | =   | **where**  *Expression*                                                                                                                                                                                                                                                                            |\n| *JoinClause*      | =   | \\[**exists** | **notexists** | **outer** \\] **join**  *Parameters*                                                                                                                                                                                                                                 |\n\n### Keywords used in the select statement\n\n| Keyword               | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n|-----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **asc**               | An option on the **order by** or **group by** clause to specify an ascending sort. If neither asc or desc is specified, then the sort is ascending.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n| **avg**               | Returns the average of the fields.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| **count**             | Rreturns the number of records.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n| **crossCompany**      | Returns data for all companies that the user is authorized to read from. A **container** can be added to reduce the number of companies involved.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| **desc**              | An option on the **order by** or **group by** clause to specify a descending sort. If neither asc or desc is specified, then the sort is ascending.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n| **exists**            | A method that returns a Boolean value and a **join** clause.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| **firstFast**         | A priority hint. The first row appears more quickly but the total return time for this option might be slower. The **firstFast** hint is automatically issued from all forms.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| **firstOnly**         | Speeds up the fetch by returning only the first row.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\n| **firstOnly10**       | The same as **firstOnly**, except returns 10 rows instead of one.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| **firstOnly100**      | The same as **firstOnly**, except returns 100 rows instead of one.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| **firstOnly1000**     | The same as **firstOnly**, except returns 1000 rows instead of one.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n| **forceLiterals**     | Instructs the kernel to reveal the actual values that are used in **where** clauses to the Microsoft SQL Server database at the time of optimization. **forceLiterals** and **forcePlaceholders** are mutually exclusive. You should not to use the **forceLiterals** keyword in **select** statements, because it could expose code to an SQL injection security threat.                                                                                                                                                                                                                                                                                                                      |\n| **forceNestedLoop**   | Forces the Microsoft SQL Server database to use a nested-loop algorithm to process a particular SQL statement containing a join algorithm. This means that a record from the first table is fetched before any records from the second table are fetched. Typically, other join algorithms, such as hash-joins and merge-joins, would be considered. This keyword is often combined with the **forceSelectOrder** keyword.                                                                                                                                                                                                                                                                     |\n| **forcePlaceholders** | Instructs the kernel not to reveal the actual values used in **where** clauses to the SQL Server database at the time of optimization. This is the default in all statements that are not **join** statements.The advantage of using this keyword is that the kernel can reuse the access plan for other similar statements with other search values. The disadvantage is that the access plan is computed without taking into consideration that data distribution might not be even. The access plan is an on-average access plan. **forcePlaceholders** and **forceLiterals** are mutually exclusive.                                                                                       |\n| **forceSelectOrder**  | Forces the SQL Server database to access the tables in a join in the specified order. If two tables are joined, the first table in the statement is always accessed first. This keyword is often combined with **forceNestedLoop.**                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n| **forUpdate**         | Selects records exclusively for update. Depending on the underlying database, the records may be locked for other users.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| **group by**          | Instructs the database to group selected records by fields.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| **index**             | Instructs the database to sort the selected records as defined by the index.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| **index hint**        | Gives the database a hint to use this index to sort the selected records as defined by the index. The database can ignore the hint. A wrong index hint can have a big performance impact. Index hints should only be applied to SQL statements that do not have dynamic **where** clauses or **order by** clauses, and where the effect of the hint can be verified.                                                                                                                                                                                                                                                                                                                           |\n| **join**              | Used to join tables on a column that is common to both tables. The join criteria are specified in where clause because there is no **on**. Reduces the number of SQL statements that are needed if you want to loop through a table and update transactions in a related table. For example, if you process 500 records in a table, and want to update related records in another table, and use a nested **while select** to do this, there will be 501 trips to the database. If you use a **join**, there will be a single trip to the database.                                                                                                                                            |\n| **maxof**             | Returns the maximum of the fields.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| **minof**             | Returns the minimum of the fields.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| **noFetch**           | Indicates that no records are to be fetched at present. This is typically used when the result of the select is passed on to another application object, for example, a query that performs the actual fetch.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| **notExists**         | Is chosen only if there are no posts.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| **optimisticLock**    | Forces a statement to run with optimistic concurrency control even if a different value is set on the table.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| **order by**          | Instructs the database to sort the selected records by fields in **order by** list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n| **outer**             | Returns all rows from the first-named table, including rows that have no match in the second-named table. This is a left outer join, although there is no **left**. There is no right outer join.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| **pessimisticLock**   | Forces a statement to run with pessimistic concurrency control even if a different value is set on the table.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| **repeatableRead**    | Specifies that no other transactions can modify data that has been read by logic inside the current transaction, until after the current transaction completes. An explicit transaction completes at either **ttsAbort** or at the outermost **ttsCommit**. For a stand-alone **select** statement, the transaction duration is the duration of **select** command. However, the database sometimes enforces the equivalent of **repeatableRead** in individual **select** statements even without this keyword appearing in your code (depending on how the database decides to scan the tables). For more information, see the documentation for the underlying relational database product. |\n| **reverse**           | Records are returned in reverse order.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| **sum**               | Returns the sum of the fields. Can be used to sum all accounts, order lines, and so on.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n| **validTimeState**    | Filters rows from a table that has its **ValidTimeStateFieldType** property set to a value other than **None.**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n\n#### Keyword code examples\n\n    // asc keyword example.\n    select * from custTable\n         order by Name asc;\n     \n    // avg keyword example. \n    CustTable custTable;;\n    select avg(value) from custTable;\n    print custTable.value;\n     \n    // count keyword example. \n    CustTable xCT;int64 iCountRows; ;\n    Select COUNT(RecID) from xCT;\n    iCountRows = xCT.RecID;\n     \n    // crossCompany keyword example.\n    CustTable custTable;\n    container conCompanies = ['dat','dmo'];\n    select crossCompany :conCompanies\n        * from custTable;\n     \n    // desc keyword example.\n    select * from custTable     \n        order by Name desc;\n     \n    // exists keyword example. \n    while select AccountNum, Name from custTable    \n        order by AccountNum\n        exists join * from ctr\n        where (ctr.AccountNum ==\n          custTable.AccountNum)\n     \n    // firstFast keyword example. \n    select firstFast custTable     \n        order by AccountNum;\n     \n    // firstOnly keyword example. \n    static InventTable find(ItemIditemId, boolean update = false)\n    {\n        InventTable inventTable;\n     \n        inventTable.selectForUpdate(update);\n        if (itemId)\n        {\n            select firstonly inventTable\n                index hint ItemIdx\n                where inventTable.itemId == itemId;\n        }\n        return inventTable;\n    }\n     \n    // forceNestedLoop keyword example. \n    while select forceSelectOrder    \n        forceNestedLoop inventTransThis\n    index hint TransIdIdx\n    where inventTransThis.InventTransId\n            == inventTrans.InventTransId\n            && inventTransThis.StatusIssue\n            <= StatusIssue::ReservOrdered \n     \n    // forcePlaceholders keyword example. \n    static void forcePlaceHoldersExample(Args _args){\n        SalesTable salesTable;\n        SalesLine salesLine;\n     \n        while select forcePlaceholders salesLine\n            join salesTable\n               where salesTable.SalesId ==\n                salesLine.SalesId\n                   && salesTable.SalesId == '10'\n        {\n            //more code\n        }\n    }\n     \n    // forceSelectOrder keyword example. \n    display ForecastHasPurch hasForecastPurch(){\n        ForecastPurch forecastPurch;\n        InventDim nventDim;\n     \n    select firstOnly forcePlaceholders\n        forceSelectOrder recId\n        from forecastPurch\n        index hint ItemIdx\n        where forecastPurch.itemId == this.itemId\n    exists join inventDim\n        index hint DimIdIdx\n        where inventDim.inventDimId == forecastPurch.inventDimId\n            && inventDim.configId == this.configId;\n        return forecastPurch.recId;\n    }\n     \n    // forUpdate keyword example. \n    ttsBegin; while select forUpdate ledgerJournalTrans\n        index hint NumVoucherIdx\n        where ledgerJournalTrans.journalNum ==\n        _journalNum &&\n        ledgerJournalTrans.voucher == _voucher\n    {\n        ledgerJournalTrans.doDelete();\n        counter++;\n    }\n    if (counter\n        && ledgerJournalTable.journalType\n        != LedgerJournalType::Periodic)\n    {\n        NumberSeq::release(\n          ledgerJournalTable.voucherSeries,\n          _voucher);\n    }\n    ttsCommit;\n    // group by keyword example. \n        CustTable custTable;;\n    while select sum(CreditMax) from custTable\n        group by CustGroup\n    {\n        print custTable.CustGroup, \" \",custTable.CreditMax;\n    }\n     \n    // index keyword example. \n        CustTable custTable;;\n    while select AccountNum, Name from custTable\n        index AccountIdx\n    {\n        print custTable.AccountNum, \" \", custTable.Name;\n    }\n     \n    // index hint keyword example. \n    while select forUpdate ledgerJournalTrans    \n        index hint NumVoucherIdx\n        where ledgerJournalTrans.journalNum\n            == _journalNum\n     \n    // join keyword example. \n    while select ledgerTable    join ledgerTrans\n        where ledgerTrans.accountNum == ledgerTable.accountNum\n    {\n        amountMST += ledgerTrans.amountMST;\n    }\n     \n    // maxof keyword example. \n    CustTable custTable;;\n    select maxof(CreditMax) from custTable;\n     \n    // minof keyword example. \n    CustTable custTable;;\n    select minof(CreditMax) from custTable;\n     \n    // noFetch keyword example. \n    select noFetch custTable\n        order by AccountNum\n     \n    // notExists keyword example. \n    while select AccountNum, Name from custTable    \n        order by AccountNum\n        notExists join * from ctr\n        where (ctr.AccountNum ==\n            custTable.AccountNum)\n\n    // optimisticLock keyword example. \n    select optimisticLock custTable    \n        where custTable.AccountNum > '1000'\n     \n    // order by keyword example. \n    select * from custTable     \n        order by accountNum desc\n        where custTable.AccountNum > \"100\";\n     \n    // outer keyword example. \n    while select AccountNum\n        from custTable\n        order by AccountNum\n        outer join * from custBankAccount\n        where custBankAccount.AccountNum ==\n            custTable.AccountNum\n        {\n            print custTable.AccountNum,\n            \" , \", custBankAccount.DlvMode;\n        } \n     \n    // pessimisticLock keyword example. \n    select pessimisticLock custTable\n        where custTable.AccountNum > '1000';\n     \n    // reverse keyword example. \n    select reverse custTable\n        order by AccountNum;\n     \n    // sum keyword example. \n    CustTable custTable;;\n    select sum(CreditMax) from custTable;\n     \n    // validTimeState keyword example. \n    static void VtsJob1(Args _args)\n    {\n        // A validTimeState table. \n        CustPackingSlipTransHistory xrec1;\n        utcDateTime myDateFrom , myDateTo;\n        anytype myAnytype = -1;\n        myDateFrom = DateTimeUtil::utcNow();\n        myDateTo = myDateFrom;\n        SELECT \n            validTimeState(myDateFrom, myDateTo)\n                *\n            FROM xrec1;\n        myAnytype = xrec1.getFieldValue(\"RecId\");\n        info(myAnytype);\n    }\n\n## select statement examples\nThe following examples demonstrate how you can use the **select** statement.\n\n    CustTable custTable;  \n    // A customer is found and returned in custTable\n    select * from custTable;\n    info(\"A: \" + custTable.AccountNum);\n     \n    // A customer with account number > \"100\" is found\n    select * from custTable\n        where custTable.AccountNum > \"100\";\n    info(\"B: \" + custTable.AccountNum);\n     \n    // Customer with the lowest account number > \"100\" found:\n    select * \n        from custTable \n        order by accountNum\n        where custTable.AccountNum > \"100\";\n    info(\"C1: \" + custTable.AccountNum);\n     \n    // The next customer is read\n    next custTable;\n    info(\"C2: \" + custTable.AccountNum);\n     \n    // Customer with higest account number\n    // (greater than 100) found: Fourth Coffee\n    select * \n        from custTable \n        order by accountNum desc\n        where custTable.accountNum > \"100\";\n    info(\"D1: \" + custTable.AccountNum);\n     \n    // The next record is read (DESC): Fabrikam, Inc.\n    next custTable; \n    info(\"D2: \" + custTable.AccountNum);\n     \n    // Customer with highest account number found: Fourth Coffee\n    select reverse custTable \n        order by accountNum;\n    info(\"E: \" + custTable.AccountNum);\n     \n    // Customer with \"lowest\" name and account number\n    // in the interval 100 to 1000 is found. This is Coho Winery.\n    select * \n        from custTable \n        order by DlvMode\n        where custTable.accountNum > \"100\"\n            && custTable.accountNum < \"1000\";\n    info(\"F: \" + custTable.AccountNum);\n     \n    // The count select returns the number of customers.\n    select count(AccountNum) \n        from custTable;\n     \n    // Prints the result of the count\n    info(strFmt(\"G: %1 = Count of AccountNums\", custTable.accountNum));\n     \n    // Returns the average credit max for non-blocked customers.\n    select avg(CreditMax) \n        from custTable\n        where custTable.blocked == CustVendorBlocked::No;\n     \n    // Prints the result of the avg\n    info(strFmt(\"H: %1 = Average CreditMax\", custTable.CreditMax));\n     \n    /*** Display from infolog:\n    Message (02:00:34 pm)\n    A: 4000\n    B: 4000\n    C1: 4000\n    C2: 4001\n    D1: 4507\n    D2: 4506\n    E: 4507\n    F: \n    G: 29 = Count of AccountNums\n    H: 103.45 = Average CreditMax\n    ***/\n\n### join code example\n\nThis code example shows how an inner **join** can be performed as part of an SQL **select** statement. The example also shows an order by clause that has each field qualified by a table name. This enables you to control how the retrieved records are sorted by using only one order by clause.\n\n    CustTable xrecCustTable;\n    CashDisc xrecCashDisc;\n    struct sut4;\n    sut4 = new struct(\"str AccountNum; str CashDisc; str Description\");\n    while select firstOnly10 *\n        from xrecCustTable\n        order by xrecCashDisc.Description\n        join xrecCashDisc\n        where xrecCustTable.CashDisc ==\n            xrecCashDisc.CashDiscCode\n            && xrecCashDisc.Description LIKE \"*Days*\"\n        {\n            sut4.value(\"AccountNum\", xrecCustTable.AccountNum );\n            sut4.value(\"CashDisc\", xrecCashDisc.CashDiscCode );\n            sut4.value(\"Description\", xrecCashDisc.Description );\n            info(sut4.toString());\n        }\n\n    /*********  Actual Infolog output\n    Message (02:29:37 pm)\n    (AccountNum:\"1101\"; CashDisc:\"0.5%D10\"; Description:\"0.5% 10 days\")\n    (AccountNum:\"4001\"; CashDisc:\"0.5%D10\"; Description:\"0.5% 10 days\")\n    (AccountNum:\"1102\"; CashDisc:\"0.5%D30\"; Description:\"0.5% 30 days\")\n    (AccountNum:\"1201\"; CashDisc:\"0.5%D30\"; Description:\"0.5% 30 days\")\n    (AccountNum:\"2211\"; CashDisc:\"0.5%D30\"; Description:\"0.5% 30 days\")\n    (AccountNum:\"1202\"; CashDisc:\"1%D15\"; Description:\"1% 15 days\")\n    (AccountNum:\"1203\"; CashDisc:\"1%D07\"; Description:\"1% 7 days\")\n    (AccountNum:\"2212\"; CashDisc:\"1%D07\"; Description:\"1% 7 days\")\n    (AccountNum:\"2213\"; CashDisc:\"1%D07\"; Description:\"1% 7 days\")\n    (AccountNum:\"2214\"; CashDisc:\"1%D07\"; Description:\"1% 7 days\")\n    *********/\n    }\n\n### group by and order by code example\n\nThis code example shows that the fields in the **group by** clause can be qualified with a table name. There can be multiple **group by** clauses instead of just one. The fields can be qualified by table name in only one **group by** clause. Use of table name qualifiers is recommended. The **order by** clause follows the same syntax patterns that group by follows. If provided, both clauses must appear after the **join** (or **from**) clause, and both must appear before the **where** clause that might exist on the same **join**. It is recommended that all group by and order by and **where** clauses appear immediately after the last **join** clause.\n\n    CustTable xrecCustTable;\n    CashDisc xrecCashDisc;\n    struct sut4;\n    sut4 = new struct(\"str AccountNum_Count; str CashDisc; str Description\");\n    while select count(AccountNum)\n        from xrecCustTable\n        order by xrecCashDisc.Description\n        join xrecCashDisc\n            group by xrecCashDisc.CashDiscCode\n                where xrecCustTable.CashDisc ==\n                    xrecCashDisc.CashDiscCode\n                    && xrecCashDisc.Description LIKE \"*Days*\"\n        {\n            sut4.value(\"AccountNum_Count\", xrecCustTable.AccountNum );\n            sut4.value(\"CashDisc\", xrecCashDisc.CashDiscCode );\n            sut4.value(\"Description\", xrecCashDisc.Description );\n            info(sut4.toString());\n        }\n    /*********  Actual Infolog output\n    Message (02:45:26 pm)\n    (AccountNum_Count:\"2\"; CashDisc:\"0.5%D10\"; Description:\"\")\n    (AccountNum_Count:\"3\"; CashDisc:\"0.5%D30\"; Description:\"\")\n    (AccountNum_Count:\"4\"; CashDisc:\"1%D07\"; Description:\"\")\n    (AccountNum_Count:\"1\"; CashDisc:\"1%D15\"; Description:\"\")\n    (AccountNum_Count:\"1\"; CashDisc:\"2%D30\"; Description:\"\")\n    (AccountNum_Count:\"1\"; CashDisc:\"3%D10\"; Description:\"\")\n    *********/\n    }\n\n### select statement with an outer join\n\nThe **select** statement supports filtering an **outer join** in the **where** clause. In the **join** clause of standard SQL there is an **on** keyword for filter criteria, but that isn't supported in X++. An inner join rejects all table rows that fail to match a row in the other joined table. But an outer join includes rows from the first table even though there is no matching row in the other joined table. Default values are substituted for the data that could not be obtained from a matching row in the other joined table. You can filter an outer join at the equivalent of an **on** clause that is part of the **join** clause. For an inner join there is no behavioral difference between filtering on an **on** clause versus on the **where** clause.\n\n#### select statement code example\n\nThis code example is based on two tables. The field types and example data are included. There is a 1-to-many relationship between the **SalesOrder** parent table and the **SalesOrderLine** child table. There are 0 or more rows in the **SalesOrderLine** table for each row in the **SalesOrder** table. There are two rows in the **SalesOrder** table.\n\n| **SalesOrderID** (integer, primary key) | **DateAdded** (date) |\n|-----------------------------------------|----------------------|\n| 1                                       | 2010-01-01           |\n| 2                                       | 2010-02-02           |\n\nThe **SalesOrderLine** table contains a foreign key field, named **SalesOrderID**, that references the primary key column of the **SalesOrder** table. The **SalesOrderID** value **2** does not occur in the data for **SalesOrderLine** table.\n\n| **SalesOrderLineID** (string, primary key) | **Quantity** (integer) | **SalesOrderID** (integer, foreign key) |\n|--------------------------------------------|------------------------|-----------------------------------------|\n| AA                                         | 32                     | 1                                       |\n| BB                                         | 67                     | 1                                       |\n| CC                                         | 66                     | 1                                       |\n\nThe code example has a **select** statement that reads the tables which are described in the previous section. The **select** statement includes a left **outer join** clause. The join criteria and the data filter are both on the **where** clause. The output from the code example is also in this section. The second record in the output has a **SalesOrderID** value of 2. That value of 2 is not present in the **SalesOrderLine** table. Therefore, some of the fields in the second record have default values, namely 0 for an integer and a zero length string for a string.\n\n    static void SelectOuterJoinExample(Args _args)\n    {\n        SalesOrder recSalesOrder;\n        SalesOrderLine recSalesOrderLine;\n        struct struct4;\n     \n        struct4 = new struct\n            (\"int SalesOrderID;\"\n            + \"date DateAdded;\"\n            + \"str SalesOrderLineID;\"\n            + \"int Quantity\"\n            );\n        while\n        select\n                *\n            from\n                recSalesOrder\n                OUTER JOIN recSalesOrderLine\n            where\n                recSalesOrder.SalesOrderID == recSalesOrderLine.SalesOrderID\n                && recSalesOrderLine.Quantity == 66\n        {\n            struct4.value(\"SalesOrderID\", recSalesOrder.SalesOrderID);\n            struct4.value(\"DateAdded\", recSalesOrder.DateAdded);\n            struct4.value(\"SalesOrderLineID\", recSalesOrderLine.SalesOrderLineID);\n            struct4.value(\"Quantity\", recSalesOrderLine.Quantity);\n            info(struct4.toString());\n        }\n    }\n    /*********  Actual Infolog output (with break spaces entered in between each output)\n    (SalesOrderID:1; \n    DateAdded:2010/1/1; \n    SalesOrderLineID:\"CC\"; \n    Quantity:66)\n    (SalesOrderID:2; \n    DateAdded:2010/2/2; \n    SalesOrderLineID:\"\"; \n    Quantity:0)\n    *********/\n\n## while select statements\n**while select** statements are used to handle data. They are the most widely used form of the select statement. **while select** loops over many records (meeting certain criteria) and can execute a statement on each record. When you perform data manipulation by using the **while select** statement, you would typically do this in a transaction to ensure data integrity. The results of a **while select** statement are returned in a table buffer variable. If you use a field list in the **select** statement, only those fields are available in the table variable. If you use aggregate functions such as **sum** or **count**, the results are returned in the fields you perform the **sum** or **count** over. You can only count, average, or sum the integer and real fields. The syntax of a **while select** statement resembles that of a **select** statement except that it is preceded by **while select** instead of **select**. The **select** statement itself is executed only one time, immediately before the first iteration of the statements in the loop. Any Boolean expressions (such as **iCounter &lt; 1**) added to the **while select** are tested only one time. This differs from how the **while** statement behaves in languages such as C++ and C\\#. For example, the following loop could iterate more than one time.\n\n    static void JobWhileSelect(Args _args)\n    {\n        int iCounter = 0;\n        BankAccountTable xrecBAT;\n        while select * from xrecBAT\n            where iCounter < 1\n        {\n            iCounter++;\n            Global::info(strFmt(\"%1 , %2\", iCounter, xrecBAT.AccountID));\n        }\n    }\n     \n    /*** Display from infolog:\n    Message (04:59:38 pm)\n    1 , Cash1\n    2 , STB-DKK\n    3 , STB-EUR\n    ***/\n\n### while select code example\n\nThis prints the name reference and telephone number of customers in **CustTable** who have an account number within a specified range.\n\n    static void JobPrintTel(Args _args)\n    {\n        CustTable xrecCT;\n        while select xrecCT \n            order by xrecCT.AccountNum\n                where  xrecCT.AccountNum >= \"4010\" \n                    && xrecCT.AccountNum <= \"4100\"\n        {\n            Global::info(strFmt(\"%1 , %2\", \n                xrecCT.AccountNum, xrecCT.SalesGroup));\n        }\n    }\n     \n    /*** Display from Infolog:\n    Message (06:04:03 pm)\n    4010 , CSG-EU\n    4011 , CSG-EU\n    4012 , CSG-OTH\n    4013 , CSG-OTH\n    4014 , CSG-OTH\n    4015 , CSG-OTH\n    4016 , CSG-EU\n    4017 , CSG-EU\n    4018 , CSG-EU\n    4020 , \n    4024 , \n    ***/\n\n### while select Code Example\n\nThis code example uses the **forUpdate** keyword.\n\n    static void LedgerJob(Args _args)\n    {\n        LedgerJournalTrans ledgerJournalTrans;\n        LedgerJournalTable ledgerJournalTable;\n        LedgerJournalId    jnJournalNum;\n        Voucher            vVoucher;\n        Counter            counter = 0;\n        jnJournalNum = \"999999_999\"; //\"000012_003\";\n        vVoucher = \"88888_888\"; //\"00001_IRG\";\n        ledgerJournalTable = \n            ledgerJournalTable::find(jnJournalNum);\n        ttsBegin;\n        while select forUpdate ledgerJournalTrans\n            index hint NumVoucherIdx\n                where ledgerJournalTrans.journalNum == jnJournalNum \n                   && ledgerJournalTrans.voucher == vVoucher\n        {\n            ledgerJournalTrans.doDelete();\n            counter++;\n        }\n     \n        //NumberSeq updates needed?\n        ttsCommit;\n        Global::info(strFmt(\"counter = %1\", counter));\n    }\n\n### Deleting a set of records\n\nYou can use a **while select** statement to loop over a set of records that meet some criteria and perform an action on each record. One such action is to **delete** a set of records. For example:\n\n    TableName myXrec;    \n    while select myXrec where conditions  // conditions is a Boolean variable defined elsewhere.\n    {      \n        myXrec.delete();    \n    }\n\nYou can achieve the same effect using the **delete\\_from** keyword.\n\n    TableName myXrec;    \n    delete_from myXrec where conditions;  // conditions is a Boolean variable defined elsewhere.\n\n### select statements on fields\n\nYou can use a **select** statement in a lookup on a field. Following a **select statement** that fetches a record in a table, you can write **.fieldName** to reference a field in the table. These **select** statements must be used in expressions. There is a difference between a **normal** **select** statement and a **field select** statement:\n\n-   The **field select** statement operates directly on a table.\n-   The **normal select** statement operates on a table buffer variable.\n\n### select field code example\n\n    void selectFieldExamples ()\n    {\n        // Prints the NameRef field from the selected customer\n        print (select CustTable order by AccountStatement).AccountStatement;\n     \n        // Uses the balance field from the customer with AccountNum 3000\n        if ((select custTable where CustTable.AccountNum == '3000').CreditMax < 50000)\n          print \"This customer has a credit maximum less than $50,000.\";\n    }\n\n### Aggregate functions: differences between X++ and SQL\n\nIn industry standard SQL, a database query can contain **aggregate functions**. Examples of such functions include **count(RecID)** and **sum(columnA)**. When an aggregate function is used but no rows match the **where** clause, a row must be returned to hold the result of the aggregates. The one returned row shows the value 0 (zero) for the **count** function, and shows **null** for the **sum** function. X++ does not support the concept of null values for the database. Therefore, when the **sum** function would return null, no row is returned to the user. Also, each data type has a specific value that is treated like a null value in certain circumstances.\n\n### index and order by keywords in select statements\n\nYou use the **order by** keyword in your **select** statements to order the data that's returned. Use the **index** hint keywords to specify that a particular index should be used in the query and to sort the selected records as defined by the index. Indexes optimize the selection of records. Combine the index hint keyword with an order by expression to select records in a specific order. If you want the sorted output in reverse order, use the **reverse** keyword. If a table index has been disabled by setting the index's **Enabled** property to No, the **select** statement that references the index is still valid. However, the database can't use the index as a hint for how to sort the data, because the index doesn't exist in the database. The following table is an overview of how to use the index hint and order by keywords in **select** statements.\n\n| Task                                                                                 | Use                                                             |\n|--------------------------------------------------------------------------------------|-----------------------------------------------------------------|\n| Select records where the order isn't significant.                                    | **select ..** **where ...**                                     |\n| Select records where the order is significant.                                       | **select ..** **order by ...** **where ...**                    |\n| Select records and force a specific index to be used.                                | **select ..** **index hint ...** **where ...**                  |\n| Select records where the order is significant and force a specific index to be used. | **select ..** **index hint ...** **order by ...** **where ...** |\n\n### index and order by code example\n\nTo select the transactions from the salestable based on a range of customers and due dates, use the following code.\n\n    SalesTable salesTable;\n        select salesTable\n        index hint CustIdx\n        order by CustAccount\n        where salesTable.CustAccount >= '3000'\n              && salesTable.CustAccount <= '4000'\n              && salesTable.FixedDueDate >= 12\\12\\2004\n              && salesTable.FixedDueDate <= 05\\05\\2009;\n\n### index hint\n\nTo use **index hint** in queries you must first specify the use of hints on the server using the following procedure.\n\n1.  Open Start &gt; Administrative Tools &gt; Microsoft Dynamics AX Server Configuration and select the Database Tuning tab.\n2.  Select Allow INDEX hints in queries and click OK.\n3.  A message box prompting you to restart the AOS service appears. Click Yes to restart the AOS service. Index hints won't be enabled until the service is restarted.\n\nWhen an **index hint** in a **select** statement refers to a non-clustered index and the **where** clause contains only the fields that are found in a clustered index on the same table, the clustered index is used instead of the index specified in the hint. For example, if you run **sp\\_helpindex InventTable** in SQL Server Management Studio, you see that the **InventTable** has a clustered index on the **DataAreaId** and **ItemId** columns and a non-clustered index on the **DataAreaId, ItemProductId,** and **ItemType** columns.\n\n| Index name       | Description                                       | Key columns                         |\n|------------------|---------------------------------------------------|-------------------------------------|\n| I\\_175ITEMIDX    | Clustered, unique, primary key located on PRIMARY | DATAAREAID, ITEMID                  |\n| I\\_175PRODUCTIDX | Nonclustered located on PRIMARY                   | DATAAREAID, ITEMPRODUCTID, ITEMTYPE |\n\nIn the following code the clustered index will be used instead of the non-clustered index specified by **index hint**.\n\n    static void IndexHint(Args _args)\n    {\n        InventTable inv;\n        \n        select * from inv index hint GroupItemIdx \n            where inv.ItemId == 'B-R14';\n    }\n\n### Write a select statement as an expression\n\nYou can use a **select** statement as an expression. This is called an **expression select**. A table buffer variable cannot be used in an expression select statement. The name of the table must be used in the **from** clause. One limitation of expression selects is that the **join** keyword is not supported in an expression join.\n\n### expression select code examples\n\nThe **select** statement inside the parentheses returns one row. The only column that can be populated with data is the column that is named in the **select** clause before the **from** clause. The name of that one column is used after the closing parenthesis to reference the data value: **).AccountNum;**.This test case returns a maximum of one row because it uses the **firstonly** keyword. However, the value that is assigned to **sAccountNum** is the same even if the **firstonly** keyword is omitted.The **where** clause in this example serves no purpose other than to show that the **where** clause must occur after the **order by** clause. The table name cannot be used to qualify a field name in the **order by** clause.\n\n    int64 nRecId, nCount;\n    str sAccountNum, sName;\n\n    sAccountNum = (select firstonly AccountNum from CustTable \n        order by AccountNum desc \n        where 0 == 0 // 'where' must occur after 'order by'. )\n        .AccountNum; \n    info(strFmt(\"Test_1.a: %1\", sAccountNum));\n\nThis is a simpler way to achieve the same result as the previous example. /\\*\\*\\*\\*\\*\\*\\*\\*\\* Actual Infolog output Test\\_1.a: 4507Test\\_1.b: 4507 \\*\\*\\*\\*\\*\\*\\*\\*\\*/\n\n        \n    int64 nRecId, nCount;\n    str sAccountNum, sName;\n\n    sAccountNum = (select maxof(AccountNum) from CustTable).AccountNum; \n    info(strFmt(\"Test_1.b: %1\", sAccountNum));\n\nThe following example includes a **where** clause. In a **where** clause, the table name must be used as a qualifier of the field.Here the **maxof** aggregate function is used, and the field **RecId** is mentioned in the function. The field that is mentioned in the aggregate function must be the same field name that is used to reference the data value after the closing parenthesis. Otherwise, empty data is returned.\n\n    int64 nRecId, nCount;\n    str sAccountNum, sName;\n\n    nRecId = (select maxof(RecId) from CustTable \n        where CustTable.Blocked == CustVendorBlocked::No)\n        .RecId; \n    info(strFmt(\"Test_2.c: %1\", nRecId));\n    /********* Actual Infolog output\n    Test_2.c: 5637144604\n    *********/\n\nThe following example demonstrates that a field name, here **RecId**, is used to reference a data value that is not a **RecId**. The **count** aggregate function does not return a **RecId** value. The **RecId** field is ordinarily used with the **count** function.\n\n    int64 nRecId, nCount;\n    str sAccountNum, sName;\n\n    nRecId = (select count(RecId) from CustTable \n        where CustTable.Blocked == CustVendorBlocked::No)\n        .RecId; \n    info(strFmt(\"Test_2.d: %1\", nRecId));\n    /********* Actual Infolog output\n    Test_2.d: 29\n    *********/\n\nThe **join** keyword is not supported in expression selects. The following example demonstrates a subselect. But expression selects do not support subselects that are equivalent to a standard inner join. For instance, the following code example does not compile. The problem is that it mentions two tables inside one expression select, namely inside the subselect. This code example shows that a subselect is supported, but only in a limited way.\n\n    // This job does not compile.\n    static void BadJob(Args _args)\n    {\n        sName = (select Name from AssetTable\n            where AssetTable.AssetId ==\n                // Here starts the subselect.\n                (select AssetId from AssetTrans\n                    where AssetTrans.AssetId ==\n                        AssetTable.AssetId // Compiler rejects this line.\n                ).AssetId).Name;\n        info(strFmt(\"Test_3: %1\", sName));\n    }\n    /********* Actual Infolog output\n    Test_3: CNC-Metal shade\n    *********/\n\n## update method\nThe **update** table method updates the current record with the contents of the buffer. It also updates the appropriate system fields. The **where** clause is optional. When used, the **where** clause specifies a condition for **update** to test while processing each row of the table. Only those rows that test **true** against the condition are updated with the new values. **update\\_recordset** is a record-set based operator that updates multiple records at once. To override the behavior of **update**, use the doUpdate method. The example selects the table **custTable** for update. Any records with the AccountNum equal to 4000 are updated (in this case only one). The **CreditMax** field is changed to 5000.\n\n    CustTable custTable;\n        ttsBegin;\n          select forUpdate custTable\n          where custTable.AccountNum == '4000'; \n          custTable.CreditMax = 5000; \n          custTable.update(); \n        ttsCommit;\n\n## doUpdate method\nThe **doUpdate** method updates the current record with the contents of the buffer. This method also updates the appropriate system fields. The **doUpdate** method should be used when the update method on the table is to be bypassed. The syntax for a **doUpdate** table method is **void doUpdate()** In the following example, **CreditMax** is increased by 1000.\n\n    static void Job1(Args _args)\n    {\n        CustTable custTable;\n        ttsBegin;\n        select forUpdate custTable\n        where custTable.CreditMax == 3000;\n        if (custTable)\n        {\n           custTable.CreditMax += 1000;\n           custTable.doUpdate();\n        }\n        ttsCommit;\n    }\n\n## delete method\nThe **delete** table method deletes the current record from the database. To use this method, specify which rows are to be deleted by using a **where** clause. Records are then removed, one at a time, from the specified table. **delete\\_from** is a record-setbased operator, which simultaneously removes multiple records. The **delete** method can be overridden, for example, to add extra validation before records are deleted. If you override the **delete** method, the original version of the **delete** method can be executed instead by calling the **doDelete** method. It is equivalent to calling **super()** in the **delete** method; **doDelete** executes the base version of the **delete** method. In the following example, all the records in the **MyTable** table that satisfy the **where** clause criterion (any record with an Account number equal to 1000) are deleted from the database. These records are deleted one at a time.\n\n    ttsBegin;\n    while select forUpdate myTable\n        where myTable.AccountNum == '1000'\n    {\n        myTable.delete();\n    }\n    ttsCommit;\n\n## doDelete method\nThe **doDelete** table method works similar to the **delete** table method because it deletes the current record from the database. Use the **doDelete** method if the delete table method has been overridden, and you want to use the original version of the **delete** method. The **doDelete** method executes the base version of the **delete** method instead of the overridden version, which is equivalent to executing **super() **in the **delete** method. This code example deletes all records in the myTable table that have an account number that is greater than or equal to 200.\n\n    ttsBegin;\n    while select forUpdate myTable\n        where myTable.AccountNum >='200';\n    {\n        myTable.doDelete();\n    }\n    ttsCommit;\n\n## insert method\nThe **insert** method updates one record at a time. To insert multiple records at a time, use array inserts, **insert\\_recordset**, or **RecordSortedList.insertDatabase**. To override the behavior of the **insert** method, use the **doInsert** method. The **xRecord .insert** method generates values for **RecId** and system fields, and then inserts the contents of the buffer into the database. The method operated as follows:\n\n-   Only the specified columns of those rows selected by the query are inserted into the named table.\n-   The columns of the table being copied from and those of the table being copied to must be type compatible.\n-   If the columns of both tables match in type and order, the column-list may be omitted from the **insert** clause.\n\n### insert code example: insert a new record\n\nThe following code example inserts a new record into the **CustTable** table, with the **AccountNum** set to 5000 and the **Name** set to MyCompany (other fields in the record will be blank).\n\n    CustTable custTable;\n    ttsBegin;\n    select forUpdate custTable;\n    custTable.AccountNum = '5000';\n    custTable.insert();\n    ttsCommit;\n\n### insert code example: transaction and duplicate key\n\nThe following example shows how you can catch a **DuplicateKeyException** in the context of an explicit transaction. The exception is thrown when a call to **xRecord .insert** fails because of a duplication of an existing unique value. In the catch block, your code can take corrective action, or it can log the error for later analysis. Then your code can continue without losing all the pending work of the transaction. You cannot catch a duplicate key exception caused by a set based operation such as **insert\\_recordset**. This example depends on two tables **TableNumberA** and **TableNumberB**. Each has one mandatory Integer field, named **NumberAKey** and **NumberBKey** respectively. Each of these key fields has a unique indexed defined on it. The **TableNumberA** table must have at least one record in it.\n\n    static void JobDuplicKeyException44Job(Args _args)\n        {\n        TableNumberA tabNumA; // Has one record, key = 11.\n        TableNumberB tabNumB;\n        int iCountTries = 0, iNumberAdjust = 0, iNewKey, ii;\n        container ctNotes;\n        // Empty the B table.\n        delete_from tabNumB;\n        // Insert a copy of one record.\n        insert_recordset tabNumB (NumberBKey)\n        select firstOnly NumberAKey from tabNumA order by NumberAKey asc;\n        ttsBegin;\n        try\n            {\n            iCountTries++;\n            ctNotes += strFmt(\"---- Inside the try block, try count is %1. ----\", iCountTries);\n            while select * from tabNumA order by NumberAKey asc\n                {   \n                tabNumB .clear();\n                iNewKey = tabNumA .NumberAKey + iNumberAdjust;\n                tabNumB .NumberBKey = iNewKey;\n                ctNotes += strFmT (\"-- %1 is the key to be tried. --\" ,iNewKey);\n                tabNumB .insert();\n                ctNotes += \"-- .insert() successful. --\";\n                break; // Keeps demo simple.\n                }\n            ttsCommit;\n            }\n        catch (Exception ::DuplicateKeyException, tabNumB) // Table is optional.\n            {\n            ctNotes += \"---- Inside the catch block. ----\";\n            ctNotes += infolog .text();\n            if (iCountTries <= 1)\n                {\n                ctNotes += \"-- Will issue retry. --\";\n                iNumberAdjust = 1;\n                retry; // Erases Infolog.\n                }\n            else\n                {\n                ctNotes += \"-- Aborting the transaction. --\";\n                ttsAbort;\n                }\n            }\n        for (ii=1; ii <= conLen(ctNotes); ii++)\n            {\n            info(conPeek(ctNotes ,ii));\n            }\n        }\n     \n    /*********Actual Infolog output\n            Message (10:53:13 am)\n        ---- Inside the try block, try count is 1. ----\n        -- 11 is the key to be tried. --\n        ---- Inside the catch block. ----\n        Cannot create a record in TableNumberB (TableNumberB).\n        The record already exists.\n        -- Will issue retry. --\n        ---- Inside the try block, try count is 2. ----\n        -- 12 is the key to be tried. --\n        -- .insert() successful. --\n    *********/\n\n## doInsert method\nThe **doInsert** method generates values for the **RecId** field and other system fields, and then inserts the contents of the buffer into the database. This operation is used when the insert method on the table is to be bypassed. In the following example, a new record is inserted with the name **Warren Langer** in the name field and the value 100 in the value field.\n\n    ttsBegin;\n    myTable.name = 'Warren Langer';\n    myTable.value = 100;\n    myTable.doInsert();\n    ttsCommit;\n\n## Transactional integrity\nIf the **integrity of transactions** is not ensured, it may lead to data corruption, or, at best, poor scalability with reference to concurrent users on the system. There are two internal checking features to help ensure the integrity of transactions: the **forUpdate** check and the **tssLevel** check. A **forUpdate check** ensures that no record can be updated or deleted if the record has not first been selected for update. A record can be selected for update, either by using the **forUpdate** keyword in the **select** statement, or by using the **selectForUpdate** method on tables. A **ttsLevel check** ensures that no record can be updated or deleted except from within the same transaction scope as it was selected for update. Integrity is ensured by using the following statements:\n\n-   **ttsBegin**: marks the beginning of a transaction. This ensures data integrity, and guarantees that all updates performed until the transaction ends (by **ttsCommit** or **ttsAbort**) are consistent (all or none).\n-   **ttsCommit**: marks the successful end of a transaction. This ends and commits a transaction. Dynamics 365 for Operations guarantees that a committed transaction will be performed according to intentions.\n-   **ttsAbort**: allows you to explicitly discard all changes in the current transaction. As a result, the database is rolled back to the initial state where nothing will have been changed. Typically, you will use this if you have detected that the user wants to break the current job. Using **ttsAbort** ensures that the database is consistent.\n\nIt is usually better to use exception handling instead of **ttsAbort**. The **throw** statement automatically aborts the current transaction. Statements between **ttsBegin** and **ttsCommit** may include one or more transaction blocks as shown in the following example. In such cases, nothing is actually committed until the successful exit from the final **ttsCommit**.\n\n    ttsBegin;\n        // Some statements.\n    ttsBegin;\n        // More statements.\n    ttsCommit;\n    ttsCommit;\n\nThe following example selects a set of records and updates the **NameAlias** field.\n\n    Custtable custTable;\n    ttsBegin;\n    select forUpdate custTable where custTable.AccountNum == '4000';\n    custTable.NameAlias = custTable.Name;\n    custTable.update();\n    ttsCommit;\n\n### Examples of code rejected by the two transaction integrity checks\n\nIn this example, the first failure is because the **forupdate** keyword is missing. The second failure is because the update is in another transaction scope rather than the one that the record was selected in **ttsCommit** for update.\n\n    ttsBegin;\n    select myTable; // Rejected by the forUpdate check.\n    mytable.myField = 'xyz';\n    myTable.update();\n    ttsCommit;\n    ttsBegin;\n    select forUpdate * from myTable;\n    myTable.myField = 'xyz';\n    ttsCommit;\n    ...\n    ttsBegin;\n    myTable.update(); // Rejected by the ttsLevel check.\n    ttsCommit;\n\n## Speeding up SQL operations\nThe following constructs allow you to insert, update, or delete multiple records. Using these constructs reduces communication between the application and the database, and it increases performance. In some situations, record-set operations can fall back to record-by-record operations.\n\n| Construct             | Description                                                                                                                                                                                                                                   |\n|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **RecordSortedList**  | Allows you to insert multiple records in one database trip. Use the **RecordSortedList** construct when you want a subset of data from a particular table, and when you want it sorted in an order that does not currently exist as an index. |\n| **RecordInsertList**  | Allows you to insert multiple records in one database trip. Use the **RecordInsertList** construct when you do not need to sort the data.                                                                                                     |\n| **insert\\_recordset** | Allows you to copy multiple records from one or more tables directly into another table on a single database trip.                                                                                                                            |\n| **update\\_recordset** | Allows you to update multiple rows in a table on a single database trip.                                                                                                                                                                      |\n| **delete\\_from**      | Allows you to delete multiple records from the database on a single database trip.                                                                                                                                                            |\n\n## insert\\_recordset\n**insert\\_recordset** copies data from one or more tables directly into one resulting destination table on a single server trip. Using **insert\\_recordset** is faster than using an array insert. However, array inserts are more flexible if you want to handle the data before you insert it. **insert\\_recordset** is a record-set-based operator, which performs operations on multiple records at a time. However, it can fall back to record-by-record operations in many situations.\n\n### insert\\_recordset Syntax\n\nThe *ListOfFields* in the destination table must match the list of fields in the source tables. Data is transferred in the order that it appears in the list of fields. Fields in the destination table that are not present in the list of fields are assigned zero-values as in other areas. System fields, including **RecId**, are assigned transparently by the kernel in the destination table. **insert\\_recordset**  *DestinationTable*  **(**  *ListOfFields*  **)** **select**  *ListOfFields1*  **from**  *SourceTable*  **\\[ where**  *WhereClause*  **\\]** **\\[ join**  *ListOfFields2*  **from**  *JoinedSourceTable* **\\[ where**  *JoinedWhereClause*  **\\]\\]**\n\n### Code example: insert data from another table\n\nThe records, **myNum** and **mySum**, are retrieved from the table **anotherTable** and inserted into the table **myTable**. The records are grouped according to **myNum**, and only the **myNum** records with a value less than or equal to 100 are included in the insertion.\n\n    insert_recordset myTable (myNum, mySum)\n        select myNum, sum(myValue) \n            from anotherTable \n            group by myNum \n            where myNum <= 100;\n\n### Code example: insert data from variables\n\nThis code example shows that the **insert\\_recordset** statement can insert data that is provided in variables. In this example, the keyword **firstonly** is used so that only one row is inserted. Literals, such as **128** or **\"this literal string\"**, cannot be used as a source of data to be inserted.\n\n    static void InsertVariable3Job(Args _args)\n    {\n        TableAlphabet    tabA2;\n        BankAccountTable tabB3;\n        str  1 sLetter = \"a\";\n        str 16 sExampleWord = \"apple\";\n        \n        DELETE_FROM tabA2;\n        INSERT_RECORDSET tabA2\n            (Letter ,ExampleWord)\n        select firstonly\n            sLetter ,sExampleWord // Variables.\n        from tabB3;\n        WHILE SELECT * from tabA2\n        {\n            info(tabA2 .Letter + \" , \" + tabA2 .ExampleWord);\n        }\n     \n    /***********  Actual Infolog output\n    Message (04:03:52 pm)\n    a , apple\n    ***********/\n    }\n\n### Code example: insert data using a join\n\nThe following code example shows a **join** of three tables on an **insert\\_recordset** statement that has a sub-**select**. Also, a **while** **select** statement with a similar join is shown. A variable is used to supply the inserted value for one column. The **str** variable must be declared with a length that is less than or equal to the maximum length of the corresponding database field. In this example, there is an **insert\\_recordset** statement for **tabEmplProj5**. One of the target fields is named **Description**, and the field's data comes from the local variable **sDescriptionVariable**. When the configuration key for the **Description** field is turned off, the **insert\\_recordset** still succeeds. The system ignores both the **Description** field and the variable **sDescriptionVariable**. This is an example of **configuration key automation**. Configuration key automation is when the system can automatically adjust the behavior of an **insert\\_recordset** statement that inserts into fields that have their configuration key turned off.\n\n    static void InsertJoin42Job(Args _args)\n    {\n        GmTabDepartment tabDept2;\n        GmTabEmployee tabEmpl3;\n        GmTabProject tabProj4;\n        GmTabEmployeeProject tabEmplProj5;\n        str 64 sDescriptionVariable = \"From variable.\";\n        \n        DELETE_FROM tabEmplProj5;\n        INSERT_RECORDSET tabEmplProj5\n            (\n            Description\n            , EmployeeRecId\n            , ProjectRecId\n            )\n        Select\n            sDescriptionVariable\n            , RecId\n        from\n            tabEmpl3\n            join\n                tabDept2\n                where tabEmpl3 .DepartmentGuid == tabDept2 .DepartmentGuid\n            join RecId\n                from tabProj4\n                where tabDept2 .DepartmentGuid == tabProj4 .DepartmentGuid\n        \n        info(int642str(tabEmplProj5 .rowCount())\n            + \" ==Number of rows inserted.\");\n        WHILE SELECT *\n            from\n                tabEmplProj5\n                join tabEmpl3\n                    where tabEmplProj5 .EmployeeRecId == tabEmpl3 .RecId\n                join tabProj4\n                    where tabEmplProj5 .ProjectRecId == tabProj4 .RecId\n        {\n            info(\n                tabEmpl3 .EmployeeName\n                + \"  --works on--  \"\n                + tabProj4 .ProjectName\n                + \" (\" + tabEmplProj5 .Description + \").\"\n                );\n        }\n     \n    /*****************  Actual Infolog output\n    Message (01:05:41 pm)\n    4 ==Number of rows inserted.\n    Alice  --works on--  Project ZZZ (From variable.).\n    Alice  --works on--  Project YY (From variable.).\n    Beth  --works on--  Project ZZZ (From variable.).\n    Beth  --works on--  Project YY (From variable.).\n    *****************/\n    }\n\n## update\\_recordset\nThe **update\\_recordset** statement enables you to update multiple rows in a single trip to the server. This means that certain tasks may have improved performance by using the power of the SQL server. ****update\\_recordset**** resembles **delete\\_from** in X++ and **update set** in SQL. It works on the database server-side on an SQL-style record-set, instead of retrieving each record separately by fetching, changing, and updating. If the **update** method is overridden, the implementation falls back to a classic looping construction, updating records one by one just as **delete\\_from** does for deletions. This also means that the construction works on temporary tables, and whole-table-cached tables by using the looping construction.\n\n### Code example: update based on a calculated value\n\nThis example updates the table **myTableBuffer** and increments the value in **field1** by ten percent in all records in the table.\n\n    MyTable myTableBuffer;\n    update_recordset myTableBuffer\n    setting field1 = field1 * 1.10;\n\n### Code example: update using a where clause\n\nThis example updates the table **myTable** in all records where **field1** has the value 0. **field1** is assigned the new value 1; **field2** is assigned the value of the sum of **fieldX** and **fieldY**. This example updates multiple fields at the same time, and it updates only those rows that satisfy the **where** clause.\n\n    MyTable myTableBuffer;\n    update_recordset myTableBuffer\n    setting\n        field1 = 1,\n        field2 = fieldX + fieldY\n    where field1 == 0;\n\n### Code example: updating joined tables\n\nThis example shows that the **update\\_recordset** statement supports the joining of several tables. Data from the joined tables can be used to assign values to fields in the table that is being updated.\n\n    static void Join22aJob(Args _args)\n    {\n        TableEmployee tabEmpl;\n        TableDepartment tabDept;\n        TableProject tabProj;\n        \n        update_recordset tabEmpl\n        setting\n            currentStatusDescription = tabDept .DeptName\n                + \", \" + tabProj .ProjName\n        join tabDept\n            where tabDept .DeptId == tabEmpl .DeptId\n        join tabProj\n            where tabProj .ProjId == tabEmpl .ProjId;\n        info(strFmt(\"Number of records updated is %1.\"\n            ,tabEmpl .rowCount()));\n    }\n\n## delete\\_from\nYou can delete multiple records from a database table by using a **delete\\_from** statement. This can be more efficient and faster than deleting one record at a time by using the **xRecord .delete** method in a loop. If you have overridden the delete method, the system interprets the **delete\\_from** statement into code that calls the **delete** method one time for each row that is deleted.\n\n### Code example: efficiently delete records using delete\\_from\n\nThe following code example is an efficient way to delete multiple records.\n\n    static void DeleteMultiRow1aJob(Args _args)\n    {\n        MyWidgetTable tabWidget;\n        \n        delete_from tabWidget\n            where tabWidget .quantity <= 100;\n    }\n\n#### Code example: inefficiently delete records using forUpdate\n\nThe following code example is inefficient. It issues a separate SQL delete call to the database server for each record. The **xRecord** **.delete** method never deletes more than one record per call.\n\n    static void DeleteMultiRow1bJob(Args _args)\n    {\n        MyWidgetTable tabWidget; // extends xRecord.\n        \n        ttsBegin;\n        while select\n            forUpdated\n            tabWidget\n            where tabWidget .quantity <= 100\n        {\n            tabWidget .delete();\n        }\n        ttsCommit;\n    }\n\n### Code example: delete with an inner join\n\nInner joins are not supported on the **delete\\_from** statement. Therefore you cannot use the unmodified **join** keyword on the **delete\\_from** statement. However, there are other ways to logically accomplish an inner join. This example shows the new and old techniques for achieving inner join logic through a sequence of statements.\n\n    // This is the new and recommended way of using the delete_from method and inner joins.\n    // The following code example is relatively efficient. It issues a \n    // separate delete_from statement for each loop iteration. However, each \n    // delete_from statement can delete multiple records, a subset of all the \n    // records that the job deletes.\n    static void DeleteInnerJoin2bJob(Args _args)\n    {\n        MyWidgetTable tabWidget; // extends xRecord.\n        \n        ttsBegin;\n        while select\n            from tabGalaxy\n                where tabGalaxy .isTrusted == 0\n        {\n            delete_from tabWidget\n                where tabWidget .GalaxyRecId ==\n                      tabGalaxy .RecId;\n        }\n        ttsCommit;\n    }\n    // This is the old way of using the delete method and inner joins. \n    // The following delete method is inefficient. It issues a \n    // separate SQL delete call to the database server for each record.\n    static void DeleteInnerJoin2aJob(Args _args)\n    {\n        MyWidgetTable tabWidget; // extends xRecord.\n        \n        ttsBegin;\n        while select\n            forUpdate\n            tabWidget\n            join tabGalaxy\n                where\n                    tabWidget .GalaxyRecId == tabGalaxy .RecId\n                    && tabGalaxy .isTrusted == 0\n        {\n            tabWidget .delete();\n        }\n        ttsCommit;\n    }\n\n### Code example: delete with notexists join keyword\n\nYou can use the **notexists join** keyword pair in a **delete\\_from** statement. The **delete\\_from** statements in the following code example are efficient. The **notexists join** clause enables the **delete\\_from** statement to delete a specific set of rows. In this example the **delete\\_from** statement removes all the parent order header rows for which there are no child order line rows. You can also use the **exists join** clause on the **delete\\_from** statement.\n\n    static void DeleteFromNotexists3bJob(Args _args)\n    {\n        GmTabOrderHeader tabOHeader;\n        GmTabOrderLine tabOLine;\n        AddressState tabAddressState;\n        str 127 sOH_Info;\n        str 127 sOL_Data;\n        int64 i64OHRecId;\n        \n        delete_from tabOLine;\n        delete_from tabOHeader;\n        // Inserts into parent table.\n        sOH_Info = \"Albert needs tires.\";\n        insert_recordset tabOHeader\n            (OH_Info)\n            select firstOnly sOH_Info from tabAddressState;\n        sOH_Info = \"Benson wants plastic.\";\n        insert_recordset tabOHeader\n            (OH_Info)\n            select firstOnly sOH_Info from tabAddressState;\n        // Obtain a OrderHeader RecId,\n        // use it to insert one child row.\n        sOL_Data = \"4 re-treads.\";\n        while select firstOnly tabOHeader\n                order by OH_Info\n                where tabOHeader .OH_Info like \"A*\"\n        {\n            i64OHRecId = tabOHeader .RecId;\n            insert_recordset tabOLine\n                (OL_Data ,OrderHeaderRecId)\n                select firstOnly\n                    sOL_Data ,i64OHRecId\n                    from tabAddressState;\n            break;\n        }\n        // Before the delete notexists.\n        // Display all parent, and then all child rows.\n        while select tabOHeader\n            order by OH_Info\n        {\n            info(strFmt(\n                \"Before: OHeader:  OH_Info==%1 , RecId==%2\"\n                ,tabOHeader .OH_Info ,tabOHeader .RecId\n                ));\n        }\n        while select tabOLine\n            order by OL_Data\n        {\n            info(strFmt(\n                \"Before: OLine:  OL_Data==%1 , OrderHeaderRecId==%2\"\n                ,tabOLine .OL_Data ,tabOLine .OrderHeaderRecId\n                ));\n        }\n        // Delete_From NotExists Join, to remove from the\n        // parent table all order headers without children.\n        delete_from tabOHeader\n            notexists join tabOLine\n                where tabOHeader .RecId ==\n                    tabOLine .OrderHeaderRecId;\n        info(strFmt\n            (\"%1 is the number of childless OHeader records deleted.\"\n            ,tabOHeader.rowCount()));\n        // After the delete notexists.\n        // Display all parent, and then all child rows.\n        info(\"- - - - - - - - - - - - - - -\");\n        while select tabOHeader\n            order by OH_Info\n        {\n            info(strFmt(\n                \"After: OHeader:  OH_Info==%1 , RecId==%2\"\n                ,tabOHeader .OH_Info ,tabOHeader .RecId\n                ));\n        }\n        while select tabOLine\n            order by OL_Data\n        {\n            info(strFmt(\n                \"After: OLine:  OL_Data==%1 , OrderHeaderRecId==%2\"\n                ,tabOLine .OL_Data ,tabOLine .OrderHeaderRecId\n                ));\n        }\n     \n    /**************  Actual Infolog output\n    Message (12:54:14 pm)\n    Before: OHeader:  OH_Info==Albert needs tires. , RecId==5637144608\n    Before: OHeader:  OH_Info==Benson wants plastic. , RecId==5637144609\n    Before: OLine:  OL_Data==4 re-treads. , OrderHeaderRecId==5637144608\n    1 is the number of childless OHeader records deleted.\n    - - - - - - - - - - - - - - -\n    After: OHeader:  OH_Info==Albert needs tires. , RecId==5637144608\n    After: OLine:  OL_Data==4 re-treads. , OrderHeaderRecId==5637144608\n    **************/\n    }\n\n## Maintain fast SQL operations\nThere are situations where record-set operations can be converted to slower record-by-record operations. The following table identifies these situations.\n\n|                                                               | DELETE\\_FROM | UPDATE\\_RECORDSET | INSERT\\_RECORDSET | ARRAY\\_INSERT | Use ... to override   |\n|---------------------------------------------------------------|--------------|-------------------|-------------------|---------------|-----------------------|\n| Non-SQL tables                                                | Yes          | Yes               | Yes               | Yes           | Not applicable        |\n| Delete actions                                                | Yes          | No                | No                | No            | **skipDeleteActions** |\n| Database log enabled                                          | Yes          | Yes               | Yes               | No            | **skipDatabaseLog**   |\n| Overridden method                                             | Yes          | Yes               | Yes               | Yes           | **skipDataMethods**   |\n| Alerts set up for table                                       | Yes          | Yes               | Yes               | No            | **skipEvents**        |\n| ValidTimeStateFieldType property not equal to None on a table | Yes          | Yes               | Yes               | Yes           | Not applicable        |\n\nYou may explicitly skip or ignore one or more things that would adversely impact performance by using the items shown in the far right column. If for some reason one of the previously mentioned SQL operations is downgraded to a record-by-record operation, all of the **skip** settings are also ignored. For example, the **insert** method on **myTable** is executed in the following example even though it is explicitly stated that this method should be skipped if **myTable** has a container or memo field defined.\n\n    public void tutorialRecordInsertList()\n    {\n        MyTable myTable;\n        RecordInsertList insertList = new RecordInsertList(\n            myTable.TableId, \n            True);\n        int i;\n        for ( i = 1; i <=  100; i++ )\n        {\n            myTable.value = i;\n            insertList.add(myTable);\n        }\n        insertList.insertDatabase();\n    }\n\n"}