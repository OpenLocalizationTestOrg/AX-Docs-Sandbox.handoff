{"nodes":[{"pos":[32,84],"content":"X++ Data Selection and Manipulation | Microsoft Docs","needQuote":true,"needEscape":true,"nodes":[{"content":"X++ Data Selection and Manipulation | Microsoft Docs","pos":[0,52]}]},{"pos":[98,180],"content":"This topic describes the X++ language support for data selection and manipulation.","needQuote":true,"needEscape":true,"nodes":[{"content":"This topic describes the X++ language support for data selection and manipulation.","pos":[0,82]}]},{"pos":[564,599],"content":"X++ Data Selection and Manipulation","linkify":"X++ Data Selection and Manipulation","nodes":[{"content":"X++ Data Selection and Manipulation","pos":[0,35]}]},{"content":"You can use SQL statements either interactively or within source code, to access and retrieve data that is stored in the database.","pos":[601,731]},{"content":"Data manipulation is performed through the following statements:","pos":[732,796]},{"pos":[802,852],"content":"<ph id=\"ph1\">`select`</ph> selects the data that you want to modify.","source":"`select` selects the data that you want to modify."},{"pos":[857,908],"content":"<ph id=\"ph1\">`insert`</ph> adds one or more new records into a table.","source":"`insert` adds one or more new records into a table."},{"pos":[913,962],"content":"<ph id=\"ph1\">`update`</ph> modifies data in existing table records.","source":"`update` modifies data in existing table records."},{"pos":[967,1013],"content":"<ph id=\"ph1\">`delete`</ph> removes existin records from a table.","source":"`delete` removes existin records from a table."},{"content":"Before any data can be changed, the data must first be selected for update by using a select statement.","pos":[1015,1118]},{"content":"The <ph id=\"ph1\">`select forUpdate`</ph> command selects records exclusively for update.","pos":[1119,1189],"source":" The `select forUpdate` command selects records exclusively for update."},{"content":"The <ph id=\"ph1\">`insert`</ph>, <ph id=\"ph2\">`update`</ph>, and <ph id=\"ph3\">`delete`</ph> methods perform operations on only one record at a time.","pos":[1190,1283],"source":" The `insert`, `update`, and `delete` methods perform operations on only one record at a time."},{"content":"The array insert, insert<ph id=\"ph1\">\\_</ph>recordset, RecordInsertList, and update<ph id=\"ph2\">\\_</ph>recordset statements perform operations on multiple records at a time.","pos":[1284,1421],"source":" The array insert, insert\\_recordset, RecordInsertList, and update\\_recordset statements perform operations on multiple records at a time."},{"pos":[1426,1443],"content":"Select Statements","linkify":"Select Statements","nodes":[{"content":"Select Statements","pos":[0,17]}]},{"content":"The <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement fetches or manipulates data from the database.","pos":[1444,1515],"source":"The **select** statement fetches or manipulates data from the database."},{"content":"All <ph id=\"ph1\">`select `</ph>statements use a table variable to fetch records.","pos":[1516,1578],"source":" All `select `statements use a table variable to fetch records."},{"content":"This variable must be declared before a <ph id=\"ph1\">`select`</ph> statement can be executed.","pos":[1579,1654],"source":" This variable must be declared before a `select` statement can be executed."},{"content":"The <ph id=\"ph1\">`select`</ph> statement only fetches one record, or field.","pos":[1655,1712],"source":" The `select` statement only fetches one record, or field."},{"content":"To fetch additional records, you can use the <ph id=\"ph1\">`next`</ph> statement.","pos":[1713,1775],"source":" To fetch additional records, you can use the `next` statement."},{"content":"The <ph id=\"ph1\">`next`</ph> statement fetches the next record in the table.","pos":[1776,1834],"source":" The `next` statement fetches the next record in the table."},{"content":"If you use <ph id=\"ph1\">`next`</ph> without a preceding <ph id=\"ph2\">`select`</ph> command, an error occurs.","pos":[1835,1907],"source":" If you use `next` without a preceding `select` command, an error occurs."},{"content":"Do not use <ph id=\"ph1\">`next`</ph> with the <ph id=\"ph2\">`firstOnly`</ph> find option.","pos":[1908,1959],"source":" Do not use `next` with the `firstOnly` find option."},{"content":"If you need to traverse a number of records, it is more appropriate to use a <ph id=\"ph1\">`while`</ph> <ph id=\"ph2\">`select`</ph> statement.","pos":[1960,2064],"source":" If you need to traverse a number of records, it is more appropriate to use a `while` `select` statement."},{"content":"Results of a <ph id=\"ph1\">`select`</ph> statement are returned in a table buffer variable.","pos":[2065,2137],"source":" Results of a `select` statement are returned in a table buffer variable."},{"content":"If you use a field list in the <ph id=\"ph1\">`select`</ph> statement, only those fields are available in the table variable.","pos":[2138,2243],"source":" If you use a field list in the `select` statement, only those fields are available in the table variable."},{"content":"If you use aggregate functions, such as <ph id=\"ph1\">`sum`</ph> or <ph id=\"ph2\">`count`</ph>, the results are returned in the fields that you perform the <ph id=\"ph3\">`sum`</ph> or <ph id=\"ph4\">`count`</ph> over.","pos":[2244,2384],"source":" If you use aggregate functions, such as `sum` or `count`, the results are returned in the fields that you perform the `sum` or `count` over."},{"content":"You can only count, average, or sum the integer and real fields.","pos":[2385,2449]},{"pos":[2454,2477],"content":"Select Statement Syntax","linkify":"Select Statement Syntax","nodes":[{"content":"Select Statement Syntax","pos":[0,23]}]},{"pos":[2482,2523],"content":"<bpt id=\"p1\">*</bpt>SelectStatement<ept id=\"p1\">*</ept><ph id=\"ph1\"> = </ph><ph id=\"ph2\">`select`</ph> <bpt id=\"p2\">*</bpt>Parameters<ept id=\"p2\">*</ept>","source":"*SelectStatement* = `select` *Parameters*"},{"pos":[2528,2708],"content":"<bpt id=\"p1\">*</bpt>Parameters<ept id=\"p1\">*</ept><ph id=\"ph1\"> = </ph><ph id=\"ph2\">`[ [ `</ph> <bpt id=\"p2\">*</bpt>FindOptions<ept id=\"p2\">*</ept> <ph id=\"ph3\">` ]`</ph> <ph id=\"ph4\">`[ `</ph> <bpt id=\"p3\">*</bpt>FieldList<ept id=\"p3\">*</ept> <ph id=\"ph5\">` from ] ]`</ph> <bpt id=\"p4\">*</bpt>TableBufferVariable<ept id=\"p4\">*</ept> <ph id=\"ph6\">`[`</ph> <bpt id=\"p5\">*</bpt>IndexClause<ept id=\"p5\">*</ept> <ph id=\"ph7\">`]`</ph> <ph id=\"ph8\">`[ `</ph> <bpt id=\"p6\">*</bpt>Options<ept id=\"p6\">*</ept> <ph id=\"ph9\">` ]`</ph> <ph id=\"ph10\">`[ `</ph> <bpt id=\"p7\">*</bpt>WhereClause<ept id=\"p7\">*</ept> <ph id=\"ph11\">` ]`</ph> <ph id=\"ph12\">`[ `</ph> <bpt id=\"p8\">*</bpt>JoinClause<ept id=\"p8\">*</ept> <ph id=\"ph13\">` ]`</ph>","source":"*Parameters* = `[ [ ` *FindOptions* ` ]` `[ ` *FieldList* ` from ] ]` *TableBufferVariable* `[` *IndexClause* `]` `[ ` *Options* ` ]` `[ ` *WhereClause* ` ]` `[ ` *JoinClause* ` ]`"},{"pos":[2713,2989],"content":"<bpt id=\"p1\">*</bpt>FindOptions<ept id=\"p1\">*</ept><ph id=\"ph1\"> = </ph><ph id=\"ph2\">`crossCompany`</ph><ph id=\"ph3\"> | </ph><ph id=\"ph4\">`reverse`</ph><ph id=\"ph5\"> | </ph><ph id=\"ph6\">`firstFast`</ph><ph id=\"ph7\"> | </ph><ph id=\"ph8\">\\[</ph> <ph id=\"ph9\">`firstOnly`</ph><ph id=\"ph10\"> | </ph><ph id=\"ph11\">`firstOnly10`</ph><ph id=\"ph12\"> | </ph><ph id=\"ph13\">`firstOnly100`</ph><ph id=\"ph14\"> | </ph><ph id=\"ph15\">`firstOnly1000`</ph> <ph id=\"ph16\">\\]</ph><ph id=\"ph17\"> | </ph><ph id=\"ph18\">`forUpdate`</ph><ph id=\"ph19\"> | </ph><ph id=\"ph20\">`noFetch`</ph><ph id=\"ph21\"> | </ph><ph id=\"ph22\">\\[</ph><ph id=\"ph23\">`forcePlaceholders`</ph><ph id=\"ph24\"> | </ph><ph id=\"ph25\">`forceLiterals`</ph><ph id=\"ph26\">\\]</ph><ph id=\"ph27\"> | </ph><ph id=\"ph28\">`forceselectorder`</ph><ph id=\"ph29\"> | </ph><ph id=\"ph30\">`forceNestedLoop`</ph><ph id=\"ph31\"> | </ph><ph id=\"ph32\">`repeatableRead`</ph><ph id=\"ph33\"> | </ph><ph id=\"ph34\">`validTimeState`</ph>","source":"*FindOptions* = `crossCompany` | `reverse` | `firstFast` | \\[ `firstOnly` | `firstOnly10` | `firstOnly100` | `firstOnly1000` \\] | `forUpdate` | `noFetch` | \\[`forcePlaceholders` | `forceLiterals`\\] | `forceselectorder` | `forceNestedLoop` | `repeatableRead` | `validTimeState`"},{"pos":[2994,3042],"content":"<bpt id=\"p1\">*</bpt>FieldList <ept id=\"p1\">*</ept><ph id=\"ph1\">= </ph><bpt id=\"p2\">*</bpt>Field<ept id=\"p2\">*</ept> <ph id=\"ph2\">` { , `</ph> <bpt id=\"p3\">*</bpt>Field<ept id=\"p3\">*</ept> <ph id=\"ph3\">` }`</ph><ph id=\"ph4\"> | </ph><ph id=\"ph5\">`*`</ph>","source":"*FieldList *= *Field* ` { , ` *Field* ` }` | `*`"},{"pos":[3047,3116],"content":"<bpt id=\"p1\">*</bpt>Field = Aggregate <ph id=\"ph1\">` ( `</ph> <ept id=\"p1\">*</ept>FieldIdentifier<bpt id=\"p2\">*</bpt> <ph id=\"ph2\">` ) | `</ph> <ept id=\"p2\">*</ept>FieldIdentifier**","source":"*Field = Aggregate ` ( ` *FieldIdentifier* ` ) | ` *FieldIdentifier**"},{"pos":[3121,3178],"content":"<bpt id=\"p1\">*</bpt>Aggregate<ept id=\"p1\">*</ept><ph id=\"ph1\"> = </ph><ph id=\"ph2\">`sum`</ph><ph id=\"ph3\"> | </ph><ph id=\"ph4\">`avg`</ph><ph id=\"ph5\"> | </ph><ph id=\"ph6\">`minof`</ph><ph id=\"ph7\"> | </ph><ph id=\"ph8\">`maxof`</ph><ph id=\"ph9\"> | </ph><ph id=\"ph10\">`count`</ph>","source":"*Aggregate* = `sum` | `avg` | `minof` | `maxof` | `count`"},{"pos":[3183,3333],"content":"<bpt id=\"p1\">*</bpt>Options <ept id=\"p1\">*</ept><ph id=\"ph1\">= </ph><ph id=\"ph2\">`[ order by`</ph> , <ph id=\"ph3\">`group by , `</ph> <bpt id=\"p2\">*</bpt>FieldIdentifier<ept id=\"p2\">*</ept> <ph id=\"ph4\">` [ asc`</ph><ph id=\"ph5\"> | </ph><ph id=\"ph6\">`desc ] { , `</ph> <bpt id=\"p3\">*</bpt>FieldIdentifier<ept id=\"p3\">*</ept> <ph id=\"ph7\">` [ asc`</ph><ph id=\"ph8\"> | </ph><ph id=\"ph9\">`desc ] }]`</ph><ph id=\"ph10\"> | </ph><ph id=\"ph11\">`[ `</ph> <bpt id=\"p4\">*</bpt>IndexClause<ept id=\"p4\">*</ept> <ph id=\"ph12\">` ]`</ph>","source":"*Options *= `[ order by` , `group by , ` *FieldIdentifier* ` [ asc` | `desc ] { , ` *FieldIdentifier* ` [ asc` | `desc ] }]` | `[ ` *IndexClause* ` ]`"},{"pos":[3338,3403],"content":"<bpt id=\"p1\">*</bpt>IndexClause <ept id=\"p1\">*</ept><ph id=\"ph1\"> = </ph><ph id=\"ph2\">`index `</ph> <bpt id=\"p2\">*</bpt>IndexName<ept id=\"p2\">*</ept><ph id=\"ph3\"> | </ph><ph id=\"ph4\">`index hint `</ph> <bpt id=\"p3\">*</bpt>IndexName<ept id=\"p3\">*</ept>","source":"*IndexClause * = `index ` *IndexName* | `index hint ` *IndexName*"},{"pos":[3408,3445],"content":"<bpt id=\"p1\">*</bpt>WhereClause <ept id=\"p1\">*</ept><ph id=\"ph1\">= </ph><ph id=\"ph2\">`where `</ph> <bpt id=\"p2\">*</bpt>Expression<ept id=\"p2\">*</ept>","source":"*WhereClause *= `where ` *Expression*"},{"pos":[3450,3523],"content":"<bpt id=\"p1\">*</bpt>JoinClause <ept id=\"p1\">*</ept><ph id=\"ph1\">= </ph><ph id=\"ph2\">\\[</ph><ph id=\"ph3\">`exists`</ph><ph id=\"ph4\"> | </ph><ph id=\"ph5\">`notexists`</ph><ph id=\"ph6\"> | </ph><ph id=\"ph7\">`outer`</ph> <ph id=\"ph8\">\\]</ph> <ph id=\"ph9\">`join `</ph> <bpt id=\"p2\">*</bpt>Parameters<ept id=\"p2\">*</ept>","source":"*JoinClause *= \\[`exists` | `notexists` | `outer` \\] `join ` *Parameters*"},{"pos":[4109,4126],"content":"<bpt id=\"p1\">*</bpt>SelectStatement<ept id=\"p1\">*</ept>","source":"*SelectStatement*"},{"pos":[4135,4156],"content":"<ph id=\"ph1\">`select`</ph> <bpt id=\"p1\">*</bpt>Parameters<ept id=\"p1\">*</ept>","source":"`select` *Parameters*"},{"pos":[4400,4412],"content":"<bpt id=\"p1\">*</bpt>Parameters<ept id=\"p1\">*</ept>","source":"*Parameters*"},{"pos":[4426,4591],"content":"<ph id=\"ph1\">`[ [ `</ph> <bpt id=\"p1\">*</bpt>FindOptions<ept id=\"p1\">*</ept> <ph id=\"ph2\">` ]`</ph> <ph id=\"ph3\">`[ `</ph> <bpt id=\"p2\">*</bpt>FieldList<ept id=\"p2\">*</ept> <ph id=\"ph4\">` from ] ]`</ph> <bpt id=\"p3\">*</bpt>TableBufferVariable<ept id=\"p3\">*</ept> <ph id=\"ph5\">`[`</ph> <bpt id=\"p4\">*</bpt>IndexClause<ept id=\"p4\">*</ept> <ph id=\"ph6\">`]`</ph> <ph id=\"ph7\">`[ `</ph> <bpt id=\"p5\">*</bpt>Options<ept id=\"p5\">*</ept> <ph id=\"ph8\">` ]`</ph> <ph id=\"ph9\">`[ `</ph> <bpt id=\"p6\">*</bpt>WhereClause<ept id=\"p6\">*</ept> <ph id=\"ph10\">` ]`</ph> <ph id=\"ph11\">`[ `</ph> <bpt id=\"p7\">*</bpt>JoinClause<ept id=\"p7\">*</ept> <ph id=\"ph12\">` ]`</ph>","source":"`[ [ ` *FindOptions* ` ]` `[ ` *FieldList* ` from ] ]` *TableBufferVariable* `[` *IndexClause* `]` `[ ` *Options* ` ]` `[ ` *WhereClause* ` ]` `[ ` *JoinClause* ` ]`"},{"pos":[4691,4704],"content":"<bpt id=\"p1\">*</bpt>FindOptions<ept id=\"p1\">*</ept>","source":"*FindOptions*"},{"pos":[4760,4774],"content":"<ph id=\"ph1\">\\[</ph> <ph id=\"ph2\">`firstOnly`</ph>","source":"\\[ `firstOnly`"},{"pos":[4810,4828],"content":"<ph id=\"ph1\">`firstOnly1000`</ph> <ph id=\"ph2\">\\]</ph>","source":"`firstOnly1000` \\]"},{"pos":[4982,4993],"content":"<bpt id=\"p1\">*</bpt>FieldList<ept id=\"p1\">*</ept>","source":"*FieldList*"},{"pos":[5008,5036],"content":"<bpt id=\"p1\">*</bpt>Field<ept id=\"p1\">*</ept> <ph id=\"ph1\">` { , `</ph> <bpt id=\"p2\">*</bpt>Field<ept id=\"p2\">*</ept> <ph id=\"ph2\">` }`</ph>","source":"*Field* ` { , ` *Field* ` }`"},{"pos":[5273,5280],"content":"<bpt id=\"p1\">*</bpt>Field<ept id=\"p1\">*</ept>","source":"*Field*"},{"pos":[5299,5338],"content":"<bpt id=\"p1\">*</bpt>Aggregate<ept id=\"p1\">*</ept> <ph id=\"ph1\">` ( `</ph> <bpt id=\"p2\">*</bpt>FieldIdentifier<ept id=\"p2\">*</ept> ` )","source":"*Aggregate* ` ( ` *FieldIdentifier* ` )"},{"pos":[5341,5360],"content":"<ph id=\"ph1\">` </ph><bpt id=\"p1\">*</bpt>FieldIdentifier<ept id=\"p1\">*</ept>","source":"` *FieldIdentifier*"},{"pos":[5564,5575],"content":"<bpt id=\"p1\">*</bpt>Aggregate<ept id=\"p1\">*</ept>","source":"*Aggregate*"},{"pos":[5855,5864],"content":"<bpt id=\"p1\">*</bpt>Options<ept id=\"p1\">*</ept>","source":"*Options*"},{"pos":[5881,5936],"content":"<ph id=\"ph1\">`[ order by`</ph> , <ph id=\"ph2\">`group by , `</ph> <bpt id=\"p1\">*</bpt>FieldIdentifier<ept id=\"p1\">*</ept> <ph id=\"ph3\">` [ asc`</ph>","source":"`[ order by` , `group by , ` *FieldIdentifier* ` [ asc`"},{"pos":[5939,5979],"content":"<ph id=\"ph1\">`desc ] { , `</ph> <bpt id=\"p1\">*</bpt>FieldIdentifier<ept id=\"p1\">*</ept> <ph id=\"ph2\">` [ asc`</ph>","source":"`desc ] { , ` *FieldIdentifier* ` [ asc`"},{"pos":[5996,6019],"content":"<ph id=\"ph1\">`[ `</ph> <bpt id=\"p1\">*</bpt>IndexClause<ept id=\"p1\">*</ept> <ph id=\"ph2\">` ]`</ph>","source":"`[ ` *IndexClause* ` ]`"},{"pos":[6146,6159],"content":"<bpt id=\"p1\">*</bpt>IndexClause<ept id=\"p1\">*</ept>","source":"*IndexClause*"},{"pos":[6172,6192],"content":"<ph id=\"ph1\">`index `</ph> <bpt id=\"p1\">*</bpt>IndexName<ept id=\"p1\">*</ept>","source":"`index ` *IndexName*"},{"pos":[6195,6220],"content":"<ph id=\"ph1\">`index hint `</ph> <bpt id=\"p1\">*</bpt>IndexName<ept id=\"p1\">*</ept>","source":"`index hint ` *IndexName*"},{"pos":[6437,6450],"content":"<bpt id=\"p1\">*</bpt>WhereClause<ept id=\"p1\">*</ept>","source":"*WhereClause*"},{"pos":[6463,6484],"content":"<ph id=\"ph1\">`where `</ph> <bpt id=\"p1\">*</bpt>Expression<ept id=\"p1\">*</ept>","source":"`where ` *Expression*"},{"pos":[6728,6740],"content":"<bpt id=\"p1\">*</bpt>JoinClause<ept id=\"p1\">*</ept>","source":"*JoinClause*"},{"pos":[6781,6812],"content":"<ph id=\"ph1\">`outer`</ph> <ph id=\"ph2\">\\]</ph> <ph id=\"ph3\">`join `</ph> <bpt id=\"p1\">*</bpt>Parameters<ept id=\"p1\">*</ept>","source":"`outer` \\] `join ` *Parameters*"},{"pos":[7022,7056],"content":"Keywords Used in the Select Syntax","linkify":"Keywords Used in the Select Syntax","nodes":[{"content":"Keywords Used in the Select Syntax","pos":[0,34]}]},{"content":"The <bpt id=\"p1\">**</bpt>asc<ept id=\"p1\">**</ept> keyword is an option on the <ph id=\"ph1\">`order by`</ph> or <ph id=\"ph2\">`group by`</ph> clause.","pos":[7058,7130],"source":"The **asc** keyword is an option on the `order by` or `group by` clause."},{"content":"The sorting is ascending.","pos":[7131,7156]},{"content":"(Sort is ascending by default.) The <bpt id=\"p1\">**</bpt>avg<ept id=\"p1\">**</ept> keyword returns the average of the fields.","pos":[7157,7243],"source":" (Sort is ascending by default.) The **avg** keyword returns the average of the fields."},{"content":"The <bpt id=\"p1\">**</bpt>count<ept id=\"p1\">**</ept> keyword returns the number of records.","pos":[7244,7296],"source":" The **count** keyword returns the number of records."},{"content":"The <bpt id=\"p1\">**</bpt>crossCompany<ept id=\"p1\">**</ept> keyword returns data for all companies that the user is authorized to read from.","pos":[7297,7398],"source":" The **crossCompany** keyword returns data for all companies that the user is authorized to read from."},{"content":"(A <ph id=\"ph1\">`container`</ph> can be added to reduce the number of companies involved.) The <bpt id=\"p1\">**</bpt>desc<ept id=\"p1\">**</ept> keyword is an option on the <ph id=\"ph2\">`order by`</ph> or <ph id=\"ph3\">`group by`</ph> clause.","pos":[7399,7545],"source":" (A `container` can be added to reduce the number of companies involved.) The **desc** keyword is an option on the `order by` or `group by` clause."},{"content":"The sorting is descending.","pos":[7546,7572]},{"content":"The <bpt id=\"p1\">**</bpt>exists<ept id=\"p1\">**</ept> keyword is a method that returns a Boolean value and a <ph id=\"ph1\">`join`</ph> clause.","pos":[7573,7657],"source":" The **exists** keyword is a method that returns a Boolean value and a `join` clause."},{"content":"The <bpt id=\"p1\">**</bpt>firstFast<ept id=\"p1\">**</ept> keyword is a priority hint.","pos":[7658,7703],"source":" The **firstFast** keyword is a priority hint."},{"content":"The first row appears more quickly but the total return time for this option might be slower.","pos":[7704,7797]},{"content":"The <ph id=\"ph1\">`firstFast`</ph> hint is automatically issued from all forms.","pos":[7798,7858],"source":" The `firstFast` hint is automatically issued from all forms."},{"content":"The <bpt id=\"p1\">**</bpt>firstOnly<ept id=\"p1\">**</ept> keyword speeds up the fetch by returning only the first row.","pos":[7859,7937],"source":" The **firstOnly** keyword speeds up the fetch by returning only the first row."},{"content":"The <bpt id=\"p1\">**</bpt>firstOnly10<ept id=\"p1\">**</ept> keyword is the same as <bpt id=\"p2\">**</bpt>firstOnly<ept id=\"p2\">**</ept>, except returns 10 rows instead of one.","pos":[7938,8034],"source":" The **firstOnly10** keyword is the same as **firstOnly**, except returns 10 rows instead of one."},{"content":"The <bpt id=\"p1\">**</bpt>firstOnly100<ept id=\"p1\">**</ept> keyword is the same as <bpt id=\"p2\">**</bpt>firstOnly<ept id=\"p2\">**</ept>, except returns 100 rows instead of one.","pos":[8035,8133],"source":" The **firstOnly100** keyword is the same as **firstOnly**, except returns 100 rows instead of one."},{"content":"The <bpt id=\"p1\">**</bpt>firstOnly1000<ept id=\"p1\">**</ept> keyword is the same as <bpt id=\"p2\">**</bpt>firstOnly<ept id=\"p2\">**</ept>, except returns 1000 rows instead of one.","pos":[8134,8234],"source":" The **firstOnly1000** keyword is the same as **firstOnly**, except returns 1000 rows instead of one."},{"content":"The <bpt id=\"p1\">**</bpt>forceLiterals<ept id=\"p1\">**</ept> keyword instructs the kernel to reveal the actual values that are used in <ph id=\"ph1\">`where`</ph> clauses to the Microsoft SQL Server database at the time of optimization.","pos":[8235,8412],"source":" The **forceLiterals** keyword instructs the kernel to reveal the actual values that are used in `where` clauses to the Microsoft SQL Server database at the time of optimization."},{"content":"<bpt id=\"p1\">**</bpt>forceLiterals<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>forcePlaceholders<ept id=\"p2\">**</ept> are mutually exclusive.","pos":[8413,8480],"source":"**forceLiterals** and **forcePlaceholders** are mutually exclusive."},{"content":"You are advised not to use the <bpt id=\"p1\">**</bpt>forceLiterals<ept id=\"p1\">**</ept> keyword in <ph id=\"ph1\">`select`</ph> statements, because it could expose code to an SQL injection security threat.","pos":[8481,8627],"source":" You are advised not to use the **forceLiterals** keyword in `select` statements, because it could expose code to an SQL injection security threat."},{"content":"The <bpt id=\"p1\">**</bpt>forceNestedLoop<ept id=\"p1\">**</ept> keyword forces the Microsoft SQL Server database to use a nested-loop algorithm to process a particular SQL statement containing a join algorithm.","pos":[8628,8798],"source":" The **forceNestedLoop** keyword forces the Microsoft SQL Server database to use a nested-loop algorithm to process a particular SQL statement containing a join algorithm."},{"content":"This means that a record from the first table is fetched before any records from the second table are fetched.","pos":[8799,8909]},{"content":"Typically, other join algorithms, such as hash-joins and merge-joins, would be considered.","pos":[8910,9000]},{"content":"This keyword is often combined with the <bpt id=\"p1\">**</bpt>forceSelectOrder<ept id=\"p1\">**</ept> keyword.","pos":[9001,9070],"source":" This keyword is often combined with the **forceSelectOrder** keyword."},{"content":"The <bpt id=\"p1\">**</bpt>forcePlaceholders<ept id=\"p1\">**</ept> keyword instructs the kernel not to reveal the actual values used in <ph id=\"ph1\">`where`</ph> clauses to the SQL Server database at the time of optimization.","pos":[9071,9237],"source":" The **forcePlaceholders** keyword instructs the kernel not to reveal the actual values used in `where` clauses to the SQL Server database at the time of optimization."},{"content":"This is the default in all statements that are not <ph id=\"ph1\">`join`</ph> statements.The advantage of using this keyword is that the kernel can reuse the access plan for other similar statements with other search values.","pos":[9238,9442],"source":" This is the default in all statements that are not `join` statements.The advantage of using this keyword is that the kernel can reuse the access plan for other similar statements with other search values."},{"content":"The disadvantage is that the access plan is computed without taking into consideration that data distribution might not be even.","pos":[9443,9571]},{"content":"The access plan is an on-average access plan.","pos":[9572,9617]},{"content":"<bpt id=\"p1\">**</bpt>forcePlaceholders<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>forceLiterals<ept id=\"p2\">**</ept> are mutually exclusive.","pos":[9618,9685],"source":"**forcePlaceholders** and **forceLiterals** are mutually exclusive."},{"content":"The <bpt id=\"p1\">**</bpt>forceSelectOrder<ept id=\"p1\">**</ept> keyword forces the SQL Server database to access the tables in a join in the specified order.","pos":[9686,9804],"source":" The **forceSelectOrder** keyword forces the SQL Server database to access the tables in a join in the specified order."},{"content":"If two tables are joined, the first table in the statement is always accessed first.","pos":[9805,9889]},{"content":"This keyword is often combined with the <bpt id=\"p1\">**</bpt>forceNestedLoop<ept id=\"p1\">**</ept> keyword.","pos":[9890,9958],"source":" This keyword is often combined with the **forceNestedLoop** keyword."},{"content":"The <bpt id=\"p1\">**</bpt>forUpdate<ept id=\"p1\">**</ept> keyword selects records exclusively for update.","pos":[9959,10024],"source":" The **forUpdate** keyword selects records exclusively for update."},{"content":"Depending on the underlying database, the records may be locked for other users.","pos":[10025,10105]},{"content":"The <bpt id=\"p1\">**</bpt>group by<ept id=\"p1\">**</ept> keyword instructs the database to group selected records by fields.","pos":[10106,10190],"source":" The **group by** keyword instructs the database to group selected records by fields."},{"content":"The <bpt id=\"p1\">**</bpt>index<ept id=\"p1\">**</ept> keyword instructs the database to sort the selected records as defined by the index.","pos":[10191,10289],"source":" The **index** keyword instructs the database to sort the selected records as defined by the index."},{"content":"The <bpt id=\"p1\">**</bpt>index hint<ept id=\"p1\">**</ept> keyword gives the database a hint to use this index to sort the selected records as defined by the index.","pos":[10290,10414],"source":" The **index hint** keyword gives the database a hint to use this index to sort the selected records as defined by the index."},{"content":"The database can ignore the hint.","pos":[10415,10448]},{"content":"A wrong index hint can have a big performance impact.","pos":[10449,10502]},{"content":"Index hints should only be applied to SQL statements that do not have dynamic <ph id=\"ph1\">`where`</ph> clauses or <ph id=\"ph2\">`order by`</ph> clauses, and where the effect of the hint can be verified.","pos":[10503,10669],"source":" Index hints should only be applied to SQL statements that do not have dynamic `where` clauses or `order by` clauses, and where the effect of the hint can be verified."},{"content":"The <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> keyword used to join tables on a column that is common to both tables.","pos":[10670,10753],"source":" The **join** keyword used to join tables on a column that is common to both tables."},{"content":"The join criteria are specified in the <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause because there is no <bpt id=\"p2\">**</bpt>on<ept id=\"p2\">**</ept> keyword.","pos":[10754,10845],"source":" The join criteria are specified in the **where** clause because there is no **on** keyword."},{"content":"Reduces the number of SQL statements that are needed if you want to loop through a table and update transactions in a related table.","pos":[10846,10978]},{"content":"For example, if you process 500 records in a table, and want to update related records in another table, and use a nested <ph id=\"ph1\">`while select`</ph> to do this, there will be 501 trips to the database.","pos":[10979,11168],"source":" For example, if you process 500 records in a table, and want to update related records in another table, and use a nested `while select` to do this, there will be 501 trips to the database."},{"content":"If you use a <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept>, there will be a single trip to the database.","pos":[11169,11236],"source":" If you use a **join**, there will be a single trip to the database."},{"content":"The <bpt id=\"p1\">**</bpt>maxof<ept id=\"p1\">**</ept> keyword returns the maximum of the fields.","pos":[11237,11293],"source":" The **maxof** keyword returns the maximum of the fields."},{"content":"The <bpt id=\"p1\">**</bpt>minof<ept id=\"p1\">**</ept> keyword returns the minimum of the fields.","pos":[11294,11350],"source":" The **minof** keyword returns the minimum of the fields."},{"content":"The <bpt id=\"p1\">**</bpt>noFetch<ept id=\"p1\">**</ept> keyword indicates that no records are to be fetched at present.","pos":[11351,11430],"source":" The **noFetch** keyword indicates that no records are to be fetched at present."},{"content":"This is typically used when the result of the select is passed on to another application object, for example, a query that performs the actual fetch.","pos":[11431,11580]},{"content":"The <bpt id=\"p1\">**</bpt>notExists<ept id=\"p1\">**</ept> keyword is chosen only if there are no posts.","pos":[11581,11644],"source":" The **notExists** keyword is chosen only if there are no posts."},{"content":"The <bpt id=\"p1\">**</bpt>optimisticLock<ept id=\"p1\">**</ept> keyword forces a statement to run with Optimistic Concurrency Control even if a different value is set on the table.For more information, see Optimistic Concurrency Control.","pos":[11645,11841],"source":" The **optimisticLock** keyword forces a statement to run with Optimistic Concurrency Control even if a different value is set on the table.For more information, see Optimistic Concurrency Control."},{"content":"The <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> keyword instructs the database to sort the selected records by fields in the <ph id=\"ph1\">`order by`</ph> list.","pos":[11842,11952],"source":" The **order by** keyword instructs the database to sort the selected records by fields in the `order by` list."},{"content":"The <bpt id=\"p1\">**</bpt>outer<ept id=\"p1\">**</ept> keyword returns all rows from the first-named table, including rows that have no match in the second-named table.","pos":[11953,12080],"source":" The **outer** keyword returns all rows from the first-named table, including rows that have no match in the second-named table."},{"content":"This is a left outer join, although there is no <bpt id=\"p1\">**</bpt>left<ept id=\"p1\">**</ept> keyword.","pos":[12081,12146],"source":" This is a left outer join, although there is no **left** keyword."},{"content":"There is no right outer join.","pos":[12147,12176]},{"content":"The <bpt id=\"p1\">**</bpt>pessimisticLock<ept id=\"p1\">**</ept> keyword forces a statement to run with Pessimistic Concurrency Control even if a different value is set on the table.For more information, see Optimistic Concurrency Control.","pos":[12177,12375],"source":" The **pessimisticLock** keyword forces a statement to run with Pessimistic Concurrency Control even if a different value is set on the table.For more information, see Optimistic Concurrency Control."},{"content":"The <bpt id=\"p1\">**</bpt>repeatableRead<ept id=\"p1\">**</ept> keyword specifies that no other transactions can modify data that has been read by logic inside the current transaction, until after the current transaction completes.An explicit transaction completes at either <bpt id=\"p2\">**</bpt>ttsAbort<ept id=\"p2\">**</ept> or at the outermost <bpt id=\"p3\">**</bpt>ttsCommit<ept id=\"p3\">**</ept>.","pos":[12376,12657],"source":" The **repeatableRead** keyword specifies that no other transactions can modify data that has been read by logic inside the current transaction, until after the current transaction completes.An explicit transaction completes at either **ttsAbort** or at the outermost **ttsCommit**."},{"content":"For a stand-alone <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement, the transaction duration is the duration of the <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> command.","pos":[12658,12765],"source":" For a stand-alone **select** statement, the transaction duration is the duration of the **select** command."},{"content":"However, the database sometimes enforces the equivalent of <bpt id=\"p1\">**</bpt>repeatableRead<ept id=\"p1\">**</ept> in individual <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statements even without this keyword appearing in your code (depending on how the database decides to scan the tables).","pos":[12766,12988],"source":" However, the database sometimes enforces the equivalent of **repeatableRead** in individual **select** statements even without this keyword appearing in your code (depending on how the database decides to scan the tables)."},{"content":"For more information, see the documentation for the underlying relational database product.","pos":[12989,13080]},{"content":"The <bpt id=\"p1\">**</bpt>reverse<ept id=\"p1\">**</ept> keyword records are returned in reverse order.","pos":[13081,13143],"source":" The **reverse** keyword records are returned in reverse order."},{"content":"The <bpt id=\"p1\">**</bpt>sum<ept id=\"p1\">**</ept> keyword returns the sum of the fields.","pos":[13144,13194],"source":" The **sum** keyword returns the sum of the fields."},{"content":"Can be used to sum all accounts, order lines, and so on.","pos":[13195,13251]},{"content":"The <bpt id=\"p1\">**</bpt>validTimeState<ept id=\"p1\">**</ept> keyword filters rows from a table that has its ValidTimeStateFieldType property set to a value other than None.","pos":[13252,13386],"source":" The **validTimeState** keyword filters rows from a table that has its ValidTimeStateFieldType property set to a value other than None."},{"content":"For more information, see Valid Time State Tables and Date Effective Data.","pos":[13387,13461]},{"pos":[13468,13489],"content":"Keyword Code Examples","linkify":"Keyword Code Examples","nodes":[{"content":"Keyword Code Examples","pos":[0,21]}]},{"pos":[19433,19458],"content":"Select Statement Examples","linkify":"Select Statement Examples","nodes":[{"content":"Select Statement Examples","pos":[0,25]}]},{"pos":[19459,19547],"content":"The following method shows several examples of how you can use the <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement.","source":"The following method shows several examples of how you can use the **select** statement."},{"pos":[22127,22144],"content":"Join Code Example","linkify":"Join Code Example","nodes":[{"content":"Join Code Example","pos":[0,17]}]},{"content":"This code example shows how an inner <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> can be performed as part of an SQL <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement.","pos":[22146,22248],"source":"This code example shows how an inner **join** can be performed as part of an SQL **select** statement."},{"content":"The example also shows an order by clause that has each field qualified by a table name.","pos":[22249,22337]},{"content":"This enables you to control how the retrieved records are sorted by using only one order by clause.","pos":[22338,22437]},{"pos":[24020,24041],"content":"Group By and Order By","linkify":"Group By and Order By","nodes":[{"content":"Group By and Order By","pos":[0,21]}]},{"content":"This code example shows that the fields in the <bpt id=\"p1\">**</bpt>group by<ept id=\"p1\">**</ept> clause can be qualified with a table name.","pos":[24043,24145],"source":"This code example shows that the fields in the **group by** clause can be qualified with a table name."},{"content":"There can be multiple <ph id=\"ph1\">`group by`</ph> clauses instead of just one.","pos":[24146,24207],"source":" There can be multiple `group by` clauses instead of just one."},{"content":"The fields can be qualified by table name in only one <ph id=\"ph1\">`group by`</ph> clause.","pos":[24208,24280],"source":" The fields can be qualified by table name in only one `group by` clause."},{"content":"Use of table name qualifiers is recommended.","pos":[24281,24325]},{"content":"The <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> clause follows the same syntax patterns that group by follows.","pos":[24326,24405],"source":" The **order by** clause follows the same syntax patterns that group by follows."},{"content":"If provided, both clauses must appear after the <ph id=\"ph1\">`join`</ph> (or <ph id=\"ph2\">`from`</ph>) clause, and both must appear before the <ph id=\"ph3\">`where`</ph> clause that might exist on the same <ph id=\"ph4\">`join`</ph>.","pos":[24406,24564],"source":" If provided, both clauses must appear after the `join` (or `from`) clause, and both must appear before the `where` clause that might exist on the same `join`."},{"content":"It is recommended that all group by and order by and <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clauses appear immediately after the last <ph id=\"ph1\">`join`</ph> clause.","pos":[24565,24684],"source":" It is recommended that all group by and order by and **where** clauses appear immediately after the last `join` clause."},{"pos":[26035,26070],"content":"Select Statement with an Outer Join","linkify":"Select Statement with an Outer Join","nodes":[{"content":"Select Statement with an Outer Join","pos":[0,35]}]},{"content":"The <ph id=\"ph1\">`select`</ph> statement supports filtering an <bpt id=\"p1\">**</bpt>outer join<ept id=\"p1\">**</ept> in the <ph id=\"ph2\">`where`</ph> clause.","pos":[26072,26154],"source":"The `select` statement supports filtering an **outer join** in the `where` clause."},{"content":"In the <ph id=\"ph1\">`join`</ph> clause of standard SQL there is an <ph id=\"ph2\">`on`</ph> keyword for filter criteria, but that isn't supported in X++.","pos":[26155,26270],"source":" In the `join` clause of standard SQL there is an `on` keyword for filter criteria, but that isn't supported in X++."},{"content":"An inner join rejects all table rows that fail to match a row in the other joined table.","pos":[26271,26359]},{"content":"But an outer join includes rows from the first table even though there is no matching row in the other joined table.","pos":[26360,26476]},{"content":"Default values are substituted for the data that could not be obtained from a matching row in the other joined table.","pos":[26477,26594]},{"content":"You can filter an outer join at the equivalent of an <ph id=\"ph1\">`on`</ph> clause that is part of the <ph id=\"ph2\">`join`</ph> clause.","pos":[26595,26694],"source":" You can filter an outer join at the equivalent of an `on` clause that is part of the `join` clause."},{"content":"For more information, see How to: Use the QueryFilter Class with Outer Joins.","pos":[26695,26772]},{"content":"For an inner join there is no behavioral difference between filtering on an <ph id=\"ph1\">`on`</ph> clause versus on the <ph id=\"ph2\">`where`</ph> clause.","pos":[26773,26890],"source":" For an inner join there is no behavioral difference between filtering on an `on` clause versus on the `where` clause."},{"pos":[26897,26926],"content":"Select statement code example","linkify":"Select statement code example","nodes":[{"content":"Select statement code example","pos":[0,29]}]},{"content":"This code example is based on two tables.","pos":[26928,26969]},{"content":"The field types and example data are included.","pos":[26970,27016]},{"content":"There is a 1-to-many relationship between the <ph id=\"ph1\">`SalesOrder`</ph> parent table and the <ph id=\"ph2\">`SalesOrderLine`</ph> child table.","pos":[27017,27126],"source":" There is a 1-to-many relationship between the `SalesOrder` parent table and the `SalesOrderLine` child table."},{"content":"There are 0 or more rows in the <ph id=\"ph1\">`SalesOrderLine`</ph> table for each row in the <ph id=\"ph2\">`SalesOrder`</ph> table.","pos":[27127,27221],"source":" There are 0 or more rows in the `SalesOrderLine` table for each row in the `SalesOrder` table."},{"content":"There are two rows in the <ph id=\"ph1\">`SalesOrder`</ph> table.","pos":[27222,27267],"source":" There are two rows in the `SalesOrder` table."},{"pos":[27271,27308],"content":"<ph id=\"ph1\">`SalesOrderID`</ph> (integer, primary key)","source":"`SalesOrderID` (integer, primary key)"},{"pos":[27311,27329],"content":"<ph id=\"ph1\">`DateAdded`</ph> (date)","source":"`DateAdded` (date)"},{"content":"1","pos":[27397,27398]},{"content":"2010-01-01","pos":[27437,27447]},{"content":"2","pos":[27460,27461]},{"content":"2010-02-02","pos":[27500,27510]},{"content":"The <ph id=\"ph1\">`SalesOrderLine`</ph> table contains a foreign key field, named <ph id=\"ph2\">`SalesOrderID`</ph>, that references the primary key column of the <ph id=\"ph3\">`SalesOrder`</ph> table.","pos":[27522,27666],"source":"The `SalesOrderLine` table contains a foreign key field, named `SalesOrderID`, that references the primary key column of the `SalesOrder` table."},{"content":"The <ph id=\"ph1\">`SalesOrderID`</ph> value <ph id=\"ph2\">`2`</ph> does not occur in the data for <ph id=\"ph3\">`SalesOrderLine`</ph> table.","pos":[27667,27750],"source":" The `SalesOrderID` value `2` does not occur in the data for `SalesOrderLine` table."},{"pos":[27754,27794],"content":"<ph id=\"ph1\">`SalesOrderLineID`</ph> (string, primary key)","source":"`SalesOrderLineID` (string, primary key)"},{"pos":[27797,27817],"content":"<ph id=\"ph1\">`Quantity`</ph> (integer)","source":"`Quantity` (integer)"},{"pos":[27820,27857],"content":"<ph id=\"ph1\">`SalesOrderID`</ph> (integer, foreign key)","source":"`SalesOrderID` (integer, foreign key)"},{"content":"AA","pos":[27970,27972]},{"content":"32","pos":[28013,28015]},{"content":"1","pos":[28036,28037]},{"content":"BB","pos":[28078,28080]},{"content":"67","pos":[28121,28123]},{"content":"1","pos":[28144,28145]},{"content":"CC","pos":[28186,28188]},{"content":"66","pos":[28229,28231]},{"content":"1","pos":[28252,28253]},{"content":"The code example has a <ph id=\"ph1\">`select`</ph> statement that reads the tables which are described in the previous section.","pos":[28293,28401],"source":"The code example has a `select` statement that reads the tables which are described in the previous section."},{"content":"The <ph id=\"ph1\">`select`</ph> statement includes a left <ph id=\"ph2\">`outer join`</ph> clause.","pos":[28402,28461],"source":" The `select` statement includes a left `outer join` clause."},{"content":"The join criteria and the data filter are both on the <ph id=\"ph1\">`where`</ph> clause.","pos":[28462,28531],"source":" The join criteria and the data filter are both on the `where` clause."},{"content":"The output from the code example is also in this section.","pos":[28532,28589]},{"content":"The second record in the output has a <ph id=\"ph1\">`SalesOrderID`</ph> value of 2.","pos":[28590,28654],"source":" The second record in the output has a `SalesOrderID` value of 2."},{"content":"That value of 2 is not present in the <ph id=\"ph1\">`SalesOrderLine`</ph> table.","pos":[28655,28716],"source":" That value of 2 is not present in the `SalesOrderLine` table."},{"content":"Therefore, some of the fields in the second record have default values, namely 0 for an integer and a zero length string for a string.","pos":[28717,28851]},{"pos":[30114,30137],"content":"while select statements","linkify":"while select statements","nodes":[{"content":"while select statements","pos":[0,23]}]},{"content":"<bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> statements are used to handle data.","pos":[30138,30190],"source":"**while select** statements are used to handle data."},{"content":"They are the most widely used form of the select statement.","pos":[30191,30250]},{"content":"<ph id=\"ph1\">`while select`</ph> loops over many records (meeting certain criteria) and can execute a statement on each record.","pos":[30251,30360],"source":"`while select` loops over many records (meeting certain criteria) and can execute a statement on each record."},{"content":"When you perform data manipulation by using the <ph id=\"ph1\">`while select`</ph> statement, you would typically do this in a transaction to ensure data integrity.","pos":[30361,30505],"source":" When you perform data manipulation by using the `while select` statement, you would typically do this in a transaction to ensure data integrity."},{"content":"The results of a <ph id=\"ph1\">`while select`</ph> statement are returned in a table buffer variable.","pos":[30506,30588],"source":" The results of a `while select` statement are returned in a table buffer variable."},{"content":"If you use a field list in the <ph id=\"ph1\">`select`</ph> statement, only those fields are available in the table variable.","pos":[30589,30694],"source":" If you use a field list in the `select` statement, only those fields are available in the table variable."},{"content":"If you use aggregate functions such as <ph id=\"ph1\">`sum`</ph> or <ph id=\"ph2\">`count`</ph>, the results are returned in the fields you perform the <ph id=\"ph3\">`sum`</ph> or <ph id=\"ph4\">`count`</ph> over.","pos":[30695,30829],"source":" If you use aggregate functions such as `sum` or `count`, the results are returned in the fields you perform the `sum` or `count` over."},{"content":"You can only count, average, or sum the integer and real fields.","pos":[30830,30894]},{"content":"The syntax of a <ph id=\"ph1\">`while select`</ph> statement resembles that of a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement except that it is preceded by <ph id=\"ph2\">`while select`</ph> instead of <ph id=\"ph3\">`select`</ph>.","pos":[30895,31042],"source":" The syntax of a `while select` statement resembles that of a **select** statement except that it is preceded by `while select` instead of `select`."},{"content":"The <ph id=\"ph1\">`select`</ph> statement itself is executed only one time, immediately before the first iteration of the statements in the loop.","pos":[31043,31169],"source":" The `select` statement itself is executed only one time, immediately before the first iteration of the statements in the loop."},{"content":"Any Boolean expressions (such as <ph id=\"ph1\">`iCounter &lt; 1`</ph>) added to the <ph id=\"ph2\">`while select`</ph> are tested only one time.","pos":[31170,31272],"source":" Any Boolean expressions (such as `iCounter < 1`) added to the `while select` are tested only one time."},{"content":"This differs from how the <ph id=\"ph1\">`while`</ph> statement behaves in languages such as C++ and C<ph id=\"ph2\">\\#</ph>. For example, the following loop could iterate more than one time.","pos":[31273,31424],"source":" This differs from how the `while` statement behaves in languages such as C++ and C\\#. For example, the following loop could iterate more than one time."},{"pos":[31861,31886],"content":"while select Code Example","linkify":"while select Code Example","nodes":[{"content":"while select Code Example","pos":[0,25]}]},{"pos":[31888,32020],"content":"This prints the name reference and telephone number of customers in <ph id=\"ph1\">`CustTable`</ph> who have an account number within a specified range.","source":"This prints the name reference and telephone number of customers in `CustTable` who have an account number within a specified range."},{"pos":[32658,32683],"content":"while select Code Example","linkify":"while select Code Example","nodes":[{"content":"while select Code Example","pos":[0,25]}]},{"pos":[32685,32734],"content":"This code example uses the <bpt id=\"p1\">**</bpt>forUpdate<ept id=\"p1\">**</ept> keyword.","source":"This code example uses the **forUpdate** keyword."},{"pos":[33622,33647],"content":"Deleting a Set of Records","linkify":"Deleting a Set of Records","nodes":[{"content":"Deleting a Set of Records","pos":[0,25]}]},{"content":"You can use a <ph id=\"ph1\">`while select`</ph> statement to loop over a set of records that meet some criteria and perform an action on each record.","pos":[33649,33779],"source":"You can use a `while select` statement to loop over a set of records that meet some criteria and perform an action on each record."},{"content":"One such action is to <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> a set of records.","pos":[33780,33830],"source":" One such action is to **delete** a set of records."},{"content":"<ph id=\"ph1\">`{    TableName myXrec;    while select myXrec      where `</ph> <bpt id=\"p1\">*</bpt>Conditions<ept id=\"p1\">*</ept>  <ph id=\"ph2\">`  {      myXrec.delete();    }  }`</ph> You can achieve the same effect using the <bpt id=\"p2\">**</bpt>delete<ph id=\"ph3\">\\_</ph>from<ept id=\"p2\">**</ept> keyword.","pos":[33831,34008],"source":"`{    TableName myXrec;    while select myXrec      where ` *Conditions*  `  {      myXrec.delete();    }  }` You can achieve the same effect using the **delete\\_from** keyword."},{"content":"<ph id=\"ph1\">`{    TableName myXrec;    delete_from myXrec      where `</ph> <bpt id=\"p1\">*</bpt>Conditions<ept id=\"p1\">*</ept> <ph id=\"ph2\">`;  }`</ph>","pos":[34009,34087],"source":"`{    TableName myXrec;    delete_from myXrec      where ` *Conditions* `;  }`"},{"pos":[34093,34120],"content":"Select Statements on Fields","linkify":"Select Statements on Fields","nodes":[{"content":"Select Statements on Fields","pos":[0,27]}]},{"content":"You can use a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement in a lookup on a field.","pos":[34122,34180],"source":"You can use a **select** statement in a lookup on a field."},{"content":"Following a <ph id=\"ph1\">`select statement`</ph> that fetches a record in a table, you can write <bpt id=\"p1\">*</bpt>.fieldName<ept id=\"p1\">*</ept> to reference a field in the table.","pos":[34181,34307],"source":" Following a `select statement` that fetches a record in a table, you can write *.fieldName* to reference a field in the table."},{"content":"These <ph id=\"ph1\">`select`</ph> statements must be used in expressions.","pos":[34308,34362],"source":" These `select` statements must be used in expressions."},{"content":"There is a difference between a <ph id=\"ph1\">`normal`</ph> <ph id=\"ph2\">`select`</ph> statement and a <ph id=\"ph3\">`field select`</ph> statement:","pos":[34363,34454],"source":" There is a difference between a `normal` `select` statement and a `field select` statement:"},{"pos":[34460,34518],"content":"The <ph id=\"ph1\">`field select`</ph> statement operates directly on a table.","source":"The `field select` statement operates directly on a table."},{"pos":[34523,34589],"content":"The <ph id=\"ph1\">`normal select`</ph> statement operates on a table buffer variable.","source":"The `normal select` statement operates on a table buffer variable."},{"pos":[34595,34620],"content":"select field Code Example","linkify":"select field Code Example","nodes":[{"content":"select field Code Example","pos":[0,25]}]},{"pos":[35050,35102],"content":"Aggregate Functions: Differences Between X++ and SQL","linkify":"Aggregate Functions: Differences Between X++ and SQL","nodes":[{"content":"Aggregate Functions: Differences Between X++ and SQL","pos":[0,52]}]},{"content":"In industry standard SQL, a database query can contain <bpt id=\"p1\">**</bpt>aggregate functions<ept id=\"p1\">**</ept>.","pos":[35104,35183],"source":"In industry standard SQL, a database query can contain **aggregate functions**."},{"content":"Examples of such functions include <ph id=\"ph1\">`count(RecID)`</ph> or <ph id=\"ph2\">`sum(columnA)`</ph>.","pos":[35184,35252],"source":" Examples of such functions include `count(RecID)` or `sum(columnA)`."},{"content":"When an aggregate function is used but no rows match the <ph id=\"ph1\">`where`</ph> clause, a row must be returned to hold the result of the aggregates.","pos":[35253,35386],"source":" When an aggregate function is used but no rows match the `where` clause, a row must be returned to hold the result of the aggregates."},{"content":"The one returned row shows the value 0 (zero) for the <ph id=\"ph1\">`count`</ph> function, and shows <ph id=\"ph2\">`null`</ph> for the <ph id=\"ph3\">`sum`</ph> function.","pos":[35387,35499],"source":" The one returned row shows the value 0 (zero) for the `count` function, and shows `null` for the `sum` function."},{"content":"X++ does not support the concept of null values for the database.","pos":[35500,35565]},{"content":"Therefore, when the <ph id=\"ph1\">`sum`</ph> function would return null, no row is returned to the user.","pos":[35566,35651],"source":" Therefore, when the `sum` function would return null, no row is returned to the user."},{"content":"Also, each data type has a specific value that is treated like a null value in certain circumstances.","pos":[35652,35753]},{"content":"For more information, see Null Values for Data Types.","pos":[35754,35807]},{"pos":[35813,35852],"content":"Index and Order By in Select Statements","linkify":"Index and Order By in Select Statements","nodes":[{"content":"Index and Order By in Select Statements","pos":[0,39]}]},{"content":"Use the <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> keyword in your <ph id=\"ph1\">`select`</ph> statements to order the data that's returned.","pos":[35854,35945],"source":"Use the **order by** keyword in your `select` statements to order the data that's returned."},{"content":"Use the <bpt id=\"p1\">**</bpt>index<ept id=\"p1\">**</ept> hint keywords to specify that a particular index should be used in the query and to sort the selected records as defined by the index.","pos":[35946,36098],"source":" Use the **index** hint keywords to specify that a particular index should be used in the query and to sort the selected records as defined by the index."},{"content":"Indexes optimize the selection of records.","pos":[36099,36141]},{"content":"Combine the index hint keyword with an order by expression to select records in a specific order.","pos":[36142,36239]},{"content":"If you want the sorted output in reverse order, use the <bpt id=\"p1\">**</bpt>reverse<ept id=\"p1\">**</ept> keyword.","pos":[36240,36316],"source":" If you want the sorted output in reverse order, use the **reverse** keyword."},{"content":"If a table index has been disabled by setting the index's <ph id=\"ph1\">`Enabled`</ph> property to No, the <ph id=\"ph2\">`select`</ph> statement that references the index is still valid.","pos":[36317,36465],"source":" If a table index has been disabled by setting the index's `Enabled` property to No, the `select` statement that references the index is still valid."},{"content":"However, the database can't use the index as a hint for how to sort the data, because the index doesn't exist in the database.","pos":[36466,36592]},{"content":"The following table is an overview of how to use the index hint and order by keywords in <ph id=\"ph1\">`select`</ph> statements.","pos":[36593,36702],"source":" The following table is an overview of how to use the index hint and order by keywords in `select` statements."},{"content":"Task","pos":[36706,36710]},{"content":"Use","pos":[36793,36796]},{"content":"Select records where the order isn't significant.","pos":[37000,37049]},{"content":"Select records where the order is significant.","pos":[37147,37193]},{"content":"Select records and force a specific index to be used.","pos":[37294,37347]},{"content":"Select records where the order is significant and force a specific index to be used.","pos":[37441,37525]},{"pos":[37591,37643],"content":"Index and Order By in Select Statements Code Example","linkify":"Index and Order By in Select Statements Code Example","nodes":[{"content":"Index and Order By in Select Statements Code Example","pos":[0,52]}]},{"content":"To select the transactions from the salestable based on a range of customers and due dates, use the following code.","pos":[37645,37760]},{"pos":[38104,38121],"content":"Using Index Hints","linkify":"Using Index Hints","nodes":[{"content":"Using Index Hints","pos":[0,17]}]},{"pos":[38123,38241],"content":"To use <bpt id=\"p1\">**</bpt>index hints<ept id=\"p1\">**</ept> in queries you must first specify the use of hints on the server using the following procedure.","source":"To use **index hints** in queries you must first specify the use of hints on the server using the following procedure."},{"content":"Open Start <ph id=\"ph1\">&amp;gt;</ph> Administrative Tools <ph id=\"ph2\">&amp;gt;</ph> Microsoft Dynamics AX Server Configuration and select the Database Tuning tab.","pos":[38247,38367],"source":"Open Start &gt; Administrative Tools &gt; Microsoft Dynamics AX Server Configuration and select the Database Tuning tab."},{"content":"Select Allow INDEX hints in queries and click OK.","pos":[38372,38421]},{"content":"A message box prompting you to restart the AOS service appears.","pos":[38426,38489]},{"content":"Click Yes to restart the AOS service.","pos":[38490,38527]},{"content":"Index hints won't be enabled until the service is restarted.","pos":[38528,38588]},{"content":"When an index hint in a select statement refers to a non-clustered index and the WHERE clause contains only the fields that are found in a clustered index on the same table, the clustered index is used instead of the index specified in the hint.","pos":[38590,38835]},{"content":"For example, if you run <ph id=\"ph1\">`sp_helpindex InventTable`</ph> in SQL Server Management Studio, you see that the InventTable has a clustered index on the DataAreaId and ItemId columns and a non-clustered index on the DataAreaId, ItemProductId, and ItemType columns.","pos":[38836,39089],"source":" For example, if you run `sp_helpindex InventTable` in SQL Server Management Studio, you see that the InventTable has a clustered index on the DataAreaId and ItemId columns and a non-clustered index on the DataAreaId, ItemProductId, and ItemType columns."},{"content":"Index name","pos":[39093,39103]},{"content":"Description","pos":[39112,39123]},{"content":"Key columns","pos":[39164,39175]},{"content":"I<ph id=\"ph1\">\\_</ph>175ITEMIDX","pos":[39315,39328],"source":"I\\_175ITEMIDX"},{"content":"Clustered, unique, primary key located on PRIMARY","pos":[39334,39383]},{"content":"DATAAREAID, ITEMID","pos":[39386,39404]},{"content":"I<ph id=\"ph1\">\\_</ph>175PRODUCTIDX","pos":[39426,39442],"source":"I\\_175PRODUCTIDX"},{"content":"Nonclustered located on PRIMARY","pos":[39445,39476]},{"content":"DATAAREAID, ITEMPRODUCTID, ITEMTYPE","pos":[39497,39532]},{"content":"In the following code the clustered index will be used instead of the non-clustered index specified in the index hint.","pos":[39536,39654]},{"pos":[39837,39880],"content":"Writing a Select Statement as an Expression","linkify":"Writing a Select Statement as an Expression","nodes":[{"content":"Writing a Select Statement as an Expression","pos":[0,43]}]},{"content":"You can use a <ph id=\"ph1\">`select`</ph> statement as an expression.","pos":[39882,39932],"source":"You can use a `select` statement as an expression."},{"content":"This is called an <bpt id=\"p1\">**</bpt>expression select<ept id=\"p1\">**</ept>.","pos":[39933,39973],"source":" This is called an **expression select**."},{"content":"A table buffer variable cannot be used in an expression select statement.","pos":[39974,40047]},{"content":"The name of the table must be used in the <ph id=\"ph1\">`from`</ph> clause.","pos":[40048,40104],"source":" The name of the table must be used in the `from` clause."},{"content":"One limitation of expression selects is that the <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> keyword is not supported in an expression join.","pos":[40105,40210],"source":" One limitation of expression selects is that the **join** keyword is not supported in an expression join."},{"content":"Test<ph id=\"ph1\">\\_</ph>3 in the code example shows that a subselect is supported, but only in a limited way.","pos":[40211,40302],"source":" Test\\_3 in the code example shows that a subselect is supported, but only in a limited way."},{"pos":[40308,40339],"content":"Expression Selects Code Example","linkify":"Expression Selects Code Example","nodes":[{"content":"Expression Selects Code Example","pos":[0,31]}]},{"content":"The following table describes the test cases in the code example.","pos":[40341,40406]},{"content":"Test case","pos":[40511,40520]},{"content":"Description","pos":[40530,40541]},{"content":"Test_1.a","pos":[40591,40599]},{"content":"The <ph id=\"ph1\">&lt;code&gt;select&lt;/code&gt;</ph> statement inside the parentheses returns one row.","pos":[40609,40682],"source":"The <code>select</code> statement inside the parentheses returns one row."},{"content":"The only column that can be populated with data is the column that is named in the <ph id=\"ph1\">&lt;code&gt;select&lt;/code&gt;</ph> clause before the <ph id=\"ph2\">&lt;code&gt;from&lt;/code&gt;</ph> clause.","pos":[40683,40829],"source":" The only column that can be populated with data is the column that is named in the <code>select</code> clause before the <code>from</code> clause."},{"content":"The name of that one column is used after the closing parenthesis to reference the data value: <ph id=\"ph1\">&lt;code&gt;).AccountNum;&lt;/code&gt;</ph>.This test case returns a maximum of one row because it uses the <ph id=\"ph2\">&lt;code&gt;firstonly&lt;/code&gt;</ph> keyword.","pos":[40830,41047],"source":" The name of that one column is used after the closing parenthesis to reference the data value: <code>).AccountNum;</code>.This test case returns a maximum of one row because it uses the <code>firstonly</code> keyword."},{"content":"However, the value that is assigned to <ph id=\"ph1\">&lt;code&gt;sAccountNum&lt;/code&gt;</ph> is the same even if the <ph id=\"ph2\">&lt;code&gt;firstonly&lt;/code&gt;</ph> keyword is omitted.The <ph id=\"ph3\">&lt;code&gt;where&lt;/code&gt;</ph> clause in this example serves no purpose other than to show that the <ph id=\"ph4\">&lt;code&gt;where&lt;/code&gt;</ph> clause must occur after the <ph id=\"ph5\">&lt;code&gt;order by&lt;/code&gt;</ph> clause.","pos":[41048,41346],"source":" However, the value that is assigned to <code>sAccountNum</code> is the same even if the <code>firstonly</code> keyword is omitted.The <code>where</code> clause in this example serves no purpose other than to show that the <code>where</code> clause must occur after the <code>order by</code> clause."},{"content":"The table name cannot be used to qualify a field name in the <ph id=\"ph1\">&lt;code&gt;order by&lt;/code&gt;</ph> clause.","pos":[41347,41437],"source":" The table name cannot be used to qualify a field name in the <code>order by</code> clause."},{"content":"Test_1.b","pos":[41471,41479]},{"content":"This is a simpler way to achieve the same result as Test_1.a.","pos":[41489,41550]},{"content":"Test_2.c","pos":[41583,41591]},{"content":"Includes a <ph id=\"ph1\">&lt;code&gt;where&lt;/code&gt;</ph> clause.","pos":[41601,41638],"source":"Includes a <code>where</code> clause."},{"content":"In a <ph id=\"ph1\">&lt;code&gt;where&lt;/code&gt;</ph> clause, the table name must be used as a qualifier of the field.Here the <ph id=\"ph2\">&lt;code&gt;maxof&lt;/code&gt;</ph> aggregate function is used, and the field <ph id=\"ph3\">&lt;code&gt;RecId&lt;/code&gt;</ph> is mentioned in the function.","pos":[41639,41845],"source":" In a <code>where</code> clause, the table name must be used as a qualifier of the field.Here the <code>maxof</code> aggregate function is used, and the field <code>RecId</code> is mentioned in the function."},{"content":"The field that is mentioned in the aggregate function must be the same field name that is used to reference the data value after the closing parenthesis.","pos":[41846,41999]},{"content":"Otherwise, empty data is returned.","pos":[42000,42034]},{"content":"Test_2.d","pos":[42068,42076]},{"content":"Demonstrates that a field name, here <ph id=\"ph1\">&lt;code&gt;RecId&lt;/code&gt;</ph>, is used to reference a data value that is not a <ph id=\"ph2\">&lt;code&gt;RecId&lt;/code&gt;</ph>.","pos":[42086,42210],"source":"Demonstrates that a field name, here <code>RecId</code>, is used to reference a data value that is not a <code>RecId</code>."},{"content":"The <ph id=\"ph1\">&lt;code&gt;count&lt;/code&gt;</ph> aggregate function does not return a <ph id=\"ph2\">&lt;code&gt;RecId&lt;/code&gt;</ph> value.","pos":[42211,42296],"source":" The <code>count</code> aggregate function does not return a <code>RecId</code> value."},{"content":"The <ph id=\"ph1\">&lt;code&gt;RecId&lt;/code&gt;</ph> field is ordinarily used with the <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> function.","pos":[42297,42382],"source":" The <code>RecId</code> field is ordinarily used with the <code>count</code> function."},{"content":"Test_3","pos":[42415,42421]},{"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>join<ept id=\"p1\">&lt;/strong&gt;</ept> keyword is not supported in expression selects.","pos":[42431,42504],"source":"The <strong>join</strong> keyword is not supported in expression selects."},{"content":"This test case demonstrates a subselect.","pos":[42505,42545]},{"content":"But expression selects do not support subselects that are equivalent to a standard inner join.","pos":[42546,42640]},{"content":"For instance, the following code example does not compile.","pos":[42641,42699]},{"content":"The problem is that it mentions two tables inside one expression select, namely inside the subselect.","pos":[42700,42801]},{"content":"The following code example demonstrates several expression selects.","pos":[43294,43361]},{"content":"Its test cases are described in the previous table.","pos":[43362,43413]},{"pos":[44871,44890],"content":"update Table Method","linkify":"update Table Method","nodes":[{"content":"update Table Method","pos":[0,19]}]},{"content":"The <bpt id=\"p1\">**</bpt>update<ept id=\"p1\">**</ept> table method updates the current record with the contents of the buffer.","pos":[44891,44978],"source":"The **update** table method updates the current record with the contents of the buffer."},{"content":"It also updates the appropriate system fields.","pos":[44979,45025]},{"content":"The <ph id=\"ph1\">`where`</ph> clause is optional.","pos":[45026,45057],"source":" The `where` clause is optional."},{"content":"When used, the <ph id=\"ph1\">`where`</ph> clause specifies a condition for <ph id=\"ph2\">`update`</ph> to test while processing each row of the table.","pos":[45058,45170],"source":" When used, the `where` clause specifies a condition for `update` to test while processing each row of the table."},{"content":"Only those rows that test <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> against the condition are updated with the new values.","pos":[45171,45260],"source":" Only those rows that test **true** against the condition are updated with the new values."},{"content":"<bpt id=\"p1\">**</bpt>update<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> is a record-set based operator that updates multiple records at once.","pos":[45261,45352],"source":"**update\\_recordset** is a record-set based operator that updates multiple records at once."},{"content":"To override the behavior of <ph id=\"ph1\">`update`</ph>, use the doUpdate method.","pos":[45353,45415],"source":" To override the behavior of `update`, use the doUpdate method."},{"pos":[45421,45453],"content":"update Table Method Code Example","linkify":"update Table Method Code Example","nodes":[{"content":"update Table Method Code Example","pos":[0,32]}]},{"content":"The example selects the table <ph id=\"ph1\">`custTable`</ph> for update.","pos":[45455,45508],"source":"The example selects the table `custTable` for update."},{"content":"Any records with the AccountNum equal to 4000 are updated (in this case only one).","pos":[45509,45591]},{"content":"The <ph id=\"ph1\">`CreditMax`</ph> field is changed to 5000.","pos":[45592,45633],"source":" The `CreditMax` field is changed to 5000."},{"pos":[45857,45878],"content":"doUpdate Table Method","linkify":"doUpdate Table Method","nodes":[{"content":"doUpdate Table Method","pos":[0,21]}]},{"content":"The <bpt id=\"p1\">**</bpt>doUpdate<ept id=\"p1\">**</ept> method updates the current record with the contents of the buffer.","pos":[45879,45962],"source":"The **doUpdate** method updates the current record with the contents of the buffer."},{"content":"This method also updates the appropriate system fields.","pos":[45963,46018]},{"content":"The <ph id=\"ph1\">`doUpdate`</ph> method should be used when the update method on the table is to be bypassed.","pos":[46019,46110],"source":" The `doUpdate` method should be used when the update method on the table is to be bypassed."},{"content":"The syntax for a <ph id=\"ph1\">`doUpdate`</ph> table method is <ph id=\"ph2\">`void doUpdate()`</ph>","pos":[46111,46172],"source":" The syntax for a `doUpdate` table method is `void doUpdate()`"},{"pos":[46178,46199],"content":"doUpdate Code Example","linkify":"doUpdate Code Example","nodes":[{"content":"doUpdate Code Example","pos":[0,21]}]},{"pos":[46525,46544],"content":"delete Table Method","linkify":"delete Table Method","nodes":[{"content":"delete Table Method","pos":[0,19]}]},{"content":"The <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> table method deletes the current record from the database.","pos":[46545,46618],"source":"The **delete** table method deletes the current record from the database."},{"content":"To use this method, specify which rows are to be deleted by using a <ph id=\"ph1\">`where`</ph> clause.","pos":[46619,46702],"source":" To use this method, specify which rows are to be deleted by using a `where` clause."},{"content":"Records are then removed, one at a time, from the specified table.","pos":[46703,46769]},{"content":"<bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> is a record-setbased operator, which simultaneously removes multiple records.","pos":[46770,46865],"source":"**delete\\_from** is a record-setbased operator, which simultaneously removes multiple records."},{"content":"The <ph id=\"ph1\">`delete`</ph> method can be overridden, for example, to add extra validation before records are deleted.","pos":[46866,46969],"source":" The `delete` method can be overridden, for example, to add extra validation before records are deleted."},{"content":"If you override the <ph id=\"ph1\">`delete`</ph> method, the original version of the <ph id=\"ph2\">`delete`</ph> method can be executed instead by calling the <ph id=\"ph3\">`doDelete`</ph> method.","pos":[46970,47108],"source":" If you override the `delete` method, the original version of the `delete` method can be executed instead by calling the `doDelete` method."},{"content":"It is equivalent to calling <ph id=\"ph1\">`super()`</ph> in the <ph id=\"ph2\">`delete`</ph> method; <ph id=\"ph3\">`doDelete`</ph> executes the base version of the <ph id=\"ph4\">`delete`</ph> method.","pos":[47109,47231],"source":" It is equivalent to calling `super()` in the `delete` method; `doDelete` executes the base version of the `delete` method."},{"pos":[47237,47269],"content":"delete Table Method Code Example","linkify":"delete Table Method Code Example","nodes":[{"content":"delete Table Method Code Example","pos":[0,32]}]},{"content":"All records in the MyTable table that satisfy the <ph id=\"ph1\">`where`</ph> clause criterion (any record with an Account number equal to 1000) are deleted from the database.","pos":[47271,47426],"source":"All records in the MyTable table that satisfy the `where` clause criterion (any record with an Account number equal to 1000) are deleted from the database."},{"content":"These records are deleted one at a time.","pos":[47427,47467]},{"pos":[47618,47639],"content":"doDelete Table Method","linkify":"doDelete Table Method","nodes":[{"content":"doDelete Table Method","pos":[0,21]}]},{"content":"The <bpt id=\"p1\">**</bpt>doDelete<ept id=\"p1\">**</ept> table method works similar to the <ph id=\"ph1\">`delete`</ph> table method because it deletes the current record from the database.","pos":[47640,47769],"source":"The **doDelete** table method works similar to the `delete` table method because it deletes the current record from the database."},{"content":"Use the <ph id=\"ph1\">`doDelete`</ph> method if the delete table method has been overridden, and you want to use the original version of the <ph id=\"ph2\">`delete`</ph> method.","pos":[47770,47908],"source":" Use the `doDelete` method if the delete table method has been overridden, and you want to use the original version of the `delete` method."},{"content":"The <ph id=\"ph1\">`doDelete`</ph> method executes the base version of the <ph id=\"ph2\">`delete`</ph> method instead of the overridden version, which is equivalent to executing <ph id=\"ph3\">`super()`</ph>in the <ph id=\"ph4\">`delete`</ph> method.","pos":[47909,48080],"source":" The `doDelete` method executes the base version of the `delete` method instead of the overridden version, which is equivalent to executing `super()`in the `delete` method."},{"pos":[48086,48107],"content":"doDelete Code Example","linkify":"doDelete Code Example","nodes":[{"content":"doDelete Code Example","pos":[0,21]}]},{"content":"This code example deletes all records in the myTable table that have an account number that is greater than or equal to 200.","pos":[48109,48233]},{"pos":[48385,48404],"content":"insert Table Method","linkify":"insert Table Method","nodes":[{"content":"insert Table Method","pos":[0,19]}]},{"content":"The <bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept> method updates one record at a time.","pos":[48405,48456],"source":"The **insert** method updates one record at a time."},{"content":"To insert multiple records at a time, use array inserts, <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept>, or <bpt id=\"p2\">**</bpt>RecordSortedList.insertDatabase<ept id=\"p2\">**</ept>.","pos":[48457,48576],"source":" To insert multiple records at a time, use array inserts, **insert\\_recordset**, or **RecordSortedList.insertDatabase**."},{"content":"To override the behavior of the <ph id=\"ph1\">`insert`</ph> method, use the <ph id=\"ph2\">`doInsert`</ph> method.","pos":[48577,48652],"source":" To override the behavior of the `insert` method, use the `doInsert` method."},{"content":"The <ph id=\"ph1\">`xRecord .insert`</ph> method generates values for <ph id=\"ph2\">`RecId`</ph> and system fields, and then inserts the contents of the buffer into the database.","pos":[48653,48792],"source":" The `xRecord .insert` method generates values for `RecId` and system fields, and then inserts the contents of the buffer into the database."},{"content":"The method operated as follows:","pos":[48793,48824]},{"content":"Only the specified columns of those rows selected by the query are inserted into the named table.","pos":[48830,48927]},{"content":"The columns of the table being copied from and those of the table being copied to must be type compatible.","pos":[48932,49038]},{"pos":[49043,49154],"content":"If the columns of both tables match in type and order, the column-list may be omitted from the <ph id=\"ph1\">`insert`</ph> clause.","source":"If the columns of both tables match in type and order, the column-list may be omitted from the `insert` clause."},{"pos":[49160,49215],"content":"insert Table Method Code Example 1: Insert a New Record","linkify":"insert Table Method Code Example 1: Insert a New Record","nodes":[{"content":"insert Table Method Code Example 1: Insert a New Record","pos":[0,55]}]},{"pos":[49217,49402],"content":"The following code example inserts a new record into the <ph id=\"ph1\">`CustTable`</ph> table, with the <ph id=\"ph2\">`AccountNum`</ph> set to 5000 and the <ph id=\"ph3\">`Name`</ph> set to MyCompany (other fields in the record will be blank).","source":"The following code example inserts a new record into the `CustTable` table, with the `AccountNum` set to 5000 and the `Name` set to MyCompany (other fields in the record will be blank)."},{"pos":[49554,49619],"content":"insert Table Method Code Example 2: Transaction and Duplicate Key","linkify":"insert Table Method Code Example 2: Transaction and Duplicate Key","nodes":[{"content":"insert Table Method Code Example 2: Transaction and Duplicate Key","pos":[0,65]}]},{"content":"The following example shows how you can catch a <ph id=\"ph1\">`DuplicateKeyException`</ph> in the context of an explicit transaction.","pos":[49621,49735],"source":"The following example shows how you can catch a `DuplicateKeyException` in the context of an explicit transaction."},{"content":"The exception is thrown when a call to <ph id=\"ph1\">`xRecord .insert`</ph> fails because of a duplication of an existing unique value.","pos":[49736,49852],"source":" The exception is thrown when a call to `xRecord .insert` fails because of a duplication of an existing unique value."},{"content":"In the catch block, your code can take corrective action, or it can log the error for later analysis.","pos":[49853,49954]},{"content":"Then your code can continue without losing all the pending work of the transaction.","pos":[49955,50038]},{"content":"You cannot catch a duplicate key exception caused by a set based operation such as <ph id=\"ph1\">`insert_recordset`</ph>.","pos":[50039,50141],"source":" You cannot catch a duplicate key exception caused by a set based operation such as `insert_recordset`."},{"content":"This example depends on two tables <ph id=\"ph1\">`TableNumberA`</ph> and <ph id=\"ph2\">`TableNumberB`</ph>.","pos":[50142,50211],"source":" This example depends on two tables `TableNumberA` and `TableNumberB`."},{"content":"Each has one mandatory Integer field, named <ph id=\"ph1\">`NumberAKey`</ph> and <ph id=\"ph2\">`NumberBKey`</ph> respectively.","pos":[50212,50299],"source":" Each has one mandatory Integer field, named `NumberAKey` and `NumberBKey` respectively."},{"content":"Each of these key fields has a unique indexed defined on it.","pos":[50300,50360]},{"content":"The <ph id=\"ph1\">`TableNumberA`</ph> table must have at least one record in it.","pos":[50361,50422],"source":" The `TableNumberA` table must have at least one record in it."},{"pos":[52729,52750],"content":"doInsert Table Method","linkify":"doInsert Table Method","nodes":[{"content":"doInsert Table Method","pos":[0,21]}]},{"content":"The <bpt id=\"p1\">**</bpt>doInsert<ept id=\"p1\">**</ept> method generates values for the <ph id=\"ph1\">`RecId`</ph> field and other system fields, and then inserts the contents of the buffer into the database.","pos":[52751,52901],"source":"The **doInsert** method generates values for the `RecId` field and other system fields, and then inserts the contents of the buffer into the database."},{"content":"This operation is used when the insert method on the table is to be bypassed.","pos":[52902,52979]},{"pos":[52985,53006],"content":"doInsert Code Example","linkify":"doInsert Code Example","nodes":[{"content":"doInsert Code Example","pos":[0,21]}]},{"pos":[53008,53118],"content":"A new record is inserted with the name <ph id=\"ph1\">`Warren Langer`</ph> in the name field and the value 100 in the value field.","source":"A new record is inserted with the name `Warren Langer` in the name field and the value 100 in the value field."},{"pos":[53238,53259],"content":"Transaction Integrity","linkify":"Transaction Integrity","nodes":[{"content":"Transaction Integrity","pos":[0,21]}]},{"content":"If the <bpt id=\"p1\">**</bpt>integrity of transactions<ept id=\"p1\">**</ept> is not ensured, it may lead to data corruption, or, at best, poor scalability with reference to concurrent users on the system.","pos":[53260,53424],"source":"If the **integrity of transactions** is not ensured, it may lead to data corruption, or, at best, poor scalability with reference to concurrent users on the system."},{"content":"There are two internal checking features to help ensure the integrity of transactions: the <ph id=\"ph1\">`forUpdate`</ph> check and the <ph id=\"ph2\">`tssLevel`</ph> check.","pos":[53425,53559],"source":" There are two internal checking features to help ensure the integrity of transactions: the `forUpdate` check and the `tssLevel` check."},{"content":"A <bpt id=\"p1\">**</bpt>forUpdate check<ept id=\"p1\">**</ept> ensures that no record can be updated or deleted if the record has not first been selected for update.","pos":[53560,53684],"source":" A **forUpdate check** ensures that no record can be updated or deleted if the record has not first been selected for update."},{"content":"A record can be selected for update, either by using the <ph id=\"ph1\">`forUpdate`</ph> keyword in the <ph id=\"ph2\">`select`</ph> statement, or by using the <ph id=\"ph3\">`selectForUpdate`</ph> method on tables.","pos":[53685,53840],"source":" A record can be selected for update, either by using the `forUpdate` keyword in the `select` statement, or by using the `selectForUpdate` method on tables."},{"content":"A <bpt id=\"p1\">**</bpt>ttsLevel check<ept id=\"p1\">**</ept> ensures that no record can be updated or deleted except from within the same transaction scope as it was selected for update.","pos":[53841,53987],"source":" A **ttsLevel check** ensures that no record can be updated or deleted except from within the same transaction scope as it was selected for update."},{"content":"Integrity is ensured by using the following statements:","pos":[53988,54043]},{"content":"<ph id=\"ph1\">`ttsBegin`</ph>: marks the beginning of a transaction.","pos":[54049,54098],"source":"`ttsBegin`: marks the beginning of a transaction."},{"content":"This ensures data integrity, and guarantees that all updates performed until the transaction ends (by <ph id=\"ph1\">`ttsCommit`</ph> or <ph id=\"ph2\">`ttsAbort`</ph>) are consistent (all or none).","pos":[54099,54257],"source":" This ensures data integrity, and guarantees that all updates performed until the transaction ends (by `ttsCommit` or `ttsAbort`) are consistent (all or none)."},{"content":"<ph id=\"ph1\">`ttsCommit`</ph>: marks the successful end of a transaction.","pos":[54262,54317],"source":"`ttsCommit`: marks the successful end of a transaction."},{"content":"This ends and commits a transaction.","pos":[54318,54354]},{"content":"MorphX guarantees that a committed transaction will be performed according to intentions.","pos":[54355,54444]},{"content":"<ph id=\"ph1\">`ttsAbort`</ph>: allows you to explicitly discard all changes in the current transaction.","pos":[54449,54533],"source":"`ttsAbort`: allows you to explicitly discard all changes in the current transaction."},{"content":"As a result, the database is rolled back to the initial state where nothing will have been changed.","pos":[54534,54633]},{"content":"Typically, you will use this if you have detected that the user wants to break the current job.","pos":[54634,54729]},{"content":"Using <ph id=\"ph1\">`ttsAbort`</ph> ensures that the database is consistent.","pos":[54730,54787],"source":" Using `ttsAbort` ensures that the database is consistent."},{"content":"It is usually better to use exception handling instead of <ph id=\"ph1\">`ttsAbort`</ph>.","pos":[54789,54858],"source":"It is usually better to use exception handling instead of `ttsAbort`."},{"content":"The <ph id=\"ph1\">`throw`</ph> statement automatically aborts the current transaction.","pos":[54859,54926],"source":" The `throw` statement automatically aborts the current transaction."},{"content":"Statements between <ph id=\"ph1\">`ttsBegin`</ph> and <ph id=\"ph2\">`ttsCommit`</ph> may include one or more transaction blocks as shown in the following example.","pos":[54927,55050],"source":" Statements between `ttsBegin` and `ttsCommit` may include one or more transaction blocks as shown in the following example."},{"content":"In such cases, nothing is actually committed until the successful exit from the final <ph id=\"ph1\">`ttsCommit`</ph>.","pos":[55051,55149],"source":" In such cases, nothing is actually committed until the successful exit from the final `ttsCommit`."},{"pos":[55270,55305],"content":"ttsBegin and ttsCommit Code Example","linkify":"ttsBegin and ttsCommit Code Example","nodes":[{"content":"ttsBegin and ttsCommit Code Example","pos":[0,35]}]},{"pos":[55501,55566],"content":"Examples of Code Rejected by the two Transaction Integrity Checks","linkify":"Examples of Code Rejected by the two Transaction Integrity Checks","nodes":[{"content":"Examples of Code Rejected by the two Transaction Integrity Checks","pos":[0,65]}]},{"content":"In this example, the first failure is because the <ph id=\"ph1\">`forupdate`</ph> keyword is missing.","pos":[55568,55649],"source":"In this example, the first failure is because the `forupdate` keyword is missing."},{"content":"The second failure is because the update is in another transaction scope rather than the one that the record was selected in <ph id=\"ph1\">`ttsCommit`</ph> for update.","pos":[55650,55798],"source":" The second failure is because the update is in another transaction scope rather than the one that the record was selected in `ttsCommit` for update."},{"pos":[56129,56155],"content":"Speeding Up SQL Operations","linkify":"Speeding Up SQL Operations","nodes":[{"content":"Speeding Up SQL Operations","pos":[0,26]}]},{"content":"The following constructs allow you to insert, update, or delete multiple records.","pos":[56156,56237]},{"content":"Using these constructs reduces communication between the application and the database, and it increases performance.","pos":[56238,56354]},{"content":"In some situations, record-set operations can fall back to record-by-record operations.","pos":[56355,56442]},{"content":"Construct","pos":[56446,56455]},{"content":"Description","pos":[56470,56481]},{"pos":[56974,56994],"content":"<bpt id=\"p1\">**</bpt>RecordSortedList<ept id=\"p1\">**</ept>","source":"**RecordSortedList**"},{"content":"Allows you to insert multiple records in one database trip.","pos":[56998,57057]},{"content":"Use the <ph id=\"ph1\">`RecordSortedList`</ph> construct when you want a subset of data from a particular table, and when you want it sorted in an order that does not currently exist as an index.","pos":[57058,57233],"source":" Use the `RecordSortedList` construct when you want a subset of data from a particular table, and when you want it sorted in an order that does not currently exist as an index."},{"pos":[57238,57258],"content":"<bpt id=\"p1\">**</bpt>RecordInsertList<ept id=\"p1\">**</ept>","source":"**RecordInsertList**"},{"content":"Allows you to insert multiple records in one database trip.","pos":[57262,57321]},{"content":"Use the <ph id=\"ph1\">`RecordInsertList`</ph> construct when you do not need to sort the data.","pos":[57322,57397],"source":" Use the `RecordInsertList` construct when you do not need to sort the data."},{"pos":[57502,57523],"content":"<bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept>","source":"**insert\\_recordset**"},{"content":"Allows you to copy multiple records from one or more tables directly into another table on a single database trip.","pos":[57526,57640]},{"pos":[57766,57787],"content":"<bpt id=\"p1\">**</bpt>update<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept>","source":"**update\\_recordset**"},{"content":"Allows you to update multiple rows in a table on a single database trip.","pos":[57790,57862]},{"pos":[58030,58046],"content":"<bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept>","source":"**delete\\_from**"},{"content":"Allows you to delete multiple records from the database on a single database trip.","pos":[58054,58136]},{"pos":[58296,58313],"content":"insert\\_recordset","linkify":"insert\\_recordset","nodes":[{"content":"insert<ph id=\"ph1\">\\_</ph>recordset","pos":[0,17],"source":"insert\\_recordset"}]},{"content":"<bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> copies data from one or more tables directly into one resulting destination table on a single server trip.","pos":[58314,58442],"source":"**insert\\_recordset** copies data from one or more tables directly into one resulting destination table on a single server trip."},{"content":"Using <ph id=\"ph1\">`insert_recordset`</ph> is faster than using an array insert.","pos":[58443,58505],"source":" Using `insert_recordset` is faster than using an array insert."},{"content":"However, array inserts are more flexible if you want to handle the data before you insert it.","pos":[58506,58599]},{"content":"<ph id=\"ph1\">`insert_recordset`</ph> is a record-set-based operator, which performs operations on multiple records at a time.","pos":[58600,58707],"source":"`insert_recordset` is a record-set-based operator, which performs operations on multiple records at a time."},{"content":"However, it can fall back to record-by-record operations in many situations.","pos":[58708,58784]},{"pos":[58790,58814],"content":"insert\\_recordset Syntax","linkify":"insert\\_recordset Syntax","nodes":[{"content":"insert<ph id=\"ph1\">\\_</ph>recordset Syntax","pos":[0,24],"source":"insert\\_recordset Syntax"}]},{"content":"The <bpt id=\"p1\">*</bpt>ListOfFields<ept id=\"p1\">*</ept> in the destination table must match the list of fields in the source tables.","pos":[58816,58911],"source":"The *ListOfFields* in the destination table must match the list of fields in the source tables."},{"content":"Data is transferred in the order that it appears in the list of fields.","pos":[58912,58983]},{"content":"Fields in the destination table that are not present in the list of fields are assigned zero-values as in other areas.","pos":[58984,59102]},{"content":"System fields, including <ph id=\"ph1\">`RecId`</ph>, are assigned transparently by the kernel in the destination table.","pos":[59103,59203],"source":" System fields, including `RecId`, are assigned transparently by the kernel in the destination table."},{"content":"<ph id=\"ph1\">`insert_recordset `</ph> <bpt id=\"p1\">*</bpt>DestinationTable<ept id=\"p1\">*</ept> <ph id=\"ph2\">` ( `</ph> <bpt id=\"p2\">*</bpt>ListOfFields<ept id=\"p2\">*</ept> <ph id=\"ph3\">` )`</ph> <ph id=\"ph4\">` select `</ph> <bpt id=\"p3\">*</bpt>ListOfFields1<ept id=\"p3\">*</ept> <ph id=\"ph5\">` from `</ph> <bpt id=\"p4\">*</bpt>SourceTable<ept id=\"p4\">*</ept> <ph id=\"ph6\">` [ where `</ph> <bpt id=\"p5\">*</bpt>WhereClause<ept id=\"p5\">*</ept> <ph id=\"ph7\">` ]`</ph> <ph id=\"ph8\">` [ join `</ph> <bpt id=\"p6\">*</bpt>ListOfFields2<ept id=\"p6\">*</ept> <ph id=\"ph9\">` from `</ph> <bpt id=\"p7\">*</bpt>JoinedSourceTable<ept id=\"p7\">*</ept> <ph id=\"ph10\">` [ where `</ph> <bpt id=\"p8\">*</bpt>JoinedWhereClause<ept id=\"p8\">*</ept> <ph id=\"ph11\">` ]]`</ph>","pos":[59204,59443],"source":"`insert_recordset ` *DestinationTable* ` ( ` *ListOfFields* ` )` ` select ` *ListOfFields1* ` from ` *SourceTable* ` [ where ` *WhereClause* ` ]` ` [ join ` *ListOfFields2* ` from ` *JoinedSourceTable* ` [ where ` *JoinedWhereClause* ` ]]`"},{"pos":[59449,59490],"content":"Example 1: insert data from another table","linkify":"Example 1: insert data from another table","nodes":[{"content":"Example 1: insert data from another table","pos":[0,41]}]},{"content":"The records, <ph id=\"ph1\">`myNum`</ph> and <ph id=\"ph2\">`mySum`</ph>, are retrieved from the table <ph id=\"ph3\">`anotherTable`</ph> and inserted into the table <ph id=\"ph4\">`myTable`</ph>.","pos":[59492,59608],"source":"The records, `myNum` and `mySum`, are retrieved from the table `anotherTable` and inserted into the table `myTable`."},{"content":"The records are grouped according to <ph id=\"ph1\">`myNum`</ph>, and only the <ph id=\"ph2\">`myNum`</ph> records with a value less than or equal to 100 are included in the insertion.","pos":[59609,59753],"source":" The records are grouped according to `myNum`, and only the `myNum` records with a value less than or equal to 100 are included in the insertion."},{"pos":[59937,59974],"content":"Example 2: insert data from variables","linkify":"Example 2: insert data from variables","nodes":[{"content":"Example 2: insert data from variables","pos":[0,37]}]},{"content":"This code example shows that the <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement can insert data that is provided in variables.","pos":[59976,60087],"source":"This code example shows that the **insert\\_recordset** statement can insert data that is provided in variables."},{"content":"In this example, the keyword <bpt id=\"p1\">**</bpt>firstonly<ept id=\"p1\">**</ept> is used so that only one row is inserted.","pos":[60088,60172],"source":" In this example, the keyword **firstonly** is used so that only one row is inserted."},{"content":"Literals, such as <ph id=\"ph1\">`128`</ph> or <ph id=\"ph2\">`\"this literal string\"`</ph>, cannot be used as a source of data to be inserted.","pos":[60173,60275],"source":" Literals, such as `128` or `\"this literal string\"`, cannot be used as a source of data to be inserted."},{"pos":[60887,60922],"content":"Example 3: insert data using a join","linkify":"Example 3: insert data using a join","nodes":[{"content":"Example 3: insert data using a join","pos":[0,35]}]},{"content":"The following code example shows a <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> of three tables on an <ph id=\"ph1\">`insert_recordset`</ph> statement that has a sub-<ph id=\"ph2\">`select`</ph>.","pos":[60924,61043],"source":"The following code example shows a **join** of three tables on an `insert_recordset` statement that has a sub-`select`."},{"content":"Also, a <ph id=\"ph1\">`while`</ph> <ph id=\"ph2\">`select`</ph> statement with a similar join is shown.","pos":[61044,61108],"source":" Also, a `while` `select` statement with a similar join is shown."},{"content":"A variable is used to supply the inserted value for one column.","pos":[61109,61172]},{"content":"The <ph id=\"ph1\">`str`</ph> variable must be declared with a length that is less than or equal to the maximum length of the corresponding database field.","pos":[61173,61308],"source":" The `str` variable must be declared with a length that is less than or equal to the maximum length of the corresponding database field."},{"content":"In this example, there is an <ph id=\"ph1\">`insert_recordset`</ph> statement for <ph id=\"ph2\">`tabEmplProj5`</ph>.","pos":[61309,61386],"source":" In this example, there is an `insert_recordset` statement for `tabEmplProj5`."},{"content":"One of the target fields is named <ph id=\"ph1\">`Description`</ph>, and the field's data comes from the local variable <ph id=\"ph2\">`sDescriptionVariable`</ph>.","pos":[61387,61510],"source":" One of the target fields is named `Description`, and the field's data comes from the local variable `sDescriptionVariable`."},{"content":"When the configuration key for the <ph id=\"ph1\">`Description`</ph> field is turned off, the <ph id=\"ph2\">`insert_recordset`</ph> still succeeds.","pos":[61511,61619],"source":" When the configuration key for the `Description` field is turned off, the `insert_recordset` still succeeds."},{"content":"The system ignores both the <ph id=\"ph1\">`Description`</ph> field and the variable <ph id=\"ph2\">`sDescriptionVariable`</ph>.","pos":[61620,61708],"source":" The system ignores both the `Description` field and the variable `sDescriptionVariable`."},{"content":"This is an example of <bpt id=\"p1\">**</bpt>configuration key automation<ept id=\"p1\">**</ept>.","pos":[61709,61764],"source":" This is an example of **configuration key automation**."},{"content":"Configuration key automation is when the system can automatically adjust the behavior of an <ph id=\"ph1\">`insert_recordset`</ph> statement that inserts into fields that have their configuration key turned off.","pos":[61765,61956],"source":" Configuration key automation is when the system can automatically adjust the behavior of an `insert_recordset` statement that inserts into fields that have their configuration key turned off."},{"pos":[63708,63725],"content":"update\\_recordset","linkify":"update\\_recordset","nodes":[{"content":"update<ph id=\"ph1\">\\_</ph>recordset","pos":[0,17],"source":"update\\_recordset"}]},{"content":"The <bpt id=\"p1\">**</bpt>update<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement enables you to update multiple rows in a single trip to the server.","pos":[63726,63829],"source":"The **update\\_recordset** statement enables you to update multiple rows in a single trip to the server."},{"content":"This means that certain tasks may have improved performance by using the power of the SQL server.","pos":[63830,63927]},{"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">`update_recordset`</ph><ept id=\"p1\">**</ept> resembles <ph id=\"ph2\">`delete_from`</ph> in X++ and <ph id=\"ph3\">`update set`</ph> in SQL.","pos":[63928,64006],"source":"**`update_recordset`** resembles `delete_from` in X++ and `update set` in SQL."},{"content":"It works on the database server-side on an SQL-style record-set, instead of retrieving each record separately by fetching, changing, and updating.","pos":[64007,64153]},{"content":"If the <ph id=\"ph1\">`update`</ph> method is overridden, the implementation falls back to a classic looping construction, updating records one by one just as <ph id=\"ph2\">`delete_from`</ph> does for deletions.","pos":[64154,64326],"source":" If the `update` method is overridden, the implementation falls back to a classic looping construction, updating records one by one just as `delete_from` does for deletions."},{"content":"This also means that the construction works on temporary tables, and whole-table-cached tables by using the looping construction.","pos":[64327,64456]},{"pos":[64462,64507],"content":"Example 1: update based on a calculated value","linkify":"Example 1: update based on a calculated value","nodes":[{"content":"Example 1: update based on a calculated value","pos":[0,45]}]},{"pos":[64509,64636],"content":"This example updates the table <ph id=\"ph1\">`myTableBuffer`</ph> and increments the value in <ph id=\"ph2\">`field1`</ph> by ten percent in all records in the table.","source":"This example updates the table `myTableBuffer` and increments the value in `field1` by ten percent in all records in the table."},{"pos":[64741,64779],"content":"Example 2: update using a where clause","linkify":"Example 2: update using a where clause","nodes":[{"content":"Example 2: update using a where clause","pos":[0,38]}]},{"content":"This example updates the table <ph id=\"ph1\">`myTable`</ph> in all records where <ph id=\"ph2\">`field1`</ph> has the value 0.","pos":[64781,64868],"source":"This example updates the table `myTable` in all records where `field1` has the value 0."},{"content":"<ph id=\"ph1\">`field1`</ph> is assigned the new value 1; <ph id=\"ph2\">`field2`</ph> is assigned the value of the sum of <ph id=\"ph3\">`fieldX`</ph> and <ph id=\"ph4\">`fieldY`</ph>.","pos":[64869,64974],"source":"`field1` is assigned the new value 1; `field2` is assigned the value of the sum of `fieldX` and `fieldY`."},{"content":"This example updates multiple fields at the same time, and it updates only those rows that satisfy the <ph id=\"ph1\">`where`</ph> clause.","pos":[64975,65093],"source":" This example updates multiple fields at the same time, and it updates only those rows that satisfy the `where` clause."},{"pos":[65250,65283],"content":"Example 3: updating joined tables","linkify":"Example 3: updating joined tables","nodes":[{"content":"Example 3: updating joined tables","pos":[0,33]}]},{"content":"This example shows that the <ph id=\"ph1\">`update_recordset`</ph> statement supports the joining of several tables.","pos":[65285,65381],"source":"This example shows that the `update_recordset` statement supports the joining of several tables."},{"content":"Data from the joined tables can be used to assign values to fields in the table that is being updated.","pos":[65382,65484]},{"pos":[66033,66045],"content":"delete\\_from","linkify":"delete\\_from","nodes":[{"content":"delete<ph id=\"ph1\">\\_</ph>from","pos":[0,12],"source":"delete\\_from"}]},{"content":"You can delete multiple records from a database table by using a <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> statement.","pos":[66046,66138],"source":"You can delete multiple records from a database table by using a **delete\\_from** statement."},{"content":"This can be more efficient and faster than deleting one record at a time by using the <ph id=\"ph1\">`xRecord .delete`</ph> method in a loop.","pos":[66139,66260],"source":" This can be more efficient and faster than deleting one record at a time by using the `xRecord .delete` method in a loop."},{"content":"If you have overridden the delete method, the system interprets the <ph id=\"ph1\">`delete_from`</ph> statement into code that calls the <ph id=\"ph2\">`delete`</ph> method one time for each row that is deleted.","pos":[66261,66432],"source":" If you have overridden the delete method, the system interprets the `delete_from` statement into code that calls the `delete` method one time for each row that is deleted."},{"pos":[66438,66496],"content":"Example 1: efficiently deleting records using delete\\_from","linkify":"Example 1: efficiently deleting records using delete\\_from","nodes":[{"content":"Example 1: efficiently deleting records using delete<ph id=\"ph1\">\\_</ph>from","pos":[0,58],"source":"Example 1: efficiently deleting records using delete\\_from"}]},{"content":"The following code example is an efficient way to delete multiple records.","pos":[66498,66572]},{"pos":[66758,66815],"content":"Example 2: inefficiently deleting records using forUpdate","linkify":"Example 2: inefficiently deleting records using forUpdate","nodes":[{"content":"Example 2: inefficiently deleting records using forUpdate","pos":[0,57]}]},{"content":"The following code example is inefficient.","pos":[66817,66859]},{"content":"It issues a separate SQL delete call to the database server for each record.","pos":[66860,66936]},{"content":"The <ph id=\"ph1\">`xRecord`</ph> <ph id=\"ph2\">`.delete`</ph> method never deletes more than one record per call.","pos":[66937,67012],"source":" The `xRecord` `.delete` method never deletes more than one record per call."},{"pos":[67341,67379],"content":"Example 3: deleting with an inner join","linkify":"Example 3: deleting with an inner join","nodes":[{"content":"Example 3: deleting with an inner join","pos":[0,38]}]},{"content":"Inner joins are not supported on the <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> statement.","pos":[67381,67445],"source":"Inner joins are not supported on the **delete\\_from** statement."},{"content":"Therefore you cannot use the unmodified <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> keyword on the <bpt id=\"p2\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p2\">**</ept> statement.","pos":[67446,67537],"source":" Therefore you cannot use the unmodified **join** keyword on the **delete\\_from** statement."},{"content":"However, there are other ways to logically accomplish an inner join.","pos":[67538,67606]},{"content":"The examples in this section show the new and old techniques for achieving inner join logic through a sequence of statements.","pos":[67607,67732]},{"pos":[69142,69189],"content":"Example 4: deleting with notexists join keyword","linkify":"Example 4: deleting with notexists join keyword","nodes":[{"content":"Example 4: deleting with notexists join keyword","pos":[0,47]}]},{"content":"You can use the <bpt id=\"p1\">**</bpt>notexists join<ept id=\"p1\">**</ept> keyword pair in a <bpt id=\"p2\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p2\">**</ept> statement.","pos":[69191,69271],"source":"You can use the **notexists join** keyword pair in a **delete\\_from** statement."},{"content":"The <ph id=\"ph1\">`delete_from`</ph> statements in the following code example are efficient.","pos":[69272,69345],"source":" The `delete_from` statements in the following code example are efficient."},{"content":"The <ph id=\"ph1\">`notexists join`</ph> clause enables the <ph id=\"ph2\">`delete_from`</ph> statement to delete a specific set of rows.","pos":[69346,69443],"source":" The `notexists join` clause enables the `delete_from` statement to delete a specific set of rows."},{"content":"In this example the <ph id=\"ph1\">`delete_from`</ph> statement removes all the parent order header rows for which there are no child order line rows.","pos":[69444,69574],"source":" In this example the `delete_from` statement removes all the parent order header rows for which there are no child order line rows."},{"content":"You can also use the <ph id=\"ph1\">`exists join`</ph> clause on the <ph id=\"ph2\">`delete_from`</ph> statement.","pos":[69575,69648],"source":" You can also use the `exists join` clause on the `delete_from` statement."},{"pos":[73043,73074],"content":"Maintaining Fast SQL Operations","linkify":"Maintaining Fast SQL Operations","nodes":[{"content":"Maintaining Fast SQL Operations","pos":[0,31]}]},{"content":"There are situations where record-set operations can be converted to slower record-by-record operations.","pos":[73075,73179]},{"content":"The following table identifies these situations.","pos":[73180,73228]},{"content":"DELETE<ph id=\"ph1\">\\_</ph>FROM","pos":[73296,73308],"source":"DELETE\\_FROM"},{"content":"UPDATE<ph id=\"ph1\">\\_</ph>RECORDSET","pos":[73311,73328],"source":"UPDATE\\_RECORDSET"},{"content":"INSERT<ph id=\"ph1\">\\_</ph>RECORDSET","pos":[73331,73348],"source":"INSERT\\_RECORDSET"},{"content":"ARRAY<ph id=\"ph1\">\\_</ph>INSERT","pos":[73351,73364],"source":"ARRAY\\_INSERT"},{"content":"Use ... to override","pos":[73367,73386]},{"content":"Non-SQL tables","pos":[73550,73564]},{"content":"Yes","pos":[73614,73617]},{"content":"Yes","pos":[73629,73632]},{"content":"Yes","pos":[73649,73652]},{"content":"Yes","pos":[73669,73672]},{"content":"Not applicable","pos":[73685,73699]},{"content":"Delete actions","pos":[73709,73723]},{"content":"Yes","pos":[73773,73776]},{"content":"No","pos":[73788,73790]},{"content":"No","pos":[73808,73810]},{"content":"No","pos":[73828,73830]},{"content":"Database log enabled","pos":[73868,73888]},{"content":"Yes","pos":[73932,73935]},{"content":"Yes","pos":[73947,73950]},{"content":"Yes","pos":[73967,73970]},{"content":"No","pos":[73987,73989]},{"content":"Overridden method","pos":[74027,74044]},{"content":"Yes","pos":[74091,74094]},{"content":"Yes","pos":[74106,74109]},{"content":"Yes","pos":[74126,74129]},{"content":"Yes","pos":[74146,74149]},{"content":"Alerts set up for table","pos":[74186,74209]},{"content":"Yes","pos":[74250,74253]},{"content":"Yes","pos":[74265,74268]},{"content":"Yes","pos":[74285,74288]},{"content":"No","pos":[74305,74307]},{"content":"ValidTimeStateFieldType property not equal to None on a table","pos":[74345,74406]},{"content":"Yes","pos":[74409,74412]},{"content":"Yes","pos":[74424,74427]},{"content":"Yes","pos":[74444,74447]},{"content":"Yes","pos":[74464,74467]},{"content":"Not applicable","pos":[74480,74494]},{"content":"You may explicitly skip or ignore one or more things that would adversely impact performance by using the items shown in the far right column.","pos":[74503,74645]},{"content":"If for some reason one of the previously mentioned SQL operations is downgraded to a record-by-record operation, all of the <ph id=\"ph1\">`skip`</ph> settings are also ignored.","pos":[74646,74804],"source":" If for some reason one of the previously mentioned SQL operations is downgraded to a record-by-record operation, all of the `skip` settings are also ignored."},{"content":"For example, the <ph id=\"ph1\">`insert`</ph> method on myTable is executed in the following example even though it is explicitly stated that this method should be skipped if myTable has a container or memo field defined.","pos":[74805,75006],"source":" For example, the `insert` method on myTable is executed in the following example even though it is explicitly stated that this method should be skipped if myTable has a container or memo field defined."}],"content":"---\n# required metadata\n\ntitle: X++ Data Selection and Manipulation | Microsoft Docs\ndescription: This topic describes the X++ language support for data selection and manipulation.\nauthor: annbe\nmanager: AnnBe\nms.date: 2016-08-27 00:35:54\nms.topic: \nms.prod: \nms.service: \nms.technology: \n\n# optional metadata\n\n# keywords: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: 61\nms.suite: Released- Dynamics AX 7.0.0\n# ms.tgt_pltfrm: \nms.custom: 150273\nms.assetid: 67626fff-6c00-4c7f-b399-80777f18c497\n# ms.region: \n# ms.industry: \nms.author: annbe\n\n---\n\n# X++ Data Selection and Manipulation\n\nYou can use SQL statements either interactively or within source code, to access and retrieve data that is stored in the database. Data manipulation is performed through the following statements:\n\n-   `select` selects the data that you want to modify.\n-   `insert` adds one or more new records into a table.\n-   `update` modifies data in existing table records.\n-   `delete` removes existin records from a table.\n\nBefore any data can be changed, the data must first be selected for update by using a select statement. The `select forUpdate` command selects records exclusively for update. The `insert`, `update`, and `delete` methods perform operations on only one record at a time. The array insert, insert\\_recordset, RecordInsertList, and update\\_recordset statements perform operations on multiple records at a time.\n\n## Select Statements\nThe **select** statement fetches or manipulates data from the database. All `select `statements use a table variable to fetch records. This variable must be declared before a `select` statement can be executed. The `select` statement only fetches one record, or field. To fetch additional records, you can use the `next` statement. The `next` statement fetches the next record in the table. If you use `next` without a preceding `select` command, an error occurs. Do not use `next` with the `firstOnly` find option. If you need to traverse a number of records, it is more appropriate to use a `while` `select` statement. Results of a `select` statement are returned in a table buffer variable. If you use a field list in the `select` statement, only those fields are available in the table variable. If you use aggregate functions, such as `sum` or `count`, the results are returned in the fields that you perform the `sum` or `count` over. You can only count, average, or sum the integer and real fields.\n\n## Select Statement Syntax\n-   *SelectStatement* = `select` *Parameters*\n-   *Parameters* = `[ [ ` *FindOptions* ` ]` `[ ` *FieldList* ` from ] ]` *TableBufferVariable* `[` *IndexClause* `]` `[ ` *Options* ` ]` `[ ` *WhereClause* ` ]` `[ ` *JoinClause* ` ]`\n-   *FindOptions* = `crossCompany` | `reverse` | `firstFast` | \\[ `firstOnly` | `firstOnly10` | `firstOnly100` | `firstOnly1000` \\] | `forUpdate` | `noFetch` | \\[`forcePlaceholders` | `forceLiterals`\\] | `forceselectorder` | `forceNestedLoop` | `repeatableRead` | `validTimeState`\n-   *FieldList *= *Field* ` { , ` *Field* ` }` | `*`\n-   *Field = Aggregate ` ( ` *FieldIdentifier* ` ) | ` *FieldIdentifier**\n-   *Aggregate* = `sum` | `avg` | `minof` | `maxof` | `count`\n-   *Options *= `[ order by` , `group by , ` *FieldIdentifier* ` [ asc` | `desc ] { , ` *FieldIdentifier* ` [ asc` | `desc ] }]` | `[ ` *IndexClause* ` ]`\n-   *IndexClause * = `index ` *IndexName* | `index hint ` *IndexName*\n-   *WhereClause *= `where ` *Expression*\n-   *JoinClause *= \\[`exists` | `notexists` | `outer` \\] `join ` *Parameters*\n\n|                   |     |                                                                                                                                                                                                                                                                      |\n|-------------------|-----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| *SelectStatement* | =   | `select` *Parameters*                                                                                                                                                                                                                                                |\n| *Parameters*      |     | `[ [ ` *FindOptions* ` ]` `[ ` *FieldList* ` from ] ]` *TableBufferVariable* `[` *IndexClause* `]` `[ ` *Options* ` ]` `[ ` *WhereClause* ` ]` `[ ` *JoinClause* ` ]`                                                                                                |\n| *FindOptions*     | =   | `crossCompany` | `reverse` | `firstFast` | \\[ `firstOnly` | `firstOnly10` | `firstOnly100` | `firstOnly1000` \\] | `forUpdate` | `noFetch` | \\[`forcePlaceholders` | `forceLiterals`\\] | `forceselectorder` | `forceNestedLoop` | `repeatableRead` | `validTimeState` |\n| *FieldList*       | =   | *Field* ` { , ` *Field* ` }` | `*`                                                                                                                                                                                                                                   |\n| *Field*           | =   | *Aggregate* ` ( ` *FieldIdentifier* ` ) | ` *FieldIdentifier*                                                                                                                                                                                                        |\n| *Aggregate*       | =   | `sum` | `avg` | `minof` | `maxof` | `count`                                                                                                                                                                                                                          |\n| *Options*         | =   | `[ order by` , `group by , ` *FieldIdentifier* ` [ asc` | `desc ] { , ` *FieldIdentifier* ` [ asc` | `desc ] }]` | `[ ` *IndexClause* ` ]`                                                                                                                           |\n| *IndexClause*     | =   | `index ` *IndexName* | `index hint ` *IndexName*                                                                                                                                                                                                                     |\n| *WhereClause*     | =   | `where ` *Expression*                                                                                                                                                                                                                                                |\n| *JoinClause*      | =   | \\[`exists` | `notexists` | `outer` \\] `join ` *Parameters*                                                                                                                                                                                                           |\n\n### Keywords Used in the Select Syntax\n\nThe **asc** keyword is an option on the `order by` or `group by` clause. The sorting is ascending. (Sort is ascending by default.) The **avg** keyword returns the average of the fields. The **count** keyword returns the number of records. The **crossCompany** keyword returns data for all companies that the user is authorized to read from. (A `container` can be added to reduce the number of companies involved.) The **desc** keyword is an option on the `order by` or `group by` clause. The sorting is descending. The **exists** keyword is a method that returns a Boolean value and a `join` clause. The **firstFast** keyword is a priority hint. The first row appears more quickly but the total return time for this option might be slower. The `firstFast` hint is automatically issued from all forms. The **firstOnly** keyword speeds up the fetch by returning only the first row. The **firstOnly10** keyword is the same as **firstOnly**, except returns 10 rows instead of one. The **firstOnly100** keyword is the same as **firstOnly**, except returns 100 rows instead of one. The **firstOnly1000** keyword is the same as **firstOnly**, except returns 1000 rows instead of one. The **forceLiterals** keyword instructs the kernel to reveal the actual values that are used in `where` clauses to the Microsoft SQL Server database at the time of optimization. **forceLiterals** and **forcePlaceholders** are mutually exclusive. You are advised not to use the **forceLiterals** keyword in `select` statements, because it could expose code to an SQL injection security threat. The **forceNestedLoop** keyword forces the Microsoft SQL Server database to use a nested-loop algorithm to process a particular SQL statement containing a join algorithm. This means that a record from the first table is fetched before any records from the second table are fetched. Typically, other join algorithms, such as hash-joins and merge-joins, would be considered. This keyword is often combined with the **forceSelectOrder** keyword. The **forcePlaceholders** keyword instructs the kernel not to reveal the actual values used in `where` clauses to the SQL Server database at the time of optimization. This is the default in all statements that are not `join` statements.The advantage of using this keyword is that the kernel can reuse the access plan for other similar statements with other search values. The disadvantage is that the access plan is computed without taking into consideration that data distribution might not be even. The access plan is an on-average access plan. **forcePlaceholders** and **forceLiterals** are mutually exclusive. The **forceSelectOrder** keyword forces the SQL Server database to access the tables in a join in the specified order. If two tables are joined, the first table in the statement is always accessed first. This keyword is often combined with the **forceNestedLoop** keyword. The **forUpdate** keyword selects records exclusively for update. Depending on the underlying database, the records may be locked for other users. The **group by** keyword instructs the database to group selected records by fields. The **index** keyword instructs the database to sort the selected records as defined by the index. The **index hint** keyword gives the database a hint to use this index to sort the selected records as defined by the index. The database can ignore the hint. A wrong index hint can have a big performance impact. Index hints should only be applied to SQL statements that do not have dynamic `where` clauses or `order by` clauses, and where the effect of the hint can be verified. The **join** keyword used to join tables on a column that is common to both tables. The join criteria are specified in the **where** clause because there is no **on** keyword. Reduces the number of SQL statements that are needed if you want to loop through a table and update transactions in a related table. For example, if you process 500 records in a table, and want to update related records in another table, and use a nested `while select` to do this, there will be 501 trips to the database. If you use a **join**, there will be a single trip to the database. The **maxof** keyword returns the maximum of the fields. The **minof** keyword returns the minimum of the fields. The **noFetch** keyword indicates that no records are to be fetched at present. This is typically used when the result of the select is passed on to another application object, for example, a query that performs the actual fetch. The **notExists** keyword is chosen only if there are no posts. The **optimisticLock** keyword forces a statement to run with Optimistic Concurrency Control even if a different value is set on the table.For more information, see Optimistic Concurrency Control. The **order by** keyword instructs the database to sort the selected records by fields in the `order by` list. The **outer** keyword returns all rows from the first-named table, including rows that have no match in the second-named table. This is a left outer join, although there is no **left** keyword. There is no right outer join. The **pessimisticLock** keyword forces a statement to run with Pessimistic Concurrency Control even if a different value is set on the table.For more information, see Optimistic Concurrency Control. The **repeatableRead** keyword specifies that no other transactions can modify data that has been read by logic inside the current transaction, until after the current transaction completes.An explicit transaction completes at either **ttsAbort** or at the outermost **ttsCommit**. For a stand-alone **select** statement, the transaction duration is the duration of the **select** command. However, the database sometimes enforces the equivalent of **repeatableRead** in individual **select** statements even without this keyword appearing in your code (depending on how the database decides to scan the tables). For more information, see the documentation for the underlying relational database product. The **reverse** keyword records are returned in reverse order. The **sum** keyword returns the sum of the fields. Can be used to sum all accounts, order lines, and so on. The **validTimeState** keyword filters rows from a table that has its ValidTimeStateFieldType property set to a value other than None. For more information, see Valid Time State Tables and Date Effective Data.\n\n#### Keyword Code Examples\n\n    // asc keyword example.\n    select * from custTable     order by Name asc;\n     \n    // avg keyword example. \n    CustTable custTable;;\n    select avg(value) from custTable;\n    print custTable.value;\n     \n    // count keyword example. \n    CustTable xCT;int64 iCountRows; ;\n    Select COUNT(RecID) from xCT;\n    iCountRows = xCT.RecID;\n     \n    // crossCompany keyword example.\n    CustTable custTable;\n    container conCompanies = ['dat','dmo'];\n    select crossCompany :conCompanies\n        * from custTable;\n     \n    // desc keyword example.\n    select * from custTable     \n        order by Name desc;\n     \n    // exists keyword example. \n    while select AccountNum, Name from custTable    \n        order by AccountNum\n        exists join * from ctr\n        where (ctr.AccountNum ==\n          custTable.AccountNum)\n     \n    // firstFast keyword example. \n    select firstFast custTable     \n        order by AccountNum;\n     \n    // firstOnly keyword example. \n    static InventTable find(ItemIditemId, boolean update = false)\n    {\n        InventTable inventTable;\n     \n        inventTable.selectForUpdate(update);\n        if (itemId)\n        {\n            select firstonly inventTable\n                index hint ItemIdx\n                where inventTable.itemId == itemId;\n        }\n        return inventTable;\n    }\n     \n    // forceNestedLoop keyword example. \n    while select forceSelectOrder    \n        forceNestedLoop inventTransThis\n    index hint TransIdIdx\n    where inventTransThis.InventTransId\n            == inventTrans.InventTransId\n            && inventTransThis.StatusIssue\n            <= StatusIssue::ReservOrdered \n     \n    // forcePlaceholders keyword example. \n    static void forcePlaceHoldersExample(Args _args){\n        SalesTable salesTable;\n        SalesLine salesLine;\n     \n        while select forcePlaceholders salesLine\n            join salesTable\n               where salesTable.SalesId ==\n                salesLine.SalesId\n                   && salesTable.SalesId == '10'\n        {\n            //more code\n        }\n    }\n     \n    // forceSelectOrder keyword example. \n    display ForecastHasPurch hasForecastPurch(){\n        ForecastPurch forecastPurch;\n        InventDim nventDim;\n     \n    select firstOnly forcePlaceholders\n        forceSelectOrder recId\n        from forecastPurch\n        index hint ItemIdx\n        where forecastPurch.itemId == this.itemId\n    exists join inventDim\n        index hint DimIdIdx\n        where inventDim.inventDimId == forecastPurch.inventDimId\n            && inventDim.configId == this.configId;\n        return forecastPurch.recId;\n    }\n     \n    // forUpdate keyword example. \n    ttsBegin; while select forUpdate ledgerJournalTrans\n        index hint NumVoucherIdx\n        where ledgerJournalTrans.journalNum ==\n        _journalNum &&\n        ledgerJournalTrans.voucher == _voucher\n    {\n        ledgerJournalTrans.doDelete();\n        counter++;\n    }\n    if (counter\n        && ledgerJournalTable.journalType\n        != LedgerJournalType::Periodic)\n    {\n        NumberSeq::release(\n          ledgerJournalTable.voucherSeries,\n          _voucher);\n    }\n    ttsCommit;\n    // group by keyword example. \n        CustTable custTable;;\n    while select sum(CreditMax) from custTable\n        group by CustGroup\n    {\n        print custTable.CustGroup, \" \",custTable.CreditMax;\n    }\n     \n    // index keyword example. \n        CustTable custTable;;\n    while select AccountNum, Name from custTable\n        index AccountIdx\n    {\n        print custTable.AccountNum, \" \", custTable.Name;\n    }\n     \n    // index hint keyword example. \n    while select forUpdate ledgerJournalTrans    \n        index hint NumVoucherIdx\n        where ledgerJournalTrans.journalNum\n            == _journalNum\n     \n    // join keyword example. \n    while select ledgerTable    join ledgerTrans\n        where ledgerTrans.accountNum == ledgerTable.accountNum\n    {\n        amountMST += ledgerTrans.amountMST;\n    }\n     \n    // maxof keyword example. \n    CustTable custTable;;\n    select maxof(CreditMax) from custTable;\n     \n    // minof keyword example. \n    CustTable custTable;;\n    select minof(CreditMax) from custTable;\n     \n    // noFetch keyword example. \n    select noFetch custTable\n        order by AccountNum\n     \n    // notExists keyword example. \n    while select AccountNum, Name from custTable    \n        order by AccountNum\n        notExists join * from ctr\n        where (ctr.AccountNum ==\n            custTable.AccountNum)\n\n    // optimisticLock keyword example. \n    select optimisticLock custTable    \n        where custTable.AccountNum > '1000'\n     \n    // order by keyword example. \n    select * from custTable     \n        order by accountNum desc\n        where custTable.AccountNum > \"100\";\n     \n    // outer keyword example. \n    while select AccountNum\n     from custTable\n     order by AccountNum\n     outer join * from custBankAccount\n     where custBankAccount.AccountNum ==\n        custTable.AccountNum\n    {\n     print custTable.AccountNum,\n        \" , \", custBankAccount.DlvMode;\n    }\n     \n    // pessimisticLock keyword example. \n    select pessimisticLock custTable    where custTable.AccountNum > '1000';\n     \n    // reverse keyword example. \n            select reverse custTable     order by AccountNum;\n     \n    // sum keyword example. \n        CustTable custTable;;\n    select sum(CreditMax) from custTable;\n     \n    // validTimeState keyword example. \n        static void VtsJob1(Args _args)\n    {\n        // A validTimeState table. \n        CustPackingSlipTransHistory xrec1;\n        utcDateTime myDateFrom , myDateTo;\n        anytype myAnytype = -1;\n        myDateFrom = DateTimeUtil::utcNow();\n        myDateTo = myDateFrom;\n        SELECT \n            validTimeState(myDateFrom, myDateTo)\n                *\n            FROM xrec1;\n        myAnytype = xrec1.getFieldValue(\"RecId\");\n        info(myAnytype);\n    }\n\n## Select Statement Examples\nThe following method shows several examples of how you can use the **select** statement.\n\n    static void SelectRecordExamples3Job(Args _args)\n    {\n        CustTable custTable;  \n        // A customer is found and returned in custTable\n        select * from custTable;\n        info(\"A: \" + custTable.AccountNum);\n     \n        // A customer with account number > \"100\" is found\n        select * from custTable\n            where custTable.AccountNum > \"100\";\n        info(\"B: \" + custTable.AccountNum);\n     \n        // Customer with the lowest account number > \"100\" found:\n        select * \n            from custTable \n                order by accountNum\n                    where custTable.AccountNum > \"100\";\n        info(\"C1: \" + custTable.AccountNum);\n     \n        // The next customer is read\n        next custTable;\n        info(\"C2: \" + custTable.AccountNum);\n     \n        // Customer with higest account number\n        // (greater than 100) found: Fourth Coffee\n        select * \n            from custTable \n                order by accountNum desc\n                    where custTable.accountNum > \"100\";\n        info(\"D1: \" + custTable.AccountNum);\n     \n        // The next record is read (DESC): Fabrikam, Inc.\n        next custTable; \n        info(\"D2: \" + custTable.AccountNum);\n     \n        // Customer with highest account number found: Fourth Coffee\n        select reverse custTable \n            order by accountNum;\n        info(\"E: \" + custTable.AccountNum);\n     \n        // Customer with \"lowest\" name and account number\n        // in the interval 100 to 1000 is found. This is Coho Winery.\n        select * \n            from custTable \n                order by DlvMode\n                    where custTable.accountNum > \"100\"\n                        && custTable.accountNum < \"1000\";\n        info(\"F: \" + custTable.AccountNum);\n     \n        // The count select returns the number of customers.\n        select count(AccountNum) \n            from custTable;\n     \n        // Prints the result of the count\n        info(strFmt(\"G: %1 = Count of AccountNums\", custTable.accountNum));\n     \n        // Returns the average credit max for non-blocked customers.\n        select avg(CreditMax) \n            from custTable\n                where custTable.blocked == CustVendorBlocked::No;\n     \n        // Prints the result of the avg\n        info(strFmt(\"H: %1 = Average CreditMax\", custTable.CreditMax));\n    }\n     \n    /*** Display from infolog:\n    Message (02:00:34 pm)\n    A: 4000\n    B: 4000\n    C1: 4000\n    C2: 4001\n    D1: 4507\n    D2: 4506\n    E: 4507\n    F: \n    G: 29 = Count of AccountNums\n    H: 103.45 = Average CreditMax\n    ***/\n\n### Join Code Example\n\nThis code example shows how an inner **join** can be performed as part of an SQL **select** statement. The example also shows an order by clause that has each field qualified by a table name. This enables you to control how the retrieved records are sorted by using only one order by clause.\n\n    static void SelectJoin22Job(Args _args)\n    {\n        CustTable xrecCustTable;\n        CashDisc xrecCashDisc;\n        struct sut4;\n        sut4 = new struct(\"str AccountNum; str CashDisc; str Description\");\n        while select firstOnly10 *\n            from xrecCustTable\n                order by xrecCashDisc.Description\n                    join xrecCashDisc\n                        where xrecCustTable.CashDisc ==\n                            xrecCashDisc.CashDiscCode\n                            && xrecCashDisc.Description LIKE \"*Days*\"\n        {\n            sut4.value(\"AccountNum\", xrecCustTable.AccountNum );\n            sut4.value(\"CashDisc\", xrecCashDisc.CashDiscCode );\n            sut4.value(\"Description\", xrecCashDisc.Description );\n            info(sut4.toString());\n        }\n    /*********  Actual Infolog output\n    Message (02:29:37 pm)\n    (AccountNum:\"1101\"; CashDisc:\"0.5%D10\"; Description:\"0.5% 10 days\")\n    (AccountNum:\"4001\"; CashDisc:\"0.5%D10\"; Description:\"0.5% 10 days\")\n    (AccountNum:\"1102\"; CashDisc:\"0.5%D30\"; Description:\"0.5% 30 days\")\n    (AccountNum:\"1201\"; CashDisc:\"0.5%D30\"; Description:\"0.5% 30 days\")\n    (AccountNum:\"2211\"; CashDisc:\"0.5%D30\"; Description:\"0.5% 30 days\")\n    (AccountNum:\"1202\"; CashDisc:\"1%D15\"; Description:\"1% 15 days\")\n    (AccountNum:\"1203\"; CashDisc:\"1%D07\"; Description:\"1% 7 days\")\n    (AccountNum:\"2212\"; CashDisc:\"1%D07\"; Description:\"1% 7 days\")\n    (AccountNum:\"2213\"; CashDisc:\"1%D07\"; Description:\"1% 7 days\")\n    (AccountNum:\"2214\"; CashDisc:\"1%D07\"; Description:\"1% 7 days\")\n    *********/\n    }\n\n### Group By and Order By\n\nThis code example shows that the fields in the **group by** clause can be qualified with a table name. There can be multiple `group by` clauses instead of just one. The fields can be qualified by table name in only one `group by` clause. Use of table name qualifiers is recommended. The **order by** clause follows the same syntax patterns that group by follows. If provided, both clauses must appear after the `join` (or `from`) clause, and both must appear before the `where` clause that might exist on the same `join`. It is recommended that all group by and order by and **where** clauses appear immediately after the last `join` clause.\n\n    static void SelectGroupBy66Job(Args _args)\n    {\n        CustTable xrecCustTable;\n        CashDisc xrecCashDisc;\n        struct sut4;\n        sut4 = new struct(\"str AccountNum_Count; str CashDisc; str Description\");\n        while select\n            count(AccountNum)\n            from xrecCustTable\n                order by xrecCashDisc.Description\n                    join xrecCashDisc\n            group by\n                xrecCashDisc.CashDiscCode\n                        where xrecCustTable.CashDisc ==\n                            xrecCashDisc.CashDiscCode\n                            && xrecCashDisc.Description LIKE \"*Days*\"\n        {\n            sut4.value(\"AccountNum_Count\", xrecCustTable.AccountNum );\n            sut4.value(\"CashDisc\", xrecCashDisc.CashDiscCode );\n            sut4.value(\"Description\", xrecCashDisc.Description );\n            info(sut4.toString());\n        }\n    /*********  Actual Infolog output\n    Message (02:45:26 pm)\n    (AccountNum_Count:\"2\"; CashDisc:\"0.5%D10\"; Description:\"\")\n    (AccountNum_Count:\"3\"; CashDisc:\"0.5%D30\"; Description:\"\")\n    (AccountNum_Count:\"4\"; CashDisc:\"1%D07\"; Description:\"\")\n    (AccountNum_Count:\"1\"; CashDisc:\"1%D15\"; Description:\"\")\n    (AccountNum_Count:\"1\"; CashDisc:\"2%D30\"; Description:\"\")\n    (AccountNum_Count:\"1\"; CashDisc:\"3%D10\"; Description:\"\")\n    *********/\n    }\n\n### Select Statement with an Outer Join\n\nThe `select` statement supports filtering an **outer join** in the `where` clause. In the `join` clause of standard SQL there is an `on` keyword for filter criteria, but that isn't supported in X++. An inner join rejects all table rows that fail to match a row in the other joined table. But an outer join includes rows from the first table even though there is no matching row in the other joined table. Default values are substituted for the data that could not be obtained from a matching row in the other joined table. You can filter an outer join at the equivalent of an `on` clause that is part of the `join` clause. For more information, see How to: Use the QueryFilter Class with Outer Joins. For an inner join there is no behavioral difference between filtering on an `on` clause versus on the `where` clause.\n\n#### Select statement code example\n\nThis code example is based on two tables. The field types and example data are included. There is a 1-to-many relationship between the `SalesOrder` parent table and the `SalesOrderLine` child table. There are 0 or more rows in the `SalesOrderLine` table for each row in the `SalesOrder` table. There are two rows in the `SalesOrder` table.\n\n| `SalesOrderID` (integer, primary key) | `DateAdded` (date) |\n|---------------------------------------|--------------------|\n| 1                                     | 2010-01-01         |\n| 2                                     | 2010-02-02         |\n\nThe `SalesOrderLine` table contains a foreign key field, named `SalesOrderID`, that references the primary key column of the `SalesOrder` table. The `SalesOrderID` value `2` does not occur in the data for `SalesOrderLine` table.\n\n| `SalesOrderLineID` (string, primary key) | `Quantity` (integer) | `SalesOrderID` (integer, foreign key) |\n|------------------------------------------|----------------------|---------------------------------------|\n| AA                                       | 32                   | 1                                     |\n| BB                                       | 67                   | 1                                     |\n| CC                                       | 66                   | 1                                     |\n\nThe code example has a `select` statement that reads the tables which are described in the previous section. The `select` statement includes a left `outer join` clause. The join criteria and the data filter are both on the `where` clause. The output from the code example is also in this section. The second record in the output has a `SalesOrderID` value of 2. That value of 2 is not present in the `SalesOrderLine` table. Therefore, some of the fields in the second record have default values, namely 0 for an integer and a zero length string for a string.\n\n    static void OuterJoinSelectJob3(Args _args)\n    {\n        SalesOrder recSalesOrder;\n        SalesOrderLine recSalesOrderLine;\n        struct struct4;\n     \n        struct4 = new struct\n            (\"int SalesOrderID;\"\n            + \"date DateAdded;\"\n            + \"str SalesOrderLineID;\"\n            + \"int Quantity\"\n            );\n        while\n        SELECT\n                *\n            from\n                recSalesOrder\n                OUTER JOIN recSalesOrderLine\n            WHERE\n                recSalesOrder.SalesOrderID == recSalesOrderLine.SalesOrderID\n                && recSalesOrderLine.Quantity == 66\n        {\n            struct4.value(\"SalesOrderID\", recSalesOrder.SalesOrderID);\n            struct4.value(\"DateAdded\", recSalesOrder.DateAdded);\n            struct4.value(\"SalesOrderLineID\", recSalesOrderLine.SalesOrderLineID);\n            struct4.value(\"Quantity\", recSalesOrderLine.Quantity);\n            info(struct4.toString());\n        }\n    }\n    /*********  Actual Infolog output (with break spaces entered in between each output)\n    (SalesOrderID:1; \n    DateAdded:2010/1/1; \n    SalesOrderLineID:\"CC\"; \n    Quantity:66)\n    (SalesOrderID:2; \n    DateAdded:2010/2/2; \n    SalesOrderLineID:\"\"; \n    Quantity:0)\n    *********/\n\n## while select statements\n**while select** statements are used to handle data. They are the most widely used form of the select statement. `while select` loops over many records (meeting certain criteria) and can execute a statement on each record. When you perform data manipulation by using the `while select` statement, you would typically do this in a transaction to ensure data integrity. The results of a `while select` statement are returned in a table buffer variable. If you use a field list in the `select` statement, only those fields are available in the table variable. If you use aggregate functions such as `sum` or `count`, the results are returned in the fields you perform the `sum` or `count` over. You can only count, average, or sum the integer and real fields. The syntax of a `while select` statement resembles that of a **select** statement except that it is preceded by `while select` instead of `select`. The `select` statement itself is executed only one time, immediately before the first iteration of the statements in the loop. Any Boolean expressions (such as `iCounter < 1`) added to the `while select` are tested only one time. This differs from how the `while` statement behaves in languages such as C++ and C\\#. For example, the following loop could iterate more than one time.\n\n    static void JobWhileSelect(Args _args) // X++ job.\n    {\n        int iCounter = 0;\n        BankAccountTable xrecBAT;\n        while select * from xrecBAT\n            where iCounter < 1\n        {\n            iCounter++;\n            Global::info(strFmt(\"%1 , %2\", iCounter, xrecBAT.AccountID));\n        }\n    }\n     \n    /*** Display from infolog:\n    Message (04:59:38 pm)\n    1 , Cash1\n    2 , STB-DKK\n    3 , STB-EUR\n    ***/\n\n### while select Code Example\n\nThis prints the name reference and telephone number of customers in `CustTable` who have an account number within a specified range.\n\n    static void JobPrintTel(Args _args)\n    {\n        CustTable xrecCT;\n        while select xrecCT \n            order by xrecCT.AccountNum\n                where  xrecCT.AccountNum >= \"4010\" \n                    && xrecCT.AccountNum <= \"4100\"\n        {\n            Global::info(strFmt(\"%1 , %2\", \n                xrecCT.AccountNum, xrecCT.SalesGroup));\n        }\n    }\n     \n    /*** Display from Infolog:\n    Message (06:04:03 pm)\n    4010 , CSG-EU\n    4011 , CSG-EU\n    4012 , CSG-OTH\n    4013 , CSG-OTH\n    4014 , CSG-OTH\n    4015 , CSG-OTH\n    4016 , CSG-EU\n    4017 , CSG-EU\n    4018 , CSG-EU\n    4020 , \n    4024 , \n    ***/\n\n### while select Code Example\n\nThis code example uses the **forUpdate** keyword.\n\n    static void LedgerJob(Args _args)\n    {\n        LedgerJournalTrans ledgerJournalTrans;\n        LedgerJournalTable ledgerJournalTable;\n        LedgerJournalId    jnJournalNum;\n        Voucher            vVoucher;\n        Counter            counter = 0;\n        jnJournalNum = \"999999_999\"; //\"000012_003\";\n        vVoucher = \"88888_888\"; //\"00001_IRG\";\n        ledgerJournalTable = \n            ledgerJournalTable::find(jnJournalNum);\n        ttsBegin;\n        while select forUpdate ledgerJournalTrans\n            index hint NumVoucherIdx\n                where ledgerJournalTrans.journalNum == jnJournalNum \n                   && ledgerJournalTrans.voucher == vVoucher\n        {\n            ledgerJournalTrans.doDelete();\n            counter++;\n        }\n     \n        //NumberSeq updates needed?\n        ttsCommit;\n        Global::info(strFmt(\"counter = %1\", counter));\n    }\n\n### Deleting a Set of Records\n\nYou can use a `while select` statement to loop over a set of records that meet some criteria and perform an action on each record. One such action is to **delete** a set of records. `{    TableName myXrec;    while select myXrec      where ` *Conditions*  `  {      myXrec.delete();    }  }` You can achieve the same effect using the **delete\\_from** keyword. `{    TableName myXrec;    delete_from myXrec      where ` *Conditions* `;  }`\n\n### Select Statements on Fields\n\nYou can use a **select** statement in a lookup on a field. Following a `select statement` that fetches a record in a table, you can write *.fieldName* to reference a field in the table. These `select` statements must be used in expressions. There is a difference between a `normal` `select` statement and a `field select` statement:\n\n-   The `field select` statement operates directly on a table.\n-   The `normal select` statement operates on a table buffer variable.\n\n### select field Code Example\n\n    void selectFieldExamples ()\n    {\n        // Prints the NameRef field from the selected customer\n        print (select CustTable order by AccountStatement).AccountStatement;\n     \n        // Uses the balance field from the customer with AccountNum 3000\n        if ((select custTable where CustTable.AccountNum == '3000').CreditMax < 50000)\n          print \"This customer has a credit maximum less than $50,000.\";\n    }\n\n### Aggregate Functions: Differences Between X++ and SQL\n\nIn industry standard SQL, a database query can contain **aggregate functions**. Examples of such functions include `count(RecID)` or `sum(columnA)`. When an aggregate function is used but no rows match the `where` clause, a row must be returned to hold the result of the aggregates. The one returned row shows the value 0 (zero) for the `count` function, and shows `null` for the `sum` function. X++ does not support the concept of null values for the database. Therefore, when the `sum` function would return null, no row is returned to the user. Also, each data type has a specific value that is treated like a null value in certain circumstances. For more information, see Null Values for Data Types.\n\n### Index and Order By in Select Statements\n\nUse the **order by** keyword in your `select` statements to order the data that's returned. Use the **index** hint keywords to specify that a particular index should be used in the query and to sort the selected records as defined by the index. Indexes optimize the selection of records. Combine the index hint keyword with an order by expression to select records in a specific order. If you want the sorted output in reverse order, use the **reverse** keyword. If a table index has been disabled by setting the index's `Enabled` property to No, the `select` statement that references the index is still valid. However, the database can't use the index as a hint for how to sort the data, because the index doesn't exist in the database. The following table is an overview of how to use the index hint and order by keywords in `select` statements.\n\n| Task                                                                                 | Use                                                     |\n|--------------------------------------------------------------------------------------|---------------------------------------------------------|\n| Select records where the order isn't significant.                                    | `select ..`` where ...`                                 |\n| Select records where the order is significant.                                       | `select ..`` order by ...`` where ...`                  |\n| Select records and force a specific index to be used.                                | `select ..`` index hint ...`` where ...`                |\n| Select records where the order is significant and force a specific index to be used. | `select ..`` index hint ...`` order by ...`` where ...` |\n\n### Index and Order By in Select Statements Code Example\n\nTo select the transactions from the salestable based on a range of customers and due dates, use the following code.\n\n    SalesTable salesTable;\n        select salesTable\n        index hint CustIdx\n        order by CustAccount\n        where salesTable.CustAccount >= '3000'\n              && salesTable.CustAccount <= '4000'\n                        && salesTable.FixedDueDate >= 12\\12\\2004\n                        && salesTable.FixedDueDate <= 05\\05\\2009;\n\n### Using Index Hints\n\nTo use **index hints** in queries you must first specify the use of hints on the server using the following procedure.\n\n1.  Open Start &gt; Administrative Tools &gt; Microsoft Dynamics AX Server Configuration and select the Database Tuning tab.\n2.  Select Allow INDEX hints in queries and click OK.\n3.  A message box prompting you to restart the AOS service appears. Click Yes to restart the AOS service. Index hints won't be enabled until the service is restarted.\n\nWhen an index hint in a select statement refers to a non-clustered index and the WHERE clause contains only the fields that are found in a clustered index on the same table, the clustered index is used instead of the index specified in the hint. For example, if you run `sp_helpindex InventTable` in SQL Server Management Studio, you see that the InventTable has a clustered index on the DataAreaId and ItemId columns and a non-clustered index on the DataAreaId, ItemProductId, and ItemType columns.\n\n| Index name       | Description                                       | Key columns                         |\n|------------------|---------------------------------------------------|-------------------------------------|\n| I\\_175ITEMIDX    | Clustered, unique, primary key located on PRIMARY | DATAAREAID, ITEMID                  |\n| I\\_175PRODUCTIDX | Nonclustered located on PRIMARY                   | DATAAREAID, ITEMPRODUCTID, ITEMTYPE |\n\nIn the following code the clustered index will be used instead of the non-clustered index specified in the index hint.\n\n    static void IndexHint(Args _args)\n    {\n        InventTable inv;\n        \n        select * from inv index hint GroupItemIdx \n            where inv.ItemId == 'B-R14';\n    }\n\n### Writing a Select Statement as an Expression\n\nYou can use a `select` statement as an expression. This is called an **expression select**. A table buffer variable cannot be used in an expression select statement. The name of the table must be used in the `from` clause. One limitation of expression selects is that the **join** keyword is not supported in an expression join. Test\\_3 in the code example shows that a subselect is supported, but only in a limited way.\n\n### Expression Selects Code Example\n\nThe following table describes the test cases in the code example.\n\n<table>\n<colgroup>\n<col width=\"50%\" />\n<col width=\"50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Test case</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Test_1.a</td>\n<td>The <code>select</code> statement inside the parentheses returns one row. The only column that can be populated with data is the column that is named in the <code>select</code> clause before the <code>from</code> clause. The name of that one column is used after the closing parenthesis to reference the data value: <code>).AccountNum;</code>.This test case returns a maximum of one row because it uses the <code>firstonly</code> keyword. However, the value that is assigned to <code>sAccountNum</code> is the same even if the <code>firstonly</code> keyword is omitted.The <code>where</code> clause in this example serves no purpose other than to show that the <code>where</code> clause must occur after the <code>order by</code> clause. The table name cannot be used to qualify a field name in the <code>order by</code> clause.</td>\n</tr>\n<tr class=\"even\">\n<td>Test_1.b</td>\n<td>This is a simpler way to achieve the same result as Test_1.a.</td>\n</tr>\n<tr class=\"odd\">\n<td>Test_2.c</td>\n<td>Includes a <code>where</code> clause. In a <code>where</code> clause, the table name must be used as a qualifier of the field.Here the <code>maxof</code> aggregate function is used, and the field <code>RecId</code> is mentioned in the function. The field that is mentioned in the aggregate function must be the same field name that is used to reference the data value after the closing parenthesis. Otherwise, empty data is returned.</td>\n</tr>\n<tr class=\"even\">\n<td>Test_2.d</td>\n<td>Demonstrates that a field name, here <code>RecId</code>, is used to reference a data value that is not a <code>RecId</code>. The <code>count</code> aggregate function does not return a <code>RecId</code> value. The <code>RecId</code> field is ordinarily used with the <code>count</code> function.</td>\n</tr>\n<tr class=\"odd\">\n<td>Test_3</td>\n<td>The <strong>join</strong> keyword is not supported in expression selects. This test case demonstrates a subselect. But expression selects do not support subselects that are equivalent to a standard inner join. For instance, the following code example does not compile. The problem is that it mentions two tables inside one expression select, namely inside the subselect.\n<pre><code>// This job does not compile.\nstatic void BadJob86(Args _args)\n{\n    // Test_3.f\n    sName = (select Name from AssetTable\n        where AssetTable.AssetId ==\n            // Here starts the subselect.\n            (select AssetId from AssetTrans\n                where AssetTrans.AssetId ==\n                    AssetTable.AssetId // Compiler rejects this line.\n            ).AssetId).Name;\n    info(strFmt(&quot;Test_3: %1&quot;, sName));\n}</code></pre></td>\n</tr>\n</tbody>\n</table>\n\nThe following code example demonstrates several expression selects. Its test cases are described in the previous table.\n\n    // Expression selects examples. \n    static void SelectAsExpression3Job(Args _args)\n    {\n        int64 nRecId,\n            nCount;\n        str sAccountNum,\n            sName;\n        \n        // Test_1.a\n        sAccountNum = (select firstonly AccountNum from CustTable\n            order by AccountNum desc\n            where 0 == 0 // 'where' must occur after 'order by'.\n            ).AccountNum;\n        info(strFmt(\"Test_1.a: %1\", sAccountNum));\n        // Test_1.b\n        sAccountNum = (select maxof(AccountNum) from CustTable).AccountNum;\n        Global::info(strFmt(\"Test_1.b: %1\", sAccountNum));\n        // Test_2.c\n        nRecId = (select maxof(RecId) from CustTable\n            where CustTable.Blocked == CustVendorBlocked::No).RecId;\n        info(strFmt(\"Test_2.c: %1\", nRecId));\n        // Test_2.d\n        nRecId = (select count(RecId) from CustTable\n            where CustTable.Blocked == CustVendorBlocked::No).RecId;\n        info(strFmt(\"Test_2.d: %1\", nRecId));\n        // Test_3\n        sName = (select Name from AssetTable\n            where AssetTable.AssetId ==\n                (select AssetId from AssetTrans\n                    where AssetTrans.AssetId == \"CNC-01\"\n                ).AssetId).Name;\n        info(strFmt(\"Test_3: %1\", sName));\n    }\n    /********* Actual Infolog output\n    Output to Infolog\n    Test_1.a: 4507Test_1.b: 4507\n    Test_2.c: 5637144604\n    Test_2.d: 29\n    Test_3: CNC-Metal shade\n    *********/\n\n## update Table Method\nThe **update** table method updates the current record with the contents of the buffer. It also updates the appropriate system fields. The `where` clause is optional. When used, the `where` clause specifies a condition for `update` to test while processing each row of the table. Only those rows that test **true** against the condition are updated with the new values. **update\\_recordset** is a record-set based operator that updates multiple records at once. To override the behavior of `update`, use the doUpdate method.\n\n### update Table Method Code Example\n\nThe example selects the table `custTable` for update. Any records with the AccountNum equal to 4000 are updated (in this case only one). The `CreditMax` field is changed to 5000.\n\n    CustTable custTable;\n        ttsBegin;\n          select forUpdate custTable\n          where custTable.AccountNum == '4000'; \n          custTable.CreditMax = 5000; \n          custTable.update(); \n        ttsCommit;\n\n## doUpdate Table Method\nThe **doUpdate** method updates the current record with the contents of the buffer. This method also updates the appropriate system fields. The `doUpdate` method should be used when the update method on the table is to be bypassed. The syntax for a `doUpdate` table method is `void doUpdate()`\n\n### doUpdate Code Example\n\n    static void Job1(Args _args)\n    {\n        CustTable custTable;\n        ttsBegin;\n        select forUpdate custTable\n        where custTable.CreditMax == 3000;\n        if (custTable)\n        {\n           custTable.CreditMax += 1000;\n           custTable.doUpdate();\n        }\n        ttsCommit;\n    }\n    ttsCommit;\n\n## delete Table Method\nThe **delete** table method deletes the current record from the database. To use this method, specify which rows are to be deleted by using a `where` clause. Records are then removed, one at a time, from the specified table. **delete\\_from** is a record-setbased operator, which simultaneously removes multiple records. The `delete` method can be overridden, for example, to add extra validation before records are deleted. If you override the `delete` method, the original version of the `delete` method can be executed instead by calling the `doDelete` method. It is equivalent to calling `super()` in the `delete` method; `doDelete` executes the base version of the `delete` method.\n\n### delete Table Method Code Example\n\nAll records in the MyTable table that satisfy the `where` clause criterion (any record with an Account number equal to 1000) are deleted from the database. These records are deleted one at a time.\n\n    ttsBegin;\n    while select forUpdate myTable\n        where myTable.AccountNum == '1000'\n    {\n        myTable.delete();\n    }\n    ttsCommit;\n\n## doDelete Table Method\nThe **doDelete** table method works similar to the `delete` table method because it deletes the current record from the database. Use the `doDelete` method if the delete table method has been overridden, and you want to use the original version of the `delete` method. The `doDelete` method executes the base version of the `delete` method instead of the overridden version, which is equivalent to executing `super()`in the `delete` method.\n\n### doDelete Code Example\n\nThis code example deletes all records in the myTable table that have an account number that is greater than or equal to 200.\n\n    ttsBegin;\n    while select forUpdate myTable\n        where myTable.AccountNum >='200';\n    {\n        myTable.doDelete();\n    }\n    ttsCommit;\n\n## insert Table Method\nThe **insert** method updates one record at a time. To insert multiple records at a time, use array inserts, **insert\\_recordset**, or **RecordSortedList.insertDatabase**. To override the behavior of the `insert` method, use the `doInsert` method. The `xRecord .insert` method generates values for `RecId` and system fields, and then inserts the contents of the buffer into the database. The method operated as follows:\n\n-   Only the specified columns of those rows selected by the query are inserted into the named table.\n-   The columns of the table being copied from and those of the table being copied to must be type compatible.\n-   If the columns of both tables match in type and order, the column-list may be omitted from the `insert` clause.\n\n### insert Table Method Code Example 1: Insert a New Record\n\nThe following code example inserts a new record into the `CustTable` table, with the `AccountNum` set to 5000 and the `Name` set to MyCompany (other fields in the record will be blank).\n\n    CustTable custTable;\n    ttsBegin;\n    select forUpdate custTable;\n    custTable.AccountNum = '5000';\n    custTable.insert();\n    ttsCommit;\n\n### insert Table Method Code Example 2: Transaction and Duplicate Key\n\nThe following example shows how you can catch a `DuplicateKeyException` in the context of an explicit transaction. The exception is thrown when a call to `xRecord .insert` fails because of a duplication of an existing unique value. In the catch block, your code can take corrective action, or it can log the error for later analysis. Then your code can continue without losing all the pending work of the transaction. You cannot catch a duplicate key exception caused by a set based operation such as `insert_recordset`. This example depends on two tables `TableNumberA` and `TableNumberB`. Each has one mandatory Integer field, named `NumberAKey` and `NumberBKey` respectively. Each of these key fields has a unique indexed defined on it. The `TableNumberA` table must have at least one record in it.\n\n    static void JobDuplicKeyException44Job(Args _args)\n        {\n        TableNumberA tabNumA; // Has one record, key = 11.\n        TableNumberB tabNumB;\n        int iCountTries = 0, iNumberAdjust = 0, iNewKey, ii;\n        container ctNotes;\n        // Empty the B table.\n        delete_from tabNumB;\n        // Insert a copy of one record.\n        insert_recordset tabNumB (NumberBKey)\n        select firstOnly NumberAKey from tabNumA order by NumberAKey asc;\n        ttsBegin;\n        try\n            {\n            iCountTries++;\n            ctNotes += strFmt(\"---- Inside the try block, try count is %1. ----\", iCountTries);\n            while select * from tabNumA order by NumberAKey asc\n                {   \n                tabNumB .clear();\n                iNewKey = tabNumA .NumberAKey + iNumberAdjust;\n                tabNumB .NumberBKey = iNewKey;\n                ctNotes += strFmT (\"-- %1 is the key to be tried. --\" ,iNewKey);\n                tabNumB .insert();\n                ctNotes += \"-- .insert() successful. --\";\n                break; // Keeps demo simple.\n                }\n            ttsCommit;\n            }\n        catch (Exception ::DuplicateKeyException, tabNumB) // Table is optional.\n            {\n            ctNotes += \"---- Inside the catch block. ----\";\n            ctNotes += infolog .text();\n            if (iCountTries <= 1)\n                {\n                ctNotes += \"-- Will issue retry. --\";\n                iNumberAdjust = 1;\n                retry; // Erases Infolog.\n                }\n            else\n                {\n                ctNotes += \"-- Aborting the transaction. --\";\n                ttsAbort;\n                }\n            }\n        for (ii=1; ii <= conLen(ctNotes); ii++)\n            {\n            info(conPeek(ctNotes ,ii));\n            }\n        }\n     \n    /*********Actual Infolog output\n            Message (10:53:13 am)\n        ---- Inside the try block, try count is 1. ----\n        -- 11 is the key to be tried. --\n        ---- Inside the catch block. ----\n        Cannot create a record in TableNumberB (TableNumberB).\n        The record already exists.\n        -- Will issue retry. --\n        ---- Inside the try block, try count is 2. ----\n        -- 12 is the key to be tried. --\n        -- .insert() successful. --\n    *********/\n\n## doInsert Table Method\nThe **doInsert** method generates values for the `RecId` field and other system fields, and then inserts the contents of the buffer into the database. This operation is used when the insert method on the table is to be bypassed.\n\n### doInsert Code Example\n\nA new record is inserted with the name `Warren Langer` in the name field and the value 100 in the value field.\n\n    ttsBegin;\n    myTable.name = 'Warren Langer';\n    myTable.value = 100;\n    myTable.doInsert();\n    ttsCommit;\n\n## Transaction Integrity\nIf the **integrity of transactions** is not ensured, it may lead to data corruption, or, at best, poor scalability with reference to concurrent users on the system. There are two internal checking features to help ensure the integrity of transactions: the `forUpdate` check and the `tssLevel` check. A **forUpdate check** ensures that no record can be updated or deleted if the record has not first been selected for update. A record can be selected for update, either by using the `forUpdate` keyword in the `select` statement, or by using the `selectForUpdate` method on tables. A **ttsLevel check** ensures that no record can be updated or deleted except from within the same transaction scope as it was selected for update. Integrity is ensured by using the following statements:\n\n-   `ttsBegin`: marks the beginning of a transaction. This ensures data integrity, and guarantees that all updates performed until the transaction ends (by `ttsCommit` or `ttsAbort`) are consistent (all or none).\n-   `ttsCommit`: marks the successful end of a transaction. This ends and commits a transaction. MorphX guarantees that a committed transaction will be performed according to intentions.\n-   `ttsAbort`: allows you to explicitly discard all changes in the current transaction. As a result, the database is rolled back to the initial state where nothing will have been changed. Typically, you will use this if you have detected that the user wants to break the current job. Using `ttsAbort` ensures that the database is consistent.\n\nIt is usually better to use exception handling instead of `ttsAbort`. The `throw` statement automatically aborts the current transaction. Statements between `ttsBegin` and `ttsCommit` may include one or more transaction blocks as shown in the following example. In such cases, nothing is actually committed until the successful exit from the final `ttsCommit`.\n\n    ttsBegin;\n        // Some statements.\n    ttsBegin;\n        // More statements.\n    ttsCommit;\n    ttsCommit;\n\n### ttsBegin and ttsCommit Code Example\n\n    Custtable custTable;\n    ttsBegin;\n    select forUpdate custTable where custTable.AccountNum == '4000';\n    custTable.NameAlias = custTable.Name;\n    custTable.update();\n    ttsCommit;\n\n### Examples of Code Rejected by the two Transaction Integrity Checks\n\nIn this example, the first failure is because the `forupdate` keyword is missing. The second failure is because the update is in another transaction scope rather than the one that the record was selected in `ttsCommit` for update.\n\n    ttsBegin;\n    select myTable; // Rejected by the forUpdate check.\n    mytable.myField = 'xyz';\n    myTable.update();\n    ttsCommit;\n    ttsBegin;\n    select forUpdate * from myTable;\n    myTable.myField = 'xyz';\n    ttsCommit;\n    ...\n    ttsBegin;\n    myTable.update(); // Rejected by the ttsLevel check.\n    ttsCommit;\n\n## Speeding Up SQL Operations\nThe following constructs allow you to insert, update, or delete multiple records. Using these constructs reduces communication between the application and the database, and it increases performance. In some situations, record-set operations can fall back to record-by-record operations.\n\n| Construct             | Description                                                                                                                                                                                                                                 |\n|-----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **RecordSortedList**  | Allows you to insert multiple records in one database trip. Use the `RecordSortedList` construct when you want a subset of data from a particular table, and when you want it sorted in an order that does not currently exist as an index. |\n| **RecordInsertList**  | Allows you to insert multiple records in one database trip. Use the `RecordInsertList` construct when you do not need to sort the data.                                                                                                     |\n| **insert\\_recordset** | Allows you to copy multiple records from one or more tables directly into another table on a single database trip.                                                                                                                          |\n| **update\\_recordset** | Allows you to update multiple rows in a table on a single database trip.                                                                                                                                                                    |\n| **delete\\_from**      | Allows you to delete multiple records from the database on a single database trip.                                                                                                                                                          |\n\n## insert\\_recordset\n**insert\\_recordset** copies data from one or more tables directly into one resulting destination table on a single server trip. Using `insert_recordset` is faster than using an array insert. However, array inserts are more flexible if you want to handle the data before you insert it. `insert_recordset` is a record-set-based operator, which performs operations on multiple records at a time. However, it can fall back to record-by-record operations in many situations.\n\n### insert\\_recordset Syntax\n\nThe *ListOfFields* in the destination table must match the list of fields in the source tables. Data is transferred in the order that it appears in the list of fields. Fields in the destination table that are not present in the list of fields are assigned zero-values as in other areas. System fields, including `RecId`, are assigned transparently by the kernel in the destination table. `insert_recordset ` *DestinationTable* ` ( ` *ListOfFields* ` )` ` select ` *ListOfFields1* ` from ` *SourceTable* ` [ where ` *WhereClause* ` ]` ` [ join ` *ListOfFields2* ` from ` *JoinedSourceTable* ` [ where ` *JoinedWhereClause* ` ]]`\n\n### Example 1: insert data from another table\n\nThe records, `myNum` and `mySum`, are retrieved from the table `anotherTable` and inserted into the table `myTable`. The records are grouped according to `myNum`, and only the `myNum` records with a value less than or equal to 100 are included in the insertion.\n\n    insert_recordset myTable (myNum, mySum)\n        select myNum, sum(myValue) \n            from anotherTable \n            group by myNum \n            where myNum <= 100;\n\n### \n\n### Example 2: insert data from variables\n\nThis code example shows that the **insert\\_recordset** statement can insert data that is provided in variables. In this example, the keyword **firstonly** is used so that only one row is inserted. Literals, such as `128` or `\"this literal string\"`, cannot be used as a source of data to be inserted.\n\n    static void InsertVariable3Job(Args _args)\n    {\n        TableAlphabet    tabA2;\n        BankAccountTable tabB3;\n        str  1 sLetter = \"a\";\n        str 16 sExampleWord = \"apple\";\n        \n        DELETE_FROM tabA2;\n        INSERT_RECORDSET tabA2\n            (Letter ,ExampleWord)\n        select firstonly\n            sLetter ,sExampleWord // Variables.\n        from tabB3;\n        WHILE SELECT * from tabA2\n        {\n            info(tabA2 .Letter + \" , \" + tabA2 .ExampleWord);\n        }\n     \n    /***********  Actual Infolog output\n    Message (04:03:52 pm)\n    a , apple\n    ***********/\n    }\n\n### Example 3: insert data using a join\n\nThe following code example shows a **join** of three tables on an `insert_recordset` statement that has a sub-`select`. Also, a `while` `select` statement with a similar join is shown. A variable is used to supply the inserted value for one column. The `str` variable must be declared with a length that is less than or equal to the maximum length of the corresponding database field. In this example, there is an `insert_recordset` statement for `tabEmplProj5`. One of the target fields is named `Description`, and the field's data comes from the local variable `sDescriptionVariable`. When the configuration key for the `Description` field is turned off, the `insert_recordset` still succeeds. The system ignores both the `Description` field and the variable `sDescriptionVariable`. This is an example of **configuration key automation**. Configuration key automation is when the system can automatically adjust the behavior of an `insert_recordset` statement that inserts into fields that have their configuration key turned off.\n\n    static void InsertJoin42Job(Args _args)\n    {\n        GmTabDepartment tabDept2;\n        GmTabEmployee tabEmpl3;\n        GmTabProject tabProj4;\n        GmTabEmployeeProject tabEmplProj5;\n        str 64 sDescriptionVariable = \"From variable.\";\n        \n        DELETE_FROM tabEmplProj5;\n        INSERT_RECORDSET tabEmplProj5\n            (\n            Description\n            , EmployeeRecId\n            , ProjectRecId\n            )\n        Select\n            sDescriptionVariable\n            , RecId\n        from\n            tabEmpl3\n            join\n                tabDept2\n                where tabEmpl3 .DepartmentGuid == tabDept2 .DepartmentGuid\n            join RecId\n                from tabProj4\n                where tabDept2 .DepartmentGuid == tabProj4 .DepartmentGuid\n        \n        info(int642str(tabEmplProj5 .rowCount())\n            + \" ==Number of rows inserted.\");\n        WHILE SELECT *\n            from\n                tabEmplProj5\n                join tabEmpl3\n                    where tabEmplProj5 .EmployeeRecId == tabEmpl3 .RecId\n                join tabProj4\n                    where tabEmplProj5 .ProjectRecId == tabProj4 .RecId\n        {\n            info(\n                tabEmpl3 .EmployeeName\n                + \"  --works on--  \"\n                + tabProj4 .ProjectName\n                + \" (\" + tabEmplProj5 .Description + \").\"\n                );\n        }\n     \n    /*****************  Actual Infolog output\n    Message (01:05:41 pm)\n    4 ==Number of rows inserted.\n    Alice  --works on--  Project ZZZ (From variable.).\n    Alice  --works on--  Project YY (From variable.).\n    Beth  --works on--  Project ZZZ (From variable.).\n    Beth  --works on--  Project YY (From variable.).\n    *****************/\n    }\n\n## update\\_recordset\nThe **update\\_recordset** statement enables you to update multiple rows in a single trip to the server. This means that certain tasks may have improved performance by using the power of the SQL server. **`update_recordset`** resembles `delete_from` in X++ and `update set` in SQL. It works on the database server-side on an SQL-style record-set, instead of retrieving each record separately by fetching, changing, and updating. If the `update` method is overridden, the implementation falls back to a classic looping construction, updating records one by one just as `delete_from` does for deletions. This also means that the construction works on temporary tables, and whole-table-cached tables by using the looping construction.\n\n### Example 1: update based on a calculated value\n\nThis example updates the table `myTableBuffer` and increments the value in `field1` by ten percent in all records in the table.\n\n    MyTable myTableBuffer;\n    update_recordset myTableBuffer\n    setting field1 = field1 * 1.10;\n\n### Example 2: update using a where clause\n\nThis example updates the table `myTable` in all records where `field1` has the value 0. `field1` is assigned the new value 1; `field2` is assigned the value of the sum of `fieldX` and `fieldY`. This example updates multiple fields at the same time, and it updates only those rows that satisfy the `where` clause.\n\n    MyTable myTableBuffer;\n    update_recordset myTableBuffer\n    setting\n        field1 = 1,\n        field2 = fieldX + fieldY\n    where field1 == 0;\n\n### Example 3: updating joined tables\n\nThis example shows that the `update_recordset` statement supports the joining of several tables. Data from the joined tables can be used to assign values to fields in the table that is being updated.\n\n    static void Join22aJob(Args _args)\n    {\n        TableEmployee tabEmpl;\n        TableDepartment tabDept;\n        TableProject tabProj;\n        \n        update_recordset tabEmpl\n        setting\n            currentStatusDescription = tabDept .DeptName\n                + \", \" + tabProj .ProjName\n        join tabDept\n            where tabDept .DeptId == tabEmpl .DeptId\n        join tabProj\n            where tabProj .ProjId == tabEmpl .ProjId;\n        info(strFmt(\"Number of records updated is %1.\"\n            ,tabEmpl .rowCount()));\n    }\n\n## delete\\_from\nYou can delete multiple records from a database table by using a **delete\\_from** statement. This can be more efficient and faster than deleting one record at a time by using the `xRecord .delete` method in a loop. If you have overridden the delete method, the system interprets the `delete_from` statement into code that calls the `delete` method one time for each row that is deleted.\n\n### Example 1: efficiently deleting records using delete\\_from\n\nThe following code example is an efficient way to delete multiple records.\n\n    static void DeleteMultiRow1aJob(Args _args)\n    {\n        MyWidgetTable tabWidget;\n        \n        delete_from tabWidget\n            where tabWidget .quantity <= 100;\n    }\n\n#### Example 2: inefficiently deleting records using forUpdate\n\nThe following code example is inefficient. It issues a separate SQL delete call to the database server for each record. The `xRecord` `.delete` method never deletes more than one record per call.\n\n    static void DeleteMultiRow1bJob(Args _args)\n    {\n        MyWidgetTable tabWidget; // extends xRecord.\n        \n        ttsBegin;\n        while select\n            forUpdate\n            tabWidget\n            where tabWidget .quantity <= 100\n        {\n            tabWidget .delete();\n        }\n        ttsCommit;\n    }\n\n### Example 3: deleting with an inner join\n\nInner joins are not supported on the **delete\\_from** statement. Therefore you cannot use the unmodified **join** keyword on the **delete\\_from** statement. However, there are other ways to logically accomplish an inner join. The examples in this section show the new and old techniques for achieving inner join logic through a sequence of statements.\n\n    // This is the new and recommended way of using the delete_from method and inner joins.\n    // The following code example is relatively efficient. It issues a \n    // separate delete_from statement for each loop iteration. However, each \n    // delete_from statement can delete multiple records, a subset of all the \n    // records that the job deletes.\n    static void DeleteInnerJoin2bJob(Args _args)\n    {\n        MyWidgetTable tabWidget; // extends xRecord.\n        \n        ttsBegin;\n        while select\n            from tabGalaxy\n                where tabGalaxy .isTrusted == 0\n        {\n            delete_from tabWidget\n                where tabWidget .GalaxyRecId ==\n                      tabGalaxy .RecId;\n        }\n        ttsCommit;\n    }\n    // This is the old way of using the delete method and inner joins. \n    // The following delete method is inefficient. It issues a \n    // separate SQL delete call to the database server for each record.\n    static void DeleteInnerJoin2aJob(Args _args)\n    {\n        MyWidgetTable tabWidget; // extends xRecord.\n        \n        ttsBegin;\n        while select\n            forUpdate\n            tabWidget\n            join tabGalaxy\n                where\n                    tabWidget .GalaxyRecId == tabGalaxy .RecId\n                    && tabGalaxy .isTrusted == 0\n        {\n            tabWidget .delete();\n        }\n        ttsCommit;\n    }\n\n### Example 4: deleting with notexists join keyword\n\nYou can use the **notexists join** keyword pair in a **delete\\_from** statement. The `delete_from` statements in the following code example are efficient. The `notexists join` clause enables the `delete_from` statement to delete a specific set of rows. In this example the `delete_from` statement removes all the parent order header rows for which there are no child order line rows. You can also use the `exists join` clause on the `delete_from` statement.\n\n    static void DeleteFromNotexists3bJob(Args _args)\n    {\n        GmTabOrderHeader tabOHeader;\n        GmTabOrderLine tabOLine;\n        AddressState tabAddressState;\n        str 127 sOH_Info;\n        str 127 sOL_Data;\n        int64 i64OHRecId;\n        \n        delete_from tabOLine;\n        delete_from tabOHeader;\n        // Inserts into parent table.\n        sOH_Info = \"Albert needs tires.\";\n        insert_recordset tabOHeader\n            (OH_Info)\n            select firstOnly sOH_Info from tabAddressState;\n        sOH_Info = \"Benson wants plastic.\";\n        insert_recordset tabOHeader\n            (OH_Info)\n            select firstOnly sOH_Info from tabAddressState;\n        // Obtain a OrderHeader RecId,\n        // use it to insert one child row.\n        sOL_Data = \"4 re-treads.\";\n        while select firstOnly tabOHeader\n                order by OH_Info\n                where tabOHeader .OH_Info like \"A*\"\n        {\n            i64OHRecId = tabOHeader .RecId;\n            insert_recordset tabOLine\n                (OL_Data ,OrderHeaderRecId)\n                select firstOnly\n                    sOL_Data ,i64OHRecId\n                    from tabAddressState;\n            break;\n        }\n        // Before the delete notexists.\n        // Display all parent, and then all child rows.\n        while select tabOHeader\n            order by OH_Info\n        {\n            info(strFmt(\n                \"Before: OHeader:  OH_Info==%1 , RecId==%2\"\n                ,tabOHeader .OH_Info ,tabOHeader .RecId\n                ));\n        }\n        while select tabOLine\n            order by OL_Data\n        {\n            info(strFmt(\n                \"Before: OLine:  OL_Data==%1 , OrderHeaderRecId==%2\"\n                ,tabOLine .OL_Data ,tabOLine .OrderHeaderRecId\n                ));\n        }\n        // Delete_From NotExists Join, to remove from the\n        // parent table all order headers without children.\n        delete_from tabOHeader\n            notexists join tabOLine\n                where tabOHeader .RecId ==\n                    tabOLine .OrderHeaderRecId;\n        info(strFmt\n            (\"%1 is the number of childless OHeader records deleted.\"\n            ,tabOHeader.rowCount()));\n        // After the delete notexists.\n        // Display all parent, and then all child rows.\n        info(\"- - - - - - - - - - - - - - -\");\n        while select tabOHeader\n            order by OH_Info\n        {\n            info(strFmt(\n                \"After: OHeader:  OH_Info==%1 , RecId==%2\"\n                ,tabOHeader .OH_Info ,tabOHeader .RecId\n                ));\n        }\n        while select tabOLine\n            order by OL_Data\n        {\n            info(strFmt(\n                \"After: OLine:  OL_Data==%1 , OrderHeaderRecId==%2\"\n                ,tabOLine .OL_Data ,tabOLine .OrderHeaderRecId\n                ));\n        }\n     \n    /**************  Actual Infolog output\n    Message (12:54:14 pm)\n    Before: OHeader:  OH_Info==Albert needs tires. , RecId==5637144608\n    Before: OHeader:  OH_Info==Benson wants plastic. , RecId==5637144609\n    Before: OLine:  OL_Data==4 re-treads. , OrderHeaderRecId==5637144608\n    1 is the number of childless OHeader records deleted.\n    - - - - - - - - - - - - - - -\n    After: OHeader:  OH_Info==Albert needs tires. , RecId==5637144608\n    After: OLine:  OL_Data==4 re-treads. , OrderHeaderRecId==5637144608\n    **************/\n    }\n\n## Maintaining Fast SQL Operations\nThere are situations where record-set operations can be converted to slower record-by-record operations. The following table identifies these situations.\n\n|                                                               | DELETE\\_FROM | UPDATE\\_RECORDSET | INSERT\\_RECORDSET | ARRAY\\_INSERT | Use ... to override |\n|---------------------------------------------------------------|--------------|-------------------|-------------------|---------------|---------------------|\n| Non-SQL tables                                                | Yes          | Yes               | Yes               | Yes           | Not applicable      |\n| Delete actions                                                | Yes          | No                | No                | No            | `skipDeleteActions` |\n| Database log enabled                                          | Yes          | Yes               | Yes               | No            | `skipDatabaseLog`   |\n| Overridden method                                             | Yes          | Yes               | Yes               | Yes           | `skipDataMethods`   |\n| Alerts set up for table                                       | Yes          | Yes               | Yes               | No            | `skipEvents`        |\n| ValidTimeStateFieldType property not equal to None on a table | Yes          | Yes               | Yes               | Yes           | Not applicable      |\n\nYou may explicitly skip or ignore one or more things that would adversely impact performance by using the items shown in the far right column. If for some reason one of the previously mentioned SQL operations is downgraded to a record-by-record operation, all of the `skip` settings are also ignored. For example, the `insert` method on myTable is executed in the following example even though it is explicitly stated that this method should be skipped if myTable has a container or memo field defined.\n\n    public void tutorialRecordInsertList()\n    {\n        MyTable myTable;\n        RecordInsertList insertList = new RecordInsertList(\n            myTable.TableId, \n            True);\n        int i;\n        for ( i = 1; i <=  100; i++ )\n        {\n            myTable.value = i;\n            insertList.add(myTable);\n        }\n        insertList.insertDatabase();\n    }\n\n"}