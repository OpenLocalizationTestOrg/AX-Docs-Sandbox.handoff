{"nodes":[{"pos":[32,62],"content":"X++ operators | Microsoft Docs","needQuote":true,"needEscape":true,"nodes":[{"content":"X++ operators | Microsoft Docs","pos":[0,30]}]},{"pos":[76,128],"content":"This topic describes the operators supported in X++.","needQuote":true,"needEscape":true,"nodes":[{"content":"This topic describes the operators supported in X++.","pos":[0,52]}]},{"pos":[520,533],"content":"X++ operators","linkify":"X++ operators","nodes":[{"content":"X++ operators","pos":[0,13]}]},{"content":"This topic describes the operators supported in X++.","pos":[535,587]},{"pos":[589,609],"content":"Assignment operators","linkify":"Assignment operators","nodes":[{"content":"Assignment operators","pos":[0,20]}]},{"content":"An assignment changes the value of a variable or field.","pos":[632,687]},{"content":"The following table shows the X++ assignment operators.","pos":[688,743]},{"content":"There is no difference between prefix and postfix operators.","pos":[744,804]},{"content":"Operator","pos":[808,816]},{"content":"Description","pos":[819,830]},{"content":"Assign the expression on the right of the equal sign to the variable on the left.","pos":[1043,1124]},{"content":"Assign the current variable value plus the expression on the right to the variable on the left.","pos":[1155,1250]},{"content":"Increment the variable by 1.","pos":[1267,1295]},{"content":"Assign the current variable value minus the expression on the right to the variable on the left.","pos":[1379,1475]},{"content":"Decrement the variable by 1.","pos":[1491,1519]},{"pos":[1595,1633],"content":"Code examples for assignment operators","linkify":"Code examples for assignment operators","nodes":[{"content":"Code examples for assignment operators","pos":[0,38]}]},{"pos":[3039,3059],"content":"Arithmetic operators","linkify":"Arithmetic operators","nodes":[{"content":"Arithmetic operators","pos":[0,20]}]},{"content":"You use arithmetic operators to perform numeric calculations.","pos":[3060,3121]},{"content":"Most of the operators are binary and take two operands.","pos":[3122,3177]},{"content":"However, the <bpt id=\"p1\">**</bpt>not<ept id=\"p1\">**</ept> (<bpt id=\"p2\">**</bpt><ph id=\"ph1\">~</ph><ept id=\"p2\">**</ept>) operator is unary and takes only one operand.","pos":[3178,3252],"source":" However, the **not** (**~**) operator is unary and takes only one operand."},{"content":"Syntax for binary operators: <bpt id=\"p1\">*</bpt>expression1<ept id=\"p1\">*</ept> <bpt id=\"p2\">*</bpt>ArithmeticOperator<ept id=\"p2\">*</ept> <bpt id=\"p3\">*</bpt>expression2<ept id=\"p3\">*</ept> Syntax for unary operators: <bpt id=\"p4\">*</bpt>ArithmeticOperator<ept id=\"p4\">*</ept> <bpt id=\"p5\">*</bpt>expression1<ept id=\"p5\">*</ept>","pos":[3253,3393],"source":" Syntax for binary operators: *expression1* *ArithmeticOperator* *expression2* Syntax for unary operators: *ArithmeticOperator* *expression1*"},{"content":"Operator","pos":[3397,3405]},{"content":"Description","pos":[3408,3419]},{"pos":[3814,3915],"content":"The <bpt id=\"p1\">**</bpt>left shift<ept id=\"p1\">**</ept> operator performs <bpt id=\"p2\">*</bpt>expression2<ept id=\"p2\">*</ept> left shift (multiplication by 2) on <bpt id=\"p3\">*</bpt>expression1<ept id=\"p3\">*</ept>.","source":"The **left shift** operator performs *expression2* left shift (multiplication by 2) on *expression1*."},{"pos":[4017,4114],"content":"The <bpt id=\"p1\">**</bpt>right shift<ept id=\"p1\">**</ept> operator performs <bpt id=\"p2\">*</bpt>expression2<ept id=\"p2\">*</ept> right shift (division by 2) on <bpt id=\"p3\">*</bpt>expression1<ept id=\"p3\">*</ept>.","source":"The **right shift** operator performs *expression2* right shift (division by 2) on *expression1*."},{"pos":[4220,4288],"content":"The <bpt id=\"p1\">**</bpt>multiply<ept id=\"p1\">**</ept> operator multiplies <bpt id=\"p2\">*</bpt>expression1<ept id=\"p2\">*</ept> by <bpt id=\"p3\">*</bpt>expression2<ept id=\"p3\">*</ept>.","source":"The **multiply** operator multiplies *expression1* by *expression2*."},{"pos":[4423,4486],"content":"The <bpt id=\"p1\">**</bpt>divide<ept id=\"p1\">**</ept> operator divides <bpt id=\"p2\">*</bpt>expression1<ept id=\"p2\">*</ept> by <bpt id=\"p3\">*</bpt>expression2<ept id=\"p3\">*</ept>.","source":"The **divide** operator divides *expression1* by *expression2*."},{"content":"DIV","pos":[4615,4618]},{"pos":[4626,4723],"content":"The <bpt id=\"p1\">**</bpt>integer division<ept id=\"p1\">**</ept> operator performs an integer division of <bpt id=\"p2\">*</bpt>expression1<ept id=\"p2\">*</ept> by <bpt id=\"p3\">*</bpt>expression2<ept id=\"p3\">*</ept>.","source":"The **integer division** operator performs an integer division of *expression1* by *expression2*."},{"content":"MOD","pos":[4818,4821]},{"pos":[4829,4943],"content":"The <bpt id=\"p1\">**</bpt>integer remainder<ept id=\"p1\">**</ept> operator returns the remainder of an integer division of <bpt id=\"p2\">*</bpt>expression1<ept id=\"p2\">*</ept> by <bpt id=\"p3\">*</bpt>expression2<ept id=\"p3\">*</ept>.","source":"The **integer remainder** operator returns the remainder of an integer division of *expression1* by *expression2*."},{"pos":[5032,5105],"content":"The <bpt id=\"p1\">**</bpt>not<ept id=\"p1\">**</ept> operator, or unary operator, performs a binary not operation.","source":"The **not** operator, or unary operator, performs a binary not operation."},{"pos":[5235,5330],"content":"The <bpt id=\"p1\">**</bpt>binary AND<ept id=\"p1\">**</ept> operator performs a binary and operation on <bpt id=\"p2\">*</bpt>expression1<ept id=\"p2\">*</ept> and <bpt id=\"p3\">*</bpt>expression2<ept id=\"p3\">*</ept>.","source":"The **binary AND** operator performs a binary and operation on *expression1* and *expression2*."},{"pos":[5438,5533],"content":"The <bpt id=\"p1\">**</bpt>binary XOR<ept id=\"p1\">**</ept> operator performs a binary XOR-operation on <bpt id=\"p2\">*</bpt>expression1<ept id=\"p2\">*</ept> and <bpt id=\"p3\">*</bpt>expression2<ept id=\"p3\">*</ept>.","source":"The **binary XOR** operator performs a binary XOR-operation on *expression1* and *expression2*."},{"pos":[5641,5734],"content":"The <bpt id=\"p1\">**</bpt>binary OR<ept id=\"p1\">**</ept> operator performs a binary or operation on <bpt id=\"p2\">*</bpt>expression1<ept id=\"p2\">*</ept> and <bpt id=\"p3\">*</bpt>expression2<ept id=\"p3\">*</ept>.","source":"The **binary OR** operator performs a binary or operation on *expression1* and *expression2*."},{"pos":[5844,5902],"content":"The <bpt id=\"p1\">**</bpt>plus<ept id=\"p1\">**</ept> operator adds <bpt id=\"p2\">*</bpt>expression1<ept id=\"p2\">*</ept> to <bpt id=\"p3\">*</bpt>expression2<ept id=\"p3\">*</ept>.","source":"The **plus** operator adds *expression1* to *expression2*."},{"pos":[6047,6113],"content":"The <bpt id=\"p1\">**</bpt>minus<ept id=\"p1\">**</ept> operator subtracts <bpt id=\"p2\">*</bpt>expression2<ept id=\"p2\">*</ept> from <bpt id=\"p3\">*</bpt>expression1<ept id=\"p3\">*</ept>.","source":"The **minus** operator subtracts *expression2* from *expression1*."},{"content":"?","pos":[6239,6240]},{"content":"The <bpt id=\"p1\">**</bpt>ternary<ept id=\"p1\">**</ept> operator takes three expressions: <bpt id=\"p2\">*</bpt>expression1<ept id=\"p2\">*</ept> ?","pos":[6250,6315],"source":"The **ternary** operator takes three expressions: *expression1* ?"},{"content":"<bpt id=\"p1\">*</bpt>expression2<ept id=\"p1\">*</ept> : <bpt id=\"p2\">*</bpt>expression3<ept id=\"p2\">*</ept>.","pos":[6316,6346],"source":"*expression2* : *expression3*."},{"content":"If <bpt id=\"p1\">*</bpt>expression1<ept id=\"p1\">*</ept> is true, <bpt id=\"p2\">*</bpt>expression2<ept id=\"p2\">*</ept> is returned.","pos":[6347,6399],"source":" If *expression1* is true, *expression2* is returned."},{"content":"Otherwise, <bpt id=\"p1\">*</bpt>expression3<ept id=\"p1\">*</ept> is returned.","pos":[6400,6437],"source":" Otherwise, *expression3* is returned."},{"pos":[6445,6483],"content":"Code examples for arithmetic operators","linkify":"Code examples for arithmetic operators","nodes":[{"content":"Code examples for arithmetic operators","pos":[0,38]}]},{"pos":[7488,7508],"content":"Expression operators","linkify":"Expression operators","nodes":[{"content":"Expression operators","pos":[0,20]}]},{"content":"The <bpt id=\"p1\">**</bpt>as<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>is<ept id=\"p2\">**</ept> expression operators control downcast assignments.","pos":[7509,7581],"source":"The **as** and **is** expression operators control downcast assignments."},{"content":"Downcast assignments involve class or table inheritance.","pos":[7582,7638]},{"content":"Assignment statements that implicitly downcast can cause errors that are difficult to predict and diagnose.","pos":[7639,7746]},{"content":"You can use the <bpt id=\"p1\">**</bpt>as<ept id=\"p1\">**</ept> keyword to make your downcasts explicit.","pos":[7747,7810],"source":" You can use the **as** keyword to make your downcasts explicit."},{"content":"You can use the <bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept> keyword to test whether a downcast is valid at run time.","pos":[7811,7890],"source":" You can use the **is** keyword to test whether a downcast is valid at run time."},{"pos":[7896,7910],"content":"The as keyword","linkify":"The as keyword","nodes":[{"content":"The as keyword","pos":[0,14]}]},{"content":"Use the <bpt id=\"p1\">**</bpt>as<ept id=\"p1\">**</ept> keyword for assignments that downcast from a base class variable to a derived class variable.","pos":[7912,8020],"source":"Use the **as** keyword for assignments that downcast from a base class variable to a derived class variable."},{"content":"The <bpt id=\"p1\">**</bpt>as<ept id=\"p1\">**</ept> keyword tells other programmers and the compiler that you believe that the downcast will be valid during run time.","pos":[8021,8146],"source":" The **as** keyword tells other programmers and the compiler that you believe that the downcast will be valid during run time."},{"pos":[8152,8246],"content":"The compiler reports an error for downcast assignment statements that lack the <bpt id=\"p1\">**</bpt>as<ept id=\"p1\">**</ept> keyword.","source":"The compiler reports an error for downcast assignment statements that lack the **as** keyword."},{"pos":[8251,8371],"content":"At run time, the <bpt id=\"p1\">**</bpt>as<ept id=\"p1\">**</ept> keyword causes the downcast assignment statement to assign <bpt id=\"p2\">**</bpt>null<ept id=\"p2\">**</ept> if the downcast isn't valid.","source":"At run time, the **as** keyword causes the downcast assignment statement to assign **null** if the downcast isn't valid."},{"pos":[8376,8462],"content":"This <bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept> keyword is often used to safely test whether the <bpt id=\"p2\">**</bpt>as<ept id=\"p2\">**</ept> keyword will work.","source":"This **is** keyword is often used to safely test whether the **as** keyword will work."},{"pos":[8469,8500],"content":"Code example for the as keyword","linkify":"Code example for the as keyword","nodes":[{"content":"Code example for the as keyword","pos":[0,31]}]},{"content":"In the following code example, the <bpt id=\"p1\">**</bpt>DerivedClass<ept id=\"p1\">**</ept> class extends the <bpt id=\"p2\">**</bpt>BaseClass<ept id=\"p2\">**</ept> class.","pos":[8502,8592],"source":"In the following code example, the **DerivedClass** class extends the **BaseClass** class."},{"content":"The code example contains two valid assignments between its <bpt id=\"p1\">**</bpt>basec<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>derivedc<ept id=\"p2\">**</ept> variables.","pos":[8593,8690],"source":" The code example contains two valid assignments between its **basec** and **derivedc** variables."},{"content":"The upcast assignment to <bpt id=\"p1\">**</bpt>basec<ept id=\"p1\">**</ept> doesn't require the <bpt id=\"p2\">**</bpt>as<ept id=\"p2\">**</ept> keyword, but the downcast assignment to <bpt id=\"p3\">**</bpt>derivedc<ept id=\"p3\">**</ept> does require the <bpt id=\"p4\">**</bpt>as<ept id=\"p4\">**</ept> keyword.","pos":[8691,8838],"source":" The upcast assignment to **basec** doesn't require the **as** keyword, but the downcast assignment to **derivedc** does require the **as** keyword."},{"content":"The following code will compile and run without errors.","pos":[8839,8894]},{"pos":[9494,9508],"content":"The is keyword","linkify":"The is keyword","nodes":[{"content":"The is keyword","pos":[0,14]}]},{"content":"The <bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept> keyword verifies whether an object is a subtype of a specified class.","pos":[9510,9590],"source":"The **is** keyword verifies whether an object is a subtype of a specified class."},{"content":"The <bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept> expression returns <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> if the object is a subtype of the class, or if the object is the same type as the class.","pos":[9591,9718],"source":" The **is** expression returns **true** if the object is a subtype of the class, or if the object is the same type as the class."},{"content":"The compiler reports an error if an <bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept> keyword expression compares two types, but neither type is a subtype of the other, and they aren't of the same type.","pos":[9719,9878],"source":" The compiler reports an error if an **is** keyword expression compares two types, but neither type is a subtype of the other, and they aren't of the same type."},{"content":"The compiler reports a similar error for any plain assignment statement between two types, where neither type is a subtype of the other, and they aren't of the same type.","pos":[9879,10049]},{"content":"At run time, the type of variable that references the underlying object is irrelevant to the <bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept> keyword.","pos":[10050,10158],"source":" At run time, the type of variable that references the underlying object is irrelevant to the **is** keyword."},{"content":"The <bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept> keyword causes the system to verify the object that the variable references, not the declared type of the variable that references the object.","pos":[10159,10312],"source":" The **is** keyword causes the system to verify the object that the variable references, not the declared type of the variable that references the object."},{"pos":[10319,10351],"content":"Code examples for the is keyword","linkify":"Code examples for the is keyword","nodes":[{"content":"Code examples for the is keyword","pos":[0,32]}]},{"content":"The following code examples illustrate the conditions that control whether an <bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept> expression returns <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>false<ept id=\"p3\">**</ept>.","pos":[10353,10479],"source":"The following code examples illustrate the conditions that control whether an **is** expression returns **true** or **false**."},{"content":"The code examples depend on the fact that the <bpt id=\"p1\">**</bpt>Form<ept id=\"p1\">**</ept> class and the <bpt id=\"p2\">**</bpt>Query<ept id=\"p2\">**</ept> class both extend the <bpt id=\"p3\">**</bpt>TreeNode<ept id=\"p3\">**</ept> class.","pos":[10480,10600],"source":" The code examples depend on the fact that the **Form** class and the **Query** class both extend the **TreeNode** class."},{"pos":[12162,12201],"content":"Code example for the is and as keywords","linkify":"Code example for the is and as keywords","nodes":[{"content":"Code example for the is and as keywords","pos":[0,39]}]},{"content":"The following code example contains a typical use of the <bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept> keyword.","pos":[12203,12275],"source":"The following code example contains a typical use of the **is** keyword."},{"content":"The <bpt id=\"p1\">**</bpt>as<ept id=\"p1\">**</ept> keyword is used after the <bpt id=\"p2\">**</bpt>is<ept id=\"p2\">**</ept> keyword verifies that the <bpt id=\"p3\">**</bpt>as<ept id=\"p3\">**</ept> keyword will succeed.","pos":[12276,12374],"source":" The **as** keyword is used after the **is** keyword verifies that the **as** keyword will succeed."},{"content":"In this example, the <bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>as<ept id=\"p2\">**</ept> keywords are uppercase to make them more visible.","pos":[12375,12463],"source":" In this example, the **is** and **as** keywords are uppercase to make them more visible."},{"pos":[13093,13123],"content":"Object class as a special case","linkify":"Object class as a special case","nodes":[{"content":"Object class as a special case","pos":[0,30]}]},{"content":"The <bpt id=\"p1\">**</bpt>Object<ept id=\"p1\">**</ept> class can appear as a special case in inheritance functionality.","pos":[13125,13204],"source":"The **Object** class can appear as a special case in inheritance functionality."},{"content":"The compiler bypasses type checking for assignments to and from variables that are declared to be of type <bpt id=\"p1\">**</bpt>Object<ept id=\"p1\">**</ept>.","pos":[13205,13322],"source":" The compiler bypasses type checking for assignments to and from variables that are declared to be of type **Object**."},{"content":"Some classes inherit from the <bpt id=\"p1\">**</bpt>Object<ept id=\"p1\">**</ept> class, some classes inherit from another class, and some classes don't inherit from any class.","pos":[13323,13458],"source":" Some classes inherit from the **Object** class, some classes inherit from another class, and some classes don't inherit from any class."},{"content":"Although the <bpt id=\"p1\">**</bpt>Dialog<ept id=\"p1\">**</ept> class doesn't inherit from any class, the assignment and call statements in the following code example work.","pos":[13459,13591],"source":" Although the **Dialog** class doesn't inherit from any class, the assignment and call statements in the following code example work."},{"content":"However, if the assignment is <bpt id=\"p1\">**</bpt>bank4 = dlog3;<ept id=\"p1\">**</ept>, it will fail at compile time, because the <bpt id=\"p2\">**</bpt>Bank<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>Dialog<ept id=\"p3\">**</ept> classes have no inheritance relationship to each other.","pos":[13592,13763],"source":" However, if the assignment is **bank4 = dlog3;**, it will fail at compile time, because the **Bank** and **Dialog** classes have no inheritance relationship to each other."},{"content":"The compiler performs only one small validation on assignments to a variable that is declared to be of the <bpt id=\"p1\">**</bpt>Object<ept id=\"p1\">**</ept> class.","pos":[13764,13888],"source":" The compiler performs only one small validation on assignments to a variable that is declared to be of the **Object** class."},{"content":"The compiler verifies that the item that is being assigned to the <bpt id=\"p1\">**</bpt>Object<ept id=\"p1\">**</ept> variable is an instance of a class.","pos":[13889,14001],"source":" The compiler verifies that the item that is being assigned to the **Object** variable is an instance of a class."},{"content":"The compiler doesn't allow an instance of a table buffer to be assigned to the <bpt id=\"p1\">**</bpt>Object<ept id=\"p1\">**</ept> variable.","pos":[14002,14101],"source":" The compiler doesn't allow an instance of a table buffer to be assigned to the **Object** variable."},{"content":"Additionally, the compiler doesn't allow primitive data types, such as <bpt id=\"p1\">**</bpt>int<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>str<ept id=\"p2\">**</ept>, to be assigned to the <bpt id=\"p3\">**</bpt>Object<ept id=\"p3\">**</ept> variable.","pos":[14102,14235],"source":" Additionally, the compiler doesn't allow primitive data types, such as **int** or **str**, to be assigned to the **Object** variable."},{"pos":[14530,14536],"content":"Tables","linkify":"Tables","nodes":[{"content":"Tables","pos":[0,6]}]},{"content":"All tables inherit directly from the Common system table, unless they explicitly inherit from a different table.","pos":[14538,14650]},{"content":"The Common table can't be instantiated.","pos":[14651,14690]},{"content":"It doesn't exist in the underlying physical database.","pos":[14691,14744]},{"content":"The Common table inherits from the <bpt id=\"p1\">**</bpt>xRecord<ept id=\"p1\">**</ept> class, but in a special way that isn't appropriate for the <bpt id=\"p2\">**</bpt>is<ept id=\"p2\">**</ept> keyword or the <bpt id=\"p3\">**</bpt>as<ept id=\"p3\">**</ept> keyword.","pos":[14745,14888],"source":" The Common table inherits from the **xRecord** class, but in a special way that isn't appropriate for the **is** keyword or the **as** keyword."},{"content":"When the <bpt id=\"p1\">**</bpt>as<ept id=\"p1\">**</ept> keyword is used to perform an invalid downcast among tables, the target variable references an unusable non-null entity.","pos":[14889,15025],"source":" When the **as** keyword is used to perform an invalid downcast among tables, the target variable references an unusable non-null entity."},{"content":"Any attempt to de-reference the target variable will cause an error that stops the program.","pos":[15026,15117]},{"pos":[15123,15169],"content":"The is and as keywords and extended data types","linkify":"The is and as keywords and extended data types","nodes":[{"content":"The is and as keywords and extended data types","pos":[0,46]}]},{"content":"Each extended data type has an <bpt id=\"p1\">**</bpt>Extends<ept id=\"p1\">**</ept> property.","pos":[15171,15223],"source":"Each extended data type has an **Extends** property."},{"content":"The style of inheritance that this property controls differs from the style of inheritance that the <bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>as<ept id=\"p2\">**</ept> keywords are designed for.","pos":[15224,15368],"source":" The style of inheritance that this property controls differs from the style of inheritance that the **is** and **as** keywords are designed for."},{"pos":[15373,15393],"content":"Relational operators","linkify":"Relational operators","nodes":[{"content":"Relational operators","pos":[0,20]}]},{"content":"The following table lists the relational operators that can be used in X++.","pos":[15394,15469]},{"content":"Most of the operators are binary and take two operands.","pos":[15470,15525]},{"content":"However, the <bpt id=\"p1\">**</bpt>not<ept id=\"p1\">**</ept> (<bpt id=\"p2\">**</bpt>!<ept id=\"p2\">**</ept>) operator is unary and takes only one operand.","pos":[15526,15600],"source":" However, the **not** (**!**) operator is unary and takes only one operand."},{"content":"Syntax for binary operators: <bpt id=\"p1\">*</bpt>expression1<ept id=\"p1\">*</ept> <bpt id=\"p2\">*</bpt>relationalOperator<ept id=\"p2\">*</ept> <bpt id=\"p3\">*</bpt>expression2<ept id=\"p3\">*</ept> Syntax for unary operators: <bpt id=\"p4\">*</bpt>relationalOperator<ept id=\"p4\">*</ept> <bpt id=\"p5\">*</bpt>expression1<ept id=\"p5\">*</ept>","pos":[15601,15741],"source":" Syntax for binary operators: *expression1* *relationalOperator* *expression2* Syntax for unary operators: *relationalOperator* *expression1*"},{"content":"Operator","pos":[15745,15753]},{"content":"Description","pos":[15756,15767]},{"content":"like","pos":[16089,16093]},{"pos":[16100,16189],"content":"The <bpt id=\"p1\">**</bpt>like<ept id=\"p1\">**</ept> relational operator returns <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> if <bpt id=\"p3\">*</bpt>expression1<ept id=\"p3\">*</ept> is like <bpt id=\"p4\">*</bpt>expression2<ept id=\"p4\">*</ept>.","source":"The **like** relational operator returns **true** if *expression1* is like *expression2*."},{"pos":[16272,16353],"content":"The <bpt id=\"p1\">**</bpt>equal<ept id=\"p1\">**</ept> relational operator returns <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> if both expressions are equal.","source":"The **equal** relational operator returns **true** if both expressions are equal."},{"pos":[16444,16573],"content":"The <bpt id=\"p1\">**</bpt>greater than or equal to<ept id=\"p1\">**</ept> relational operator returns <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> if <bpt id=\"p3\">*</bpt>expression1<ept id=\"p3\">*</ept> is greater than or equal to <bpt id=\"p4\">*</bpt>expression2<ept id=\"p4\">*</ept>.","source":"The **greater than or equal to** relational operator returns **true** if *expression1* is greater than or equal to *expression2*."},{"pos":[16616,16739],"content":"The <bpt id=\"p1\">**</bpt>less than or equal to<ept id=\"p1\">**</ept> relational operator returns <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> if <bpt id=\"p3\">*</bpt>expression1<ept id=\"p3\">*</ept> is less than or equal to <bpt id=\"p4\">*</bpt>expression2<ept id=\"p4\">*</ept>.","source":"The **less than or equal to** relational operator returns **true** if *expression1* is less than or equal to *expression2*."},{"pos":[16788,16893],"content":"The <bpt id=\"p1\">**</bpt>greater than<ept id=\"p1\">**</ept> relational operator returns <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> if <bpt id=\"p3\">*</bpt>expression1<ept id=\"p3\">*</ept> is greater than <bpt id=\"p4\">*</bpt>expression2<ept id=\"p4\">*</ept>.","source":"The **greater than** relational operator returns **true** if *expression1* is greater than *expression2*."},{"pos":[16960,17059],"content":"The <bpt id=\"p1\">**</bpt>less than<ept id=\"p1\">**</ept> relational operator returns <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> if <bpt id=\"p3\">*</bpt>expression1<ept id=\"p3\">*</ept> is less than <bpt id=\"p4\">*</bpt>expression2<ept id=\"p4\">*</ept>.","source":"The **less than** relational operator returns **true** if *expression1* is less than *expression2*."},{"content":"!=","pos":[17121,17123]},{"pos":[17132,17263],"content":"The <bpt id=\"p1\">**</bpt>not equal<ept id=\"p1\">**</ept> relational operator returns <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> if <bpt id=\"p3\">*</bpt>expression1<ept id=\"p3\">*</ept> differs from (that is, if it isn't equal to) <bpt id=\"p4\">*</bpt>expression2<ept id=\"p4\">*</ept>.","source":"The **not equal** relational operator returns **true** if *expression1* differs from (that is, if it isn't equal to) *expression2*."},{"pos":[17304,17402],"content":"The <bpt id=\"p1\">**</bpt>and<ept id=\"p1\">**</ept> relational operator returns <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> if both <bpt id=\"p3\">*</bpt>expression1<ept id=\"p3\">*</ept> and <bpt id=\"p4\">*</bpt>expression2<ept id=\"p4\">*</ept> are true.","source":"The **and** relational operator returns **true** if both *expression1* and *expression2* are true."},{"pos":[17476,17587],"content":"The <bpt id=\"p1\">**</bpt>or<ept id=\"p1\">**</ept> relational operator returns <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> if <bpt id=\"p3\">*</bpt>expression1<ept id=\"p3\">*</ept> or <bpt id=\"p4\">*</bpt>expression2<ept id=\"p4\">*</ept> is true, or if both are true.","source":"The **or** relational operator returns **true** if *expression1* or *expression2* is true, or if both are true."},{"content":"!","pos":[17637,17638]},{"content":"The <bpt id=\"p1\">**</bpt>not<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>unary<ept id=\"p2\">**</ept> relational operator negates the expression.","pos":[17648,17716],"source":"The **not** or **unary** relational operator negates the expression."},{"content":"It returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the expression is false and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if the expression is true.","pos":[17717,17804],"source":" It returns **true** if the expression is false and **false** if the expression is true."},{"pos":[17812,17829],"content":"The like operator","linkify":"The like operator","nodes":[{"content":"The like operator","pos":[0,17]}]},{"content":"The <bpt id=\"p1\">**</bpt>like<ept id=\"p1\">**</ept> operator can use <bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept> as a wildcard character for zero or more characters, and <bpt id=\"p3\">**</bpt>?<ept id=\"p3\">**</ept>","pos":[17831,17930],"source":"The **like** operator can use **\\*** as a wildcard character for zero or more characters, and **?**"},{"content":"as a wildcard character for one character.","pos":[17931,17973]},{"content":"The operand can't be longer than 1,000 characters.","pos":[17974,18024]},{"content":"The <bpt id=\"p1\">**</bpt>like<ept id=\"p1\">**</ept> operator is evaluated by the underlying SQL, so the result might differ on different installations.","pos":[18025,18137],"source":" The **like** operator is evaluated by the underlying SQL, so the result might differ on different installations."},{"content":"If the expressions that you're comparing contain a file path, you must include four backslashes between each element, as shown in the following example.","pos":[18138,18290]},{"pos":[18390,18413],"content":"The equal (==) operator","linkify":"The equal (==) operator","nodes":[{"content":"The equal (==) operator","pos":[0,23]}]},{"content":"When you use the <bpt id=\"p1\">**</bpt>equal<ept id=\"p1\">**</ept> (<bpt id=\"p2\">**</bpt><ph id=\"ph1\">==</ph><ept id=\"p2\">**</ept>) operator to compare objects, the object references are compared, not the objects themselves.","pos":[18415,18543],"source":"When you use the **equal** (**==**) operator to compare objects, the object references are compared, not the objects themselves."},{"content":"This behavior might cause issues if you compare two objects, one of which is located on the server, and the other of which is located on the client.","pos":[18544,18692]},{"content":"In these cases, you should use the <bpt id=\"p1\">**</bpt>equal<ept id=\"p1\">**</ept> method in the <bpt id=\"p2\">**</bpt>Object<ept id=\"p2\">**</ept> class.","pos":[18693,18769],"source":" In these cases, you should use the **equal** method in the **Object** class."},{"content":"You can override this method to specify what it means for two objects to be equal.","pos":[18770,18852]},{"content":"If you don't override the <bpt id=\"p1\">**</bpt>equal<ept id=\"p1\">**</ept> method, the comparison is identical to the comparison that is done by the <bpt id=\"p2\">**</bpt>equal<ept id=\"p2\">**</ept> (<bpt id=\"p3\">**</bpt><ph id=\"ph1\">==</ph><ept id=\"p3\">**</ept>) operator.","pos":[18853,18991],"source":" If you don't override the **equal** method, the comparison is identical to the comparison that is done by the **equal** (**==**) operator."},{"pos":[18997,19035],"content":"Code examples for relational operators","linkify":"Code examples for relational operators","nodes":[{"content":"Code examples for relational operators","pos":[0,38]}]},{"pos":[19810,19829],"content":"Operator precedence","linkify":"Operator precedence","nodes":[{"content":"Operator precedence","pos":[0,19]}]},{"content":"The order that a compound expression is evaluated in can be important.","pos":[19830,19900]},{"content":"For example, <bpt id=\"p1\">**</bpt>(x + y / 100)<ept id=\"p1\">**</ept> gives a different result, depending on whether the addition or the division is done first.","pos":[19901,20022],"source":" For example, **(x + y / 100)** gives a different result, depending on whether the addition or the division is done first."},{"content":"You can use parentheses (<bpt id=\"p1\">**</bpt>()<ept id=\"p1\">**</ept>) to explicitly tell the compiler how it should evaluate an expression.","pos":[20023,20125],"source":" You can use parentheses (**()**) to explicitly tell the compiler how it should evaluate an expression."},{"content":"For example, you can specify <bpt id=\"p1\">**</bpt>(x + y) / 100<ept id=\"p1\">**</ept>.","pos":[20126,20173],"source":" For example, you can specify **(x + y) / 100**."},{"content":"If you don't explicitly tell the compiler the order that you want operations to be done in, the order is based on the precedence that is assigned to the operators.","pos":[20174,20337]},{"content":"For example, the division operator has higher precedence than the addition operator.","pos":[20338,20422]},{"content":"Therefore, for the expression <bpt id=\"p1\">**</bpt>x + y / 100<ept id=\"p1\">**</ept>, the compiler evaluates <bpt id=\"p2\">**</bpt>y / 100<ept id=\"p2\">**</ept> first.","pos":[20423,20511],"source":" Therefore, for the expression **x + y / 100**, the compiler evaluates **y / 100** first."},{"content":"In other words,<ph id=\"ph1\">` `</ph><bpt id=\"p1\">**</bpt>x + y / 100<ept id=\"p1\">**</ept> is equivalent to <bpt id=\"p2\">**</bpt>x + (y / 100)<ept id=\"p2\">**</ept>.","pos":[20512,20581],"source":" In other words,` `**x + y / 100** is equivalent to **x + (y / 100)**."},{"content":"To make your code easy to read and maintain, be explicit.","pos":[20582,20639]},{"content":"Use parentheses to indicate which operators should be evaluated first.","pos":[20640,20710]},{"content":"The following table lists the operators in order of precedence.","pos":[20711,20774]},{"content":"The higher an operator appears in the table, the higher its precedence.","pos":[20775,20846]},{"content":"Operators that have higher precedence are evaluated before operators that have lower precedence.","pos":[20847,20943]},{"content":"Note that the operator precedence of X++ isn't the same as the operator precedence of other languages, such as C<ph id=\"ph1\">\\#</ph> and Java.","pos":[20944,21068],"source":" Note that the operator precedence of X++ isn't the same as the operator precedence of other languages, such as C\\# and Java."},{"content":"Operators, in order of precedence","pos":[21072,21105]},{"content":"Syntax","pos":[21139,21145]},{"content":"Unary","pos":[21292,21297]},{"content":"- ~ !","pos":[21359,21364]},{"pos":[21402,21466],"content":"Multiplicative, shift, bitwise <bpt id=\"p1\">**</bpt>AND<ept id=\"p1\">**</ept>, bitwise exclusive <bpt id=\"p2\">**</bpt>OR<ept id=\"p2\">**</ept>","source":"Multiplicative, shift, bitwise **AND**, bitwise exclusive **OR**"},{"content":"<ph id=\"ph1\">\\*</ph> / % DIV <ph id=\"ph2\">&amp;lt;</ph><ph id=\"ph3\">&amp;lt;</ph> <ph id=\"ph4\">&amp;gt;</ph><ph id=\"ph5\">&amp;gt;</ph> &amp; ^","pos":[21469,21501],"source":"\\* / % DIV &lt;&lt; &gt;&gt; & ^"},{"pos":[21512,21546],"content":"Additive, bitwise inclusive <bpt id=\"p1\">**</bpt>OR<ept id=\"p1\">**</ept>","source":"Additive, bitwise inclusive **OR**"},{"content":"+ â€“","pos":[21579,21582]},{"content":"Relational, equality","pos":[21622,21642]},{"content":"<ph id=\"ph1\">&amp;lt;</ph> <ph id=\"ph2\">&amp;lt;</ph>= == != <ph id=\"ph3\">&amp;gt;</ph> <ph id=\"ph4\">&amp;gt;</ph>= like as is","pos":[21689,21727],"source":"&lt; &lt;= == != &gt; &gt;= like as is"},{"pos":[21732,21757],"content":"Logical (<bpt id=\"p1\">**</bpt>AND<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>OR<ept id=\"p2\">**</ept>)","source":"Logical (**AND**, **OR**)"},{"content":"Conditional","pos":[21842,21853]},{"content":"?","pos":[21909,21910]},{"content":":","pos":[21911,21912]},{"content":"Operators on the same line have equal precedence.","pos":[21951,22000]},{"content":"If an expression includes more than one of these operators, it's evaluated from left to right, unless assignment operators are used.","pos":[22001,22133]},{"content":"(Assignment operators are evaluated from right to left.) For example, <bpt id=\"p1\">**</bpt><ph id=\"ph1\">&amp;&amp;</ph><ept id=\"p1\">**</ept> (logical <bpt id=\"p2\">**</bpt>AND<ept id=\"p2\">**</ept>) and <bpt id=\"p3\">**</bpt><ph id=\"ph2\">||</ph><ept id=\"p3\">**</ept> (logical <bpt id=\"p4\">**</bpt>OR<ept id=\"p4\">**</ept>) have the same precedence, and are evaluated from left to right.","pos":[22134,22320],"source":" (Assignment operators are evaluated from right to left.) For example, **&&** (logical **AND**) and **||** (logical **OR**) have the same precedence, and are evaluated from left to right."},{"content":"Therefore, <bpt id=\"p1\">**</bpt>0&amp;&amp;0||1 == 1<ept id=\"p1\">**</ept>, and <bpt id=\"p2\">**</bpt>1||0&amp;&amp;0 == 0<ept id=\"p2\">**</ept>.","pos":[22321,22371],"source":" Therefore, **0&&0||1 == 1**, and **1||0&&0 == 0**."}],"content":"---\n# required metadata\n\ntitle: X++ operators | Microsoft Docs\ndescription: This topic describes the operators supported in X++.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 2016-08-27 00:51:34\nms.topic: \nms.prod: \nms.service: \nms.technology: \n\n# optional metadata\n\n# keywords: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: 61\nms.suite: Released- Dynamics AX 7.0.0\n# ms.tgt_pltfrm: \nms.custom: 150373\nms.assetid: d09549a4-0b6e-4be3-ba57-21334d9b3a52\nms.region: Global\n# ms.industry: \nms.author: robinr\n\n---\n\n# X++ operators\n\nThis topic describes the operators supported in X++.\n\nAssignment operators\n--------------------\n\nAn assignment changes the value of a variable or field. The following table shows the X++ assignment operators. There is no difference between prefix and postfix operators.\n\n| Operator | Description                                                                                      |\n|----------|--------------------------------------------------------------------------------------------------|\n| =        | Assign the expression on the right of the equal sign to the variable on the left.                |\n| +=       | Assign the current variable value plus the expression on the right to the variable on the left.  |\n| ++       | Increment the variable by 1.                                                                     |\n| -=       | Assign the current variable value minus the expression on the right to the variable on the left. |\n| --       | Decrement the variable by 1.                                                                     |\n\n### Code examples for assignment operators\n\n    // An example of assignment operators and their output. \n    static void Example1()\n    {\n        int i = 1;\n        // Using the = operator. i is assigned the value of i, plus 1. i = 2.\n        i = i + 1;\n        info(strFmt(\"Example 1: The result is \"), i); // The result is 2.\n    }\n\n    static void Example2()\n    {\n        int i = 1;\n        // Using the += operator. i is assigned the value of i, plus 1. \n        // i = 2 (i = i + 1).\n        i += 1;\n        info(strFmt(\"Example 2: The result is \"), i); // The result is 2. \n    }\n\n    static void Example3()\n    {\n        int i = 1;\n        // Using the ++ operator. i is incremented by 1, and then \n        // by 1 again in the second statement. The final value of i is 3.\n        i++;\n        ++i;\n        info(strFmt(\"Example 3: The result is \"), i); // The result is 3. \n    }\n\n    static void Example4()\n    {\n        int i = 1;\n        // Using the -= operator. i is assigned the value of i minus 1. \n        // i = 0 (i = i - 1).\n        i -= 1;\n        info(strFmt(\"Example 4: The result is \"), i); // The result is 0. \n    }\n\n    static void Example5()\n    {\n        int i = 1;\n        // Using the -- operator. i is decremented by 1, and then by \n        // 1 again in the second statement. The final value of i is -1.\n        i--;\n        --i;\n        info(strFmt(\"Example 5: The result is \"), i); // The result is -1. \n    }\n\n## Arithmetic operators\nYou use arithmetic operators to perform numeric calculations. Most of the operators are binary and take two operands. However, the **not** (**~**) operator is unary and takes only one operand. Syntax for binary operators: *expression1* *ArithmeticOperator* *expression2* Syntax for unary operators: *ArithmeticOperator* *expression1*\n\n| Operator | Description                                                                                                                                                                                 |\n|----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| &lt;&lt; | The **left shift** operator performs *expression2* left shift (multiplication by 2) on *expression1*.                                                                                       |\n| &gt;&gt; | The **right shift** operator performs *expression2* right shift (division by 2) on *expression1*.                                                                                           |\n| \\*       | The **multiply** operator multiplies *expression1* by *expression2*.                                                                                                                        |\n| /        | The **divide** operator divides *expression1* by *expression2*.                                                                                                                             |\n| DIV      | The **integer division** operator performs an integer division of *expression1* by *expression2*.                                                                                           |\n| MOD      | The **integer remainder** operator returns the remainder of an integer division of *expression1* by *expression2*.                                                                          |\n| ~        | The **not** operator, or unary operator, performs a binary not operation.                                                                                                                   |\n| &        | The **binary AND** operator performs a binary and operation on *expression1* and *expression2*.                                                                                             |\n| ^        | The **binary XOR** operator performs a binary XOR-operation on *expression1* and *expression2*.                                                                                             |\n| |        | The **binary OR** operator performs a binary or operation on *expression1* and *expression2*.                                                                                               |\n| +        | The **plus** operator adds *expression1* to *expression2*.                                                                                                                                  |\n| -        | The **minus** operator subtracts *expression2* from *expression1*.                                                                                                                          |\n| ?        | The **ternary** operator takes three expressions: *expression1* ? *expression2* : *expression3*. If *expression1* is true, *expression2* is returned. Otherwise, *expression3* is returned. |\n\n### Code examples for arithmetic operators\n\n    int a = 1 << 4; // Perform four left shifts on 1 (1*2*2*2*2). a=16.\n    int b = 16 >> 4;  // Perform four right shifts on 16 (16/2/2/2/2). b=1.\n    int c = 4 * 5;  // Multiply 4 by 5. c=20.\n    int d = 20 / 5;  // Divide 20 by 5. d=4.\n    int e = 100 div 21;  // Return the integer division of 100 by 21. e=4 (4*21 = 84, remainder 16).\n    int f = 100 mod 21;  // Return the remainder of the integer division of 100 by 21. f=16.\n    int g = ~1;  // Binary negate 1 (all bits are reversed). g=-2.\n    int h = 1 & 3;  // Binary AND. Return the bits that are in common in the two integers. h=1.\n    int i = 1 | 3;  // Binary OR. Return the bits that are set in either 1 or 3. i=3.\n    int j = 1 ^ 3;  // Binary XOR. Return the bits that are set in 1 and NOT set in 3, and vice versa. j=2.\n    int k = 1 + 3;  // Add 1 and 3. k=4.\n    int l = 3 - 1;  // Subtract 1 from 3. l=2.\n    int m = (400 > 4) ? 1 : 5;  // If 400>4, 1 is returned. Otherwise, 5 is returned. Because 400>4, 1 is returned. m=1.\n\n## Expression operators\nThe **as** and **is** expression operators control downcast assignments. Downcast assignments involve class or table inheritance. Assignment statements that implicitly downcast can cause errors that are difficult to predict and diagnose. You can use the **as** keyword to make your downcasts explicit. You can use the **is** keyword to test whether a downcast is valid at run time.\n\n### The as keyword\n\nUse the **as** keyword for assignments that downcast from a base class variable to a derived class variable. The **as** keyword tells other programmers and the compiler that you believe that the downcast will be valid during run time.\n\n-   The compiler reports an error for downcast assignment statements that lack the **as** keyword.\n-   At run time, the **as** keyword causes the downcast assignment statement to assign **null** if the downcast isn't valid.\n-   This **is** keyword is often used to safely test whether the **as** keyword will work.\n\n#### Code example for the as keyword\n\nIn the following code example, the **DerivedClass** class extends the **BaseClass** class. The code example contains two valid assignments between its **basec** and **derivedc** variables. The upcast assignment to **basec** doesn't require the **as** keyword, but the downcast assignment to **derivedc** does require the **as** keyword. The following code will compile and run without errors.\n\n    static void AsKeywordExample()\n    {\n        // DerivedClass extends BaseClass.\n        BaseClass basec;\n        DerivedClass derivedc;\n        // BottomClass extends DerivedClass.\n        BottomClass bottomc;\n        derivedc = new DerivedClass();\n        // AS is not required for an upcast assignment like this.\n        basec = derivedc;\n        // AS is required for a downcast assignment like this.\n        derivedc = basec as DerivedClass;\n        bottomc = new BottomClass();\n        // AS causes this invalid downcast to assign null.\n        bottomc = basec as DerivedClass;\n    }\n\n### The is keyword\n\nThe **is** keyword verifies whether an object is a subtype of a specified class. The **is** expression returns **true** if the object is a subtype of the class, or if the object is the same type as the class. The compiler reports an error if an **is** keyword expression compares two types, but neither type is a subtype of the other, and they aren't of the same type. The compiler reports a similar error for any plain assignment statement between two types, where neither type is a subtype of the other, and they aren't of the same type. At run time, the type of variable that references the underlying object is irrelevant to the **is** keyword. The **is** keyword causes the system to verify the object that the variable references, not the declared type of the variable that references the object.\n\n#### Code examples for the is keyword\n\nThe following code examples illustrate the conditions that control whether an **is** expression returns **true** or **false**. The code examples depend on the fact that the **Form** class and the **Query** class both extend the **TreeNode** class.\n\n    // The compiler issues an error for the following code. \n    // The compiler ascertains that the Form class and the Query class are not \n    // part of the same inheritance hierarchy. Both the Form class and the Query class\n    // extend the TreeNode class, but neither Form nor Query is a subtype of the other.\n    Form myForm = new Form();\n    info(strFmt(\"%1\", (myForm is Query)));\n\n    // The Infolog displays 0 during run time, where 0 means false. No supertype \n    // object can be considered to also be of its subtype class.\n    TreeNode myTreeNode = new TreeNode();\n    info(strFmt(\"%1\", (myTreeNode is Form)));\n\n    // The Infolog displays 0 during run time, where 0 means false. A null \n    // reference causes the is expression to return false.\n    Form myForm;\n    info(strFmt(\"%1\", (myForm is Form)));\n\n    // The Infolog displays 1 during run time, where 1 means true. \n    // An object is an instance of its own class type.\n    Form myForm = new Form();\n    info(strFmt(\"%1\", (myForm is Form)));\n\n    // The Infolog displays 1 during run time, where 1 means true. \n    // Every subtype is also of its supertype.\n    Form myForm = new Form();\n    info(strFmt(\"%1\", (myForm is TreeNode)));\n     \n    // The Infolog displays 1 during run time, where 1 means true. \n    // The type of the underlying object matters in the is expression,\n    // not the type of the variable that references the object.\n    Form myForm = new Form();\n    TreeNode myTreeNode;\n    myTreeNode = myForm; // Upcast.\n    info(strFmt(\"%1\", (myTreeNode is Form)));\n\n#### Code example for the is and as keywords\n\nThe following code example contains a typical use of the **is** keyword. The **as** keyword is used after the **is** keyword verifies that the **as** keyword will succeed. In this example, the **is** and **as** keywords are uppercase to make them more visible.\n\n    static void IsKeywordExample() \n    {\n        DerivedClass derivedc;\n        BaseClass basec;\n        basec = new DerivedClass();  // An upcast.\n        if (basec IS DerivedClass)\n        {\n            info(\"Test 1: (basec IS DerivedClass) is true. Good.\");\n            derivedc = basec AS DerivedClass;\n        }\n        basec = new BaseClass();\n        if (!(basec IS DerivedClass))\n        {\n            info(\"Test 2: !(basec IS DerivedClass) is true. Good.\");\n        }\n    }\n     \n    //Output to the Infolog\n    Test 1: (basec IS DerivedClass) is true. Good.\n    Test 2: (!(basec IS DerivedClass)) is true. Good.\n\n### Object class as a special case\n\nThe **Object** class can appear as a special case in inheritance functionality. The compiler bypasses type checking for assignments to and from variables that are declared to be of type **Object**. Some classes inherit from the **Object** class, some classes inherit from another class, and some classes don't inherit from any class. Although the **Dialog** class doesn't inherit from any class, the assignment and call statements in the following code example work. However, if the assignment is **bank4 = dlog3;**, it will fail at compile time, because the **Bank** and **Dialog** classes have no inheritance relationship to each other. The compiler performs only one small validation on assignments to a variable that is declared to be of the **Object** class. The compiler verifies that the item that is being assigned to the **Object** variable is an instance of a class. The compiler doesn't allow an instance of a table buffer to be assigned to the **Object** variable. Additionally, the compiler doesn't allow primitive data types, such as **int** or **str**, to be assigned to the **Object** variable.\n\n    static void ObjectExample()\n    {\n        Bank bank4;\n        Object obj2;\n        Dialog dlog3 = new Dialog(\"Test 4.\");\n        obj2 = dlog3;  // The assignment does work.\n        obj2.run(false);  // The call causes the dialog to appear.\n        info(\"Test 4a is finished.\");\n    }\n\n### Tables\n\nAll tables inherit directly from the Common system table, unless they explicitly inherit from a different table. The Common table can't be instantiated. It doesn't exist in the underlying physical database. The Common table inherits from the **xRecord** class, but in a special way that isn't appropriate for the **is** keyword or the **as** keyword. When the **as** keyword is used to perform an invalid downcast among tables, the target variable references an unusable non-null entity. Any attempt to de-reference the target variable will cause an error that stops the program.\n\n### The is and as keywords and extended data types\n\nEach extended data type has an **Extends** property. The style of inheritance that this property controls differs from the style of inheritance that the **is** and **as** keywords are designed for.\n\n## Relational operators\nThe following table lists the relational operators that can be used in X++. Most of the operators are binary and take two operands. However, the **not** (**!**) operator is unary and takes only one operand. Syntax for binary operators: *expression1* *relationalOperator* *expression2* Syntax for unary operators: *relationalOperator* *expression1*\n\n| Operator | Description                                                                                                                                                  |\n|----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| like     | The **like** relational operator returns **true** if *expression1* is like *expression2*.                                                                    |\n| ==       | The **equal** relational operator returns **true** if both expressions are equal.                                                                            |\n| &gt;=    | The **greater than or equal to** relational operator returns **true** if *expression1* is greater than or equal to *expression2*.                            |\n| &lt;=    | The **less than or equal to** relational operator returns **true** if *expression1* is less than or equal to *expression2*.                                  |\n| &gt;     | The **greater than** relational operator returns **true** if *expression1* is greater than *expression2*.                                                    |\n| &lt;     | The **less than** relational operator returns **true** if *expression1* is less than *expression2*.                                                          |\n| !=       | The **not equal** relational operator returns **true** if *expression1* differs from (that is, if it isn't equal to) *expression2*.                          |\n| &&       | The **and** relational operator returns **true** if both *expression1* and *expression2* are true.                                                           |\n| ||       | The **or** relational operator returns **true** if *expression1* or *expression2* is true, or if both are true.                                              |\n| !        | The **not** or **unary** relational operator negates the expression. It returns **true** if the expression is false and **false** if the expression is true. |\n\n### The like operator\n\nThe **like** operator can use **\\*** as a wildcard character for zero or more characters, and **?** as a wildcard character for one character. The operand can't be longer than 1,000 characters. The **like** operator is evaluated by the underlying SQL, so the result might differ on different installations. If the expressions that you're comparing contain a file path, you must include four backslashes between each element, as shown in the following example.\n\n    select * from xRefpaths\n    where xRefPaths.Path like \"\\\\\\\\Classes\\\\\\\\AddressSelectForm\"\n\n### The equal (==) operator\n\nWhen you use the **equal** (**==**) operator to compare objects, the object references are compared, not the objects themselves. This behavior might cause issues if you compare two objects, one of which is located on the server, and the other of which is located on the client. In these cases, you should use the **equal** method in the **Object** class. You can override this method to specify what it means for two objects to be equal. If you don't override the **equal** method, the comparison is identical to the comparison that is done by the **equal** (**==**) operator.\n\n### Code examples for relational operators\n\n    \"Jones\" like \"Jo?es\"  // Returns true, because the ? is equal to any single character.\n    \"Fabrikam, Inc.\" like \"Fa*\"  // Returns true, because the * is equal to zero or more characters.\n    (( 42 * 2) == 84)  // Returns true, because 42*2 is equal to 84.\n    today() >= 1\\1\\1980  // Returns true, because today is later than January 1, 1980.\n    ((11 div 10) >= 1)  // Returns true, because 11 div 10 is 1 (therefore, >= 1 is true).\n    (11<= 12)  // Returns true, because 11 is less than 12.\n    ((11 div 10) > 1)  // Returns false, because 11 div 10 is 1.\n    (11 div 10) < 1)  // Returns false, because 11 div 10 is 1.\n    (11 != 12)  // Returns true, because 11 is not equal to 12.\n    (1 == 1) && (3 > 1)  // Returns true, because both expressions are true.\n\n## Operator precedence\nThe order that a compound expression is evaluated in can be important. For example, **(x + y / 100)** gives a different result, depending on whether the addition or the division is done first. You can use parentheses (**()**) to explicitly tell the compiler how it should evaluate an expression. For example, you can specify **(x + y) / 100**. If you don't explicitly tell the compiler the order that you want operations to be done in, the order is based on the precedence that is assigned to the operators. For example, the division operator has higher precedence than the addition operator. Therefore, for the expression **x + y / 100**, the compiler evaluates **y / 100** first. In other words,` `**x + y / 100** is equivalent to **x + (y / 100)**. To make your code easy to read and maintain, be explicit. Use parentheses to indicate which operators should be evaluated first. The following table lists the operators in order of precedence. The higher an operator appears in the table, the higher its precedence. Operators that have higher precedence are evaluated before operators that have lower precedence. Note that the operator precedence of X++ isn't the same as the operator precedence of other languages, such as C\\# and Java.\n\n| Operators, in order of precedence                                | Syntax                                 |\n|------------------------------------------------------------------|----------------------------------------|\n| Unary                                                            | - ~ !                                  |\n| Multiplicative, shift, bitwise **AND**, bitwise exclusive **OR** | \\* / % DIV &lt;&lt; &gt;&gt; & ^       |\n| Additive, bitwise inclusive **OR**                               | + â€“ |                                  |\n| Relational, equality                                             | &lt; &lt;= == != &gt; &gt;= like as is |\n| Logical (**AND**, **OR**)                                        | && ||                                  |\n| Conditional                                                      | ? :                                    |\n\nOperators on the same line have equal precedence. If an expression includes more than one of these operators, it's evaluated from left to right, unless assignment operators are used. (Assignment operators are evaluated from right to left.) For example, **&&** (logical **AND**) and **||** (logical **OR**) have the same precedence, and are evaluated from left to right. Therefore, **0&&0||1 == 1**, and **1||0&&0 == 0**.\n\n"}