{"content":"---\n# required metadata\n\ntitle: Retail SDK samples\ndescription: This topic describes three new samples that were released together with the Retail SDK in December 2016.\nauthor: josaw1\nmanager: AnnBe\nms.date: 04/04/2017\nms.topic: article\nms.prod: \nms.service: Dynamics365Operations\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \n# ms.reviewer: 2051\nms.search.scope: Operations, Platform\n# ms.tgt_pltfrm: \nms.custom: 266164\nms.assetid: d24470fd-07ad-4c3f-b23a-3f6c1401edc6\nms.search.region: Global\n# ms.search.industry: \nms.author: mumani\nms.search.validFrom: 2016-08-30\nms.dyn365.ops.version: Platform update 2\n\n---\n\n# Retail SDK samples\n\n[!include[banner](../../includes/banner.md)]\n\n\nThis topic describes three new samples that were released together with the Retail SDK in December 2016.\n\nOverride message handler sample\n-------------------------------\n\n**Scenario:** Sometimes, one of Fabrikam's customers is in the customer relationship management (CRM) system but isn't imported into Microsoft Dynamics 365 for Operations. Therefore, Fabrikam wants to look up the customer from the CRM system and the point of sale (POS). Here are the business requirements:\n\n-   Search for customers from the CRM system and the POS.\n-   Merge the results, and show a unified result set in Retail Modern POS (MPOS).\n\nHere are some situations where you might use the override message handler:\n\n-   You want to use a third-party inventory system for stock updates and inquiries.\n-   You want to integrate with an external tax system for tax calculation.\n-   You want to integrate with a third-party loyalty system.\n\nHere are the basic tasks in the sample:\n\n1.  Override and implement the existing customer search request, because we are changing the existing search behavior so that an external search is performed.\n2.  After the external search is completed, call the standard search request, and merge both results.\n\nHere is the code for these tasks.\n\n    public sealed class CustomerSearchRequestHandler : SingleRequestHandler<CustomersSearchRequest, CustomersSearchResponse>\n    {\n        /// <summary>\n        /// Executes the workflow to retrieve customer information.\n        /// </summary>\n        /// <param name=\"request\">The request.</param>\n        /// <returns>The response.</returns>\n        protected override CustomersSearchResponse Process(CustomersSearchRequest request)\n        {\n            ThrowIf.Null(request, \"request\");\n            ThrowIf.Null(request.Criteria, \"request.Criteria\");\n            // Execute custom customer search logic here.\n            CustomersSearchResponse externalResponse = this.ExternalCustomerSearch(request.Criteria.Keyword);\n            // Execute original customer search logic.\n            var requestHandler = new Microsoft.Dynamics.Commerce.Runtime.Workflow.CustomerSearchRequestHandler();\n            CustomersSearchResponse originalResponse = \n                request.RequestContext.Runtime.Execute<CustomersSearchResponse>(request, request.RequestContext, requestHandler, skipRequestTriggers: false);\n            return new CustomersSearchResponse(externalResponse.Customers.Union(originalResponse.Customers).AsPagedResult());\n        }\n    }\n\nThe full sample code is in the RetailSDK\\\\SampleExtensions\\\\CommerceRuntime\\\\Extensions.CustomerSearchSample folder of the software development kit (SDK).\n\n### Best practice\n\nIf you're planning to completely change the behavior of an existing request or response, or if you want to use your logic in addition to the standard logic, override the standard message handler.\n\n## Request handler triggers and extension properties sample\n**Scenario:** Fabrikam wants to collect customer email preferences for email marketing. Here are the business requirements:\n\n-   Enable a customer’s email preferences to be collected and updated from the POS.\n-   A customer's email preferences should become effective immediately.\n\nHere are some situations where you might use extension properties:\n\n-   You want to extend entities such as the customer and sales order, but you don't want to create a new separate entity.\n-   As new entity fields are read from or written to the database, they should be sent between the commerce runtime (CRT) and the POS, and updated in the client.\n-   You want temporary internal flags that can be used to control the flow of custom logic.\n-   You want to set custom receipt fields that the receipt customization will access when receipts are generated.\n\nThe following steps show the CRT code changes. For MPOS and the channel database, see the full sample. Notice that the following samples differ from previous code, where changes to the standard database artifacts were required. (For example, to expose new columns as extension properties, changes to the view were required. To receive a list of extension properties and update these properties together with standard fields, changes to the stored procedure were required.) Eventually, as we move to a model that doesn't have inline changes, merge conflicts should not occur even when the database is updated. Therefore, our new recommendation is that you make separate database calls to read, write, and update entities.\n\n1.  **Read the entity.** Implement the post-trigger for **GetCustomerDataRequest**, read the value from channel database, and add the value to the extension property.\n\n        public class GetCustomerTriggers : IRequestTrigger\n        {\n            public IEnumerable<Type> SupportedRequestTypes\n            {\n                get { return new[] { typeof(GetCustomerDataRequest) }; }\n            }\n            public void OnExecuted(Request request, Response response)\n            {\n                // Check if default handler found a customer.\n                var customer = ((SingleEntityDataServiceResponse<Customer>)response).Entity;\n                if (customer == null)\n                {\n                    return;\n                }\n                // Read from a custom view mapped to a custom table.\n                var query = new SqlPagedQuery(QueryResultSettings.SingleRecord)\n                {\n                    Select = new ColumnSet(new string[] { \"EMAILOPTIN\" }),\n                    From = \"CUSTOMEREXTENSIONVIEW\",\n                    Where = \"ACCOUNTNUM = @accountNum AND DATAAREAID = @dataAreaId\"\n                };\n                query.Parameters[\"@accountNum\"] = customer.AccountNumber;\n                query.Parameters[\"@dataAreaId\"] = request.RequestContext.GetChannelConfiguration().InventLocationDataAreaId;\n                using (var databaseContext = new SqlServerDatabaseContext(request))\n                {\n                    // Use ExtensionEntity which will map all columns to extension properties.\n                    ExtensionsEntity extensions = databaseContext.ReadEntity<ExtensionsEntity>(query).FirstOrDefault();\n                    var emailOptIn = extensions != null ? extensions.GetProperty(\"EMAILOPTIN\") : null;\n                    // If the EmailOptIn is found, set it at a new extension property at the Customer.\n                    if (emailOptIn != null)\n                    {\n                        customer.SetProperty(\"EMAILOPTIN\", emailOptIn);\n                    }\n                }\n            }\n        }\n\n2.  **Write the entity.** Override the handler for **CreateOrUpdateCustomerDataRequest** to run the original request handler and the custom stored procedure inside a transaction scope. If the database transaction isn't required, a post-trigger suffices here.\n\n        protected override SingleEntityDataServiceResponse<Customer> Process(CreateOrUpdateCustomerDataRequest request)\n        {\n            using (var databaseContext = new SqlServerDatabaseContext(request))\n            using (var transactionScope = new TransactionScope())\n            {\n                // Execute original functionality to save the customer.\n                var requestHandler = new Microsoft.Dynamics.Commerce.Runtime.DataServices.SqlServer.CustomerSqlServerDataService();\n                var response = (SingleEntityDataServiceResponse<Customer>)requestHandler.Execute(request);\n                // Execute additional functionality to save the customer's extension properties.\n                if (!request.Customer.ExtensionProperties.IsNullOrEmpty())\n                {\n                    // The stored procedure will determine which extension properties are saved to which tables.\n                    ParameterSet parameters = new ParameterSet();\n                    parameters[\"@TVP_EXTENSIONPROPERTIESTABLETYPE\"] = new ExtensionPropertiesTableType(request.Customer.RecordId, request.Customer.ExtensionProperties).DataTable;\n                    databaseContext.ExecuteStoredProcedureNonQuery(\"UPDATECUSTOMEREXTENSIONPROPERTIES\", parameters);\n                }\n                transactionScope.Complete();\n                return response;\n            }\n        }\n\nBefore you try this sample, be sure to create the custom tables, views, and stored procedures in the channel database. Additionally, make the relevant changes to MPOS. The full sample code, together with additional comments, is in the RetailSDK\\\\SampleExtensions\\\\CommerceRuntime\\\\Extensions.EmailPreferenceSample folder of the SDK. For information about how to create custom database artifacts, see the RetailSDK\\\\Documents\\\\SampleExtensionsInstructions\\\\EmailPreference folder of the SDK.\n\n### Best practice\n\nBecause the order of triggers isn't guaranteed when the triggers are chained, and because of the internal cache mechanism, the pre-triggers should not change the *request* message, and the post-triggers should not change the *response* message. Extension properties are allowed, because no core properties are being changed. You should use pre-triggers and post-triggers to handle extension properties. You should also use pre-triggers to do validation and post-triggers to do additional actions.\n\n## Custom fields and custom receipt types sample\n**Scenario:** Fabrikam wants to print a special receipt whenever products that have a warranty are sold. Sales receipts should include the warranty expiration date, the warranty ID, and other information. Here are the business requirements:\n\n-   Print special receipts.\n-   Print additional warranty information on sale receipts.\n\nThe following steps show the CRT code changes:\n\n1.  At the headquarters (HQ), create two custom receipt fields: **EXPIRATIONDATE** for the warranty expiration date and **WARRANTYID** for the warranty ID. Add these fields to the receipt format layout.\n2.  To add the custom fields to the sales receipts or any receipt format, implement **GetSalesTransactionCustomReceiptFieldServiceRequest**, as shown in the following code. This code is called every time that the standard code doesn’t recognize the receipt field.\n\n        public IEnumerable<Type> SupportedRequestTypes\n        {\n            get\n            {\n                return new[] { typeof(GetSalesTransactionCustomReceiptFieldServiceRequest) };\n            }\n        }\n        public Response Execute(Request request)\n        {\n            Type requestedType = request.GetType();\n            if (requestedType == typeof(GetSalesTransactionCustomReceiptFieldServiceRequest))\n            {\n                return this.GetCustomReceiptFieldForSalesTransactionReceipts( (GetSalesTransactionCustomReceiptFieldServiceRequest)request);\n            }\n            throw new NotSupportedException(string.Format(\"Request '{0}' is not supported.\", request.GetType()));\n        }\n\n3.  Add the logic for your sample fields.\n\n        private GetCustomReceiptFieldServiceResponse GetCustomReceiptFieldForSalesTransactionReceipts( GetSalesTransactionCustomReceiptFieldServiceRequest request)\n        {\n            string receiptFieldName = request.CustomReceiptField;\n            string returnValue = string.Empty;\n            switch (receiptFieldName)\n            {\n                case \"WARRANTYID\":\n                    {\n                        // Write your logic\n                    }\n                    break;\n                case \"EXPIRATIONDATE\":\n                    {\n                        // Write your logic\n                    }\n                    break;\n            }\n            return new GetCustomReceiptFieldServiceResponse(returnValue);\n        }\n\n4.  To create new receipt type, implement **GetCustomReceiptsRequest**.\n\n        protected override GetReceiptResponse Process(GetCustomReceiptsRequest request)\n        {\n            Collection<Receipt> result = new Collection<Receipt>();\n                // 2. Now we can handle any additional receipt here.\n            switch (request.ReceiptRetrievalCriteria.ReceiptType)\n            {\n                // An example of getting custom receipts.\n                case ReceiptType.CustomReceipt1:\n                    {\n                        IEnumerable<Receipt> customReceipts = this.GetCustomReceipts(salesOrder, request.ReceiptRetrievalCriteria);\n                        result.AddRange(customReceipts);\n                    }\n                    break;\n                default:\n                    // Add more logic to handle more types of custom receipt types.\n                    break;\n            }\n            return new GetReceiptResponse(new ReadOnlyCollection<Receipt>(result));\n        }\n\nThe full sample code is in the RetailSDK\\\\SampleExtensions\\\\CommerceRuntime\\\\Extensions.ReceiptsSamplefolder folder of the SDK. **Note:** You should call the printing of the custom receipt type from the client. For more information, see [Extensibility patterns and best practices](https://youtu.be/qQkHFubENIY)[.]()\n\n### Best practice\n\nAvoid making database calls for each custom receipt field. Instead, use extension properties that were previously set on entities. Custom receipt types can be called by any logic (per sales line, one time per some condition). See the sample for a more complete scenario.\n\n\n\n","nodes":[{"pos":[32,50],"content":"Retail SDK samples","needQuote":true,"needEscape":true,"nodes":[{"content":"Retail SDK samples","pos":[0,18]}]},{"pos":[64,168],"content":"This topic describes three new samples that were released together with the Retail SDK in December 2016.","needQuote":true,"needEscape":true,"nodes":[{"content":"This topic describes three new samples that were released together with the Retail SDK in December 2016.","pos":[0,104]}]},{"pos":[674,692],"content":"Retail SDK samples","linkify":"Retail SDK samples","nodes":[{"content":"Retail SDK samples","pos":[0,18]}]},{"content":"This topic describes three new samples that were released together with the Retail SDK in December 2016.","pos":[741,845]},{"pos":[847,878],"content":"Override message handler sample","linkify":"Override message handler sample","nodes":[{"content":"Override message handler sample","pos":[0,31]}]},{"content":"<bpt id=\"p1\">**</bpt>Scenario:<ept id=\"p1\">**</ept> Sometimes, one of Fabrikam's customers is in the customer relationship management (CRM) system but isn't imported into Microsoft Dynamics 365 for Operations.","pos":[912,1083],"source":"**Scenario:** Sometimes, one of Fabrikam's customers is in the customer relationship management (CRM) system but isn't imported into Microsoft Dynamics 365 for Operations."},{"content":"Therefore, Fabrikam wants to look up the customer from the CRM system and the point of sale (POS).","pos":[1084,1182]},{"content":"Here are the business requirements:","pos":[1183,1218]},{"content":"Search for customers from the CRM system and the POS.","pos":[1224,1277]},{"content":"Merge the results, and show a unified result set in Retail Modern POS (MPOS).","pos":[1282,1359]},{"content":"Here are some situations where you might use the override message handler:","pos":[1361,1435]},{"content":"You want to use a third-party inventory system for stock updates and inquiries.","pos":[1441,1520]},{"content":"You want to integrate with an external tax system for tax calculation.","pos":[1525,1595]},{"content":"You want to integrate with a third-party loyalty system.","pos":[1600,1656]},{"content":"Here are the basic tasks in the sample:","pos":[1658,1697]},{"content":"Override and implement the existing customer search request, because we are changing the existing search behavior so that an external search is performed.","pos":[1703,1857]},{"content":"After the external search is completed, call the standard search request, and merge both results.","pos":[1862,1959]},{"content":"Here is the code for these tasks.","pos":[1961,1994]},{"content":"The full sample code is in the RetailSDK<ph id=\"ph1\">\\\\</ph>SampleExtensions<ph id=\"ph2\">\\\\</ph>CommerceRuntime<ph id=\"ph3\">\\\\</ph>Extensions.CustomerSearchSample folder of the software development kit (SDK).","pos":[3245,3399],"source":"The full sample code is in the RetailSDK\\\\SampleExtensions\\\\CommerceRuntime\\\\Extensions.CustomerSearchSample folder of the software development kit (SDK)."},{"pos":[3405,3418],"content":"Best practice","linkify":"Best practice","nodes":[{"content":"Best practice","pos":[0,13]}]},{"content":"If you're planning to completely change the behavior of an existing request or response, or if you want to use your logic in addition to the standard logic, override the standard message handler.","pos":[3420,3615]},{"pos":[3620,3676],"content":"Request handler triggers and extension properties sample","linkify":"Request handler triggers and extension properties sample","nodes":[{"content":"Request handler triggers and extension properties sample","pos":[0,56]}]},{"content":"<bpt id=\"p1\">**</bpt>Scenario:<ept id=\"p1\">**</ept> Fabrikam wants to collect customer email preferences for email marketing.","pos":[3677,3764],"source":"**Scenario:** Fabrikam wants to collect customer email preferences for email marketing."},{"content":"Here are the business requirements:","pos":[3765,3800]},{"content":"Enable a customer’s email preferences to be collected and updated from the POS.","pos":[3806,3885]},{"content":"A customer's email preferences should become effective immediately.","pos":[3890,3957]},{"content":"Here are some situations where you might use extension properties:","pos":[3959,4025]},{"content":"You want to extend entities such as the customer and sales order, but you don't want to create a new separate entity.","pos":[4031,4148]},{"content":"As new entity fields are read from or written to the database, they should be sent between the commerce runtime (CRT) and the POS, and updated in the client.","pos":[4153,4310]},{"content":"You want temporary internal flags that can be used to control the flow of custom logic.","pos":[4315,4402]},{"content":"You want to set custom receipt fields that the receipt customization will access when receipts are generated.","pos":[4407,4516]},{"content":"The following steps show the CRT code changes.","pos":[4518,4564]},{"content":"For MPOS and the channel database, see the full sample.","pos":[4565,4620]},{"content":"Notice that the following samples differ from previous code, where changes to the standard database artifacts were required.","pos":[4621,4745]},{"content":"(For example, to expose new columns as extension properties, changes to the view were required.","pos":[4746,4841]},{"content":"To receive a list of extension properties and update these properties together with standard fields, changes to the stored procedure were required.) Eventually, as we move to a model that doesn't have inline changes, merge conflicts should not occur even when the database is updated.","pos":[4842,5126]},{"content":"Therefore, our new recommendation is that you make separate database calls to read, write, and update entities.","pos":[5127,5238]},{"content":"<bpt id=\"p1\">**</bpt>Read the entity.<ept id=\"p1\">**</ept>","pos":[5244,5264],"source":"**Read the entity.**"},{"content":"Implement the post-trigger for <bpt id=\"p1\">**</bpt>GetCustomerDataRequest<ept id=\"p1\">**</ept>, read the value from channel database, and add the value to the extension property.","pos":[5265,5406],"source":" Implement the post-trigger for **GetCustomerDataRequest**, read the value from channel database, and add the value to the extension property."},{"content":"<bpt id=\"p1\">**</bpt>Write the entity.<ept id=\"p1\">**</ept>","pos":[7305,7326],"source":"**Write the entity.**"},{"content":"Override the handler for <bpt id=\"p1\">**</bpt>CreateOrUpdateCustomerDataRequest<ept id=\"p1\">**</ept> to run the original request handler and the custom stored procedure inside a transaction scope.","pos":[7327,7485],"source":" Override the handler for **CreateOrUpdateCustomerDataRequest** to run the original request handler and the custom stored procedure inside a transaction scope."},{"content":"If the database transaction isn't required, a post-trigger suffices here.","pos":[7486,7559]},{"content":"Before you try this sample, be sure to create the custom tables, views, and stored procedures in the channel database.","pos":[8948,9066]},{"content":"Additionally, make the relevant changes to MPOS.","pos":[9067,9115]},{"content":"The full sample code, together with additional comments, is in the RetailSDK<ph id=\"ph1\">\\\\</ph>SampleExtensions<ph id=\"ph2\">\\\\</ph>CommerceRuntime<ph id=\"ph3\">\\\\</ph>Extensions.EmailPreferenceSample folder of the SDK.","pos":[9116,9280],"source":" The full sample code, together with additional comments, is in the RetailSDK\\\\SampleExtensions\\\\CommerceRuntime\\\\Extensions.EmailPreferenceSample folder of the SDK."},{"content":"For information about how to create custom database artifacts, see the RetailSDK<ph id=\"ph1\">\\\\</ph>Documents<ph id=\"ph2\">\\\\</ph>SampleExtensionsInstructions<ph id=\"ph3\">\\\\</ph>EmailPreference folder of the SDK.","pos":[9281,9438],"source":" For information about how to create custom database artifacts, see the RetailSDK\\\\Documents\\\\SampleExtensionsInstructions\\\\EmailPreference folder of the SDK."},{"pos":[9444,9457],"content":"Best practice","linkify":"Best practice","nodes":[{"content":"Best practice","pos":[0,13]}]},{"content":"Because the order of triggers isn't guaranteed when the triggers are chained, and because of the internal cache mechanism, the pre-triggers should not change the <bpt id=\"p1\">*</bpt>request<ept id=\"p1\">*</ept> message, and the post-triggers should not change the <bpt id=\"p2\">*</bpt>response<ept id=\"p2\">*</ept> message.","pos":[9459,9703],"source":"Because the order of triggers isn't guaranteed when the triggers are chained, and because of the internal cache mechanism, the pre-triggers should not change the *request* message, and the post-triggers should not change the *response* message."},{"content":"Extension properties are allowed, because no core properties are being changed.","pos":[9704,9783]},{"content":"You should use pre-triggers and post-triggers to handle extension properties.","pos":[9784,9861]},{"content":"You should also use pre-triggers to do validation and post-triggers to do additional actions.","pos":[9862,9955]},{"pos":[9960,10005],"content":"Custom fields and custom receipt types sample","linkify":"Custom fields and custom receipt types sample","nodes":[{"content":"Custom fields and custom receipt types sample","pos":[0,45]}]},{"content":"<bpt id=\"p1\">**</bpt>Scenario:<ept id=\"p1\">**</ept> Fabrikam wants to print a special receipt whenever products that have a warranty are sold.","pos":[10006,10110],"source":"**Scenario:** Fabrikam wants to print a special receipt whenever products that have a warranty are sold."},{"content":"Sales receipts should include the warranty expiration date, the warranty ID, and other information.","pos":[10111,10210]},{"content":"Here are the business requirements:","pos":[10211,10246]},{"content":"Print special receipts.","pos":[10252,10275]},{"content":"Print additional warranty information on sale receipts.","pos":[10280,10335]},{"content":"The following steps show the CRT code changes:","pos":[10337,10383]},{"content":"At the headquarters (HQ), create two custom receipt fields: <bpt id=\"p1\">**</bpt>EXPIRATIONDATE<ept id=\"p1\">**</ept> for the warranty expiration date and <bpt id=\"p2\">**</bpt>WARRANTYID<ept id=\"p2\">**</ept> for the warranty ID.","pos":[10389,10540],"source":"At the headquarters (HQ), create two custom receipt fields: **EXPIRATIONDATE** for the warranty expiration date and **WARRANTYID** for the warranty ID."},{"content":"Add these fields to the receipt format layout.","pos":[10541,10587]},{"content":"To add the custom fields to the sales receipts or any receipt format, implement <bpt id=\"p1\">**</bpt>GetSalesTransactionCustomReceiptFieldServiceRequest<ept id=\"p1\">**</ept>, as shown in the following code.","pos":[10592,10760],"source":"To add the custom fields to the sales receipts or any receipt format, implement **GetSalesTransactionCustomReceiptFieldServiceRequest**, as shown in the following code."},{"content":"This code is called every time that the standard code doesn’t recognize the receipt field.","pos":[10761,10851]},{"content":"Add the logic for your sample fields.","pos":[11569,11606]},{"pos":[12354,12421],"content":"To create new receipt type, implement <bpt id=\"p1\">**</bpt>GetCustomReceiptsRequest<ept id=\"p1\">**</ept>.","source":"To create new receipt type, implement **GetCustomReceiptsRequest**."},{"content":"The full sample code is in the RetailSDK<ph id=\"ph1\">\\\\</ph>SampleExtensions<ph id=\"ph2\">\\\\</ph>CommerceRuntime<ph id=\"ph3\">\\\\</ph>Extensions.ReceiptsSamplefolder folder of the SDK.","pos":[13350,13477],"source":"The full sample code is in the RetailSDK\\\\SampleExtensions\\\\CommerceRuntime\\\\Extensions.ReceiptsSamplefolder folder of the SDK."},{"content":"<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> You should call the printing of the custom receipt type from the client.","pos":[13478,13560],"source":"**Note:** You should call the printing of the custom receipt type from the client."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Extensibility patterns and best practices<ept id=\"p1\">](https://youtu.be/qQkHFubENIY)</ept><bpt id=\"p2\">[</bpt>.<ept id=\"p2\">]()</ept>","pos":[13561,13665],"source":" For more information, see [Extensibility patterns and best practices](https://youtu.be/qQkHFubENIY)[.]()"},{"pos":[13671,13684],"content":"Best practice","linkify":"Best practice","nodes":[{"content":"Best practice","pos":[0,13]}]},{"content":"Avoid making database calls for each custom receipt field.","pos":[13686,13744]},{"content":"Instead, use extension properties that were previously set on entities.","pos":[13745,13816]},{"content":"Custom receipt types can be called by any logic (per sales line, one time per some condition).","pos":[13817,13911]},{"content":"See the sample for a more complete scenario.","pos":[13912,13956]}]}