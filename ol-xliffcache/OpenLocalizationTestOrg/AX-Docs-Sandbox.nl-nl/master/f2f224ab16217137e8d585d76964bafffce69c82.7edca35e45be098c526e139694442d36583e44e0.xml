{"content":"---\n# required metadata\n\ntitle: X++ variables and data types\ndescription: This topic describes variables and data types in X++.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \n# ms.reviewer: 61\nms.search.scope: AX 7.0.0, Operations\n# ms.tgt_pltfrm: \nms.custom: 150183\nms.assetid: 0ff4e759-851d-4b53-aa67-6f03eee53f02\nms.search.region: Global\n# ms.search.industry: \nms.author: robinr\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# X++ variables and data types\n\n[!include[banner](../includes/banner.md)]\n\n\nThis topic describes variables and data types in X++.\n\nVariables\n---------\n\nA *variable* is an identifier that points to a memory location where information of a specific data type is stored. The size, precision, default value, implicit and explicit [conversion](xpp-conversion-run-time-functions.md) functions, and range depend on the variable's data type. The *scope* of a variable defines the area in the code where an item can be accessed. *Instance variables* are declared in class declarations, and can be accessed from any methods in the class or from methods that extend the class. *Local variables* can be accessed only in the block where they were defined. When a variable is declared, memory is allocated, and the variable is initialized to the default value. You can assign values to both static fields and instance fields as part of the declaration statement. Variables can be declared anywhere in a code block in a method. They don't have to be declared at the beginning of a method. *Constants* are variables where the value can't be changed when the variable is declared. They use the **const** or **readonly** keyword. Constants differ from *read-only fields* in only one way. Read-only fields can be assigned a value only one time, and that value never changes. The field can be assigned its value either inline, at the place where the field is declared, or in the constructor. When you declare variables of managed types that aren't authored in X++, you have two options. You can fully qualify the type names in the declaration by including the full namespace, or you can add a **using** statement to your file and then omit the namespace from the type name.\n\n### Variable examples\n\n    // An example of two valid variable names.\n    str variableName;\n    CustInfo custNumber;\n            \n    // An example of simultaneously declaring and initializing a variable.\n    real pi = 3.14159265359; // Assigns value of pi to 12 significant digits.\n            \n    // An example of initializing an object by using the new method on the class.\n    Access accessObject = new Access(); // Simple call to the new method in the Access class.\n            \n    // An example of multiple declarations using integers.\n    int i,j; // Declares 2 integers, i and j.\n            \n    // An example of multiple declarations using an array.\n    int a[100,5], b=1; // Declares array with 100 integers with 5 in memory and b as an integer with value 1.\n     \n    // An example of how variable scopes work.\n    class ScopeExample\n    {\n        // The variable a is declared within the class.\n        int a;\n        \n        // Because the method below is declared within the class,\n        // it can access all the variables defined within the class.\n        void aNewMethod()\n        {\n            // The variable b is declared within the method.\n            // It can only be accessed by this method.\n            int b;\n        }\n    }\n     \n    // An example of an assignment of field members inline.\n    public class FieldAssignmentExample\n    {\n        int field1 = 1;\n        str field2 = \"Banana\";\n        void new()\n        {\n            // ...\n        }\n    }\n     \n    class ConstantExample\n    {\n        // An example of a constant being declared at the class level.\n        public const str MyContent = 'SomeValue';\n        public int ResultSoFar()\n        {\n            return 1;\n        }\n    }\n\n    // The constants can then be referenced by using the double-colon syntax.\n    str value = ConstantExample::MyContent;\n    // If you're in the scope of the class where the const is defined, \n    // you can omit the type name prefix (ConstantExample in this example).\n     \n    // An example of the using clause where the alias can denote\n    // namespaces and classes.\n    using System;\n    using IONS=System.IO; // Namespace alias.\n    using Alist=System.Collections.ArrayList; // Class alias.\n    public class NamespaceExample\n    {\n        public static void Main(Args a)\n        {\n            Int32 I; // Alternative to System.Int32.\n            Alist al; // Using a class alias.\n            al = new Alist();\n            str s;\n            al.Add(1);\n            s.IONS.Path::ChangeExtension(@\"c:\\tmp\\test.xml\", \".txt\");\n        }\n    }\n\n### var\n\nYou can declare a variable without explicitly providing the type of the variable, if the compiler can determine the type from the initialization expression. The variable is still strongly-typed into one, unambiguous type. You can use **var** only on declarations where initialization expressions are provided. (The compiler will infer the type from the initialization expression.) In some cases, this approach can make code easier to read. You should use **var** to declare local variables in these situations:\n\n-   When the type of the variable is obvious from the right side of the assignment\n-   When the exact type isn't important\n-   For the declarations of **for** loop counters\n-   For disposable objects inside **using** statements\n\nDon't use **var** when the type isn't clear from the initialization expression.\n\n### var examples\n\n    // When the type of a variable is clear from\n    // the context, use var in the declaration.\n    var var1 = \"This is clearly a string.\";\n    var var2 = 27; // This is an integer (not a real).\n    var i = System.Convert::ToInt32(3.4);\n            \n    // Don't use var when the type of the variable is not clear\n    // from the context. Use an explicit type instead.\n    int var4 = myObject.ResultSoFar();\n\n### Declare anywhere\n\nDeclarations can now be provided wherever statements can be provided. A declaration is syntactically a statement, a *declaration statement*. You can provide declarations immediately before the variable is used, and you don’t have to declare all the variables in one place. Therefore, you have precise control over the scope of your variables. You can give variables smaller scopes, outside which the variables can’t be referenced. The lifetime of the variable is the scope that it’s declared in. Scopes can be started at the block level (inside compound statements), in **for** statements, and in **using** statements. There are several advantages to making scopes small:\n\n-   Readability is enhanced.\n-   You reduce the risk that a variable will be reused in an inappropriate manner during long-term maintenance of the code.\n-   It's easier to refactor code. You can copy in code without having to worry that variables might be reused in contexts where they shouldn’t be reused.\n\nIn the following example, we declare the loop counter inside the **for** statement that it's used in.\n\n    void MyMethod()\n    {\n        for (int i = 0; i < 10; i++)\n        {\n            info(strfmt(\"i is %1\", i));\n        }\n    }\n\nThe scope of the variable is the **for** statement itself, and includes the condition expression and the loop update parts. The value can’t be used outside this scope. In the following example, when the compiler reaches the **info** statement, it will issue the following error message: \"'i' isn't declared.\"\n\n    void MyMethod()\n    {\n        for (int i = 0; i < 10; i++)\n        {\n            if (i == 7)\n            {\n                break;\n            }\n        }\n        // The next statement causes a compiler error.\n        info(strfmt(\"Found: %1\", i));\n    }\n\nYou can also scope variables to a **using** statement, as shown in the following example.\n\n    static void AnotherMethod()\n    {\n        str textFromFile;\n        using (System.IO.StreamReader sr = new System.IO.StreamReader(\"c:\\\\test.txt\"))\n        {\n            textFromFile = sr.ReadToEnd();\n        }\n    }\n\nWhen you use an object that implements **IDisposable**, you should declare and instantiate that object in a **using** statement. The **using** statement calls the **Dispose** method on the object correctly, even if an exception occurs while you're calling methods on the object. You can achieve the same result by putting the object inside a **try** block and then explicitly calling **Dispose** in a **finally** block. In fact, the compiler translates the **using** statement in just this manner. The following example shows some of the features that we have been describing.\n\n    // loop variable declared within the loop: It will\n    // not be misused outside the loop\n    for(int i = 1; i < 10; i++)\n    {\n        // Because this value is not used from outside the loop,\n        // its declaration belongs in this smaller scope.\n        str s = int2str(i);\n        info(s);\n    }\n\nTo prevent confusion, the compiler issues an error message if you try to introduce a variable that will hide another variable in an enclosing scope, or even in the same scope. For example, the following code will cause the compiler to issue the following diagnostic message: \"A local variable named 'i' can't be declared in this scope because it would give a different meaning to 'i', which is already used in a parent or current scope to denote something else.\"\n\n    {\n        int i;\n        {\n            int i;\n        }\n    }\n\n### Constants, read-only variables, and macros\n\nThe concept of macros is fully supported. However, constants have the following advantages over macros:\n\n-   You can add a documentation comment to a constant but not to the value of a macro. Eventually, the language service will pick up this comment and provide useful information to the user.\n-   A constant is known by IntelliSense.\n-   A constant is cross-referenced. Therefore, you can find all references for a specific constant but not for a macro.\n-   A constant is subject to access modifiers. You can use the **private**, **protected**, and **public** modifiers. The accessibility of macros isn't rigorously defined.\n-   Constant variables have scope, whereas macros don't have scope.\n-   You can see the value of a constant or a read-only variable in the debugger.\n\nMacros that are defined in class scopes (that is, in class declarations) are effectively available in all methods of all derived classes. This feature was originally a bug in the implementation of the legacy compiler macro. However, many application programmers often take advantage of it now. The X++ compiler still honors this feature, but no new code that uses it should be written. This feature also has a significant effect on the performance of the compiler. Constants can be declared at the class level, as shown in the following example.\n\n    private const str MyConstant = 'SomeValue';\n\nThe constants can then be referenced by using the double colon (::) syntax.\n\n    str value = MyClass::MyConstant;\n\nIf you're in the scope of the class where the constant (**const**) is defined, you can omit the type name prefix (**MyClass** in the preceding example). Therefore, you can easily implement the concept of a macro library. The list of macro symbols becomes a class that has public **const** definitions. You can also define constants as variables only. The compiler will maintain the invariant so that the value can't be modified.\n\n    {\n        const int Blue = 0x0000FF;\n        const int Green = 0x00FF00;\n        const int Red = 0xFF0000;\n    }\n\n## Primitive data types\nThe primitive data types in X++ are **anytype**, **boolean**, **date**, **enum**, **guid**, **int**, **int64**, **real**, **str**, **timeOfDay**, and **utcdatetime**.\n\n### anytype\n\nThe **anytype** data type is a placeholder for any data type. You should use variables of this type only as arguments and return values. To use **anytype** as a variable, you must first assign a value to it. Otherwise, a run-time error occurs. After you've assigned a value to **anytype**, you can't convert it to another data type. Although you can use **anytype** variables in expressions, they're usually used as arguments and return types. The size, precision, scope, default value, and range of **anytype** depend on the conversion type that you assign to it. You can use **anytype** just as you use the data type that you convert it to. For example, if you assign an integer, you can then apply relational and arithmetic operators to the variable. An **anytype** variable is automatically converted to a date, enumeration (enum), integer, real, string, extended data type (EDT) (record), class, or container when a value is assigned to the type. Additionally, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **any2date**, **any2enum**, **any2int**, **any2real**, and **any2str**. You can't change the variable to another data type after you've converted it to **anytype**.\n\n#### anytype examples\n\n    // An example of using anytype variables.\n    public static str range(anytype _from, anytype _to)\n    {\n        return queryValue(_from) + '..' + queryValue(_to);\n    }\n\n    // Another example of using anytype variables.\n    void put(int position, anytype data)\n    {\n        record = conPoke (record, position, data);\n    }\n\n    public void AnytypeMethod()\n    {\n        // An example of automatic conversion for anytype.\n        anytype a;\n        a = \"text\"; // Automatically assigns a string literal.\n    }\n\n### boolean\n\nThe **boolean** data type contains a value that is evaluated as either **true** or **false**. You can use the reserved literal keywords **true** and **false** wherever a **boolean** expression is expected. The size of a **boolean** is 1 byte. The default value is **false**, and the internal representation is a short number. A **boolean** is automatically converted to an **int**, **date**, or **real**. It has no explicit conversion functions. The internal representation of a **boolean** is an integer. You can assign any integer value to a variable that is declared as the **boolean** type. The integer value **0** (zero) is evaluated as **false**, and all other integer values are evaluated as **true**. Because the internal representation of a **boolean** is an integer, **boolean** values are automatically converted to integers and reals.\n\n#### boolean examples\n\n    public void BooleanMethod()\n    {\n        // Simple declaration of a boolean variable, b.\n        boolean b;\n            \n        // Multiple declarations of booleans.\n        boolean b1, b2;\n          \n        // Boolean variable is initialized to true.\n        boolean b3 = true;\n            \n        // Declares a dynamic array of booleans.\n        boolean b4[];\n            \n        // This example shows the most common usage of a boolean: a boolean in\n        // a conditional statement and as a result of a logical expression.\n        void main()\n        {\n            // Declares a boolean called exprValue.\n            boolean exprValue;\n                \n            // Assigns ExprValue the value of (7*6 == 42), which equates to true.\n            exprValue = (7*6 == 42);\n                \n            // If the conditional statement is true, print \"OK\".\n            if (exprValue)\n            {\n                print \"OK\";  //\"OK\" is printed because the expression is true.\n            }\n        }\n    }\n\n### date\n\nThe **date** data type contains the day, month, and year. Dates can be written as literals by using the following syntax: **Date literal = day \\\\ month \\\\ year**. You must use four digits for the year. The **date** data type can hold dates between January 1, 1900, and December 31, 2154. The size of a **date** is 32 bits. The default value is **null**, and the internal representation is a date. A **date** has no implicit conversions. However, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can used: **str2date**, **date2str**, **date2num**, and **int2date**. You can add and subtract integers from dates, but you can't add or subtract two dates from each other. If you try, a compiler error occurs.\n\n#### date examples\n\n    public void DateMethod()\n    {\n        // Simple declaration of a date variable, d.\n       date d;\n            \n        // Multiple declaration of two date variables.\n        date d1, d2;\n            \n        // A date variable, d3, is initialized to the 21st of November 1998.\n        date d3 = 21\\11\\1998;\n            \n        // Declaration of a dynamic array of dates.\n        date d4[];\n            \n        // Using arithmetic operators with integer variables and dates.\n        void myMethod()\n        {\n            int anInteger;\n            date aDate;\n            // Sets the date variable aDate to January 1, 1998.\n            aDate = 1\\1\\1998;\n            // Sets the integer variable anInteger to 30.\n            anInteger = 30;\n            // Uses an integer value in the computation of dates.\n            // This sets aDate to aDate + 30; that is the 31st of January 1998.\n            aDate = aDate + anInteger;\n                \n            // Create 2 variables, set bDate, and then subtract from that date.\n            date bDate;\n            int dateDifference;\n            bDate = 2\\10\\1998; \n            dateDifference = bDate - aDate;    // dateDifference will equal 9.\n        }\n    }\n\n### enum\n\nAn **enum** is a list of literals. Before you can use an **enum**, you must declare it in Application Explorer. The literal values are represented internally as integers. The first literal has the number 0, the next literal has the number 1, the next literal has the number 2, and so on. You can use **enum** values as integers in expressions. The default value for the first entry is **0**, and the internal representation is a short number. An **enum** value is automatically converted to a **boolean**, **int**, or **real**. Additionally, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **enum2str** and **str2enum**. Hundreds of enumerable types are built into the standard application. For example, the **NoYes** enum has two associated literals: **No** has the value **0**, and **Yes** has the value **1**. You can create as many enum types as you want, and you can declare up to 251 (0 to 250) literals in a single enum type. To reference an **enum** value, enter the name of the enum, two colons, and then the name of the literal. For example, to use the literal **No** in the **NoYes** enum, enter **NoYes::No**.\n\n#### Create an enum\n\n1.  In Solution Explorer, right-click the project, point to **Add**, and then click **New Item**.\n2.  Under **Artifacts**, select **Data Types**.\n3.  Click **Base Enum** to select the new item type.\n4.  In the **Name** field, enter a name for the enum, and then click **Add**. A new enum is added to the project, and the enum designer for the new element is opened.\n5.  In the enum designer, right-click the enum name, and then click **New Element**.\n6.  In the **Properties** window, enter the name of the enum element.\n\n#### enum examples\n\n    public void EnumMethod()\n    {\n        // Declare the enum (a NoYes enum) in the Application Explorer.\n        NoYes done;\n            \n        // An array of Criteria enums.\n        Criteria crit[100];\n    }\n\n### guid\n\nThe **guid** data type holds a *globally unique identifier* (GUID) value. A GUID is an integer that can be used across all computers and networks, wherever a unique identifier is required. It's unlikely that the number will be duplicated. A valid GUID meets all the following specifications:\n\n-   It must have 32 hexadecimal digits.\n-   It must have four dash characters that are embedded at the following locations: 8-4-4-4-12.\n-   Braces ({}) at the beginning and end of a string are optional. For example, both \"12345678-BBBb-cCCCC-0000-123456789012\" and \"{12345678-BBBb-cCCCC-0000-123456789012}\" are valid GUID strings.\n-   It must have a total of either 36 or 38 characters, depending on whether braces are added.\n-   The hexadecimal digits a–f (or A–F) can be uppercase, lowercase, or mixed.\n\nThe size of a **guid** is 16 bytes or 128 bits. The following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **any2guid**, **guid2str**, **newGuid**, **str2guid**, **Global::guidFromString**, and **Global::stringFromGuid**.\n\n#### guid examples\n\nThe following set of examples shows how to use the **guid** functions. The code output of these examples follows.\n\n    // An example of how to use the GUID functions.\n    static void GuidRoundTripJob(Args _args)\n    {\n        guid guid2;\n        str string3;\n            \n        // Convert a guid to a string, and back to a guid.\n        guid2 = newGuid();\n        info(strFmt(\"Info_a1:  guid2 == %1\", guid2));\n        string3 = guid2str(guid2);\n        info(strFmt(\"Info_a2:  string3 == %1\", string3));\n        guid2 = str2guid(string3);\n        info(strFmt(\"Info_a3:  guid2 == %1\", guid2));\n            \n        // Test string representations of a guid. Mixing upper and lower case letters does not affect the guid.\n        guid2 = str2guid(\"BB345678-abcd-ABCD-0000-bbbbffff9012\");\n        string3 = guid2str(guid2);\n        info(strFmt(\"Info_b1:  8-4-4-4-12 format for dashes works (%1)\", string3));\n        info(strFmt(\"Info_b2:  Mixed upper and lower case works.\"));\n            \n        // Test invalid dash locations, see output is all zeros. Dash locations must be exact.\n        guid2 = str2guid(\"CC2345678abcd-ABCD-0000-cccc9012\");\n        string3 = guid2str(guid2);\n        info(strFmt(\"Info_c1:  These embedded dash locations are required.  %1\", string3));\n            \n        // Braces {} are optional.\n        guid2 = str2guid(\"{DD345678-abcd-ABCD-0000-ddddaaaa9012}\");\n        string3 = guid2str(guid2);\n        info(strFmt(\"Info_d1:  Braces {} are optional (%1)\", string3));\n    }\n\n#### guid code output\n\nThe following output appears in the Infolog. Note that the string includes the optional braces.\n\n    Message (02:26:46 pm)\n    Info_a1:  guid2 == {93945629-734B-475E-99CE-6AA7AFA43259}\n    Info_a2:  string3 == {93945629-734B-475E-99CE-6AA7AFA43259}\n    Info_a3:  guid2 == {93945629-734B-475E-99CE-6AA7AFA43259}\n    Info_b1:  8-4-4-4-12 format for dashes works ({BB345678-ABCD-ABCD-0000-BBBBFFFF9012})\n    Info_b2:  Mixed upper and lower case works.\n    Info_c1:  These embedded dash locations are required.  {00000000-0000-0000-0000-000000000000}\n    Info_d1:  Braces {} are optional ({DD345678-ABCD-ABCD-0000-DDDDAAAA9012})\n\n### int and int64\n\n*Integers* are numbers that have no decimal places. There are two integer types: **int** and **int64**. Integers are used as control variables in repetitive statements or as indexes in arrays. You can also use *integer literals* anywhere that an integer expression is expected, and both relational and arithmetic operators can be applied. An integer literal is the integer as it's entered directly in the code, such as **32768**. An **int** is 32 bits wide, and an **int64** is 64 bits wide. The default value is **0**, and the internal representation is a long number. An integer is automatically converted to a **boolean**, **enum**, or **real**. Additionally, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **str2int**, **int2str**, **str2int64**, and **int642str**. The range of an **int** is \\[-2,147,483,647 : 2,147,483,647\\], and the range of an **int64** is \\[-9,223,372,036,854,775,808 : 9,223,372,036,854,775,808\\]. All integers in either of these ranges can be used as literals.\n\n#### int and int64 examples\n\nThe following example shows how to declare integers and use them in expressions. If you try to assign the largest integer plus 1 to an **int64**, you get the wrong result, because the number is interpreted as a 32-bit number. Therefore, the number is wrapped around and stored as -2,147,483,647 instead. To prevent this behavior, add \"u\" to the end of the number. For example, enter **int64 i = 0x8000 0000u** (0x8000 0000 is 2,147,483,648).\n\n    public void IntegerMethod()\n    {\n        // Declaration of an integer variable, i.\n        int i;\n            \n        // Declaration of two int64 variables.\n        int64 i1, i2;\n            \n        // An integer variable is initialized to the value 100.\n        int i3 = 100;\n            \n        // Declaration of a dynamic array of integers.\n        int i4[];\n        void element()\n        {\n            // Two integer variables are declared and initialized.\n            int k = 1, j = 2;\n                \n            // j is assigned the result of j + ((i + i) DIV 2).\n            j +=(i + i) div 2;\n                \n            // This results in: j=3.\n\n            if (j > 2 )\n            {\n                print \"J is greater than 2\";\n            }\n            else\n            {\n                print \"J is NOT greater than 2\";\n            }\n        }\n    }\n\n### real\n\nA **real** variable can hold decimal values in addition to integers. You can use *decimal literals* anywhere that a **real** is expected. A decimal literal is the decimal as it's entered directly in the code, such as **2.123876**. Real literals can also be written by using exponential notation, such as **1.0e3**. Reals can be used in all expressions, and they can be used with both relational and arithmetic operators. A **real** has a precision of 16 significant digits. The default value for a **real** is **0.0**, and the internal representation is a binary-coded digital (BCD) number. The BCD encoding enables exact representations of values that are multiples of 0.1. The range of a **real** variable is -(10)¹²⁷ through (10)¹²⁷. All reals in this range can be used as literals in X++. A **real** variable is automatically converted to a **boolean**, **enum**, or **int**. If the result is an integer, or if the operator is an integer operator, the **real** is converted to an integer. If the result is a **boolean**, the **real** is converted to a **boolean**, and so on. Additionally, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **str2num** and **num2str**. Direct assignments between X++ **real** and Microsoft .NET Framework **System.Decimal** convert the value correctly. A call to a conversion function isn't required. A *decimal number* is a floating-point value that consists of a sign, a numeric value where each digit is in the range 0 through 9, and a scaling factor that indicates the position of a floating decimal point that separates the integral and fractional parts of the numeric value. The binary representation of a **real** value consists of a 1-bit sign, a 96-bit integer number, and a scaling factor. The scaling factor is used to divide the 96-bit integer and specify what part of it is a decimal fraction. The scaling factor is implicitly the number 10 raised to an exponent in the range 0 through 28. Therefore, the binary representation of a decimal value represents (\\[-2⁹⁶ through 2⁹⁶\\] ÷ 10(0\\\\ through\\\\ 28)), where -(2⁹⁶-1) is the minimum value that can be expressed and 2⁹⁶-1 is the maximum value. **Note:** The type that is used to represent **real** values in Microsoft Dynamics 365 for Finance and Operations has changed from the interpreted X++ of Microsoft Dynamics AX 2012. However, you don't have to rewrite any code, because the new type can express all the values that the old type could express. We provide this material in the interest of full disclosure only. All instances of the **real** type are now implemented as instances of the .NET decimal type (**System.Decimal**). Just as the **real** type in previous versions, the decimal type in a binary-coded decimal type is resilient to rounding errors. The range and resolution of the decimal type differ from previous versions. The original X++ **real** type supported 16 digits and an exponent that defined the position of the decimal point. However, the X++ **real** type for Microsoft Dynamics 365 for Finance and Operations and later can represent decimal numbers in the range 79,228,162,514,264,337,593,543,950,335 (2⁹⁶-1) through -79,228,162,514,264,337,593,543,950,335 (-\\[2⁹⁶-1\\]). Rounding is still required for the new **real** type. For example, the following code produces a result of 0.9999999999999999999999999999 instead of 1. No number of decimals will suffice to represent the value of 1/3 accurately. The discrepancy obtained here is due to the fact that only a finite number of decimals are provided. You should use the **round** function to round to the number of decimals required.\n\n    // An example of using the debugger to show the value of the variables.\n    public static void UseTheDebugger(Args a)\n    {\n        real dividend = 1.0;\n        real divisor = 3.0;\n        str stringvalue;\n        System.Decimal valueAsDecimal;\n        real value = dividend/divisor * divisor; \n        valueAsDecimal = value;\n        info(valueAsDecimal.ToString(\"G28\"));\n        // An example of using the Round function to round to the number of decimals required.\n        value  = round(value, 2);\n    }\n\n#### real examples\n\n    public void RealMethod()\n    {\n        // Simple declaration of a real variable, r.\n        real r;\n            \n        // Multiple declaration of two real variables.\n        real r1, r2;\n          \n        // A real variable is initialized to the approximate value of pi.\n        real r3 = 3.1415;\n            \n        // Declaration of a dynamic array of reals.\n        real r4[];\n            \n        // An example of a real literal written using exponential notation.\n        real r;\n        r = 1.000e3;\n        r = 1.2345e+3;\n        r = 1.2345e+03;\n        r = 1234.5e4;\n        r = 1.0e1; // Means 1.0E1 \n    }\n            \n    // An example of automatic conversions.\n    void main()\n    {\n        // Declares a variable of type integer with the name exprValue.\n        int exprValue;\n            \n        // Declares a real variable with the name area.\n        real area = 3.141528;\n        exprValue = Area/3;\n                \n        // The expression Area/3 is a real expression because\n        // division is a real operator, and the result is 1.047176. This result is\n        // automatically converted (actually truncated) to an integer with the value 1,\n        // because exprValue is an integer.\n    }\n            \n    // An example of a real being converted to .NET System.Decimal.\n    void AnotherMain(Args _args)\n    {\n        real real9;\n        System.Decimal sysdec1;\n                \n        // Direct assignments supported between these types.\n        sysdec1 = 2.3456;\n        real9 = sysdec1;\n        info(strFmt(\"strFmt says real9 == %1\", real9));\n    }\n            \n    /***\n    Message (05:48:43 pm)\n    strFmt says real9 == 2.35\n    ***/\n            \n    // An example of using reals in expressions.\n    void myMethod()\n    {\n        // Two real variables are declared and initialized.\n        real i = 2.5, j = 2.5;\n            \n        // j is assigned the result of j * i, so j=6.25.\n        j = j * i;\n        if (j > (i * 2)) // If j > 5 \n        {\n            print \"Great\"; // \"Great\" is printed.\n        }\n        else\n        {\n           print \"Oops\"; // else \"Oops\" is printed.\n        }\n    }\n\n### str\n\nA **str** variable (a *string*) is a sequence of characters that are used as texts, help lines, addresses, telephone numbers, and so on. To declare a string, use the **str** keyword. *String literals* are characters that are enclosed in quotation marks (\"\"). String literals can be used wherever string expressions are expected. Examples of string literals include \"StringLit\" and \"Hello World\". If you want the string to span more than one line, precede it with an at sign (@). You can use strings in logical expressions, such as comparisons. You can also concatenate strings by using the + operator. The default value for a string is **empty**, and the internal representation is a list of characters. There are no automatic conversions for strings. However, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **str2int**, **str2int64**, **int2str**, **str2num**, **num2str**, **str2date**, and **date2str**. A string can hold an unlimited number of characters. However, you can specify the maximum length of a string in the variable declaration. The string is then truncated to that maximum length. An example is shown in the next section.\n\n#### str examples\n\n    void StringMethod()\n    {\n        // Declare a dynamic string of unlimited length.\n        str unlimitedString;\n            \n        // Declare a string with a maximum of 64 characters\n        // in order to force a truncation, initialized to \"A\".\n        str 64 maxLengthString = \"A\";\n            \n        // Declare an array of 100 strings.\n       str 30 hundredStrings[100];\n            \n        // Using strings in expressions.\n        void myMethod()\n        {\n            // Two strings are declared and initialized.\n            str a=\"Hello\", b=\"World\";\n                \n            // The concatenation of a, \" \" and b is printed in a window.\n            print a+\" \"+b;\n        }\n    }\n\n### timeOfDay\n\nThe **timeOfDay** (time) data type is an integer value that represents the number of seconds that have passed since midnight. Like integers, **timeOfDay** variables can be used as literals. Relational and arithmetic operators can be applied to **timeOfDay** variables. A **timeOfDay** variable can also be used in expressions. The range of a **timeOfDay** data type is in the closed interval \\[0; 86,400\\]. Values above 86,400 (23:59:59) can't be interpreted. A **timeOfDay** variable is automatically converted to a **boolean**, **enum**, or **real**. Additionally, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **str2time** and **time2str**.\n\n#### timeOfDay examples\n\n    public void TimeofdayMethod()\n    {\n        // Declaration of a timeOfDay variable, time1.\n        timeOfDay time1;\n            \n        // Declaration and initialization of a timeOfDay variable to 00:21:35.\n        timeOfDay time2 = 1295;\n    }\n\n### utcdatetime\n\nThe **utcdatetime** data type combines the **date** type and the **timeOfDay** type. A **utcdatetime** variable also holds information about the time zone. However, this information can't be accessed in code. The format for a **utcdatetime** literal is **yyyy-mm-ddThh:mm:ss**. The uppercase \"T\" is required. This format can be written without quotation marks. The minimum value is **1900-01-01T00:00:00**, and the maximum value is **1900-01-01T00:00:00**. This maximum value matches the upper range of **date** and **timeOfDay**. The smallest unit of time in **utcdatetime** is one second. A **utcdatetime** variable that has been declared but hasn't been initialized has the default value **1900-01-01T00:00:00**. This value is the value that is returned by **DateTimeUtil::minValue()**. Some functions treat an input parameter of this minimum value as **null**. For example, the **DateTimeUtil::toStr** method returns an empty string. However, the **DateTimeUtil::addSeconds** method returns a usable **utcdatetime** value. There are no implicit conversions for the **utcdatetime** data type. The **DateTimeUtil** class provides many methods that you can use to manipulate **utcdatetime** values. The following explicit [conversion functions](xpp-conversion-run-time-functions.md) can also be used: **str2datetime** and **datetime2str**. Additionally, the **Global** class provides the **utcDateTime2SystemDateTime** and **CLRSystemDateTime2UtcDateTime** conversion methods to support common language runtime (CLR) interop. Comparison operators are the only type of operators that can be used with the **utcdatetime** data type. The following operators can be used to compare two **utcdatetime** values: !=, &lt;, &lt;=, ==, &gt;, and &gt;=. When you add a **utcdatetime** field to a table, we recommend that you base the field on an EDT.\n\n#### utcdatetime examples\n\n    public void UtcdatetimeMethod()\n    {\n        // Declaring a utcdatetime literal.\n        utcdatetime myUtc2 = 1988-07-20T13:34:45;\n            \n        // Another example of declaring a utcdatetime literal.\n        int iDay = DateTimeUtil::day(1988-07-20T13:34:45);\n            \n        // utcdatetime using a quoted string parameter into the DateTimeUtil::parse method.\n        utcdatetime myUtc4 = DateTimeUtil::parse(\"1988-07-20T13:34:45\");\n    }\n\n## Composite data types\nThe composite data types in X++ are arrays, containers, classes as data types, delegates as data types, and tables as data types.\n\n### Array\n\nAn *array* is a variable that contains a list of items that have the same data type. The elements of an array are accessed by using integer indexes. You use a separate statement to initialize each element in an array. When you use a container data type or an array object to create a collection, you can initialize multiple elements by using a single statement. By default, all the items in an array have the default value of the data type in the array. There are three kinds of arrays: *dynamic arrays*, *fixed-length arrays*, and *partly on disk arrays*.\n\n-   **Dynamic arrays** – These arrays are declared by using an empty array option. In other word, they have only brackets (\\[\\]).\n-   **Fixed-length arrays** – These arrays can hold the number of items that is specified in the declaration. Fixed-length arrays are declared like dynamic arrays, but a length option is included in the brackets.\n-   **Partly on disk arrays** – These arrays are declared as either dynamic arrays or fixed-length arrays that have an extra option that declares how many items should be held in memory. The other items are stored on disk and are automatically loaded when they are referenced.\n\nX++ supports only one-dimensional arrays. However, you can mimic the behavior of multiple array indexes. (For more information, see the \"Multiple array indexes\" section). Variables in objects and tables can be declared as arrays. For example, this functionality is used in address lines in the standard application. An array collection class lets you store objects in an array. Array indexes begin at 1. The first item in the array is referenced as \\[1\\], the second item is referenced as \\[2\\], and so on. The following syntax is used to access an array element: **ArrayItemReference = ArrayVariable \\[ Index \\]**. In this syntax, **ArrayVariable** is the identifier of the array, and **Index** is the number of the array element. **Index** can be an integer expression. Item zero \\[0\\] is used to clear the array. If a value is assigned to index 0 in an array, all elements in the array are reset to their default value.\n\n#### Array examples\n\n    public void ArrayMethod()\n    {\n        int myArray[10]; // Fixed-length array with 10 integers.\n        myArray[4] = 1; // Accessing the 4th element in the array.\n        myArray[0] = 0; // Resets all elements in intArray. \n     \n        // Dynamic array of integers.\n        int intArray[];\n            \n        // Dynamic array of variables of type Datatype.\n        //Datatype arrayVariable[];\n            \n        // Fixed-length arrays.\n        boolean boolArray[100]; // Fixed-length array of booleans with 100 items.\n            \n        // Two examples of Partly On Disk Arrays.\n        // Dynamic integer array with only 100 elements in memory.\n        int arrayVariable [ ,100];\n        // Fixed-length string array with 1000 elements, and only 200 in memory.\n        str arrayVariable2 [1000,200];\n\n            // A dynamic array of integers.\n            int i[];\n            // A fixed-length real array with 100 elements.\n            real r[100];\n            // A dynamic array of dates with only 10 elements in memory.\n            date d[,10];\n            // A fixed length array of NoYes variables with 100 elements and 10 in memory.\n            NoYes ny[100,10];\n    }\n\n#### Multiple array indexes\n\nSome languages, such as C++ and C\\#, let you declare arrays that have more than one index. In other words, you can define \"arrays of arrays.\" In X++, you can't directly create multiple array indexes, because only one-dimensional arrays are supported. However, you can implement multiple indexes by using the method that is described in this section. For example, you want to declare an array that has two dimensions, to hold an amount that is earned by country by dimension. There are 10 countries and three dimensions. In C++ and C\\#, you declare the following array.\n\n    // This is C# or C++ code, not X++ code.\n    real earning[10, 3];\n\nHowever, X++ doesn't support this declaration. Instead, you can define a one-dimensional array where the number of elements is the product of the elements in each dimension. Here is an example.\n\n    public void MultipleArrayMethod()\n    {\n        // Step 1: define a one-dimensional array with the number\n        // of elements that is the product of the elements in each dimension.\n        real earnings[10*3];\n            \n        // Step 2: to refer to a specific element, such as earnings[i,j], write the following:\n        // declare i and j (maybe) and assign the value to something\n        int i = 1;\n        int j = 2;\n        real element = earnings[(i-1)*3 + j];\n    }\n\n    // This can be written into a macro like this:\n    #localmacro.earningIndex\n    (%1-1)*3+%2\n    #endmacro\n\n    public void CallTheMacro()\n    {\n        // Next, call the specific element within the macro like this:\n        int i = 1;\n        int j = 2;\n        real element = earnings[#earningIndex(i,j)];\n\n        // The previous scheme can be extended to any number of dimensions.\n        // The element a[i1, i2, ..., ik] can be accessed by computing the\n        // offset into an array containing (d1*d2*...*dk) elements.\n        //(i1 - 1)*d2*d3*..*dk +\n        //(i2 - 1)*d3*d4*...*dk + .... +\n        //(ik-1 -1)*dk +\n        //(ik-1)\n    }\n\n### Container\n\nA *container* object is a dynamic list of items that contain primitive data types or composite data types. A container is useful when you must pass various types of values between the client and server tiers. However, if you plan to repeatedly add to a list in a loop, a container isn't a good choice. Containers are most suitable for processes that don't involve excessive modification to the size or contents of the container. When a container undergoes excessive additions of data, overall system performance can decrease, because container data must be repeatedly copied, and new space must be repeatedly allocated. A container isn't a class. A container contains an ordered sequence of primitive values or other containers. Because of the flexibility of **anytype**, a container offers a good way to store values of different types together. A container can be stored in the database. A container is one of the column types that you can select when you use Application Explorer to add a column to a table. A container slightly resembles an array, or collections such as the **List** or **Stack** classes. However, you can never change the size or content of a container after the container is created. X++ statements that appear to modify a container are internally building a new container and copying values as required. Even an assignment of a container to another container variable creates a new copy of the container. All these operations can affect performance. In the functions that provide access to a container (such as **conPeek**), the container is 1-based, not 0-based. Indexing is 1-based for arrays. The default value of a container is **empty**. The container doesn't contain any values. Some statements that use containers might appear to modify a container. However, inside the system, containers are never modified. Instead, the data from the original container is combined with data from the command to build a new container. You can create a new container by using one of the following functions: **conDel**, **conIns**, or **conPoke**. Additionally, the **Global** class has static methods for handling containers. These methods include **con2ArraySource**, **con2Buf**, **con2List**, **con2Str**, **containerFromXmlNode**, **conView**, and **str2Con**. There are several intrinsic functions for handling a container, such as **conIns** and **conPeek**. The X++ **conPeek** function returns an **anytype** type. Therefore, it's easier to read the values from a container when you don't know the type of each value. An **anytype** can be assigned to any X++ value type, provided that the value can be converted. Your code is easier to read when it avoids explicit data type conversions. Therefore, assign values from a container to the same data type that was used to put the value into the container. You must not assign a container to an **anytype**, because the system might not be able to determine the correct conversions. In these cases, unexpected behavior or errors might occur.\n\n#### Comparing container to other options\n\nThe **container** type resembles other constructs, such as arrays and collection classes such as **List** and **Stack**. The difference between a container and **List** is that an instance of the **List** class is mutable. A **List** object first allocates more space than its data consumes. Then, as data is added, the space is filled. This behavior is more efficient than allocating more space every time that an element is added. An update of a **List** performs faster than similar operations on a container. When you construct a **List** object, you determine the one type of data that the **List** object can store. This restriction is less flexible for a **List** than it is for a container. However, you can store objects in a **List**, whereas a container can store only value types. The difference between a container and an array is that an array can hold only items of its declared type. You can allocate memory space for an array and fill that space with values later. For example, you can fill in values in a loop. This behavior is efficient and performs well. When you want to build a new container by appending new data, you can use either the **+=** operator or the **conIns** function. The **+=** operator is the faster alternative. Use the **conIns** function only when you want to add new data before the last index of the original data. In Dynamics AX 2012, although you could use the X++ compiler to store object references in containers, the result would fail at run time. However, in Microsoft Dynamics 365 for Finance and Operations, when the compiler sees an attempt to store an object reference in a container, it issues an error message. If the type of the element that is added to the container is **anytype**, the compiler can’t determine whether the value is a reference type. In this case, the compiler allows the attempt. It's assumed that the user knows what he or she is doing. Although the compiler doesn't diagnose the code as erroneous, an error will be thrown at run time.\n\n#### Container examples\n\n    public void ContainerExample() \n    {\n        // First, declare the variables you are using.  \n        container myContainer;\n        container myContainer4;\n        container myContainer5; \n        // Three ways to declare a container.\n        myContainer = [1];\n        myContainer += [2];\n        myContainer4 = myContainer5;\n            \n        // Declare a container.\n        container cr3;\n            \n        // Assign a literal container to a container variable.\n        cr3 = [22, \"blue\"];\n            \n        // Declare and assign a container.\n        container cr2 = [1, \"blue\", true];\n            \n        // Mimic container modification (implicitly creates a copy).\n        cr3 += [16, strMyColorString];\n        cr3 = conIns(cr3, 1, 3.14);\n        cr3 = conPoke(cr3, 2, \"violet\");\n            \n        // Assignment of a container (implicitly creates a copy).\n        cr2 = cr3;\n            \n        // Read a value from the container.\n        str  myStr = conPeek(cr2, 1);\n            \n        // One statement that does multiple assignments from a container.\n        str myStr;\n        int myInt;\n        container cr4 = [\"Hello\", 22, 20\\07\\1988];\n        [myStr, myInt] = cr4; // \"Hello\", 22\n            \n        // Example of applying the = operator to a container. The example\n        // initializes myContainer2 and myContainer33.\n        myContainer2 = [2, \"apple\"];\n            \n        // Next, you make a copy of myContainer33 and assign the copy to myContainer2.\n        myContainer33 = [33, \"grape\"];\n        myContainer2 = myContainer33;  // The container that myContainer2 had been holding is no longer available and cannot be recovered.\n        // An example of building a new container by\n        // assigning a new value to myContainer33 through the += operator.\n        myContainer33 += [34, \"banana\"];\n    }\n\n    // List class example. In this example, variable2 and variable3 refer to the same List object.\n    static void JobC(Args _args)\n    {\n        container variable2, variable33;\n        variable2 += [98];\n        variable33 = variable2;\n        variable2 += [97];\n    }\n\n    // Container example. The variable2 and variable3 hold different containers.\n    static void JobL(Args _args)\n    {\n        List variable2,variable33;\n        variable2 = new List(Types::Integer);\n        variable2.addEnd(98);\n        variable33 = variable2;\n        variable2.addEnd(97);\n    }\n\n    // The automatic type conversion by anytype also applies to the special syntax for making multiple\n    // assignments from a container in one statement. This is shown in the following code example,\n    // which assigns a str to an int, and an int to a str.\n    static void JobContainerMultiAssignmentUsesAnytype(Args _args)\n    {\n        container con2;\n        int int4;\n        str str7;\n        con2 = [\"11\", 222];\n        [int4, str7] = con2;\n        info(strfmt(\"int4==11==(%1), str7==222==(%2)\", int4, str7));\n    }\n\n    /***  Output:\n    Message (10:36:22 am)\n    int4==11==(11), str7==222==(222)\n    ***/\n        \n    static void UseQuery()\n    {\n        // An example of how the compiler diagnoses attempts to store object in containers\n        container c = [new Query()];   // This statement will cause the error message shown below.\n        /*** Instance of type 'Query' cannot be added to a container. ***/\n            \n        // An example of a code that won't cause an error message, but will\n        // cause an error message to be thrown at runtime.\n        anytype a = new Query();\n        container d = [a];\n    }\n\n### Classes as data types\n\nA *class* is a type definition that describes both variables and methods for instances of the class. (The instances of a class are also known as *objects*.) A class is only a definition for objects, and all objects are **null** when they are declared. In Application Explorer, every application class under the **Classes** node is a data type. You can declare variables of these types in your code. You can construct instances of a class and assign the instances to variables. Classes can be nested in source code. Nested classes are available only inside forms (such as a class that extends **FormRun**), and are used to represent controls, data sources, or data fields. An attribute decoration, such as the attribute decoration on a class or a method, can omit the suffix of the attribute name if the suffix is **Attribute**. Therefore, X++ allows **\\[MyFavorite\\]** instead of requiring **\\[MyFavoriteAttribute\\]**. Additionally, attributes are now applied to the handlers of delegates and methods, to map the handlers to those targets. In AX 2012 and earlier versions, you could designate a method to run on either the client or the server. However, in Microsoft Dynamics 365 for Finance and Operations and later versions, all compiled X++ code is run as .NET Common Intermediate Language (CIL) on the server. There is no longer any code that is evaluated at the client site or in the browser. Therefore, the **client** and **server** keywords are now ignored. Although these keywords don't cause a compile error if they are used, they should not be used in any new code.\n\n#### Private and protected member variables\n\nPreviously, all member variables that were defined in a class were protected. You can now make the visibility of member variables explicit by adding the **private**, **protected**, and **public** keywords. The interpretation of these modifiers is obvious and is aligned with the semantics for methods:\n\n-   **private** – The member variable can be used only within the class where it’s defined.\n-   **protected** – The member variable can be used in the class where it’s defined and all subclasses of that class.\n-   **public** – The member variable can be used anywhere. It’s visible outside the confines of the class hierarchy where it’s defined.\n\nBy default, member variables that aren’t adorned with an explicit modifier are still protected. However, as a best practice, you should explicitly specify the visibility. As we described earlier, when a member variable is defined as **public**, it can be accessed outside the class where it’s defined. In this case, you must specify a qualifier that designates the object that is hosting the variable. To specify the qualifier, use the dot notation, as you do for method calls. In the following example, **field1** is accessed by using the explicit **this** qualifier. In this case, it might not be a good idea to make a member variable public, because that approach exposes the internal workings of the class to its consumers, and therefore creates a strong dependency between the class implementation and its consumers. You should always try to depend only on a contract, not an implementation.\n\n    public class AnotherClass3\n    {\n        int field1;\n        str field2;\n        void new()\n        {\n            this.field1 = 1;   // Explicit object designated.\n            field2 = \"Banana\";  // 'this' assumed, as usual.\n        }\n    }\n\n#### Static constructors and static fields\n\n*Static fields* are fields that are declared by using the **static** keyword. Conceptually, static fields apply to the class, not to instances of the class. Static constructors are guaranteed to run before any static calls or instance calls are made to the class. The execution of the static constructor is relative to the user’s session. You never call the static constructor explicitly. Instead, the compiler will generate code to make sure that the constructor is called exactly one time, before any other method on the class is called. A static constructor is used to initialize any static data or perform an action that must be performed only one time. You can't provide parameters for the static constructor, and it must be marked with the **static** keyword.\n\n    // An example of how a singleton (call instance in the example below)\n    // can be created using the static constructor.\n    public class Singleton\n    {\n        private static Singleton instance;\n        private void new()\n        {\n        }\n        static void TypeNew()    // This is the static constructor.\n        {\n            instance = new Singleton();\n        }\n\n        public static Singleton Instance()\n        {\n            return Singleton::instance;\n        }\n    }\n     \n    // The singleton ensures that only one instance of the class\n    // will be called, which is consumed by the following. \n    {\n        // Your code here.\n        Singleton i = Singleton::Instance();\n    }\n\n#### Class elements in Application Explorer\n\nUnder most class nodes in Application Explorer, there are two special nodes: a **classDeclaration** node and a **new** node. A **classDeclaration** always contains the X++ **class** keyword. Additional keywords, such as **extends**, can be included to modify the class. This node can also contain declarations of member variables. The member variables can't be initialized to a value in **classDeclaration**, and they can't be static. In the following example, the variables **m\\_priority** and **m\\_rectangle** are members of the class.\n\n    // An example of a classDeclaration.\n    public class YourDerivedClass extends YourBaseClass\n    {\n        int m_priority;\n        Rectangle m_rectangle;\n        void new(int _length, int _width)\n        {\n            this.m_rectangle = new Rectangle(_length, _width);\n        }\n    }\n\nA **new** operator contains logic that is run when the **new** operator is used to create an instance of the class. The logic in the **new** method might construct an object and assign that object to a variable that is declared in the **classDeclaration**. Each class can have only one **new** method. However, in the **new** method, you often should call the **new** method of the base class. To call the **new** method of the base class, call **super()**. The following example shows the **new** method for the **YourDerivedClass** class in the previous **classDeclaration** example. In this **new** method, the code constructs an instance of the **Rectangle** class. The instance is assigned to the **m\\_rectangle** variable. The **this** keyword that is used in the example is optional. However, if you include it, IntelliSense might be more helpful.\n\n    // An example of the new method from the previous classDeclaration example.\n    void new(int _length, int _width)\n    {\n        this.m_rectangle = new Rectangle(_length, _width);\n    }\n\n#### Garbage collection\n\nEventually during run time, most objects no longer have any variable that points to them. The system scans for these objects and erases them from memory. The memory space then becomes available for other uses. The **Object** class has a method that is named **finalize**. However, the **finalize** method isn't a destructor. The runtime never calls the **finalize** method, even when an object is collected as garbage.\n\n#### System classes\n\nIn Application Explorer, under **System Documentation** &gt; **Classes**, there is a list of the kernel classes or system classes. System classes aren't written in X++, and you can't see their source code. You can't add system classes. System classes usually have a **new** method, but they don't have a **classDeclaration** node. Every application class implicitly extends the **Object** system class. Some system classes are extended by an application class that has a similar name. For instance, **xClassFactory** is extended by **ClassFactory**. In these cases, you should not use the system class. For more information, see \"Substitute application classes for system classes\" in [X++ classes and methods](xpp-classes-methods.md).\n\n#### Extension methods\n\nThe extension method feature lets you add extension methods to a target class by writing the methods in a separate extension class. The following rules apply:\n\n-   The extension class must be static.\n-   The name of the extension class must end with the ten-character suffix **\\_Extension**. However, there’s no restriction on the part of the name that precedes the suffix.\n-   Every extension method in the extension class must be declared as **public static**.\n-   The first parameter in every extension method is the type that the extension method extends. However, when the extension method is called, the caller must not pass in anything for the first parameter. Instead, the system automatically passes in the required object for the first parameter.\n-   The target of an extension method must be a class, table, view, or map application object type.\n\nAn extension class can contain private or protected static methods. These methods are typically used for implementation details and aren't exposed as extensions. The extension method technique doesn’t affect the source code of the class that it extends. Therefore, the addition to the class doesn't require over-layering. Upgrades to the target class are never affected by any existing extension methods. However, if an upgrade to the target class adds a method that has the same name as your extension method, your extension method can no longer be reached through objects of the target class. The extension method technique uses the same dot-delimited syntax that you often use to call regular instance methods. Extension methods can access all public artifacts of the target class, but they can’t access anything that is protected or private. Therefore, extension methods can be considered a type of syntactic sugar. Regardless of the target type, an extension class is used to add extension methods to the type. For example, an extension table isn't used to add methods to a table, and there’s no such thing as an extension table.\n\n    // An example of an extension class holding a few extension methods.\n    public static class AtlInventLocation_Extension\n    {\n        public static InventLocation refillEnabled(\n           InventLocation _warehouse,\n           boolean _isRefillEnabled = true)\n        {\n           _warehouse.ReqRefill = _isRefillEnabled;\n           return _warehouse;\n        }\n\n        public static InventLocation save(InventLocation _warehouse)\n        {\n           _warehouse.write();\n           return _warehouse;\n        }\n    }\n\n### Delegates as data types\n\nA *delegate* collects methods that subscribe to it. The delegate specifies the parameter signature that all its subscriber methods must share. When the delegate is called, the delegate calls each of its subscribers. A delegate never returns a value and **can't have a default value**. At first, every delegate has no subscribed methods. There is no limit on the number of parameters that a delegate can declare, and there is no limitation on the type of those parameters. The delegate body is always empty, because the delegate's only purpose is to define the contract that subscribers must conform to. A delegate doesn't have to be defined in a class. Delegates can also be defined in a table, form, or query.\n\n#### Delegate examples\n\n    abstract class VarDatClass\n    {\n        // delegatemethod examples\n        // An example of declaring a delegate.\n        delegate void notifyChange(utcdatetime _dateTime, str _changeDescription)\n        {\n        }\n\n        // An example of subscribing an event handler to a delegate.\n        public static void notifyStatic(utcDateTime _dateTime, str _changeDescription)\n        {\n            info(\"A notification has occurred calling static handler:\" +\n                DateTimeUtil::toStr(_dateTime) +\n                \" Message:\" +\n                _changeDescription);\n        }\n    }\n\n### Tables as data types\n\nAll tables can be treated as class definitions. A table variable can be considered an instance (object) of the table (class) definition. For every field in a table variable, the default value is **empty**. You can address fields and create methods on tables. The methods can be invoked on instances of the table. To manipulate (that is, read, update, insert, and delete) records in tables, you must declare at least one table variable that can hold the record in focus. As a best practice, you should use the name of the table as the name of the variable but use an initial lowercase letter. Here are a few important differences between tables and objects:\n\n-   You can't allocate space for table variables. Allocation is done implicitly.\n-   Fields in table variables are public. You can reference them anywhere.\n-   Fields in table variables can be referenced by using expressions.\n\nThere is no automatic conversion, but table variables that are declared as **Common** can hold data from any table.\n\n#### Scope of table variables\n\nIn most respects, table variables can be considered objects. However, unlike objects, they aren't explicitly allocated. Only a variable declaration is required. All tables are compatible with the Common table, just as all objects are compatible with the **Object** class. Table variables are declared as common buffers and can be used to hold data from any table. You can't access tables that don't have table variables. The principles for declaring table variables and objects are the same, except with regard to the allocation of space.\n\n#### Table examples\n\nThe syntax enables various possibilities for referencing fields in records. For example, you can use the **TableName.(FieldId)** syntax. The following example prints the contents of the fields in the current record in the Customer table.\n\n    // Declares and allocates space for one CustTable record.\n    public void myMethod()\n    {\n        CustomerTable custTable;\n    }\n\n    // An example of referencing table variables.\n    public void printAccountNo()\n    {\n        CustomerTable custTable;\n        print custTable.AccountNo;  // Prints the field reference.\n    }\n\nThe following example uses the **fieldCnt** and **fieldCnt2Id** methods. The **fieldCnt** method counts the number of fields in a table, whereas **fieldCnt2Id** returns the ID for a field number. For example, you can use the **fieldCnt2Id** method to learn that field number 6 in a table has the ID 54. This conversion is required, because there is no guarantee that the IDs of the fields in a table are consecutive.\n\n    // An example of the various possibilities for referencing fields in records.\n    public void printCust()\n    {\n        int i, n, k;\n        CustomerTable custTable;\n        DictTable dictTable;\n        dictTable = new DictTable(custTable.TableId);\n        n = dictTable.fieldCnt();\n        print \"Number of fields in table: \", n;\n        for(i=1; i<=n; i++)\n        {\n            k = dictTable.fieldCnt2Id(i);\n            print \"The \", dictTable.fieldName(k),\n            \" field with Id=\",k, \" contains '\",\n            custTable.(k), \"'\";\n        }\n    }\n\n## Collection classes\nThe X++ language syntax provides two composite types: arrays and containers. These composite types are useful for aggregating values of primitive types. However, you can't store class objects in arrays or containers. *Collection classes* are used to store objects. They let you create arrays, lists, sets, maps, and structs that can hold any data type, even objects. For maximum performance, the classes are implemented in C++ (they are system classes). Collection classes were previously known as *foundation classes*. The collection classes are **Array**, **List**, **Map**, **Set**, and **Struct**.\n\n-   **Array** – This class resembles the **array** type in the X++ language, but it can hold values of any single type, even objects and records. Objects are accessed in a specific order.\n-   **List** – This class contains elements that are accessed sequentially. Unlike an array, the **List** class provides an **addStart** method. Like the **Set** class, the **List** class provides the **getEnumerator** and **getIterator** methods. You can use an iterator to insert and delete items from a **List** object.\n-   **Map** – This class associates a key value with another value.\n-   **Set** – This class holds values of any single type. Values aren't stored in the sequence in which they are added. Instead, the **Set** object stores the value in a manner that optimizes performance for the **in** method. A **Set** object ignores any attempt to add a value that the **Set** object is already storing. Unlike the **Array** class, the **Set** class provides the **in** and **remove** methods.\n-   **Struct** – This class can contain values of more than one type. It's used to group information about a specific entity.\n\nThe constructor for every collection class except **Struct** takes a type parameter that is an element of the **Types** system enum. The collection instance can store items of that type only. The **Types::AnyType** enum element is a special case that can't be used to construct a collection object, such as a **Set** object. The **null** value can't be stored as an element in a **Set** object. Additionally, **null** can't be a key in a **Map** object. You can iterate through a collection object by using an iterator or enumerator. Here are typical examples that show how you can obtain an iterator.\n\n    new MapIterator(myMap)\n    myMap.getEnumerator()\n\nFor **Set** objects, if any elements are added or removed after an iterator is created, the iterator instance can no longer be used to read from or step through the collection. For **Map** objects, as for **Set** objects, if any elements are removed, the iterator is no longer valid. However, a **MapIterator** object remains valid even after a call to the **Map.insert** method, regardless of whether the key is new, or whether the key already exists and only the value is being updated in the **Map** element. Code that calls **Map.insert** and depends on the iterator object remaining valid might fail if it's run as .NET Framework CIL. You can use the collection classes to form more complex classes. For example, you can easily implement a stack by using a list where elements are always added to the beginning of the list. The newest element then occupies the top of the stack. You can also extend the collection classes. For example, you can extend the **List** class to create a list of customer records where the operations are type-safe. In this case, the derived collection class will accept only customer records.\n\n## Extended data types\n*Extended data types* are user-defined types that are based on the **boolean**, **int**, **int64**, **real**, **str**, and **date** primitive data types, and on the **container** composite type. An EDT is a primitive data type or container that has a supplementary name and additional properties. For example, you can create a new EDT that is named **Name** and base it on a string. You can then use the new EDT in variable and field declarations in the development environment. You can also base EDTs on other EDTs. EDTs are standard data types, but they have a specific name and additional properties. EDTs undergo the same value and type [conversions](xpp-conversion-run-time-functions.md) as the standard data types that they are based on. Here are the benefits of EDTs:\n\n-   Code is easier to read, because variables have a meaningful data type. For example, the data type is **Name** instead of **str**.\n-   The properties that you set for an EDT are used by all instances of that type. Therefore, EDTs help reduce work and promote consistency. For example, account numbers (**AccountNum** data type) have the same properties throughout the system.\n-   You can create hierarchies of EDTs. The EDTs can inherit the appropriate properties from the parent, and you can change other properties. For example, the **ItemCode** data type is used as the basis for the **MarkupItemCode** and **PriceDiscItemCode** data types.\n\n### Create an EDT\n\nThis feature isn't implemented as a language construct. To create an EDT, follow these steps.\n\n1.  In Solution Explorer, right-click on the project, point to **Add**, and then click **New item**.\n2.  In the **Add New Item** dialog box, select **Installed** and then **Artifacts** in the left pane.\n3.  In the middle pane, select the EDT type to create.\n4.  Enter a name, and then click **Add**.\n\n### EDT example\n\n    public void EdtMethod()\n    {\n        // Example of declaring EDT variables where\n        // a UserGroupID (integer) variable is declared and initialized to 1.\n        UserGroupID groupID = 1;\n            \n        // An Amount (real) variable is declared.\n        Amount currency;\n    }\n\n## Null values for data types\nMicrosoft Dynamics 365 for Finance and Operations doesn't support the concept of **null** values that is available in many other database management systems (DBMSs). A variable in X++ always has a type and a value. However, for each data type, one value is considered **null** (for example, when the **validateField** table method is run).\n\n| Type        | Value that is treated as null                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n|-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Date        | 1900-01-01                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| Enum        | An element that has its value set to **0**                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| Integer     | 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n| Real        | 0.0                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| String      | An empty string                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| Time        | 00:00:00                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| Utcdatetime | Any value that has its date portion set to **1900-01-01**, regardless of the value of the time portion For example, the value **1900-01-01T22:33:44** is treated as **null**. Note that any **utcDateTime** value that has its date portion set to **1900-01-01** is shown as blank by the X++ **print** statement. Only the value **1900-01-01T00:00:00** is shown as blank by the **Global::info** method. That value is the value from the **DateTimeUtil::MinValue** method. |\n\nTherefore, when the **validateField** method checks whether a user has entered a value in a mandatory field, **0** isn't accepted in an **integer** type field, the first entry isn't accepted in an **enum** type field, and so on. Additionally, in SQL X++ statements, the values that are listed in the previous table yield **false** in a Boolean comparison. However, In non-SQL X++ statements, the equal and relational operators work with these values, just as they work with other values. Variables of the **container** type, and classes and variables of the **table** type can be **null** in the traditional DBMS sense. A **table** type is **null** if all its fields have their **null** value.\n\n\n\n","nodes":[{"pos":[4,615],"nodes":[{"content":"X++ variables and data types","nodes":[{"pos":[0,28],"content":"X++ variables and data types","nodes":[{"content":"X++ variables and data types","pos":[0,28]}]}],"pos":[27,56],"yaml":true},{"content":"This topic describes variables and data types in X++.","nodes":[{"pos":[0,53],"content":"This topic describes variables and data types in X++.","nodes":[{"content":"This topic describes variables and data types in X++.","pos":[0,53]}]}],"pos":[69,123],"yaml":true}],"content":"# required metadata\n\ntitle: X++ variables and data types\ndescription: This topic describes variables and data types in X++.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \n# ms.reviewer: 61\nms.search.scope: AX 7.0.0, Operations\n# ms.tgt_pltfrm: \nms.custom: 150183\nms.assetid: 0ff4e759-851d-4b53-aa67-6f03eee53f02\nms.search.region: Global\n# ms.search.industry: \nms.author: robinr\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n","yamlblock":true},{"pos":[623,651],"content":"X++ variables and data types","linkify":"X++ variables and data types","nodes":[{"content":"X++ variables and data types","pos":[0,28]}]},{"content":"This topic describes variables and data types in X++.","pos":[697,750]},{"pos":[752,761],"content":"Variables","linkify":"Variables","nodes":[{"content":"Variables","pos":[0,9]}]},{"content":"A <bpt id=\"p1\">*</bpt>variable<ept id=\"p1\">*</ept> is an identifier that points to a memory location where information of a specific data type is stored.","pos":[773,888],"source":"A *variable* is an identifier that points to a memory location where information of a specific data type is stored."},{"content":"The size, precision, default value, implicit and explicit <bpt id=\"p1\">[</bpt>conversion<ept id=\"p1\">](xpp-conversion-run-time-functions.md)</ept> functions, and range depend on the variable's data type.","pos":[889,1054],"source":" The size, precision, default value, implicit and explicit [conversion](xpp-conversion-run-time-functions.md) functions, and range depend on the variable's data type."},{"content":"The <bpt id=\"p1\">*</bpt>scope<ept id=\"p1\">*</ept> of a variable defines the area in the code where an item can be accessed.","pos":[1055,1140],"source":" The *scope* of a variable defines the area in the code where an item can be accessed."},{"content":"<bpt id=\"p1\">*</bpt>Instance variables<ept id=\"p1\">*</ept> are declared in class declarations, and can be accessed from any methods in the class or from methods that extend the class.","pos":[1141,1286],"source":"*Instance variables* are declared in class declarations, and can be accessed from any methods in the class or from methods that extend the class."},{"content":"<bpt id=\"p1\">*</bpt>Local variables<ept id=\"p1\">*</ept> can be accessed only in the block where they were defined.","pos":[1287,1363],"source":"*Local variables* can be accessed only in the block where they were defined."},{"content":"When a variable is declared, memory is allocated, and the variable is initialized to the default value.","pos":[1364,1467]},{"content":"You can assign values to both static fields and instance fields as part of the declaration statement.","pos":[1468,1569]},{"content":"Variables can be declared anywhere in a code block in a method.","pos":[1570,1633]},{"content":"They don't have to be declared at the beginning of a method.","pos":[1634,1694]},{"content":"<bpt id=\"p1\">*</bpt>Constants<ept id=\"p1\">*</ept> are variables where the value can't be changed when the variable is declared.","pos":[1695,1784],"source":"*Constants* are variables where the value can't be changed when the variable is declared."},{"content":"They use the <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>readonly<ept id=\"p2\">**</ept> keyword.","pos":[1785,1832],"source":" They use the **const** or **readonly** keyword."},{"content":"Constants differ from <bpt id=\"p1\">*</bpt>read-only fields<ept id=\"p1\">*</ept> in only one way.","pos":[1833,1890],"source":" Constants differ from *read-only fields* in only one way."},{"content":"Read-only fields can be assigned a value only one time, and that value never changes.","pos":[1891,1976]},{"content":"The field can be assigned its value either inline, at the place where the field is declared, or in the constructor.","pos":[1977,2092]},{"content":"When you declare variables of managed types that aren't authored in X++, you have two options.","pos":[2093,2187]},{"content":"You can fully qualify the type names in the declaration by including the full namespace, or you can add a <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statement to your file and then omit the namespace from the type name.","pos":[2188,2374],"source":" You can fully qualify the type names in the declaration by including the full namespace, or you can add a **using** statement to your file and then omit the namespace from the type name."},{"pos":[2380,2397],"content":"Variable examples","linkify":"Variable examples","nodes":[{"content":"Variable examples","pos":[0,17]}]},{"pos":[4954,4957],"content":"var","linkify":"var","nodes":[{"content":"var","pos":[0,3]}]},{"content":"You can declare a variable without explicitly providing the type of the variable, if the compiler can determine the type from the initialization expression.","pos":[4959,5115]},{"content":"The variable is still strongly-typed into one, unambiguous type.","pos":[5116,5180]},{"content":"You can use <bpt id=\"p1\">**</bpt>var<ept id=\"p1\">**</ept> only on declarations where initialization expressions are provided.","pos":[5181,5268],"source":" You can use **var** only on declarations where initialization expressions are provided."},{"content":"(The compiler will infer the type from the initialization expression.) In some cases, this approach can make code easier to read.","pos":[5269,5398]},{"content":"You should use <bpt id=\"p1\">**</bpt>var<ept id=\"p1\">**</ept> to declare local variables in these situations:","pos":[5399,5469],"source":" You should use **var** to declare local variables in these situations:"},{"content":"When the type of the variable is obvious from the right side of the assignment","pos":[5475,5553]},{"content":"When the exact type isn't important","pos":[5558,5593]},{"pos":[5598,5643],"content":"For the declarations of <bpt id=\"p1\">**</bpt>for<ept id=\"p1\">**</ept> loop counters","source":"For the declarations of **for** loop counters"},{"pos":[5648,5698],"content":"For disposable objects inside <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statements","source":"For disposable objects inside **using** statements"},{"pos":[5700,5779],"content":"Don't use <bpt id=\"p1\">**</bpt>var<ept id=\"p1\">**</ept> when the type isn't clear from the initialization expression.","source":"Don't use **var** when the type isn't clear from the initialization expression."},{"pos":[5785,5797],"content":"var examples","linkify":"var examples","nodes":[{"content":"var examples","pos":[0,12]}]},{"pos":[6213,6229],"content":"Declare anywhere","linkify":"Declare anywhere","nodes":[{"content":"Declare anywhere","pos":[0,16]}]},{"content":"Declarations can now be provided wherever statements can be provided.","pos":[6231,6300]},{"content":"A declaration is syntactically a statement, a <bpt id=\"p1\">*</bpt>declaration statement<ept id=\"p1\">*</ept>.","pos":[6301,6371],"source":" A declaration is syntactically a statement, a *declaration statement*."},{"content":"You can provide declarations immediately before the variable is used, and you don’t have to declare all the variables in one place.","pos":[6372,6503]},{"content":"Therefore, you have precise control over the scope of your variables.","pos":[6504,6573]},{"content":"You can give variables smaller scopes, outside which the variables can’t be referenced.","pos":[6574,6661]},{"content":"The lifetime of the variable is the scope that it’s declared in.","pos":[6662,6726]},{"content":"Scopes can be started at the block level (inside compound statements), in <bpt id=\"p1\">**</bpt>for<ept id=\"p1\">**</ept> statements, and in <bpt id=\"p2\">**</bpt>using<ept id=\"p2\">**</ept> statements.","pos":[6727,6849],"source":" Scopes can be started at the block level (inside compound statements), in **for** statements, and in **using** statements."},{"content":"There are several advantages to making scopes small:","pos":[6850,6902]},{"content":"Readability is enhanced.","pos":[6908,6932]},{"content":"You reduce the risk that a variable will be reused in an inappropriate manner during long-term maintenance of the code.","pos":[6937,7056]},{"content":"It's easier to refactor code.","pos":[7061,7090]},{"content":"You can copy in code without having to worry that variables might be reused in contexts where they shouldn’t be reused.","pos":[7091,7210]},{"pos":[7212,7313],"content":"In the following example, we declare the loop counter inside the <bpt id=\"p1\">**</bpt>for<ept id=\"p1\">**</ept> statement that it's used in.","source":"In the following example, we declare the loop counter inside the **for** statement that it's used in."},{"content":"The scope of the variable is the <bpt id=\"p1\">**</bpt>for<ept id=\"p1\">**</ept> statement itself, and includes the condition expression and the loop update parts.","pos":[7445,7568],"source":"The scope of the variable is the **for** statement itself, and includes the condition expression and the loop update parts."},{"content":"The value can’t be used outside this scope.","pos":[7569,7612]},{"content":"In the following example, when the compiler reaches the <bpt id=\"p1\">**</bpt>info<ept id=\"p1\">**</ept> statement, it will issue the following error message: \"'i' isn't declared.\"","pos":[7613,7753],"source":" In the following example, when the compiler reaches the **info** statement, it will issue the following error message: \"'i' isn't declared.\""},{"pos":[8013,8102],"content":"You can also scope variables to a <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statement, as shown in the following example.","source":"You can also scope variables to a **using** statement, as shown in the following example."},{"content":"When you use an object that implements <bpt id=\"p1\">**</bpt>IDisposable<ept id=\"p1\">**</ept>, you should declare and instantiate that object in a <bpt id=\"p2\">**</bpt>using<ept id=\"p2\">**</ept> statement.","pos":[8325,8453],"source":"When you use an object that implements **IDisposable**, you should declare and instantiate that object in a **using** statement."},{"content":"The <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statement calls the <bpt id=\"p2\">**</bpt>Dispose<ept id=\"p2\">**</ept> method on the object correctly, even if an exception occurs while you're calling methods on the object.","pos":[8454,8603],"source":" The **using** statement calls the **Dispose** method on the object correctly, even if an exception occurs while you're calling methods on the object."},{"content":"You can achieve the same result by putting the object inside a <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> block and then explicitly calling <bpt id=\"p2\">**</bpt>Dispose<ept id=\"p2\">**</ept> in a <bpt id=\"p3\">**</bpt>finally<ept id=\"p3\">**</ept> block.","pos":[8604,8744],"source":" You can achieve the same result by putting the object inside a **try** block and then explicitly calling **Dispose** in a **finally** block."},{"content":"In fact, the compiler translates the <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statement in just this manner.","pos":[8745,8822],"source":" In fact, the compiler translates the **using** statement in just this manner."},{"content":"The following example shows some of the features that we have been describing.","pos":[8823,8901]},{"content":"To prevent confusion, the compiler issues an error message if you try to introduce a variable that will hide another variable in an enclosing scope, or even in the same scope.","pos":[9210,9385]},{"content":"For example, the following code will cause the compiler to issue the following diagnostic message: \"A local variable named 'i' can't be declared in this scope because it would give a different meaning to 'i', which is already used in a parent or current scope to denote something else.\"","pos":[9386,9672]},{"pos":[9745,9787],"content":"Constants, read-only variables, and macros","linkify":"Constants, read-only variables, and macros","nodes":[{"content":"Constants, read-only variables, and macros","pos":[0,42]}]},{"content":"The concept of macros is fully supported.","pos":[9789,9830]},{"content":"However, constants have the following advantages over macros:","pos":[9831,9892]},{"content":"You can add a documentation comment to a constant but not to the value of a macro.","pos":[9898,9980]},{"content":"Eventually, the language service will pick up this comment and provide useful information to the user.","pos":[9981,10083]},{"content":"A constant is known by IntelliSense.","pos":[10088,10124]},{"content":"A constant is cross-referenced.","pos":[10129,10160]},{"content":"Therefore, you can find all references for a specific constant but not for a macro.","pos":[10161,10244]},{"content":"A constant is subject to access modifiers.","pos":[10249,10291]},{"content":"You can use the <bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>protected<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>public<ept id=\"p3\">**</ept> modifiers.","pos":[10292,10361],"source":" You can use the **private**, **protected**, and **public** modifiers."},{"content":"The accessibility of macros isn't rigorously defined.","pos":[10362,10415]},{"content":"Constant variables have scope, whereas macros don't have scope.","pos":[10420,10483]},{"content":"You can see the value of a constant or a read-only variable in the debugger.","pos":[10488,10564]},{"content":"Macros that are defined in class scopes (that is, in class declarations) are effectively available in all methods of all derived classes.","pos":[10566,10703]},{"content":"This feature was originally a bug in the implementation of the legacy compiler macro.","pos":[10704,10789]},{"content":"However, many application programmers often take advantage of it now.","pos":[10790,10859]},{"content":"The X++ compiler still honors this feature, but no new code that uses it should be written.","pos":[10860,10951]},{"content":"This feature also has a significant effect on the performance of the compiler.","pos":[10952,11030]},{"content":"Constants can be declared at the class level, as shown in the following example.","pos":[11031,11111]},{"content":"The constants can then be referenced by using the double colon (::) syntax.","pos":[11162,11237]},{"content":"If you're in the scope of the class where the constant (<bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>) is defined, you can omit the type name prefix (<bpt id=\"p2\">**</bpt>MyClass<ept id=\"p2\">**</ept> in the preceding example).","pos":[11277,11429],"source":"If you're in the scope of the class where the constant (**const**) is defined, you can omit the type name prefix (**MyClass** in the preceding example)."},{"content":"Therefore, you can easily implement the concept of a macro library.","pos":[11430,11497]},{"content":"The list of macro symbols becomes a class that has public <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> definitions.","pos":[11498,11578],"source":" The list of macro symbols becomes a class that has public **const** definitions."},{"content":"You can also define constants as variables only.","pos":[11579,11627]},{"content":"The compiler will maintain the invariant so that the value can't be modified.","pos":[11628,11705]},{"pos":[11828,11848],"content":"Primitive data types","linkify":"Primitive data types","nodes":[{"content":"Primitive data types","pos":[0,20]}]},{"pos":[11849,12015],"content":"The primitive data types in X++ are <bpt id=\"p1\">**</bpt>anytype<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>boolean<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>date<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>enum<ept id=\"p4\">**</ept>, <bpt id=\"p5\">**</bpt>guid<ept id=\"p5\">**</ept>, <bpt id=\"p6\">**</bpt>int<ept id=\"p6\">**</ept>, <bpt id=\"p7\">**</bpt>int64<ept id=\"p7\">**</ept>, <bpt id=\"p8\">**</bpt>real<ept id=\"p8\">**</ept>, <bpt id=\"p9\">**</bpt>str<ept id=\"p9\">**</ept>, <bpt id=\"p10\">**</bpt>timeOfDay<ept id=\"p10\">**</ept>, and <bpt id=\"p11\">**</bpt>utcdatetime<ept id=\"p11\">**</ept>.","source":"The primitive data types in X++ are **anytype**, **boolean**, **date**, **enum**, **guid**, **int**, **int64**, **real**, **str**, **timeOfDay**, and **utcdatetime**."},{"pos":[12021,12028],"content":"anytype","linkify":"anytype","nodes":[{"content":"anytype","pos":[0,7]}]},{"content":"The <bpt id=\"p1\">**</bpt>anytype<ept id=\"p1\">**</ept> data type is a placeholder for any data type.","pos":[12030,12091],"source":"The **anytype** data type is a placeholder for any data type."},{"content":"You should use variables of this type only as arguments and return values.","pos":[12092,12166]},{"content":"To use <bpt id=\"p1\">**</bpt>anytype<ept id=\"p1\">**</ept> as a variable, you must first assign a value to it.","pos":[12167,12237],"source":" To use **anytype** as a variable, you must first assign a value to it."},{"content":"Otherwise, a run-time error occurs.","pos":[12238,12273]},{"content":"After you've assigned a value to <bpt id=\"p1\">**</bpt>anytype<ept id=\"p1\">**</ept>, you can't convert it to another data type.","pos":[12274,12362],"source":" After you've assigned a value to **anytype**, you can't convert it to another data type."},{"content":"Although you can use <bpt id=\"p1\">**</bpt>anytype<ept id=\"p1\">**</ept> variables in expressions, they're usually used as arguments and return types.","pos":[12363,12473],"source":" Although you can use **anytype** variables in expressions, they're usually used as arguments and return types."},{"content":"The size, precision, scope, default value, and range of <bpt id=\"p1\">**</bpt>anytype<ept id=\"p1\">**</ept> depend on the conversion type that you assign to it.","pos":[12474,12594],"source":" The size, precision, scope, default value, and range of **anytype** depend on the conversion type that you assign to it."},{"content":"You can use <bpt id=\"p1\">**</bpt>anytype<ept id=\"p1\">**</ept> just as you use the data type that you convert it to.","pos":[12595,12672],"source":" You can use **anytype** just as you use the data type that you convert it to."},{"content":"For example, if you assign an integer, you can then apply relational and arithmetic operators to the variable.","pos":[12673,12783]},{"content":"An <bpt id=\"p1\">**</bpt>anytype<ept id=\"p1\">**</ept> variable is automatically converted to a date, enumeration (enum), integer, real, string, extended data type (EDT) (record), class, or container when a value is assigned to the type.","pos":[12784,12981],"source":" An **anytype** variable is automatically converted to a date, enumeration (enum), integer, real, string, extended data type (EDT) (record), class, or container when a value is assigned to the type."},{"content":"Additionally, the following explicit <bpt id=\"p1\">[</bpt>conversion functions<ept id=\"p1\">](xpp-conversion-run-time-functions.md)</ept> can be used: <bpt id=\"p2\">**</bpt>any2date<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>any2enum<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>any2int<ept id=\"p4\">**</ept>, <bpt id=\"p5\">**</bpt>any2real<ept id=\"p5\">**</ept>, and <bpt id=\"p6\">**</bpt>any2str<ept id=\"p6\">**</ept>.","pos":[12982,13164],"source":" Additionally, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **any2date**, **any2enum**, **any2int**, **any2real**, and **any2str**."},{"content":"You can't change the variable to another data type after you've converted it to <bpt id=\"p1\">**</bpt>anytype<ept id=\"p1\">**</ept>.","pos":[13165,13257],"source":" You can't change the variable to another data type after you've converted it to **anytype**."},{"pos":[13264,13280],"content":"anytype examples","linkify":"anytype examples","nodes":[{"content":"anytype examples","pos":[0,16]}]},{"pos":[13802,13809],"content":"boolean","linkify":"boolean","nodes":[{"content":"boolean","pos":[0,7]}]},{"content":"The <bpt id=\"p1\">**</bpt>boolean<ept id=\"p1\">**</ept> data type contains a value that is evaluated as either <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>false<ept id=\"p3\">**</ept>.","pos":[13811,13904],"source":"The **boolean** data type contains a value that is evaluated as either **true** or **false**."},{"content":"You can use the reserved literal keywords <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> wherever a <bpt id=\"p3\">**</bpt>boolean<ept id=\"p3\">**</ept> expression is expected.","pos":[13905,14016],"source":" You can use the reserved literal keywords **true** and **false** wherever a **boolean** expression is expected."},{"content":"The size of a <bpt id=\"p1\">**</bpt>boolean<ept id=\"p1\">**</ept> is 1 byte.","pos":[14017,14053],"source":" The size of a **boolean** is 1 byte."},{"content":"The default value is <bpt id=\"p1\">**</bpt>false<ept id=\"p1\">**</ept>, and the internal representation is a short number.","pos":[14054,14136],"source":" The default value is **false**, and the internal representation is a short number."},{"content":"A <bpt id=\"p1\">**</bpt>boolean<ept id=\"p1\">**</ept> is automatically converted to an <bpt id=\"p2\">**</bpt>int<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>date<ept id=\"p3\">**</ept>, or <bpt id=\"p4\">**</bpt>real<ept id=\"p4\">**</ept>.","pos":[14137,14215],"source":" A **boolean** is automatically converted to an **int**, **date**, or **real**."},{"content":"It has no explicit conversion functions.","pos":[14216,14256]},{"content":"The internal representation of a <bpt id=\"p1\">**</bpt>boolean<ept id=\"p1\">**</ept> is an integer.","pos":[14257,14316],"source":" The internal representation of a **boolean** is an integer."},{"content":"You can assign any integer value to a variable that is declared as the <bpt id=\"p1\">**</bpt>boolean<ept id=\"p1\">**</ept> type.","pos":[14317,14405],"source":" You can assign any integer value to a variable that is declared as the **boolean** type."},{"content":"The integer value <bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept> (zero) is evaluated as <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>, and all other integer values are evaluated as <bpt id=\"p3\">**</bpt>true<ept id=\"p3\">**</ept>.","pos":[14406,14519],"source":" The integer value **0** (zero) is evaluated as **false**, and all other integer values are evaluated as **true**."},{"content":"Because the internal representation of a <bpt id=\"p1\">**</bpt>boolean<ept id=\"p1\">**</ept> is an integer, <bpt id=\"p2\">**</bpt>boolean<ept id=\"p2\">**</ept> values are automatically converted to integers and reals.","pos":[14520,14657],"source":" Because the internal representation of a **boolean** is an integer, **boolean** values are automatically converted to integers and reals."},{"pos":[14664,14680],"content":"boolean examples","linkify":"boolean examples","nodes":[{"content":"boolean examples","pos":[0,16]}]},{"pos":[15706,15710],"content":"date","linkify":"date","nodes":[{"content":"date","pos":[0,4]}]},{"content":"The <bpt id=\"p1\">**</bpt>date<ept id=\"p1\">**</ept> data type contains the day, month, and year.","pos":[15712,15769],"source":"The **date** data type contains the day, month, and year."},{"content":"Dates can be written as literals by using the following syntax: <bpt id=\"p1\">**</bpt>Date literal = day <ph id=\"ph1\">\\\\</ph> month <ph id=\"ph2\">\\\\</ph> year<ept id=\"p1\">**</ept>.","pos":[15770,15874],"source":" Dates can be written as literals by using the following syntax: **Date literal = day \\\\ month \\\\ year**."},{"content":"You must use four digits for the year.","pos":[15875,15913]},{"content":"The <bpt id=\"p1\">**</bpt>date<ept id=\"p1\">**</ept> data type can hold dates between January 1, 1900, and December 31, 2154.","pos":[15914,15999],"source":" The **date** data type can hold dates between January 1, 1900, and December 31, 2154."},{"content":"The size of a <bpt id=\"p1\">**</bpt>date<ept id=\"p1\">**</ept> is 32 bits.","pos":[16000,16034],"source":" The size of a **date** is 32 bits."},{"content":"The default value is <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept>, and the internal representation is a date.","pos":[16035,16108],"source":" The default value is **null**, and the internal representation is a date."},{"content":"A <bpt id=\"p1\">**</bpt>date<ept id=\"p1\">**</ept> has no implicit conversions.","pos":[16109,16148],"source":" A **date** has no implicit conversions."},{"content":"However, the following explicit <bpt id=\"p1\">[</bpt>conversion functions<ept id=\"p1\">](xpp-conversion-run-time-functions.md)</ept> can used: <bpt id=\"p2\">**</bpt>str2date<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>date2str<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>date2num<ept id=\"p4\">**</ept>, and <bpt id=\"p5\">**</bpt>int2date<ept id=\"p5\">**</ept>.","pos":[16149,16311],"source":" However, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can used: **str2date**, **date2str**, **date2num**, and **int2date**."},{"content":"You can add and subtract integers from dates, but you can't add or subtract two dates from each other.","pos":[16312,16414]},{"content":"If you try, a compiler error occurs.","pos":[16415,16451]},{"pos":[16458,16471],"content":"date examples","linkify":"date examples","nodes":[{"content":"date examples","pos":[0,13]}]},{"pos":[17689,17693],"content":"enum","linkify":"enum","nodes":[{"content":"enum","pos":[0,4]}]},{"content":"An <bpt id=\"p1\">**</bpt>enum<ept id=\"p1\">**</ept> is a list of literals.","pos":[17695,17729],"source":"An **enum** is a list of literals."},{"content":"Before you can use an <bpt id=\"p1\">**</bpt>enum<ept id=\"p1\">**</ept>, you must declare it in Application Explorer.","pos":[17730,17806],"source":" Before you can use an **enum**, you must declare it in Application Explorer."},{"content":"The literal values are represented internally as integers.","pos":[17807,17865]},{"content":"The first literal has the number 0, the next literal has the number 1, the next literal has the number 2, and so on.","pos":[17866,17982]},{"content":"You can use <bpt id=\"p1\">**</bpt>enum<ept id=\"p1\">**</ept> values as integers in expressions.","pos":[17983,18038],"source":" You can use **enum** values as integers in expressions."},{"content":"The default value for the first entry is <bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept>, and the internal representation is a short number.","pos":[18039,18137],"source":" The default value for the first entry is **0**, and the internal representation is a short number."},{"content":"An <bpt id=\"p1\">**</bpt>enum<ept id=\"p1\">**</ept> value is automatically converted to a <bpt id=\"p2\">**</bpt>boolean<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>int<ept id=\"p3\">**</ept>, or <bpt id=\"p4\">**</bpt>real<ept id=\"p4\">**</ept>.","pos":[18138,18222],"source":" An **enum** value is automatically converted to a **boolean**, **int**, or **real**."},{"content":"Additionally, the following explicit <bpt id=\"p1\">[</bpt>conversion functions<ept id=\"p1\">](xpp-conversion-run-time-functions.md)</ept> can be used: <bpt id=\"p2\">**</bpt>enum2str<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>str2enum<ept id=\"p3\">**</ept>.","pos":[18223,18364],"source":" Additionally, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **enum2str** and **str2enum**."},{"content":"Hundreds of enumerable types are built into the standard application.","pos":[18365,18434]},{"content":"For example, the <bpt id=\"p1\">**</bpt>NoYes<ept id=\"p1\">**</ept> enum has two associated literals: <bpt id=\"p2\">**</bpt>No<ept id=\"p2\">**</ept> has the value <bpt id=\"p3\">**</bpt>0<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>Yes<ept id=\"p4\">**</ept> has the value <bpt id=\"p5\">**</bpt>1<ept id=\"p5\">**</ept>.","pos":[18435,18556],"source":" For example, the **NoYes** enum has two associated literals: **No** has the value **0**, and **Yes** has the value **1**."},{"content":"You can create as many enum types as you want, and you can declare up to 251 (0 to 250) literals in a single enum type.","pos":[18557,18676]},{"content":"To reference an <bpt id=\"p1\">**</bpt>enum<ept id=\"p1\">**</ept> value, enter the name of the enum, two colons, and then the name of the literal.","pos":[18677,18782],"source":" To reference an **enum** value, enter the name of the enum, two colons, and then the name of the literal."},{"content":"For example, to use the literal <bpt id=\"p1\">**</bpt>No<ept id=\"p1\">**</ept> in the <bpt id=\"p2\">**</bpt>NoYes<ept id=\"p2\">**</ept> enum, enter <bpt id=\"p3\">**</bpt>NoYes::No<ept id=\"p3\">**</ept>.","pos":[18783,18865],"source":" For example, to use the literal **No** in the **NoYes** enum, enter **NoYes::No**."},{"pos":[18872,18886],"content":"Create an enum","linkify":"Create an enum","nodes":[{"content":"Create an enum","pos":[0,14]}]},{"pos":[18892,18985],"content":"In Solution Explorer, right-click the project, point to <bpt id=\"p1\">**</bpt>Add<ept id=\"p1\">**</ept>, and then click <bpt id=\"p2\">**</bpt>New Item<ept id=\"p2\">**</ept>.","source":"In Solution Explorer, right-click the project, point to **Add**, and then click **New Item**."},{"pos":[18990,19033],"content":"Under <bpt id=\"p1\">**</bpt>Artifacts<ept id=\"p1\">**</ept>, select <bpt id=\"p2\">**</bpt>Data Types<ept id=\"p2\">**</ept>.","source":"Under **Artifacts**, select **Data Types**."},{"pos":[19038,19086],"content":"Click <bpt id=\"p1\">**</bpt>Base Enum<ept id=\"p1\">**</ept> to select the new item type.","source":"Click **Base Enum** to select the new item type."},{"content":"In the <bpt id=\"p1\">**</bpt>Name<ept id=\"p1\">**</ept> field, enter a name for the enum, and then click <bpt id=\"p2\">**</bpt>Add<ept id=\"p2\">**</ept>.","pos":[19091,19164],"source":"In the **Name** field, enter a name for the enum, and then click **Add**."},{"content":"A new enum is added to the project, and the enum designer for the new element is opened.","pos":[19165,19253]},{"pos":[19258,19338],"content":"In the enum designer, right-click the enum name, and then click <bpt id=\"p1\">**</bpt>New Element<ept id=\"p1\">**</ept>.","source":"In the enum designer, right-click the enum name, and then click **New Element**."},{"pos":[19343,19408],"content":"In the <bpt id=\"p1\">**</bpt>Properties<ept id=\"p1\">**</ept> window, enter the name of the enum element.","source":"In the **Properties** window, enter the name of the enum element."},{"pos":[19415,19428],"content":"enum examples","linkify":"enum examples","nodes":[{"content":"enum examples","pos":[0,13]}]},{"pos":[19648,19652],"content":"guid","linkify":"guid","nodes":[{"content":"guid","pos":[0,4]}]},{"content":"The <bpt id=\"p1\">**</bpt>guid<ept id=\"p1\">**</ept> data type holds a <bpt id=\"p2\">*</bpt>globally unique identifier<ept id=\"p2\">*</ept> (GUID) value.","pos":[19654,19727],"source":"The **guid** data type holds a *globally unique identifier* (GUID) value."},{"content":"A GUID is an integer that can be used across all computers and networks, wherever a unique identifier is required.","pos":[19728,19842]},{"content":"It's unlikely that the number will be duplicated.","pos":[19843,19892]},{"content":"A valid GUID meets all the following specifications:","pos":[19893,19945]},{"content":"It must have 32 hexadecimal digits.","pos":[19951,19986]},{"content":"It must have four dash characters that are embedded at the following locations: 8-4-4-4-12.","pos":[19991,20082]},{"content":"Braces ({}) at the beginning and end of a string are optional.","pos":[20087,20149]},{"content":"For example, both \"12345678-BBBb-cCCCC-0000-123456789012\" and \"{12345678-BBBb-cCCCC-0000-123456789012}\" are valid GUID strings.","pos":[20150,20277]},{"content":"It must have a total of either 36 or 38 characters, depending on whether braces are added.","pos":[20282,20372]},{"content":"The hexadecimal digits a–f (or A–F) can be uppercase, lowercase, or mixed.","pos":[20377,20451]},{"content":"The size of a <bpt id=\"p1\">**</bpt>guid<ept id=\"p1\">**</ept> is 16 bytes or 128 bits.","pos":[20453,20500],"source":"The size of a **guid** is 16 bytes or 128 bits."},{"content":"The following explicit <bpt id=\"p1\">[</bpt>conversion functions<ept id=\"p1\">](xpp-conversion-run-time-functions.md)</ept> can be used: <bpt id=\"p2\">**</bpt>any2guid<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>guid2str<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>newGuid<ept id=\"p4\">**</ept>, <bpt id=\"p5\">**</bpt>str2guid<ept id=\"p5\">**</ept>, <bpt id=\"p6\">**</bpt>Global::guidFromString<ept id=\"p6\">**</ept>, and <bpt id=\"p7\">**</bpt>Global::stringFromGuid<ept id=\"p7\">**</ept>.","pos":[20501,20712],"source":" The following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **any2guid**, **guid2str**, **newGuid**, **str2guid**, **Global::guidFromString**, and **Global::stringFromGuid**."},{"pos":[20719,20732],"content":"guid examples","linkify":"guid examples","nodes":[{"content":"guid examples","pos":[0,13]}]},{"content":"The following set of examples shows how to use the <bpt id=\"p1\">**</bpt>guid<ept id=\"p1\">**</ept> functions.","pos":[20734,20804],"source":"The following set of examples shows how to use the **guid** functions."},{"content":"The code output of these examples follows.","pos":[20805,20847]},{"pos":[22239,22255],"content":"guid code output","linkify":"guid code output","nodes":[{"content":"guid code output","pos":[0,16]}]},{"content":"The following output appears in the Infolog.","pos":[22257,22301]},{"content":"Note that the string includes the optional braces.","pos":[22302,22352]},{"pos":[22887,22900],"content":"int and int64","linkify":"int and int64","nodes":[{"content":"int and int64","pos":[0,13]}]},{"content":"<bpt id=\"p1\">*</bpt>Integers<ept id=\"p1\">*</ept> are numbers that have no decimal places.","pos":[22902,22953],"source":"*Integers* are numbers that have no decimal places."},{"content":"There are two integer types: <bpt id=\"p1\">**</bpt>int<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>int64<ept id=\"p2\">**</ept>.","pos":[22954,23005],"source":" There are two integer types: **int** and **int64**."},{"content":"Integers are used as control variables in repetitive statements or as indexes in arrays.","pos":[23006,23094]},{"content":"You can also use <bpt id=\"p1\">*</bpt>integer literals<ept id=\"p1\">*</ept> anywhere that an integer expression is expected, and both relational and arithmetic operators can be applied.","pos":[23095,23240],"source":" You can also use *integer literals* anywhere that an integer expression is expected, and both relational and arithmetic operators can be applied."},{"content":"An integer literal is the integer as it's entered directly in the code, such as <bpt id=\"p1\">**</bpt>32768<ept id=\"p1\">**</ept>.","pos":[23241,23331],"source":" An integer literal is the integer as it's entered directly in the code, such as **32768**."},{"content":"An <bpt id=\"p1\">**</bpt>int<ept id=\"p1\">**</ept> is 32 bits wide, and an <bpt id=\"p2\">**</bpt>int64<ept id=\"p2\">**</ept> is 64 bits wide.","pos":[23332,23393],"source":" An **int** is 32 bits wide, and an **int64** is 64 bits wide."},{"content":"The default value is <bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept>, and the internal representation is a long number.","pos":[23394,23471],"source":" The default value is **0**, and the internal representation is a long number."},{"content":"An integer is automatically converted to a <bpt id=\"p1\">**</bpt>boolean<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>enum<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>real<ept id=\"p3\">**</ept>.","pos":[23472,23550],"source":" An integer is automatically converted to a **boolean**, **enum**, or **real**."},{"content":"Additionally, the following explicit <bpt id=\"p1\">[</bpt>conversion functions<ept id=\"p1\">](xpp-conversion-run-time-functions.md)</ept> can be used: <bpt id=\"p2\">**</bpt>str2int<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>int2str<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>str2int64<ept id=\"p4\">**</ept>, and <bpt id=\"p5\">**</bpt>int642str<ept id=\"p5\">**</ept>.","pos":[23551,23721],"source":" Additionally, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **str2int**, **int2str**, **str2int64**, and **int642str**."},{"content":"The range of an <bpt id=\"p1\">**</bpt>int<ept id=\"p1\">**</ept> is <ph id=\"ph1\">\\[</ph>-2,147,483,647 : 2,147,483,647<ph id=\"ph2\">\\]</ph>, and the range of an <bpt id=\"p2\">**</bpt>int64<ept id=\"p2\">**</ept> is <ph id=\"ph3\">\\[</ph>-9,223,372,036,854,775,808 : 9,223,372,036,854,775,808<ph id=\"ph4\">\\]</ph>.","pos":[23722,23877],"source":" The range of an **int** is \\[-2,147,483,647 : 2,147,483,647\\], and the range of an **int64** is \\[-9,223,372,036,854,775,808 : 9,223,372,036,854,775,808\\]."},{"content":"All integers in either of these ranges can be used as literals.","pos":[23878,23941]},{"pos":[23948,23970],"content":"int and int64 examples","linkify":"int and int64 examples","nodes":[{"content":"int and int64 examples","pos":[0,22]}]},{"content":"The following example shows how to declare integers and use them in expressions.","pos":[23972,24052]},{"content":"If you try to assign the largest integer plus 1 to an <bpt id=\"p1\">**</bpt>int64<ept id=\"p1\">**</ept>, you get the wrong result, because the number is interpreted as a 32-bit number.","pos":[24053,24197],"source":" If you try to assign the largest integer plus 1 to an **int64**, you get the wrong result, because the number is interpreted as a 32-bit number."},{"content":"Therefore, the number is wrapped around and stored as -2,147,483,647 instead.","pos":[24198,24275]},{"content":"To prevent this behavior, add \"u\" to the end of the number.","pos":[24276,24335]},{"content":"For example, enter <bpt id=\"p1\">**</bpt>int64 i = 0x8000 0000u<ept id=\"p1\">**</ept> (0x8000 0000 is 2,147,483,648).","pos":[24336,24413],"source":" For example, enter **int64 i = 0x8000 0000u** (0x8000 0000 is 2,147,483,648)."},{"pos":[25294,25298],"content":"real","linkify":"real","nodes":[{"content":"real","pos":[0,4]}]},{"content":"A <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> variable can hold decimal values in addition to integers.","pos":[25300,25368],"source":"A **real** variable can hold decimal values in addition to integers."},{"content":"You can use <bpt id=\"p1\">*</bpt>decimal literals<ept id=\"p1\">*</ept> anywhere that a <bpt id=\"p2\">**</bpt>real<ept id=\"p2\">**</ept> is expected.","pos":[25369,25437],"source":" You can use *decimal literals* anywhere that a **real** is expected."},{"content":"A decimal literal is the decimal as it's entered directly in the code, such as <bpt id=\"p1\">**</bpt>2.123876<ept id=\"p1\">**</ept>.","pos":[25438,25530],"source":" A decimal literal is the decimal as it's entered directly in the code, such as **2.123876**."},{"content":"Real literals can also be written by using exponential notation, such as <bpt id=\"p1\">**</bpt>1.0e3<ept id=\"p1\">**</ept>.","pos":[25531,25614],"source":" Real literals can also be written by using exponential notation, such as **1.0e3**."},{"content":"Reals can be used in all expressions, and they can be used with both relational and arithmetic operators.","pos":[25615,25720]},{"content":"A <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> has a precision of 16 significant digits.","pos":[25721,25773],"source":" A **real** has a precision of 16 significant digits."},{"content":"The default value for a <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> is <bpt id=\"p2\">**</bpt>0.0<ept id=\"p2\">**</ept>, and the internal representation is a binary-coded digital (BCD) number.","pos":[25774,25890],"source":" The default value for a **real** is **0.0**, and the internal representation is a binary-coded digital (BCD) number."},{"content":"The BCD encoding enables exact representations of values that are multiples of 0.1.","pos":[25891,25974]},{"content":"The range of a <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> variable is -(10)¹²⁷ through (10)¹²⁷.","pos":[25975,26036],"source":" The range of a **real** variable is -(10)¹²⁷ through (10)¹²⁷."},{"content":"All reals in this range can be used as literals in X++.","pos":[26037,26092]},{"content":"A <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> variable is automatically converted to a <bpt id=\"p2\">**</bpt>boolean<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>enum<ept id=\"p3\">**</ept>, or <bpt id=\"p4\">**</bpt>int<ept id=\"p4\">**</ept>.","pos":[26093,26179],"source":" A **real** variable is automatically converted to a **boolean**, **enum**, or **int**."},{"content":"If the result is an integer, or if the operator is an integer operator, the <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> is converted to an integer.","pos":[26180,26292],"source":" If the result is an integer, or if the operator is an integer operator, the **real** is converted to an integer."},{"content":"If the result is a <bpt id=\"p1\">**</bpt>boolean<ept id=\"p1\">**</ept>, the <bpt id=\"p2\">**</bpt>real<ept id=\"p2\">**</ept> is converted to a <bpt id=\"p3\">**</bpt>boolean<ept id=\"p3\">**</ept>, and so on.","pos":[26293,26379],"source":" If the result is a **boolean**, the **real** is converted to a **boolean**, and so on."},{"content":"Additionally, the following explicit <bpt id=\"p1\">[</bpt>conversion functions<ept id=\"p1\">](xpp-conversion-run-time-functions.md)</ept> can be used: <bpt id=\"p2\">**</bpt>str2num<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>num2str<ept id=\"p3\">**</ept>.","pos":[26380,26519],"source":" Additionally, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **str2num** and **num2str**."},{"content":"Direct assignments between X++ <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> and Microsoft .NET Framework <bpt id=\"p2\">**</bpt>System.Decimal<ept id=\"p2\">**</ept> convert the value correctly.","pos":[26520,26636],"source":" Direct assignments between X++ **real** and Microsoft .NET Framework **System.Decimal** convert the value correctly."},{"content":"A call to a conversion function isn't required.","pos":[26637,26684]},{"content":"A <bpt id=\"p1\">*</bpt>decimal number<ept id=\"p1\">*</ept> is a floating-point value that consists of a sign, a numeric value where each digit is in the range 0 through 9, and a scaling factor that indicates the position of a floating decimal point that separates the integral and fractional parts of the numeric value.","pos":[26685,26964],"source":" A *decimal number* is a floating-point value that consists of a sign, a numeric value where each digit is in the range 0 through 9, and a scaling factor that indicates the position of a floating decimal point that separates the integral and fractional parts of the numeric value."},{"content":"The binary representation of a <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> value consists of a 1-bit sign, a 96-bit integer number, and a scaling factor.","pos":[26965,27083],"source":" The binary representation of a **real** value consists of a 1-bit sign, a 96-bit integer number, and a scaling factor."},{"content":"The scaling factor is used to divide the 96-bit integer and specify what part of it is a decimal fraction.","pos":[27084,27190]},{"content":"The scaling factor is implicitly the number 10 raised to an exponent in the range 0 through 28.","pos":[27191,27286]},{"content":"Therefore, the binary representation of a decimal value represents (<ph id=\"ph1\">\\[</ph>-2⁹⁶ through 2⁹⁶<ph id=\"ph2\">\\]</ph> ÷ 10(0<ph id=\"ph3\">\\\\</ph> through<ph id=\"ph4\">\\\\</ph> 28)), where -(2⁹⁶-1) is the minimum value that can be expressed and 2⁹⁶-1 is the maximum value.","pos":[27287,27490],"source":" Therefore, the binary representation of a decimal value represents (\\[-2⁹⁶ through 2⁹⁶\\] ÷ 10(0\\\\ through\\\\ 28)), where -(2⁹⁶-1) is the minimum value that can be expressed and 2⁹⁶-1 is the maximum value."},{"content":"<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> The type that is used to represent <bpt id=\"p2\">**</bpt>real<ept id=\"p2\">**</ept> values in Microsoft Dynamics 365 for Finance and Operations has changed from the interpreted X++ of Microsoft Dynamics AX 2012.","pos":[27491,27672],"source":"**Note:** The type that is used to represent **real** values in Microsoft Dynamics 365 for Finance and Operations has changed from the interpreted X++ of Microsoft Dynamics AX 2012."},{"content":"However, you don't have to rewrite any code, because the new type can express all the values that the old type could express.","pos":[27673,27798]},{"content":"We provide this material in the interest of full disclosure only.","pos":[27799,27864]},{"content":"All instances of the <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> type are now implemented as instances of the .NET decimal type (<bpt id=\"p2\">**</bpt>System.Decimal<ept id=\"p2\">**</ept>).","pos":[27865,27979],"source":" All instances of the **real** type are now implemented as instances of the .NET decimal type (**System.Decimal**)."},{"content":"Just as the <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> type in previous versions, the decimal type in a binary-coded decimal type is resilient to rounding errors.","pos":[27980,28108],"source":" Just as the **real** type in previous versions, the decimal type in a binary-coded decimal type is resilient to rounding errors."},{"content":"The range and resolution of the decimal type differ from previous versions.","pos":[28109,28184]},{"content":"The original X++ <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> type supported 16 digits and an exponent that defined the position of the decimal point.","pos":[28185,28299],"source":" The original X++ **real** type supported 16 digits and an exponent that defined the position of the decimal point."},{"content":"However, the X++ <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> type for Microsoft Dynamics 365 for Finance and Operations and later can represent decimal numbers in the range 79,228,162,514,264,337,593,543,950,335 (2⁹⁶-1) through -79,228,162,514,264,337,593,543,950,335 (-<ph id=\"ph1\">\\[</ph>2⁹⁶-1<ph id=\"ph2\">\\]</ph>).","pos":[28300,28546],"source":" However, the X++ **real** type for Microsoft Dynamics 365 for Finance and Operations and later can represent decimal numbers in the range 79,228,162,514,264,337,593,543,950,335 (2⁹⁶-1) through -79,228,162,514,264,337,593,543,950,335 (-\\[2⁹⁶-1\\])."},{"content":"Rounding is still required for the new <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> type.","pos":[28547,28600],"source":" Rounding is still required for the new **real** type."},{"content":"For example, the following code produces a result of 0.9999999999999999999999999999 instead of 1.","pos":[28601,28698]},{"content":"No number of decimals will suffice to represent the value of 1/3 accurately.","pos":[28699,28775]},{"content":"The discrepancy obtained here is due to the fact that only a finite number of decimals are provided.","pos":[28776,28876]},{"content":"You should use the <bpt id=\"p1\">**</bpt>round<ept id=\"p1\">**</ept> function to round to the number of decimals required.","pos":[28877,28959],"source":" You should use the **round** function to round to the number of decimals required."},{"pos":[29479,29492],"content":"real examples","linkify":"real examples","nodes":[{"content":"real examples","pos":[0,13]}]},{"pos":[31641,31644],"content":"str","linkify":"str","nodes":[{"content":"str","pos":[0,3]}]},{"content":"A <bpt id=\"p1\">**</bpt>str<ept id=\"p1\">**</ept> variable (a <bpt id=\"p2\">*</bpt>string<ept id=\"p2\">*</ept>) is a sequence of characters that are used as texts, help lines, addresses, telephone numbers, and so on.","pos":[31646,31782],"source":"A **str** variable (a *string*) is a sequence of characters that are used as texts, help lines, addresses, telephone numbers, and so on."},{"content":"To declare a string, use the <bpt id=\"p1\">**</bpt>str<ept id=\"p1\">**</ept> keyword.","pos":[31783,31828],"source":" To declare a string, use the **str** keyword."},{"content":"<bpt id=\"p1\">*</bpt>String literals<ept id=\"p1\">*</ept> are characters that are enclosed in quotation marks (\"\").","pos":[31829,31904],"source":"*String literals* are characters that are enclosed in quotation marks (\"\")."},{"content":"String literals can be used wherever string expressions are expected.","pos":[31905,31974]},{"content":"Examples of string literals include \"StringLit\" and \"Hello World\".","pos":[31975,32041]},{"content":"If you want the string to span more than one line, precede it with an at sign (@).","pos":[32042,32124]},{"content":"You can use strings in logical expressions, such as comparisons.","pos":[32125,32189]},{"content":"You can also concatenate strings by using the + operator.","pos":[32190,32247]},{"content":"The default value for a string is <bpt id=\"p1\">**</bpt>empty<ept id=\"p1\">**</ept>, and the internal representation is a list of characters.","pos":[32248,32349],"source":" The default value for a string is **empty**, and the internal representation is a list of characters."},{"content":"There are no automatic conversions for strings.","pos":[32350,32397]},{"content":"However, the following explicit <bpt id=\"p1\">[</bpt>conversion functions<ept id=\"p1\">](xpp-conversion-run-time-functions.md)</ept> can be used: <bpt id=\"p2\">**</bpt>str2int<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>str2int64<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>int2str<ept id=\"p4\">**</ept>, <bpt id=\"p5\">**</bpt>str2num<ept id=\"p5\">**</ept>, <bpt id=\"p6\">**</bpt>num2str<ept id=\"p6\">**</ept>, <bpt id=\"p7\">**</bpt>str2date<ept id=\"p7\">**</ept>, and <bpt id=\"p8\">**</bpt>date2str<ept id=\"p8\">**</ept>.","pos":[32398,32602],"source":" However, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **str2int**, **str2int64**, **int2str**, **str2num**, **num2str**, **str2date**, and **date2str**."},{"content":"A string can hold an unlimited number of characters.","pos":[32603,32655]},{"content":"However, you can specify the maximum length of a string in the variable declaration.","pos":[32656,32740]},{"content":"The string is then truncated to that maximum length.","pos":[32741,32793]},{"content":"An example is shown in the next section.","pos":[32794,32834]},{"pos":[32841,32853],"content":"str examples","linkify":"str examples","nodes":[{"content":"str examples","pos":[0,12]}]},{"pos":[33558,33567],"content":"timeOfDay","linkify":"timeOfDay","nodes":[{"content":"timeOfDay","pos":[0,9]}]},{"content":"The <bpt id=\"p1\">**</bpt>timeOfDay<ept id=\"p1\">**</ept> (time) data type is an integer value that represents the number of seconds that have passed since midnight.","pos":[33569,33694],"source":"The **timeOfDay** (time) data type is an integer value that represents the number of seconds that have passed since midnight."},{"content":"Like integers, <bpt id=\"p1\">**</bpt>timeOfDay<ept id=\"p1\">**</ept> variables can be used as literals.","pos":[33695,33758],"source":" Like integers, **timeOfDay** variables can be used as literals."},{"content":"Relational and arithmetic operators can be applied to <bpt id=\"p1\">**</bpt>timeOfDay<ept id=\"p1\">**</ept> variables.","pos":[33759,33837],"source":" Relational and arithmetic operators can be applied to **timeOfDay** variables."},{"content":"A <bpt id=\"p1\">**</bpt>timeOfDay<ept id=\"p1\">**</ept> variable can also be used in expressions.","pos":[33838,33895],"source":" A **timeOfDay** variable can also be used in expressions."},{"content":"The range of a <bpt id=\"p1\">**</bpt>timeOfDay<ept id=\"p1\">**</ept> data type is in the closed interval <ph id=\"ph1\">\\[</ph>0; 86,400<ph id=\"ph2\">\\]</ph>.","pos":[33896,33975],"source":" The range of a **timeOfDay** data type is in the closed interval \\[0; 86,400\\]."},{"content":"Values above 86,400 (23:59:59) can't be interpreted.","pos":[33976,34028]},{"content":"A <bpt id=\"p1\">**</bpt>timeOfDay<ept id=\"p1\">**</ept> variable is automatically converted to a <bpt id=\"p2\">**</bpt>boolean<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>enum<ept id=\"p3\">**</ept>, or <bpt id=\"p4\">**</bpt>real<ept id=\"p4\">**</ept>.","pos":[34029,34121],"source":" A **timeOfDay** variable is automatically converted to a **boolean**, **enum**, or **real**."},{"content":"Additionally, the following explicit <bpt id=\"p1\">[</bpt>conversion functions<ept id=\"p1\">](xpp-conversion-run-time-functions.md)</ept> can be used: <bpt id=\"p2\">**</bpt>str2time<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>time2str<ept id=\"p3\">**</ept>.","pos":[34122,34263],"source":" Additionally, the following explicit [conversion functions](xpp-conversion-run-time-functions.md) can be used: **str2time** and **time2str**."},{"pos":[34270,34288],"content":"timeOfDay examples","linkify":"timeOfDay examples","nodes":[{"content":"timeOfDay examples","pos":[0,18]}]},{"pos":[34545,34556],"content":"utcdatetime","linkify":"utcdatetime","nodes":[{"content":"utcdatetime","pos":[0,11]}]},{"content":"The <bpt id=\"p1\">**</bpt>utcdatetime<ept id=\"p1\">**</ept> data type combines the <bpt id=\"p2\">**</bpt>date<ept id=\"p2\">**</ept> type and the <bpt id=\"p3\">**</bpt>timeOfDay<ept id=\"p3\">**</ept> type.","pos":[34558,34642],"source":"The **utcdatetime** data type combines the **date** type and the **timeOfDay** type."},{"content":"A <bpt id=\"p1\">**</bpt>utcdatetime<ept id=\"p1\">**</ept> variable also holds information about the time zone.","pos":[34643,34713],"source":" A **utcdatetime** variable also holds information about the time zone."},{"content":"However, this information can't be accessed in code.","pos":[34714,34766]},{"content":"The format for a <bpt id=\"p1\">**</bpt>utcdatetime<ept id=\"p1\">**</ept> literal is <bpt id=\"p2\">**</bpt>yyyy-mm-ddThh:mm:ss<ept id=\"p2\">**</ept>.","pos":[34767,34835],"source":" The format for a **utcdatetime** literal is **yyyy-mm-ddThh:mm:ss**."},{"content":"The uppercase \"T\" is required.","pos":[34836,34866]},{"content":"This format can be written without quotation marks.","pos":[34867,34918]},{"content":"The minimum value is <bpt id=\"p1\">**</bpt>1900-01-01T00:00:00<ept id=\"p1\">**</ept>, and the maximum value is <bpt id=\"p2\">**</bpt>1900-01-01T00:00:00<ept id=\"p2\">**</ept>.","pos":[34919,35014],"source":" The minimum value is **1900-01-01T00:00:00**, and the maximum value is **1900-01-01T00:00:00**."},{"content":"This maximum value matches the upper range of <bpt id=\"p1\">**</bpt>date<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>timeOfDay<ept id=\"p2\">**</ept>.","pos":[35015,35088],"source":" This maximum value matches the upper range of **date** and **timeOfDay**."},{"content":"The smallest unit of time in <bpt id=\"p1\">**</bpt>utcdatetime<ept id=\"p1\">**</ept> is one second.","pos":[35089,35148],"source":" The smallest unit of time in **utcdatetime** is one second."},{"content":"A <bpt id=\"p1\">**</bpt>utcdatetime<ept id=\"p1\">**</ept> variable that has been declared but hasn't been initialized has the default value <bpt id=\"p2\">**</bpt>1900-01-01T00:00:00<ept id=\"p2\">**</ept>.","pos":[35149,35273],"source":" A **utcdatetime** variable that has been declared but hasn't been initialized has the default value **1900-01-01T00:00:00**."},{"content":"This value is the value that is returned by <bpt id=\"p1\">**</bpt>DateTimeUtil::minValue()<ept id=\"p1\">**</ept>.","pos":[35274,35347],"source":" This value is the value that is returned by **DateTimeUtil::minValue()**."},{"content":"Some functions treat an input parameter of this minimum value as <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept>.","pos":[35348,35422],"source":" Some functions treat an input parameter of this minimum value as **null**."},{"content":"For example, the <bpt id=\"p1\">**</bpt>DateTimeUtil::toStr<ept id=\"p1\">**</ept> method returns an empty string.","pos":[35423,35495],"source":" For example, the **DateTimeUtil::toStr** method returns an empty string."},{"content":"However, the <bpt id=\"p1\">**</bpt>DateTimeUtil::addSeconds<ept id=\"p1\">**</ept> method returns a usable <bpt id=\"p2\">**</bpt>utcdatetime<ept id=\"p2\">**</ept> value.","pos":[35496,35584],"source":" However, the **DateTimeUtil::addSeconds** method returns a usable **utcdatetime** value."},{"content":"There are no implicit conversions for the <bpt id=\"p1\">**</bpt>utcdatetime<ept id=\"p1\">**</ept> data type.","pos":[35585,35653],"source":" There are no implicit conversions for the **utcdatetime** data type."},{"content":"The <bpt id=\"p1\">**</bpt>DateTimeUtil<ept id=\"p1\">**</ept> class provides many methods that you can use to manipulate <bpt id=\"p2\">**</bpt>utcdatetime<ept id=\"p2\">**</ept> values.","pos":[35654,35757],"source":" The **DateTimeUtil** class provides many methods that you can use to manipulate **utcdatetime** values."},{"content":"The following explicit <bpt id=\"p1\">[</bpt>conversion functions<ept id=\"p1\">](xpp-conversion-run-time-functions.md)</ept> can also be used: <bpt id=\"p2\">**</bpt>str2datetime<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>datetime2str<ept id=\"p3\">**</ept>.","pos":[35758,35898],"source":" The following explicit [conversion functions](xpp-conversion-run-time-functions.md) can also be used: **str2datetime** and **datetime2str**."},{"content":"Additionally, the <bpt id=\"p1\">**</bpt>Global<ept id=\"p1\">**</ept> class provides the <bpt id=\"p2\">**</bpt>utcDateTime2SystemDateTime<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>CLRSystemDateTime2UtcDateTime<ept id=\"p3\">**</ept> conversion methods to support common language runtime (CLR) interop.","pos":[35899,36084],"source":" Additionally, the **Global** class provides the **utcDateTime2SystemDateTime** and **CLRSystemDateTime2UtcDateTime** conversion methods to support common language runtime (CLR) interop."},{"content":"Comparison operators are the only type of operators that can be used with the <bpt id=\"p1\">**</bpt>utcdatetime<ept id=\"p1\">**</ept> data type.","pos":[36085,36189],"source":" Comparison operators are the only type of operators that can be used with the **utcdatetime** data type."},{"content":"The following operators can be used to compare two <bpt id=\"p1\">**</bpt>utcdatetime<ept id=\"p1\">**</ept> values: !=, <ph id=\"ph1\">&amp;lt;</ph>, <ph id=\"ph2\">&amp;lt;</ph>=, ==, <ph id=\"ph3\">&amp;gt;</ph>, and <ph id=\"ph4\">&amp;gt;</ph>=.","pos":[36190,36302],"source":" The following operators can be used to compare two **utcdatetime** values: !=, &lt;, &lt;=, ==, &gt;, and &gt;=."},{"content":"When you add a <bpt id=\"p1\">**</bpt>utcdatetime<ept id=\"p1\">**</ept> field to a table, we recommend that you base the field on an EDT.","pos":[36303,36399],"source":" When you add a **utcdatetime** field to a table, we recommend that you base the field on an EDT."},{"pos":[36406,36426],"content":"utcdatetime examples","linkify":"utcdatetime examples","nodes":[{"content":"utcdatetime examples","pos":[0,20]}]},{"pos":[36887,36907],"content":"Composite data types","linkify":"Composite data types","nodes":[{"content":"Composite data types","pos":[0,20]}]},{"content":"The composite data types in X++ are arrays, containers, classes as data types, delegates as data types, and tables as data types.","pos":[36908,37037]},{"pos":[37043,37048],"content":"Array","linkify":"Array","nodes":[{"content":"Array","pos":[0,5]}]},{"content":"An <bpt id=\"p1\">*</bpt>array<ept id=\"p1\">*</ept> is a variable that contains a list of items that have the same data type.","pos":[37050,37134],"source":"An *array* is a variable that contains a list of items that have the same data type."},{"content":"The elements of an array are accessed by using integer indexes.","pos":[37135,37198]},{"content":"You use a separate statement to initialize each element in an array.","pos":[37199,37267]},{"content":"When you use a container data type or an array object to create a collection, you can initialize multiple elements by using a single statement.","pos":[37268,37411]},{"content":"By default, all the items in an array have the default value of the data type in the array.","pos":[37412,37503]},{"content":"There are three kinds of arrays: <bpt id=\"p1\">*</bpt>dynamic arrays<ept id=\"p1\">*</ept>, <bpt id=\"p2\">*</bpt>fixed-length arrays<ept id=\"p2\">*</ept>, and <bpt id=\"p3\">*</bpt>partly on disk arrays<ept id=\"p3\">*</ept>.","pos":[37504,37606],"source":" There are three kinds of arrays: *dynamic arrays*, *fixed-length arrays*, and *partly on disk arrays*."},{"content":"<bpt id=\"p1\">**</bpt>Dynamic arrays<ept id=\"p1\">**</ept> – These arrays are declared by using an empty array option.","pos":[37612,37690],"source":"**Dynamic arrays** – These arrays are declared by using an empty array option."},{"content":"In other word, they have only brackets (<ph id=\"ph1\">\\[</ph><ph id=\"ph2\">\\]</ph>).","pos":[37691,37737],"source":" In other word, they have only brackets (\\[\\])."},{"content":"<bpt id=\"p1\">**</bpt>Fixed-length arrays<ept id=\"p1\">**</ept> – These arrays can hold the number of items that is specified in the declaration.","pos":[37742,37847],"source":"**Fixed-length arrays** – These arrays can hold the number of items that is specified in the declaration."},{"content":"Fixed-length arrays are declared like dynamic arrays, but a length option is included in the brackets.","pos":[37848,37950]},{"content":"<bpt id=\"p1\">**</bpt>Partly on disk arrays<ept id=\"p1\">**</ept> – These arrays are declared as either dynamic arrays or fixed-length arrays that have an extra option that declares how many items should be held in memory.","pos":[37955,38137],"source":"**Partly on disk arrays** – These arrays are declared as either dynamic arrays or fixed-length arrays that have an extra option that declares how many items should be held in memory."},{"content":"The other items are stored on disk and are automatically loaded when they are referenced.","pos":[38138,38227]},{"content":"X++ supports only one-dimensional arrays.","pos":[38229,38270]},{"content":"However, you can mimic the behavior of multiple array indexes.","pos":[38271,38333]},{"content":"(For more information, see the \"Multiple array indexes\" section).","pos":[38334,38399]},{"content":"Variables in objects and tables can be declared as arrays.","pos":[38400,38458]},{"content":"For example, this functionality is used in address lines in the standard application.","pos":[38459,38544]},{"content":"An array collection class lets you store objects in an array.","pos":[38545,38606]},{"content":"Array indexes begin at 1.","pos":[38607,38632]},{"content":"The first item in the array is referenced as <ph id=\"ph1\">\\[</ph>1<ph id=\"ph2\">\\]</ph>, the second item is referenced as <ph id=\"ph3\">\\[</ph>2<ph id=\"ph4\">\\]</ph>, and so on.","pos":[38633,38735],"source":" The first item in the array is referenced as \\[1\\], the second item is referenced as \\[2\\], and so on."},{"content":"The following syntax is used to access an array element: <bpt id=\"p1\">**</bpt>ArrayItemReference = ArrayVariable <ph id=\"ph1\">\\[</ph> Index <ph id=\"ph2\">\\]</ph><ept id=\"p1\">**</ept>.","pos":[38736,38844],"source":" The following syntax is used to access an array element: **ArrayItemReference = ArrayVariable \\[ Index \\]**."},{"content":"In this syntax, <bpt id=\"p1\">**</bpt>ArrayVariable<ept id=\"p1\">**</ept> is the identifier of the array, and <bpt id=\"p2\">**</bpt>Index<ept id=\"p2\">**</ept> is the number of the array element.","pos":[38845,38960],"source":" In this syntax, **ArrayVariable** is the identifier of the array, and **Index** is the number of the array element."},{"content":"<bpt id=\"p1\">**</bpt>Index<ept id=\"p1\">**</ept> can be an integer expression.","pos":[38961,39000],"source":"**Index** can be an integer expression."},{"content":"Item zero <ph id=\"ph1\">\\[</ph>0<ph id=\"ph2\">\\]</ph> is used to clear the array.","pos":[39001,39044],"source":" Item zero \\[0\\] is used to clear the array."},{"content":"If a value is assigned to index 0 in an array, all elements in the array are reset to their default value.","pos":[39045,39151]},{"pos":[39158,39172],"content":"Array examples","linkify":"Array examples","nodes":[{"content":"Array examples","pos":[0,14]}]},{"pos":[40370,40392],"content":"Multiple array indexes","linkify":"Multiple array indexes","nodes":[{"content":"Multiple array indexes","pos":[0,22]}]},{"content":"Some languages, such as C++ and C<ph id=\"ph1\">\\#</ph>, let you declare arrays that have more than one index.","pos":[40394,40484],"source":"Some languages, such as C++ and C\\#, let you declare arrays that have more than one index."},{"content":"In other words, you can define \"arrays of arrays.\"","pos":[40485,40535]},{"content":"In X++, you can't directly create multiple array indexes, because only one-dimensional arrays are supported.","pos":[40536,40644]},{"content":"However, you can implement multiple indexes by using the method that is described in this section.","pos":[40645,40743]},{"content":"For example, you want to declare an array that has two dimensions, to hold an amount that is earned by country by dimension.","pos":[40744,40868]},{"content":"There are 10 countries and three dimensions.","pos":[40869,40913]},{"content":"In C++ and C<ph id=\"ph1\">\\#</ph>, you declare the following array.","pos":[40914,40962],"source":" In C++ and C\\#, you declare the following array."},{"content":"However, X++ doesn't support this declaration.","pos":[41035,41081]},{"content":"Instead, you can define a one-dimensional array where the number of elements is the product of the elements in each dimension.","pos":[41082,41208]},{"content":"Here is an example.","pos":[41209,41228]},{"pos":[42372,42381],"content":"Container","linkify":"Container","nodes":[{"content":"Container","pos":[0,9]}]},{"content":"A <bpt id=\"p1\">*</bpt>container<ept id=\"p1\">*</ept> object is a dynamic list of items that contain primitive data types or composite data types.","pos":[42383,42489],"source":"A *container* object is a dynamic list of items that contain primitive data types or composite data types."},{"content":"A container is useful when you must pass various types of values between the client and server tiers.","pos":[42490,42591]},{"content":"However, if you plan to repeatedly add to a list in a loop, a container isn't a good choice.","pos":[42592,42684]},{"content":"Containers are most suitable for processes that don't involve excessive modification to the size or contents of the container.","pos":[42685,42811]},{"content":"When a container undergoes excessive additions of data, overall system performance can decrease, because container data must be repeatedly copied, and new space must be repeatedly allocated.","pos":[42812,43002]},{"content":"A container isn't a class.","pos":[43003,43029]},{"content":"A container contains an ordered sequence of primitive values or other containers.","pos":[43030,43111]},{"content":"Because of the flexibility of <bpt id=\"p1\">**</bpt>anytype<ept id=\"p1\">**</ept>, a container offers a good way to store values of different types together.","pos":[43112,43229],"source":" Because of the flexibility of **anytype**, a container offers a good way to store values of different types together."},{"content":"A container can be stored in the database.","pos":[43230,43272]},{"content":"A container is one of the column types that you can select when you use Application Explorer to add a column to a table.","pos":[43273,43393]},{"content":"A container slightly resembles an array, or collections such as the <bpt id=\"p1\">**</bpt>List<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>Stack<ept id=\"p2\">**</ept> classes.","pos":[43394,43492],"source":" A container slightly resembles an array, or collections such as the **List** or **Stack** classes."},{"content":"However, you can never change the size or content of a container after the container is created.","pos":[43493,43589]},{"content":"X++ statements that appear to modify a container are internally building a new container and copying values as required.","pos":[43590,43710]},{"content":"Even an assignment of a container to another container variable creates a new copy of the container.","pos":[43711,43811]},{"content":"All these operations can affect performance.","pos":[43812,43856]},{"content":"In the functions that provide access to a container (such as <bpt id=\"p1\">**</bpt>conPeek<ept id=\"p1\">**</ept>), the container is 1-based, not 0-based.","pos":[43857,43970],"source":" In the functions that provide access to a container (such as **conPeek**), the container is 1-based, not 0-based."},{"content":"Indexing is 1-based for arrays.","pos":[43971,44002]},{"content":"The default value of a container is <bpt id=\"p1\">**</bpt>empty<ept id=\"p1\">**</ept>.","pos":[44003,44049],"source":" The default value of a container is **empty**."},{"content":"The container doesn't contain any values.","pos":[44050,44091]},{"content":"Some statements that use containers might appear to modify a container.","pos":[44092,44163]},{"content":"However, inside the system, containers are never modified.","pos":[44164,44222]},{"content":"Instead, the data from the original container is combined with data from the command to build a new container.","pos":[44223,44333]},{"content":"You can create a new container by using one of the following functions: <bpt id=\"p1\">**</bpt>conDel<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>conIns<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>conPoke<ept id=\"p3\">**</ept>.","pos":[44334,44445],"source":" You can create a new container by using one of the following functions: **conDel**, **conIns**, or **conPoke**."},{"content":"Additionally, the <bpt id=\"p1\">**</bpt>Global<ept id=\"p1\">**</ept> class has static methods for handling containers.","pos":[44446,44524],"source":" Additionally, the **Global** class has static methods for handling containers."},{"content":"These methods include <bpt id=\"p1\">**</bpt>con2ArraySource<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>con2Buf<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>con2List<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>con2Str<ept id=\"p4\">**</ept>, <bpt id=\"p5\">**</bpt>containerFromXmlNode<ept id=\"p5\">**</ept>, <bpt id=\"p6\">**</bpt>conView<ept id=\"p6\">**</ept>, and <bpt id=\"p7\">**</bpt>str2Con<ept id=\"p7\">**</ept>.","pos":[44525,44663],"source":" These methods include **con2ArraySource**, **con2Buf**, **con2List**, **con2Str**, **containerFromXmlNode**, **conView**, and **str2Con**."},{"content":"There are several intrinsic functions for handling a container, such as <bpt id=\"p1\">**</bpt>conIns<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>conPeek<ept id=\"p2\">**</ept>.","pos":[44664,44763],"source":" There are several intrinsic functions for handling a container, such as **conIns** and **conPeek**."},{"content":"The X++ <bpt id=\"p1\">**</bpt>conPeek<ept id=\"p1\">**</ept> function returns an <bpt id=\"p2\">**</bpt>anytype<ept id=\"p2\">**</ept> type.","pos":[44764,44821],"source":" The X++ **conPeek** function returns an **anytype** type."},{"content":"Therefore, it's easier to read the values from a container when you don't know the type of each value.","pos":[44822,44924]},{"content":"An <bpt id=\"p1\">**</bpt>anytype<ept id=\"p1\">**</ept> can be assigned to any X++ value type, provided that the value can be converted.","pos":[44925,45020],"source":" An **anytype** can be assigned to any X++ value type, provided that the value can be converted."},{"content":"Your code is easier to read when it avoids explicit data type conversions.","pos":[45021,45095]},{"content":"Therefore, assign values from a container to the same data type that was used to put the value into the container.","pos":[45096,45210]},{"content":"You must not assign a container to an <bpt id=\"p1\">**</bpt>anytype<ept id=\"p1\">**</ept>, because the system might not be able to determine the correct conversions.","pos":[45211,45336],"source":" You must not assign a container to an **anytype**, because the system might not be able to determine the correct conversions."},{"content":"In these cases, unexpected behavior or errors might occur.","pos":[45337,45395]},{"pos":[45402,45438],"content":"Comparing container to other options","linkify":"Comparing container to other options","nodes":[{"content":"Comparing container to other options","pos":[0,36]}]},{"content":"The <bpt id=\"p1\">**</bpt>container<ept id=\"p1\">**</ept> type resembles other constructs, such as arrays and collection classes such as <bpt id=\"p2\">**</bpt>List<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>Stack<ept id=\"p3\">**</ept>.","pos":[45440,45560],"source":"The **container** type resembles other constructs, such as arrays and collection classes such as **List** and **Stack**."},{"content":"The difference between a container and <bpt id=\"p1\">**</bpt>List<ept id=\"p1\">**</ept> is that an instance of the <bpt id=\"p2\">**</bpt>List<ept id=\"p2\">**</ept> class is mutable.","pos":[45561,45662],"source":" The difference between a container and **List** is that an instance of the **List** class is mutable."},{"content":"A <bpt id=\"p1\">**</bpt>List<ept id=\"p1\">**</ept> object first allocates more space than its data consumes.","pos":[45663,45731],"source":" A **List** object first allocates more space than its data consumes."},{"content":"Then, as data is added, the space is filled.","pos":[45732,45776]},{"content":"This behavior is more efficient than allocating more space every time that an element is added.","pos":[45777,45872]},{"content":"An update of a <bpt id=\"p1\">**</bpt>List<ept id=\"p1\">**</ept> performs faster than similar operations on a container.","pos":[45873,45952],"source":" An update of a **List** performs faster than similar operations on a container."},{"content":"When you construct a <bpt id=\"p1\">**</bpt>List<ept id=\"p1\">**</ept> object, you determine the one type of data that the <bpt id=\"p2\">**</bpt>List<ept id=\"p2\">**</ept> object can store.","pos":[45953,46061],"source":" When you construct a **List** object, you determine the one type of data that the **List** object can store."},{"content":"This restriction is less flexible for a <bpt id=\"p1\">**</bpt>List<ept id=\"p1\">**</ept> than it is for a container.","pos":[46062,46138],"source":" This restriction is less flexible for a **List** than it is for a container."},{"content":"However, you can store objects in a <bpt id=\"p1\">**</bpt>List<ept id=\"p1\">**</ept>, whereas a container can store only value types.","pos":[46139,46232],"source":" However, you can store objects in a **List**, whereas a container can store only value types."},{"content":"The difference between a container and an array is that an array can hold only items of its declared type.","pos":[46233,46339]},{"content":"You can allocate memory space for an array and fill that space with values later.","pos":[46340,46421]},{"content":"For example, you can fill in values in a loop.","pos":[46422,46468]},{"content":"This behavior is efficient and performs well.","pos":[46469,46514]},{"content":"When you want to build a new container by appending new data, you can use either the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">+=</ph><ept id=\"p1\">**</ept> operator or the <bpt id=\"p2\">**</bpt>conIns<ept id=\"p2\">**</ept> function.","pos":[46515,46643],"source":" When you want to build a new container by appending new data, you can use either the **+=** operator or the **conIns** function."},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">+=</ph><ept id=\"p1\">**</ept> operator is the faster alternative.","pos":[46644,46690],"source":" The **+=** operator is the faster alternative."},{"content":"Use the <bpt id=\"p1\">**</bpt>conIns<ept id=\"p1\">**</ept> function only when you want to add new data before the last index of the original data.","pos":[46691,46797],"source":" Use the **conIns** function only when you want to add new data before the last index of the original data."},{"content":"In Dynamics AX 2012, although you could use the X++ compiler to store object references in containers, the result would fail at run time.","pos":[46798,46935]},{"content":"However, in Microsoft Dynamics 365 for Finance and Operations, when the compiler sees an attempt to store an object reference in a container, it issues an error message.","pos":[46936,47105]},{"content":"If the type of the element that is added to the container is <bpt id=\"p1\">**</bpt>anytype<ept id=\"p1\">**</ept>, the compiler can’t determine whether the value is a reference type.","pos":[47106,47247],"source":" If the type of the element that is added to the container is **anytype**, the compiler can’t determine whether the value is a reference type."},{"content":"In this case, the compiler allows the attempt.","pos":[47248,47294]},{"content":"It's assumed that the user knows what he or she is doing.","pos":[47295,47352]},{"content":"Although the compiler doesn't diagnose the code as erroneous, an error will be thrown at run time.","pos":[47353,47451]},{"pos":[47458,47476],"content":"Container examples","linkify":"Container examples","nodes":[{"content":"Container examples","pos":[0,18]}]},{"pos":[51042,51063],"content":"Classes as data types","linkify":"Classes as data types","nodes":[{"content":"Classes as data types","pos":[0,21]}]},{"content":"A <bpt id=\"p1\">*</bpt>class<ept id=\"p1\">*</ept> is a type definition that describes both variables and methods for instances of the class.","pos":[51065,51165],"source":"A *class* is a type definition that describes both variables and methods for instances of the class."},{"content":"(The instances of a class are also known as <bpt id=\"p1\">*</bpt>objects<ept id=\"p1\">*</ept>.) A class is only a definition for objects, and all objects are <bpt id=\"p2\">**</bpt>null<ept id=\"p2\">**</ept> when they are declared.","pos":[51166,51316],"source":" (The instances of a class are also known as *objects*.) A class is only a definition for objects, and all objects are **null** when they are declared."},{"content":"In Application Explorer, every application class under the <bpt id=\"p1\">**</bpt>Classes<ept id=\"p1\">**</ept> node is a data type.","pos":[51317,51408],"source":" In Application Explorer, every application class under the **Classes** node is a data type."},{"content":"You can declare variables of these types in your code.","pos":[51409,51463]},{"content":"You can construct instances of a class and assign the instances to variables.","pos":[51464,51541]},{"content":"Classes can be nested in source code.","pos":[51542,51579]},{"content":"Nested classes are available only inside forms (such as a class that extends <bpt id=\"p1\">**</bpt>FormRun<ept id=\"p1\">**</ept>), and are used to represent controls, data sources, or data fields.","pos":[51580,51736],"source":" Nested classes are available only inside forms (such as a class that extends **FormRun**), and are used to represent controls, data sources, or data fields."},{"content":"An attribute decoration, such as the attribute decoration on a class or a method, can omit the suffix of the attribute name if the suffix is <bpt id=\"p1\">**</bpt>Attribute<ept id=\"p1\">**</ept>.","pos":[51737,51892],"source":" An attribute decoration, such as the attribute decoration on a class or a method, can omit the suffix of the attribute name if the suffix is **Attribute**."},{"content":"Therefore, X++ allows <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\[</ph>MyFavorite<ph id=\"ph2\">\\]</ph><ept id=\"p1\">**</ept> instead of requiring <bpt id=\"p2\">**</bpt><ph id=\"ph3\">\\[</ph>MyFavoriteAttribute<ph id=\"ph4\">\\]</ph><ept id=\"p2\">**</ept>.","pos":[51893,51983],"source":" Therefore, X++ allows **\\[MyFavorite\\]** instead of requiring **\\[MyFavoriteAttribute\\]**."},{"content":"Additionally, attributes are now applied to the handlers of delegates and methods, to map the handlers to those targets.","pos":[51984,52104]},{"content":"In AX 2012 and earlier versions, you could designate a method to run on either the client or the server.","pos":[52105,52209]},{"content":"However, in Microsoft Dynamics 365 for Finance and Operations and later versions, all compiled X++ code is run as .NET Common Intermediate Language (CIL) on the server.","pos":[52210,52378]},{"content":"There is no longer any code that is evaluated at the client site or in the browser.","pos":[52379,52462]},{"content":"Therefore, the <bpt id=\"p1\">**</bpt>client<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>server<ept id=\"p2\">**</ept> keywords are now ignored.","pos":[52463,52529],"source":" Therefore, the **client** and **server** keywords are now ignored."},{"content":"Although these keywords don't cause a compile error if they are used, they should not be used in any new code.","pos":[52530,52640]},{"pos":[52647,52685],"content":"Private and protected member variables","linkify":"Private and protected member variables","nodes":[{"content":"Private and protected member variables","pos":[0,38]}]},{"content":"Previously, all member variables that were defined in a class were protected.","pos":[52687,52764]},{"content":"You can now make the visibility of member variables explicit by adding the <bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>protected<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>public<ept id=\"p3\">**</ept> keywords.","pos":[52765,52892],"source":" You can now make the visibility of member variables explicit by adding the **private**, **protected**, and **public** keywords."},{"content":"The interpretation of these modifiers is obvious and is aligned with the semantics for methods:","pos":[52893,52988]},{"pos":[52994,53081],"content":"<bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept> – The member variable can be used only within the class where it’s defined.","source":"**private** – The member variable can be used only within the class where it’s defined."},{"pos":[53086,53199],"content":"<bpt id=\"p1\">**</bpt>protected<ept id=\"p1\">**</ept> – The member variable can be used in the class where it’s defined and all subclasses of that class.","source":"**protected** – The member variable can be used in the class where it’s defined and all subclasses of that class."},{"content":"<bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> – The member variable can be used anywhere.","pos":[53204,53258],"source":"**public** – The member variable can be used anywhere."},{"content":"It’s visible outside the confines of the class hierarchy where it’s defined.","pos":[53259,53335]},{"content":"By default, member variables that aren’t adorned with an explicit modifier are still protected.","pos":[53337,53432]},{"content":"However, as a best practice, you should explicitly specify the visibility.","pos":[53433,53507]},{"content":"As we described earlier, when a member variable is defined as <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept>, it can be accessed outside the class where it’s defined.","pos":[53508,53638],"source":" As we described earlier, when a member variable is defined as **public**, it can be accessed outside the class where it’s defined."},{"content":"In this case, you must specify a qualifier that designates the object that is hosting the variable.","pos":[53639,53738]},{"content":"To specify the qualifier, use the dot notation, as you do for method calls.","pos":[53739,53814]},{"content":"In the following example, <bpt id=\"p1\">**</bpt>field1<ept id=\"p1\">**</ept> is accessed by using the explicit <bpt id=\"p2\">**</bpt>this<ept id=\"p2\">**</ept> qualifier.","pos":[53815,53905],"source":" In the following example, **field1** is accessed by using the explicit **this** qualifier."},{"content":"In this case, it might not be a good idea to make a member variable public, because that approach exposes the internal workings of the class to its consumers, and therefore creates a strong dependency between the class implementation and its consumers.","pos":[53906,54158]},{"content":"You should always try to depend only on a contract, not an implementation.","pos":[54159,54233]},{"pos":[54486,54523],"content":"Static constructors and static fields","linkify":"Static constructors and static fields","nodes":[{"content":"Static constructors and static fields","pos":[0,37]}]},{"content":"<bpt id=\"p1\">*</bpt>Static fields<ept id=\"p1\">*</ept> are fields that are declared by using the <bpt id=\"p2\">**</bpt>static<ept id=\"p2\">**</ept> keyword.","pos":[54525,54602],"source":"*Static fields* are fields that are declared by using the **static** keyword."},{"content":"Conceptually, static fields apply to the class, not to instances of the class.","pos":[54603,54681]},{"content":"Static constructors are guaranteed to run before any static calls or instance calls are made to the class.","pos":[54682,54788]},{"content":"The execution of the static constructor is relative to the user’s session.","pos":[54789,54863]},{"content":"You never call the static constructor explicitly.","pos":[54864,54913]},{"content":"Instead, the compiler will generate code to make sure that the constructor is called exactly one time, before any other method on the class is called.","pos":[54914,55064]},{"content":"A static constructor is used to initialize any static data or perform an action that must be performed only one time.","pos":[55065,55182]},{"content":"You can't provide parameters for the static constructor, and it must be marked with the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> keyword.","pos":[55183,55290],"source":" You can't provide parameters for the static constructor, and it must be marked with the **static** keyword."},{"pos":[56000,56038],"content":"Class elements in Application Explorer","linkify":"Class elements in Application Explorer","nodes":[{"content":"Class elements in Application Explorer","pos":[0,38]}]},{"content":"Under most class nodes in Application Explorer, there are two special nodes: a <bpt id=\"p1\">**</bpt>classDeclaration<ept id=\"p1\">**</ept> node and a <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> node.","pos":[56040,56164],"source":"Under most class nodes in Application Explorer, there are two special nodes: a **classDeclaration** node and a **new** node."},{"content":"A <bpt id=\"p1\">**</bpt>classDeclaration<ept id=\"p1\">**</ept> always contains the X++ <bpt id=\"p2\">**</bpt>class<ept id=\"p2\">**</ept> keyword.","pos":[56165,56230],"source":" A **classDeclaration** always contains the X++ **class** keyword."},{"content":"Additional keywords, such as <bpt id=\"p1\">**</bpt>extends<ept id=\"p1\">**</ept>, can be included to modify the class.","pos":[56231,56309],"source":" Additional keywords, such as **extends**, can be included to modify the class."},{"content":"This node can also contain declarations of member variables.","pos":[56310,56370]},{"content":"The member variables can't be initialized to a value in <bpt id=\"p1\">**</bpt>classDeclaration<ept id=\"p1\">**</ept>, and they can't be static.","pos":[56371,56474],"source":" The member variables can't be initialized to a value in **classDeclaration**, and they can't be static."},{"content":"In the following example, the variables <bpt id=\"p1\">**</bpt>m<ph id=\"ph1\">\\_</ph>priority<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>m<ph id=\"ph2\">\\_</ph>rectangle<ept id=\"p2\">**</ept> are members of the class.","pos":[56475,56577],"source":" In the following example, the variables **m\\_priority** and **m\\_rectangle** are members of the class."},{"content":"A <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator contains logic that is run when the <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> operator is used to create an instance of the class.","pos":[56869,56984],"source":"A **new** operator contains logic that is run when the **new** operator is used to create an instance of the class."},{"content":"The logic in the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method might construct an object and assign that object to a variable that is declared in the <bpt id=\"p2\">**</bpt>classDeclaration<ept id=\"p2\">**</ept>.","pos":[56985,57125],"source":" The logic in the **new** method might construct an object and assign that object to a variable that is declared in the **classDeclaration**."},{"content":"Each class can have only one <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method.","pos":[57126,57170],"source":" Each class can have only one **new** method."},{"content":"However, in the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method, you often should call the <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> method of the base class.","pos":[57171,57262],"source":" However, in the **new** method, you often should call the **new** method of the base class."},{"content":"To call the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method of the base class, call <bpt id=\"p2\">**</bpt>super()<ept id=\"p2\">**</ept>.","pos":[57263,57326],"source":" To call the **new** method of the base class, call **super()**."},{"content":"The following example shows the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method for the <bpt id=\"p2\">**</bpt>YourDerivedClass<ept id=\"p2\">**</ept> class in the previous <bpt id=\"p3\">**</bpt>classDeclaration<ept id=\"p3\">**</ept> example.","pos":[57327,57454],"source":" The following example shows the **new** method for the **YourDerivedClass** class in the previous **classDeclaration** example."},{"content":"In this <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method, the code constructs an instance of the <bpt id=\"p2\">**</bpt>Rectangle<ept id=\"p2\">**</ept> class.","pos":[57455,57538],"source":" In this **new** method, the code constructs an instance of the **Rectangle** class."},{"content":"The instance is assigned to the <bpt id=\"p1\">**</bpt>m<ph id=\"ph1\">\\_</ph>rectangle<ept id=\"p1\">**</ept> variable.","pos":[57539,57597],"source":" The instance is assigned to the **m\\_rectangle** variable."},{"content":"The <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> keyword that is used in the example is optional.","pos":[57598,57659],"source":" The **this** keyword that is used in the example is optional."},{"content":"However, if you include it, IntelliSense might be more helpful.","pos":[57660,57723]},{"pos":[57920,57938],"content":"Garbage collection","linkify":"Garbage collection","nodes":[{"content":"Garbage collection","pos":[0,18]}]},{"content":"Eventually during run time, most objects no longer have any variable that points to them.","pos":[57940,58029]},{"content":"The system scans for these objects and erases them from memory.","pos":[58030,58093]},{"content":"The memory space then becomes available for other uses.","pos":[58094,58149]},{"content":"The <bpt id=\"p1\">**</bpt>Object<ept id=\"p1\">**</ept> class has a method that is named <bpt id=\"p2\">**</bpt>finalize<ept id=\"p2\">**</ept>.","pos":[58150,58211],"source":" The **Object** class has a method that is named **finalize**."},{"content":"However, the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method isn't a destructor.","pos":[58212,58264],"source":" However, the **finalize** method isn't a destructor."},{"content":"The runtime never calls the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method, even when an object is collected as garbage.","pos":[58265,58358],"source":" The runtime never calls the **finalize** method, even when an object is collected as garbage."},{"pos":[58365,58379],"content":"System classes","linkify":"System classes","nodes":[{"content":"System classes","pos":[0,14]}]},{"content":"In Application Explorer, under <bpt id=\"p1\">**</bpt>System Documentation<ept id=\"p1\">**</ept> <ph id=\"ph1\">&amp;gt;</ph> <bpt id=\"p2\">**</bpt>Classes<ept id=\"p2\">**</ept>, there is a list of the kernel classes or system classes.","pos":[58381,58511],"source":"In Application Explorer, under **System Documentation** &gt; **Classes**, there is a list of the kernel classes or system classes."},{"content":"System classes aren't written in X++, and you can't see their source code.","pos":[58512,58586]},{"content":"You can't add system classes.","pos":[58587,58616]},{"content":"System classes usually have a <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method, but they don't have a <bpt id=\"p2\">**</bpt>classDeclaration<ept id=\"p2\">**</ept> node.","pos":[58617,58711],"source":" System classes usually have a **new** method, but they don't have a **classDeclaration** node."},{"content":"Every application class implicitly extends the <bpt id=\"p1\">**</bpt>Object<ept id=\"p1\">**</ept> system class.","pos":[58712,58783],"source":" Every application class implicitly extends the **Object** system class."},{"content":"Some system classes are extended by an application class that has a similar name.","pos":[58784,58865]},{"content":"For instance, <bpt id=\"p1\">**</bpt>xClassFactory<ept id=\"p1\">**</ept> is extended by <bpt id=\"p2\">**</bpt>ClassFactory<ept id=\"p2\">**</ept>.","pos":[58866,58930],"source":" For instance, **xClassFactory** is extended by **ClassFactory**."},{"content":"In these cases, you should not use the system class.","pos":[58931,58983]},{"content":"For more information, see \"Substitute application classes for system classes\" in <bpt id=\"p1\">[</bpt>X++ classes and methods<ept id=\"p1\">](xpp-classes-methods.md)</ept>.","pos":[58984,59115],"source":" For more information, see \"Substitute application classes for system classes\" in [X++ classes and methods](xpp-classes-methods.md)."},{"pos":[59122,59139],"content":"Extension methods","linkify":"Extension methods","nodes":[{"content":"Extension methods","pos":[0,17]}]},{"content":"The extension method feature lets you add extension methods to a target class by writing the methods in a separate extension class.","pos":[59141,59272]},{"content":"The following rules apply:","pos":[59273,59299]},{"content":"The extension class must be static.","pos":[59305,59340]},{"content":"The name of the extension class must end with the ten-character suffix <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\_</ph>Extension<ept id=\"p1\">**</ept>.","pos":[59345,59432],"source":"The name of the extension class must end with the ten-character suffix **\\_Extension**."},{"content":"However, there’s no restriction on the part of the name that precedes the suffix.","pos":[59433,59514]},{"pos":[59519,59603],"content":"Every extension method in the extension class must be declared as <bpt id=\"p1\">**</bpt>public static<ept id=\"p1\">**</ept>.","source":"Every extension method in the extension class must be declared as **public static**."},{"content":"The first parameter in every extension method is the type that the extension method extends.","pos":[59608,59700]},{"content":"However, when the extension method is called, the caller must not pass in anything for the first parameter.","pos":[59701,59808]},{"content":"Instead, the system automatically passes in the required object for the first parameter.","pos":[59809,59897]},{"content":"The target of an extension method must be a class, table, view, or map application object type.","pos":[59902,59997]},{"content":"An extension class can contain private or protected static methods.","pos":[59999,60066]},{"content":"These methods are typically used for implementation details and aren't exposed as extensions.","pos":[60067,60160]},{"content":"The extension method technique doesn’t affect the source code of the class that it extends.","pos":[60161,60252]},{"content":"Therefore, the addition to the class doesn't require over-layering.","pos":[60253,60320]},{"content":"Upgrades to the target class are never affected by any existing extension methods.","pos":[60321,60403]},{"content":"However, if an upgrade to the target class adds a method that has the same name as your extension method, your extension method can no longer be reached through objects of the target class.","pos":[60404,60593]},{"content":"The extension method technique uses the same dot-delimited syntax that you often use to call regular instance methods.","pos":[60594,60712]},{"content":"Extension methods can access all public artifacts of the target class, but they can’t access anything that is protected or private.","pos":[60713,60844]},{"content":"Therefore, extension methods can be considered a type of syntactic sugar.","pos":[60845,60918]},{"content":"Regardless of the target type, an extension class is used to add extension methods to the type.","pos":[60919,61014]},{"content":"For example, an extension table isn't used to add methods to a table, and there’s no such thing as an extension table.","pos":[61015,61133]},{"pos":[61664,61687],"content":"Delegates as data types","linkify":"Delegates as data types","nodes":[{"content":"Delegates as data types","pos":[0,23]}]},{"content":"A <bpt id=\"p1\">*</bpt>delegate<ept id=\"p1\">*</ept> collects methods that subscribe to it.","pos":[61689,61740],"source":"A *delegate* collects methods that subscribe to it."},{"content":"The delegate specifies the parameter signature that all its subscriber methods must share.","pos":[61741,61831]},{"content":"When the delegate is called, the delegate calls each of its subscribers.","pos":[61832,61904]},{"content":"A delegate never returns a value and <bpt id=\"p1\">**</bpt>can't have a default value<ept id=\"p1\">**</ept>.","pos":[61905,61973],"source":" A delegate never returns a value and **can't have a default value**."},{"content":"At first, every delegate has no subscribed methods.","pos":[61974,62025]},{"content":"There is no limit on the number of parameters that a delegate can declare, and there is no limitation on the type of those parameters.","pos":[62026,62160]},{"content":"The delegate body is always empty, because the delegate's only purpose is to define the contract that subscribers must conform to.","pos":[62161,62291]},{"content":"A delegate doesn't have to be defined in a class.","pos":[62292,62341]},{"content":"Delegates can also be defined in a table, form, or query.","pos":[62342,62399]},{"pos":[62406,62423],"content":"Delegate examples","linkify":"Delegate examples","nodes":[{"content":"Delegate examples","pos":[0,17]}]},{"pos":[63023,63043],"content":"Tables as data types","linkify":"Tables as data types","nodes":[{"content":"Tables as data types","pos":[0,20]}]},{"content":"All tables can be treated as class definitions.","pos":[63045,63092]},{"content":"A table variable can be considered an instance (object) of the table (class) definition.","pos":[63093,63181]},{"content":"For every field in a table variable, the default value is <bpt id=\"p1\">**</bpt>empty<ept id=\"p1\">**</ept>.","pos":[63182,63250],"source":" For every field in a table variable, the default value is **empty**."},{"content":"You can address fields and create methods on tables.","pos":[63251,63303]},{"content":"The methods can be invoked on instances of the table.","pos":[63304,63357]},{"content":"To manipulate (that is, read, update, insert, and delete) records in tables, you must declare at least one table variable that can hold the record in focus.","pos":[63358,63514]},{"content":"As a best practice, you should use the name of the table as the name of the variable but use an initial lowercase letter.","pos":[63515,63636]},{"content":"Here are a few important differences between tables and objects:","pos":[63637,63701]},{"content":"You can't allocate space for table variables.","pos":[63707,63752]},{"content":"Allocation is done implicitly.","pos":[63753,63783]},{"content":"Fields in table variables are public.","pos":[63788,63825]},{"content":"You can reference them anywhere.","pos":[63826,63858]},{"content":"Fields in table variables can be referenced by using expressions.","pos":[63863,63928]},{"pos":[63930,64045],"content":"There is no automatic conversion, but table variables that are declared as <bpt id=\"p1\">**</bpt>Common<ept id=\"p1\">**</ept> can hold data from any table.","source":"There is no automatic conversion, but table variables that are declared as **Common** can hold data from any table."},{"pos":[64052,64076],"content":"Scope of table variables","linkify":"Scope of table variables","nodes":[{"content":"Scope of table variables","pos":[0,24]}]},{"content":"In most respects, table variables can be considered objects.","pos":[64078,64138]},{"content":"However, unlike objects, they aren't explicitly allocated.","pos":[64139,64197]},{"content":"Only a variable declaration is required.","pos":[64198,64238]},{"content":"All tables are compatible with the Common table, just as all objects are compatible with the <bpt id=\"p1\">**</bpt>Object<ept id=\"p1\">**</ept> class.","pos":[64239,64349],"source":" All tables are compatible with the Common table, just as all objects are compatible with the **Object** class."},{"content":"Table variables are declared as common buffers and can be used to hold data from any table.","pos":[64350,64441]},{"content":"You can't access tables that don't have table variables.","pos":[64442,64498]},{"content":"The principles for declaring table variables and objects are the same, except with regard to the allocation of space.","pos":[64499,64616]},{"pos":[64623,64637],"content":"Table examples","linkify":"Table examples","nodes":[{"content":"Table examples","pos":[0,14]}]},{"content":"The syntax enables various possibilities for referencing fields in records.","pos":[64639,64714]},{"content":"For example, you can use the <bpt id=\"p1\">**</bpt>TableName.(FieldId)<ept id=\"p1\">**</ept> syntax.","pos":[64715,64775],"source":" For example, you can use the **TableName.(FieldId)** syntax."},{"content":"The following example prints the contents of the fields in the current record in the Customer table.","pos":[64776,64876]},{"content":"The following example uses the <bpt id=\"p1\">**</bpt>fieldCnt<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>fieldCnt2Id<ept id=\"p2\">**</ept> methods.","pos":[65209,65281],"source":"The following example uses the **fieldCnt** and **fieldCnt2Id** methods."},{"content":"The <bpt id=\"p1\">**</bpt>fieldCnt<ept id=\"p1\">**</ept> method counts the number of fields in a table, whereas <bpt id=\"p2\">**</bpt>fieldCnt2Id<ept id=\"p2\">**</ept> returns the ID for a field number.","pos":[65282,65404],"source":" The **fieldCnt** method counts the number of fields in a table, whereas **fieldCnt2Id** returns the ID for a field number."},{"content":"For example, you can use the <bpt id=\"p1\">**</bpt>fieldCnt2Id<ept id=\"p1\">**</ept> method to learn that field number 6 in a table has the ID 54.","pos":[65405,65511],"source":" For example, you can use the **fieldCnt2Id** method to learn that field number 6 in a table has the ID 54."},{"content":"This conversion is required, because there is no guarantee that the IDs of the fields in a table are consecutive.","pos":[65512,65625]},{"pos":[66192,66210],"content":"Collection classes","linkify":"Collection classes","nodes":[{"content":"Collection classes","pos":[0,18]}]},{"content":"The X++ language syntax provides two composite types: arrays and containers.","pos":[66211,66287]},{"content":"These composite types are useful for aggregating values of primitive types.","pos":[66288,66363]},{"content":"However, you can't store class objects in arrays or containers.","pos":[66364,66427]},{"content":"<bpt id=\"p1\">*</bpt>Collection classes<ept id=\"p1\">*</ept> are used to store objects.","pos":[66428,66475],"source":"*Collection classes* are used to store objects."},{"content":"They let you create arrays, lists, sets, maps, and structs that can hold any data type, even objects.","pos":[66476,66577]},{"content":"For maximum performance, the classes are implemented in C++ (they are system classes).","pos":[66578,66664]},{"content":"Collection classes were previously known as <bpt id=\"p1\">*</bpt>foundation classes<ept id=\"p1\">*</ept>.","pos":[66665,66730],"source":" Collection classes were previously known as *foundation classes*."},{"content":"The collection classes are <bpt id=\"p1\">**</bpt>Array<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>List<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>Map<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>Set<ept id=\"p4\">**</ept>, and <bpt id=\"p5\">**</bpt>Struct<ept id=\"p5\">**</ept>.","pos":[66731,66812],"source":" The collection classes are **Array**, **List**, **Map**, **Set**, and **Struct**."},{"content":"<bpt id=\"p1\">**</bpt>Array<ept id=\"p1\">**</ept> – This class resembles the <bpt id=\"p2\">**</bpt>array<ept id=\"p2\">**</ept> type in the X++ language, but it can hold values of any single type, even objects and records.","pos":[66818,66959],"source":"**Array** – This class resembles the **array** type in the X++ language, but it can hold values of any single type, even objects and records."},{"content":"Objects are accessed in a specific order.","pos":[66960,67001]},{"content":"<bpt id=\"p1\">**</bpt>List<ept id=\"p1\">**</ept> – This class contains elements that are accessed sequentially.","pos":[67006,67077],"source":"**List** – This class contains elements that are accessed sequentially."},{"content":"Unlike an array, the <bpt id=\"p1\">**</bpt>List<ept id=\"p1\">**</ept> class provides an <bpt id=\"p2\">**</bpt>addStart<ept id=\"p2\">**</ept> method.","pos":[67078,67146],"source":" Unlike an array, the **List** class provides an **addStart** method."},{"content":"Like the <bpt id=\"p1\">**</bpt>Set<ept id=\"p1\">**</ept> class, the <bpt id=\"p2\">**</bpt>List<ept id=\"p2\">**</ept> class provides the <bpt id=\"p3\">**</bpt>getEnumerator<ept id=\"p3\">**</ept> and <bpt id=\"p4\">**</bpt>getIterator<ept id=\"p4\">**</ept> methods.","pos":[67147,67249],"source":" Like the **Set** class, the **List** class provides the **getEnumerator** and **getIterator** methods."},{"content":"You can use an iterator to insert and delete items from a <bpt id=\"p1\">**</bpt>List<ept id=\"p1\">**</ept> object.","pos":[67250,67324],"source":" You can use an iterator to insert and delete items from a **List** object."},{"pos":[67329,67392],"content":"<bpt id=\"p1\">**</bpt>Map<ept id=\"p1\">**</ept> – This class associates a key value with another value.","source":"**Map** – This class associates a key value with another value."},{"content":"<bpt id=\"p1\">**</bpt>Set<ept id=\"p1\">**</ept> – This class holds values of any single type.","pos":[67397,67450],"source":"**Set** – This class holds values of any single type."},{"content":"Values aren't stored in the sequence in which they are added.","pos":[67451,67512]},{"content":"Instead, the <bpt id=\"p1\">**</bpt>Set<ept id=\"p1\">**</ept> object stores the value in a manner that optimizes performance for the <bpt id=\"p2\">**</bpt>in<ept id=\"p2\">**</ept> method.","pos":[67513,67619],"source":" Instead, the **Set** object stores the value in a manner that optimizes performance for the **in** method."},{"content":"A <bpt id=\"p1\">**</bpt>Set<ept id=\"p1\">**</ept> object ignores any attempt to add a value that the <bpt id=\"p2\">**</bpt>Set<ept id=\"p2\">**</ept> object is already storing.","pos":[67620,67715],"source":" A **Set** object ignores any attempt to add a value that the **Set** object is already storing."},{"content":"Unlike the <bpt id=\"p1\">**</bpt>Array<ept id=\"p1\">**</ept> class, the <bpt id=\"p2\">**</bpt>Set<ept id=\"p2\">**</ept> class provides the <bpt id=\"p3\">**</bpt>in<ept id=\"p3\">**</ept> and <bpt id=\"p4\">**</bpt>remove<ept id=\"p4\">**</ept> methods.","pos":[67716,67805],"source":" Unlike the **Array** class, the **Set** class provides the **in** and **remove** methods."},{"content":"<bpt id=\"p1\">**</bpt>Struct<ept id=\"p1\">**</ept> – This class can contain values of more than one type.","pos":[67810,67875],"source":"**Struct** – This class can contain values of more than one type."},{"content":"It's used to group information about a specific entity.","pos":[67876,67931]},{"content":"The constructor for every collection class except <bpt id=\"p1\">**</bpt>Struct<ept id=\"p1\">**</ept> takes a type parameter that is an element of the <bpt id=\"p2\">**</bpt>Types<ept id=\"p2\">**</ept> system enum.","pos":[67933,68065],"source":"The constructor for every collection class except **Struct** takes a type parameter that is an element of the **Types** system enum."},{"content":"The collection instance can store items of that type only.","pos":[68066,68124]},{"content":"The <bpt id=\"p1\">**</bpt>Types::AnyType<ept id=\"p1\">**</ept> enum element is a special case that can't be used to construct a collection object, such as a <bpt id=\"p2\">**</bpt>Set<ept id=\"p2\">**</ept> object.","pos":[68125,68257],"source":" The **Types::AnyType** enum element is a special case that can't be used to construct a collection object, such as a **Set** object."},{"content":"The <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept> value can't be stored as an element in a <bpt id=\"p2\">**</bpt>Set<ept id=\"p2\">**</ept> object.","pos":[68258,68327],"source":" The **null** value can't be stored as an element in a **Set** object."},{"content":"Additionally, <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept> can't be a key in a <bpt id=\"p2\">**</bpt>Map<ept id=\"p2\">**</ept> object.","pos":[68328,68386],"source":" Additionally, **null** can't be a key in a **Map** object."},{"content":"You can iterate through a collection object by using an iterator or enumerator.","pos":[68387,68466]},{"content":"Here are typical examples that show how you can obtain an iterator.","pos":[68467,68534]},{"content":"For <bpt id=\"p1\">**</bpt>Set<ept id=\"p1\">**</ept> objects, if any elements are added or removed after an iterator is created, the iterator instance can no longer be used to read from or step through the collection.","pos":[68590,68766],"source":"For **Set** objects, if any elements are added or removed after an iterator is created, the iterator instance can no longer be used to read from or step through the collection."},{"content":"For <bpt id=\"p1\">**</bpt>Map<ept id=\"p1\">**</ept> objects, as for <bpt id=\"p2\">**</bpt>Set<ept id=\"p2\">**</ept> objects, if any elements are removed, the iterator is no longer valid.","pos":[68767,68873],"source":" For **Map** objects, as for **Set** objects, if any elements are removed, the iterator is no longer valid."},{"content":"However, a <bpt id=\"p1\">**</bpt>MapIterator<ept id=\"p1\">**</ept> object remains valid even after a call to the <bpt id=\"p2\">**</bpt>Map.insert<ept id=\"p2\">**</ept> method, regardless of whether the key is new, or whether the key already exists and only the value is being updated in the <bpt id=\"p3\">**</bpt>Map<ept id=\"p3\">**</ept> element.","pos":[68874,69101],"source":" However, a **MapIterator** object remains valid even after a call to the **Map.insert** method, regardless of whether the key is new, or whether the key already exists and only the value is being updated in the **Map** element."},{"content":"Code that calls <bpt id=\"p1\">**</bpt>Map.insert<ept id=\"p1\">**</ept> and depends on the iterator object remaining valid might fail if it's run as .NET Framework CIL.","pos":[69102,69229],"source":" Code that calls **Map.insert** and depends on the iterator object remaining valid might fail if it's run as .NET Framework CIL."},{"content":"You can use the collection classes to form more complex classes.","pos":[69230,69294]},{"content":"For example, you can easily implement a stack by using a list where elements are always added to the beginning of the list.","pos":[69295,69418]},{"content":"The newest element then occupies the top of the stack.","pos":[69419,69473]},{"content":"You can also extend the collection classes.","pos":[69474,69517]},{"content":"For example, you can extend the <bpt id=\"p1\">**</bpt>List<ept id=\"p1\">**</ept> class to create a list of customer records where the operations are type-safe.","pos":[69518,69637],"source":" For example, you can extend the **List** class to create a list of customer records where the operations are type-safe."},{"content":"In this case, the derived collection class will accept only customer records.","pos":[69638,69715]},{"pos":[69720,69739],"content":"Extended data types","linkify":"Extended data types","nodes":[{"content":"Extended data types","pos":[0,19]}]},{"content":"<bpt id=\"p1\">*</bpt>Extended data types<ept id=\"p1\">*</ept> are user-defined types that are based on the <bpt id=\"p2\">**</bpt>boolean<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>int<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>int64<ept id=\"p4\">**</ept>, <bpt id=\"p5\">**</bpt>real<ept id=\"p5\">**</ept>, <bpt id=\"p6\">**</bpt>str<ept id=\"p6\">**</ept>, and <bpt id=\"p7\">**</bpt>date<ept id=\"p7\">**</ept> primitive data types, and on the <bpt id=\"p8\">**</bpt>container<ept id=\"p8\">**</ept> composite type.","pos":[69740,69934],"source":"*Extended data types* are user-defined types that are based on the **boolean**, **int**, **int64**, **real**, **str**, and **date** primitive data types, and on the **container** composite type."},{"content":"An EDT is a primitive data type or container that has a supplementary name and additional properties.","pos":[69935,70036]},{"content":"For example, you can create a new EDT that is named <bpt id=\"p1\">**</bpt>Name<ept id=\"p1\">**</ept> and base it on a string.","pos":[70037,70122],"source":" For example, you can create a new EDT that is named **Name** and base it on a string."},{"content":"You can then use the new EDT in variable and field declarations in the development environment.","pos":[70123,70218]},{"content":"You can also base EDTs on other EDTs.","pos":[70219,70256]},{"content":"EDTs are standard data types, but they have a specific name and additional properties.","pos":[70257,70343]},{"content":"EDTs undergo the same value and type <bpt id=\"p1\">[</bpt>conversions<ept id=\"p1\">](xpp-conversion-run-time-functions.md)</ept> as the standard data types that they are based on.","pos":[70344,70483],"source":" EDTs undergo the same value and type [conversions](xpp-conversion-run-time-functions.md) as the standard data types that they are based on."},{"content":"Here are the benefits of EDTs:","pos":[70484,70514]},{"content":"Code is easier to read, because variables have a meaningful data type.","pos":[70520,70590]},{"content":"For example, the data type is <bpt id=\"p1\">**</bpt>Name<ept id=\"p1\">**</ept> instead of <bpt id=\"p2\">**</bpt>str<ept id=\"p2\">**</ept>.","pos":[70591,70649],"source":" For example, the data type is **Name** instead of **str**."},{"content":"The properties that you set for an EDT are used by all instances of that type.","pos":[70654,70732]},{"content":"Therefore, EDTs help reduce work and promote consistency.","pos":[70733,70790]},{"content":"For example, account numbers (<bpt id=\"p1\">**</bpt>AccountNum<ept id=\"p1\">**</ept> data type) have the same properties throughout the system.","pos":[70791,70894],"source":" For example, account numbers (**AccountNum** data type) have the same properties throughout the system."},{"content":"You can create hierarchies of EDTs.","pos":[70899,70934]},{"content":"The EDTs can inherit the appropriate properties from the parent, and you can change other properties.","pos":[70935,71036]},{"content":"For example, the <bpt id=\"p1\">**</bpt>ItemCode<ept id=\"p1\">**</ept> data type is used as the basis for the <bpt id=\"p2\">**</bpt>MarkupItemCode<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>PriceDiscItemCode<ept id=\"p3\">**</ept> data types.","pos":[71037,71162],"source":" For example, the **ItemCode** data type is used as the basis for the **MarkupItemCode** and **PriceDiscItemCode** data types."},{"pos":[71168,71181],"content":"Create an EDT","linkify":"Create an EDT","nodes":[{"content":"Create an EDT","pos":[0,13]}]},{"content":"This feature isn't implemented as a language construct.","pos":[71183,71238]},{"content":"To create an EDT, follow these steps.","pos":[71239,71276]},{"pos":[71282,71378],"content":"In Solution Explorer, right-click on the project, point to <bpt id=\"p1\">**</bpt>Add<ept id=\"p1\">**</ept>, and then click <bpt id=\"p2\">**</bpt>New item<ept id=\"p2\">**</ept>.","source":"In Solution Explorer, right-click on the project, point to **Add**, and then click **New item**."},{"pos":[71383,71480],"content":"In the <bpt id=\"p1\">**</bpt>Add New Item<ept id=\"p1\">**</ept> dialog box, select <bpt id=\"p2\">**</bpt>Installed<ept id=\"p2\">**</ept> and then <bpt id=\"p3\">**</bpt>Artifacts<ept id=\"p3\">**</ept> in the left pane.","source":"In the **Add New Item** dialog box, select **Installed** and then **Artifacts** in the left pane."},{"content":"In the middle pane, select the EDT type to create.","pos":[71485,71535]},{"pos":[71540,71577],"content":"Enter a name, and then click <bpt id=\"p1\">**</bpt>Add<ept id=\"p1\">**</ept>.","source":"Enter a name, and then click **Add**."},{"pos":[71583,71594],"content":"EDT example","linkify":"EDT example","nodes":[{"content":"EDT example","pos":[0,11]}]},{"pos":[71891,71917],"content":"Null values for data types","linkify":"Null values for data types","nodes":[{"content":"Null values for data types","pos":[0,26]}]},{"content":"Microsoft Dynamics 365 for Finance and Operations doesn't support the concept of <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept> values that is available in many other database management systems (DBMSs).","pos":[71918,72083],"source":"Microsoft Dynamics 365 for Finance and Operations doesn't support the concept of **null** values that is available in many other database management systems (DBMSs)."},{"content":"A variable in X++ always has a type and a value.","pos":[72084,72132]},{"content":"However, for each data type, one value is considered <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept> (for example, when the <bpt id=\"p2\">**</bpt>validateField<ept id=\"p2\">**</ept> table method is run).","pos":[72133,72257],"source":" However, for each data type, one value is considered **null** (for example, when the **validateField** table method is run)."},{"content":"Type","pos":[72261,72265]},{"content":"Value that is treated as null","pos":[72275,72304]},{"content":"Date","pos":[73227,73231]},{"content":"1900-01-01","pos":[73241,73251]},{"content":"Enum","pos":[73710,73714]},{"pos":[73724,73766],"content":"An element that has its value set to <bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept>","source":"An element that has its value set to **0**"},{"content":"Integer","pos":[74193,74200]},{"content":"0","pos":[74207,74208]},{"content":"Real","pos":[74676,74680]},{"content":"0.0","pos":[74690,74693]},{"content":"String","pos":[75159,75165]},{"content":"An empty string","pos":[75173,75188]},{"content":"Time","pos":[75642,75646]},{"content":"00:00:00","pos":[75656,75664]},{"content":"Utcdatetime","pos":[76125,76136]},{"content":"Any value that has its date portion set to <bpt id=\"p1\">**</bpt>1900-01-01<ept id=\"p1\">**</ept>, regardless of the value of the time portion For example, the value <bpt id=\"p2\">**</bpt>1900-01-01T22:33:44<ept id=\"p2\">**</ept> is treated as <bpt id=\"p3\">**</bpt>null<ept id=\"p3\">**</ept>.","pos":[76139,76312],"source":"Any value that has its date portion set to **1900-01-01**, regardless of the value of the time portion For example, the value **1900-01-01T22:33:44** is treated as **null**."},{"content":"Note that any <bpt id=\"p1\">**</bpt>utcDateTime<ept id=\"p1\">**</ept> value that has its date portion set to <bpt id=\"p2\">**</bpt>1900-01-01<ept id=\"p2\">**</ept> is shown as blank by the X++ <bpt id=\"p3\">**</bpt>print<ept id=\"p3\">**</ept> statement.","pos":[76313,76446],"source":" Note that any **utcDateTime** value that has its date portion set to **1900-01-01** is shown as blank by the X++ **print** statement."},{"content":"Only the value <bpt id=\"p1\">**</bpt>1900-01-01T00:00:00<ept id=\"p1\">**</ept> is shown as blank by the <bpt id=\"p2\">**</bpt>Global::info<ept id=\"p2\">**</ept> method.","pos":[76447,76535],"source":" Only the value **1900-01-01T00:00:00** is shown as blank by the **Global::info** method."},{"content":"That value is the value from the <bpt id=\"p1\">**</bpt>DateTimeUtil::MinValue<ept id=\"p1\">**</ept> method.","pos":[76536,76603],"source":" That value is the value from the **DateTimeUtil::MinValue** method."},{"content":"Therefore, when the <bpt id=\"p1\">**</bpt>validateField<ept id=\"p1\">**</ept> method checks whether a user has entered a value in a mandatory field, <bpt id=\"p2\">**</bpt>0<ept id=\"p2\">**</ept> isn't accepted in an <bpt id=\"p3\">**</bpt>integer<ept id=\"p3\">**</ept> type field, the first entry isn't accepted in an <bpt id=\"p4\">**</bpt>enum<ept id=\"p4\">**</ept> type field, and so on.","pos":[76607,76835],"source":"Therefore, when the **validateField** method checks whether a user has entered a value in a mandatory field, **0** isn't accepted in an **integer** type field, the first entry isn't accepted in an **enum** type field, and so on."},{"content":"Additionally, in SQL X++ statements, the values that are listed in the previous table yield <bpt id=\"p1\">**</bpt>false<ept id=\"p1\">**</ept> in a Boolean comparison.","pos":[76836,76962],"source":" Additionally, in SQL X++ statements, the values that are listed in the previous table yield **false** in a Boolean comparison."},{"content":"However, In non-SQL X++ statements, the equal and relational operators work with these values, just as they work with other values.","pos":[76963,77094]},{"content":"Variables of the <bpt id=\"p1\">**</bpt>container<ept id=\"p1\">**</ept> type, and classes and variables of the <bpt id=\"p2\">**</bpt>table<ept id=\"p2\">**</ept> type can be <bpt id=\"p3\">**</bpt>null<ept id=\"p3\">**</ept> in the traditional DBMS sense.","pos":[77095,77226],"source":" Variables of the **container** type, and classes and variables of the **table** type can be **null** in the traditional DBMS sense."},{"content":"A <bpt id=\"p1\">**</bpt>table<ept id=\"p1\">**</ept> type is <bpt id=\"p2\">**</bpt>null<ept id=\"p2\">**</ept> if all its fields have their <bpt id=\"p3\">**</bpt>null<ept id=\"p3\">**</ept> value.","pos":[77227,77300],"source":" A **table** type is **null** if all its fields have their **null** value."}]}