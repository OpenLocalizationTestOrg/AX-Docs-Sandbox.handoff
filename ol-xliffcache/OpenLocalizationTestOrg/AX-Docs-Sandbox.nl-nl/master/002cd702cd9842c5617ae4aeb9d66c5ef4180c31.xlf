<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="nl-nl">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-bf14093" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">002cd702cd9842c5617ae4aeb9d66c5ef4180c31</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dev-itpro\dev-reference\xpp-variables-data-types.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">do-not-translate</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c36b35195b65f82307a695f2c2187853380c200d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa4ea1ebe3ace06b029dec7abe3fb72bf382020e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>X++ variables and data types | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>This topic describes variables and data types in X++.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>X++ variables and data types</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This topic describes variables and data types in X++.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Variables</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>variable<ept id="p1">**</ept> is an identifier that points to a memory location where information of a specific data type is stored.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The size, precision, default value, implicit and explicit <bpt id="p1">[</bpt>conversion<ept id="p1">](https://docs.microsoft.com/en-us/dynamics365/operations/dev-itpro/dev-reference/x-conversion-run-time-functions)</ept> functions, and range depends on the variable's data type.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The scope of a variable defines the area in the code where an item can be accessed.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Instance variables<ept id="p1">**</ept> are declared in class declarations and can be accessed from any methods in the class or from methods that extend the class.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Local variables<ept id="p1">**</ept> can be accessed only in the block in which they were defined.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>When a variable is <bpt id="p1">**</bpt>declared<ept id="p1">**</ept>, memory is allocated and the variable is initialized to the default value.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can assign a value to a field as part of the declaration statement.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This applies to both static and instance fields.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Variables can be declared anywhere in a code block in a method, not just at the beginning of a method.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Constants<ept id="p1">**</ept> (using the keywords <bpt id="p2">**</bpt>const<ept id="p2">**</ept> or <bpt id="p3">**</bpt>readonly<ept id="p3">**</ept>) are variables where the value cannot be changed when the variable is declared.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Read-only fields<ept id="p1">**</ept> can only be assigned a value once, and that value never changes; the field can be assigned its value either inline, at the place where the field is declared, or in the constructor.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>That is the only difference between constant and read-only variables.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>When declaring variables of managed types that aren't authored in X++, you have two options.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You can fully qualify the type names in the declaration by including the full namespace, or you can add a <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statement to your file and then leave the namespace off of the type name.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Variable Code Examples</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Var</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You can declare a variable without explicitly providing the type of the variable, if the compiler can determine the type from the initialization expression.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The variable is still strongly-typed into one, unambiguous type.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>It’s only possible to use <bpt id="p1">**</bpt>var<ept id="p1">**</ept> on declarations where an initialization expressions are provided (from which the compiler will infer the type).</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>There are situations where this can make code easier to read.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You should use a var when you want to declare local variables when the type of the variable is obvious from the right side of the assignment, or when the precise type is not important, for the declarations of for loop counters, and for disposable objects inside using statements.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Don't use var when the type isn't apparent from the initialization expression.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Var Code Examples</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Declare anywhere</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Declarations can now be provided anywhere statements can be provided.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A declaration is syntactically a statement, a declaration statement.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>You can, therefore, provide declarations immediately prior to the usage, and you don’t have to declare the variables all in one place.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>This gives you fine-grained control over the scope of your variables.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You can provide smaller scopes for variables, outside of which the variables can’t be referenced.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The lifetime of the variable is the scope in which it’s declared.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Scopes can be started at the block level (inside compound statements), in <bpt id="p1">**</bpt>for<ept id="p1">**</ept> statements, and in <bpt id="p2">**</bpt>using<ept id="p2">**</ept> statements.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>There are several advantages to making scopes small.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Readability is enhanced.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>You can reduce the risk of reusing a variable inappropriately during long-term maintenance of the code.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Refactoring becomes much easier.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>You can copy code in without having to worry about variables being reused in contexts they shouldn’t.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In this example, we declare the loop counter inside the <bpt id="p1">**</bpt>for<ept id="p1">**</ept> statement in which it's used.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The scope of the variable is the <bpt id="p1">**</bpt>for<ept id="p1">**</ept> statement itself, including the condition expression and the loop update parts.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The value can’t be used outside this scope.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The compiler will issues the error message "'i' is not declared."</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>when it reaches the <bpt id="p1">**</bpt>info<ept id="p1">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>You can also scope variables to a <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>When you use an object that implements <bpt id="p1">**</bpt>IDisposable, <ept id="p1">**</ept>you should declare and instantiate it in a <bpt id="p2">**</bpt>using<ept id="p2">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statement calls the <bpt id="p2">**</bpt>Dispose<ept id="p2">**</ept> method on the object in the correct way, even if an exception occurs while you are calling methods on the object.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can achieve the same result by putting the object inside a try block, and then explicitly calling <bpt id="p1">**</bpt>Dispose<ept id="p1">**</ept> in a finally block; in fact, this is how the <bpt id="p2">**</bpt>using<ept id="p2">**</ept> statement is translated by the compiler.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The following example shows some of the features described.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>To avoid confusion, the compiler will issue an error if you attempt to introduce a variable that would hide another variable in an enclosing scope or even in the same scope.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For instance, the following code will cause the compiler to issue the following diagnostic message: "A local variable named 'i' cannot be declared in this scope because it would give a different meaning to 'i', which is already used in a parent or current scope to denote something else."</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Constants, readonly variables, and macros</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The concept of macros is fully supported.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Compared to macros, constants have the following benefits:</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You can add a documentation comment to a constant, not to the value of a macro.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Ultimately, the language service will pick this up and provide good information to the user.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A constant is known by IntelliSense.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>A constant is cross-referenced, so you can find all references of a particular constant.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This is not the case for a macro.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>A constant is subject to access modifiers, either private, protected, or public.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The accessibility of macros is not rigorously defined.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Constants variables have scope, while macros do not.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>You can see the value of a constant or a readonly variable in the debugger.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Macros that are defined in class scopes (in class declarations) are effectively available in all methods of all derived classes.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This was originally a bug in the legacy compiler macro implementation, but this loophole is now massively exploited by application programmers.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The X++ compiler still honors this, but no new code that uses this should be written.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>This particular feature also considerably impacts compiler performance.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Constants can be declared at the class level as shown below.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The constants can then be referenced by using the double-colon syntax.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If you're in the scope of the class where the const is defined, you can omit the type name prefix <bpt id="p1">**</bpt>(MyClass<ept id="p1">**</ept> in the example above).</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>You can easily implement the concept of a macro library this way.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The list of macro symbols becomes a class with public const definitions.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You can also define constants solely as variables.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The compiler will maintain the invariant that the value can't be modified.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Primitive data types</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The primitive data types in X++ are <bpt id="p1">**</bpt>anytype, boolean, date, enum, guid, int, int64, real, str, timeOfDay,<ept id="p1">**</ept> and <bpt id="p2">**</bpt>utcdatetime.<ept id="p2">**</ept></source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>anytype</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>anytype<ept id="p1">**</ept> data type is a placeholder for any data type.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Variables of this type should only be used as arguments and return values.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If anytype is used as a variable, you must assign a value to it before it can be used or you will get a run-time error.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>After you have assigned a value to it, you cannot convert it to another data type.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>You can use anytype variables in expressions although anytype is usually used as arguments and return types.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The size, precision, scope, default value, and range of <bpt id="p1">**</bpt>anytype<ept id="p1">**</ept> depends on the conversion type that you assign to it.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You can use them in the same way that you can use the data type that you convert them to.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>For example, if you assign an integer, you can then apply relational and arithmetic operators to the variable.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>anytype<ept id="p1">**</ept> is automatically converted to dates, enums, integers, reals, strings, extended data types (records), classes, and containers by assigning a value to the type.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Explicit <bpt id="p1">[</bpt>conversion<ept id="p1">](https://docs.microsoft.com/en-us/dynamics365/operations/dev-itpro/dev-reference/x-conversion-run-time-functions)</ept> functions can be done by using <bpt id="p2">**</bpt>any2date<ept id="p2">**</ept>, <bpt id="p3">**</bpt>any2enum<ept id="p3">**</ept>, <bpt id="p4">**</bpt>any2int<ept id="p4">**</ept>, <bpt id="p5">**</bpt>any2real<ept id="p5">**</ept>, and <bpt id="p6">**</bpt>any2str<ept id="p6">**</ept>.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You cannot change the variable to another data type after you have converted to <bpt id="p1">**</bpt>anytype.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>anytype code examples</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>boolean</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>boolean<ept id="p1">**</ept> data type contains a value that evaluates to either <bpt id="p2">**</bpt>true<ept id="p2">**</ept> or <bpt id="p3">**</bpt>false<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>You can use the reserved literal keywords <bpt id="p1">**</bpt>true<ept id="p1">**</ept> and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> where ever a <bpt id="p3">**</bpt>boolean<ept id="p3">**</ept> expression is expected.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>boolean's<ept id="p1">**</ept> size is 1 byte.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The default value for a <bpt id="p1">**</bpt>boolean<ept id="p1">**</ept> is <bpt id="p2">**</bpt>false<ept id="p2">**</ept> and its internal representation is as a short number.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>boolean<ept id="p1">**</ept> is automatically converted to <bpt id="p2">**</bpt>int<ept id="p2">**</ept>, <bpt id="p3">**</bpt>date<ept id="p3">**</ept>, or <bpt id="p4">**</bpt>real<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>It has no explicit conversion functions.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The internal representation of a <bpt id="p1">**</bpt>boolean<ept id="p1">**</ept> is an integer.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can assign any integer value to a variable declared of type <bpt id="p1">**</bpt>boolean.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The integer value 0 (zero) evaluates to false, and all other integer values evaluate to true.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Because the internal representation of a <bpt id="p1">**</bpt>boolean<ept id="p1">**</ept> is an integer, <bpt id="p2">**</bpt>boolean<ept id="p2">**</ept> values are automatically converted into integers and reals.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>boolean code examples</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>date</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>date<ept id="p1">**</ept> data type contains the day, month, and year.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Dates can be written as literals in by using this syntax: <bpt id="p1">**</bpt>Date literal = day <ph id="ph1">\\</ph> month <ph id="ph2">\\</ph> year<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>You must use four digits for the year.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The date data type can hold dates between January 1, 1900, and December 31, 2154.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The size of a date is 32 bits.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The default value is <bpt id="p1">**</bpt>null<ept id="p1">**</ept> and the internal representation is as a <bpt id="p2">**</bpt>date<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A date has no implicit conversions, but can be explicitly <bpt id="p1">[</bpt>converted<ept id="p1">](https://docs.microsoft.com/en-us/dynamics365/operations/dev-itpro/dev-reference/x-conversion-run-time-functions)</ept> through the use of <bpt id="p2">**</bpt>str2date<ept id="p2">**</ept>, <bpt id="p3">**</bpt>date2str<ept id="p3">**</ept>, <bpt id="p4">**</bpt>date2num<ept id="p4">**</ept>, and <bpt id="p5">**</bpt>int2date<ept id="p5">**</ept>.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>You can add and subtract integers from dates but you cannot add or subtract two dates from each other.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>This will result in a compiler error.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>date code examples</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>enum</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">**</bpt>enum<ept id="p1">**</ept> (also known as an <bpt id="p2">**</bpt>enumeration<ept id="p2">**</ept>) is a list of literals.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>You must declare an <bpt id="p1">**</bpt>enum<ept id="p1">**</ept> in the Application Explorer before you can use it.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The literal values are represented internally as integers.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The first literal has number 0, the next has number 1, the next has number 2, and so on.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>enum<ept id="p1">**</ept> values as integers in expressions.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The default value for the first entry is <bpt id="p1">**</bpt>0<ept id="p1">**</ept> and the internal representation is a short number.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>enum<ept id="p1">**</ept> values are automatically converted to a <bpt id="p2">**</bpt>boolean<ept id="p2">**</ept>, <bpt id="p3">**</bpt>int<ept id="p3">**</ept>, or <bpt id="p4">**</bpt>real<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">**</bpt>enum<ept id="p1">**</ept> value can also be explicitly <bpt id="p2">[</bpt>converted<ept id="p2">](https://docs.microsoft.com/en-us/dynamics365/operations/dev-itpro/dev-reference/x-conversion-run-time-functions)</ept> through the use of <bpt id="p3">**</bpt>enum2str<ept id="p3">**</ept> and <bpt id="p4">**</bpt>str2enum<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>There are hundreds of enumerable types that are built into the standard application.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>For example, the enum <bpt id="p1">**</bpt>NoYes<ept id="p1">**</ept> has two associated literals, where <bpt id="p2">**</bpt>No<ept id="p2">**</ept> has the value 0, and <bpt id="p3">**</bpt>Yes<ept id="p3">**</ept> has the value 1.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>You can create as many <bpt id="p1">**</bpt>enum<ept id="p1">**</ept> types as you want, and you can declare up to 251 (0 to 250) literals in a single <bpt id="p2">**</bpt>enum<ept id="p2">**</ept> type.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>To reference an <bpt id="p1">**</bpt>enum<ept id="p1">**</ept> value, use the name of the <bpt id="p2">**</bpt>enum,<ept id="p2">**</ept> followed by the name of the literal, separated by two colons.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>For example, to use the literal <bpt id="p1">**</bpt>No<ept id="p1">**</ept> in the <bpt id="p2">**</bpt>NoYes enum,<ept id="p2">**</ept> write <bpt id="p3">**</bpt>NoYes::No<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Create an enum</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>In <bpt id="p1">**</bpt>Solution Explorer<ept id="p1">**</ept>, right-click the project, point to <bpt id="p2">**</bpt>Add<ept id="p2">**</ept>, and then click <bpt id="p3">**</bpt>New Item<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Under <bpt id="p1">**</bpt>Artifacts<ept id="p1">**</ept>, select <bpt id="p2">**</bpt>Data Types<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Click <bpt id="p1">**</bpt>Base Enum<ept id="p1">**</ept> to select the new item type.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> field, enter the name of your enum, and then click <bpt id="p2">**</bpt>Add<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>This adds a new enum to the project, and opens the enum designer for the new element.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>In the enum designer, right-click on the enum name and then click <bpt id="p1">**</bpt>New Element<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> window, enter the Name of the enum element.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>enum code examples</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>guid</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>guid<ept id="p1">**</ept> type holds a GUID value.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>A GUID<bpt id="p1">**</bpt> <ept id="p1">**</ept>(globally unique identifier) is an integer that can be used across all computers and networks wherever a unique identifier is required.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Such a number has a very low probability of being duplicated.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>A valid GUID meets all of these specifications:</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>It must have 32 hexadecimal digits.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>It must have four dash characters embedded at the locations 8-4-4-4-12.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Braces (<bpt id="p1">**</bpt>{}<ept id="p1">**</ept>) at the beginning and end of a string are optional.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>For example, both <bpt id="p1">**</bpt>"12345678-BBBb-cCCCC-0000-123456789012"<ept id="p1">**</ept> and <bpt id="p2">**</bpt>"{12345678-BBBb-cCCCC-0000-123456789012}"<ept id="p2">**</ept> are valid GUID strings.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>It must have a total of either 36 or 38 characters, depending on whether or not braces are added.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The hexadecimal digits a-f (or A-F) can be uppercase, lowercase, or mixed.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The size of a <bpt id="p1">**</bpt>guid<ept id="p1">**</ept> is 16 bytes or 128 bits.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The six explicit <bpt id="p1">[</bpt>conversion<ept id="p1">](https://docs.microsoft.com/en-us/dynamics365/operations/dev-itpro/dev-reference/x-conversion-run-time-functions)</ept> functions for a GUID are <bpt id="p2">**</bpt>any2guid<ept id="p2">**</ept>, <bpt id="p3">**</bpt>guid2str<ept id="p3">**</ept>, <bpt id="p4">**</bpt>newGuid<ept id="p4">**</ept>, <bpt id="p5">**</bpt>str2guid<ept id="p5">**</ept>, <bpt id="p6">**</bpt>Global::guidFromString<ept id="p6">**</ept>, and <bpt id="p7">**</bpt>Global::stringFromGuid. <ept id="p7">**</ept></source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>guid code examples</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The following code example illustrates how to use the <bpt id="p1">**</bpt>guid<ept id="p1">**</ept> functions.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The output of these examples is shown below.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>guid code output</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The output that is displayed in the Infolog is as follows.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Note that the string includes the optional braces.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>int and int64</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Integers are numbers without decimals.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>There are two integer types: <bpt id="p1">**</bpt>int <ept id="p1">**</ept>and <bpt id="p2">**</bpt>int64<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Integers are used as control variables in repetitive statements or as indexes in arrays.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>You can also use integer literals anywhere an integer-expression is expected and both relational and arithmetic operators can be applied.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>An integer literal is the integer written directly in the code, for example, 32768.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">**</bpt>int<ept id="p1">**</ept> is 32 bits wide and an <bpt id="p2">**</bpt>int64<ept id="p2">**</ept> is 64 bits wide.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The default value is <bpt id="p1">**</bpt>0<ept id="p1">**</ept> and the internal representation is a long number.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Integers are automatically converted into <bpt id="p1">**</bpt>boolean<ept id="p1">**</ept>, <bpt id="p2">**</bpt>enum<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>real<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>There are four explicit <bpt id="p1">[</bpt>conversion<ept id="p1">](https://docs.microsoft.com/en-us/dynamics365/operations/dev-itpro/dev-reference/x-conversion-run-time-functions)</ept> functions for integers: <bpt id="p2">**</bpt>str2int<ept id="p2">**</ept>, <bpt id="p3">**</bpt>int2str<ept id="p3">**</ept>, <bpt id="p4">**</bpt>str2int64<ept id="p4">**</ept>, and <bpt id="p5">**</bpt>int642str<ept id="p5">**</ept>.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The range of an int is <ph id="ph1">\[</ph>-2,147,483,647 : 2,147,483,647<ph id="ph2">\]</ph>.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The range of an int64 is <ph id="ph1">\[</ph>-9,223,372,036,854,775,808 : 9,223,372,036,854,775,808<ph id="ph2">\]</ph>.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>All integers in either of these ranges can be used as literals.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>int and int64 code examples</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Here is an example of declaring integers and using integers in expressions.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>If you try to assign the largest integer plus 1 to an <bpt id="p1">**</bpt>int64,<ept id="p1">**</ept> you will get the wrong result.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>This is because it is interpreted as a 32-bit number, and therefore the number is wrapped around and stored as -2,147,483,647 instead.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>To prevent this, add a "u" to the end of the number, for example: <bpt id="p1">**</bpt>int64 i = 0x8000 0000u<ept id="p1">**</ept> (0x8000 0000 is 2,147,483,648).</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>real</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>real<ept id="p1">**</ept> variables can hold decimal values in addition to holding integers.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>You can use decimal literals anywhere where a real is expected.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>A decimal literal is the decimal written directly in the code, for example, 2.123876.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Real literals can also be written using exponential notation such as 1.0e3.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Reals can be used in all expressions and with both relational operators and arithmetic operators.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>real<ept id="p1">**</ept> has a precision of 16 significant digits.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The default for a real is <bpt id="p1">**</bpt>0.0<ept id="p1">**</ept>, and it's internal representation is as a BCD (binary-coded digital) number.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The BCD encoding makes it possible to make exact representations of values that are multiples of 0.1.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>A real variable's range is -(10)¹²⁷ to (10)¹²⁷.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>All reals in this range can be used as literals in X++.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>real<ept id="p1">**</ept> variables are automatically converted to <bpt id="p2">**</bpt>boolean<ept id="p2">**</ept>, <bpt id="p3">**</bpt>enum<ept id="p3">**</ept>, or <bpt id="p4">**</bpt>int<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>If the result is an integer or the operator is an integer-operator, reals **** are converted into integers.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>If the result is a <bpt id="p1">**</bpt>boolean,<ept id="p1">**</ept> the <bpt id="p2">**</bpt>real<ept id="p2">**</ept> is converted to <bpt id="p3">**</bpt>boolean,<ept id="p3">**</ept> and so on.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You can also explicitly convert using <bpt id="p1">**</bpt>str2num<ept id="p1">**</ept> or <bpt id="p2">**</bpt>num2str<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Direct assignments between X++ <bpt id="p1">**</bpt>real<ept id="p1">**</ept> and .NET Framework <bpt id="p2">**</bpt>System.Decimal<ept id="p2">**</ept> convert the value correctly without the need to call any conversion function.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>A decimal number is a floating-point value that consists of a sign, a numeric value where each digit in the value ranges from 0 to 9, and a scaling factor that indicates the position of a floating decimal point that separates the integral and fractional parts of the numeric value.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The binary representation of a real value consists of a 1-bit sign, a 96-bit integer number, and a scaling factor used to divide the 96-bit integer and specify what portion of it is a decimal fraction.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The scaling factor is implicitly the number 10, raised to an exponent ranging from 0 to 28.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Therefore, the binary representation of a decimal value represents ((-2⁹⁶ to 2⁹⁶)/10(0<ph id="ph1">\\</ph> to<ph id="ph2">\\</ph> 28)), where -(2⁹⁶-1) is equal to the minimum value and 2⁹⁶-1 is equal to the maximum value that can be expressed.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Note: The type used to represent real values has changed in Microsoft Dynamics AX from interpreted X++ of Dynamics AX 2012.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>This won’t require you to rewrite any code, because the new type can express all of the values that the old one could.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>We provide this material in the interest of full disclosure only.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>All instances of the real type are now implemented as instances of the .NET decimal type (<bpt id="p1">**</bpt>System.Decimal<ept id="p1">**</ept>).</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Just as the <bpt id="p1">**</bpt>real<ept id="p1">**</ept> type in previous versions, the decimal type in a binary coded decimal type that, unlike floating point type, is resilient to rounding errors.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The range and resolution of the decimal type are different from previous versions.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The original X++ real type supported 16 digits and an exponent that defined where the decimal point is placed.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The X++ <bpt id="p1">**</bpt>real<ept id="p1">**</ept> type for Microsoft Dynamics AX and later can represent decimal numbers ranging from positive 79,228,162,514,264,337,593,543,950,335 (2⁹⁶-1) to negative 79,228,162,514,264,337,593,543,950,335 (-(2⁹⁶-1)).</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The new real type doesn’t eliminate the need for rounding.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>For example, the following code produces a result of 0.9999999999999999999999999999 instead of 1.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>real code examples</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>str</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>A<bpt id="p1">**</bpt> str<ept id="p1">**</ept> variable (a string)<bpt id="p2">**</bpt> <ept id="p2">**</ept>are sequences of characters that are used as texts, help lines, addresses, telephone numbers, and so on.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>To declare a string, use the <bpt id="p1">**</bpt>str<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>String literals are characters that are enclosed in quotation marks (" ") that can be used where string expressions are expected.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Some examples of this would be <bpt id="p1">**</bpt>"StringLit"<ept id="p1">**</ept> and <bpt id="p2">**</bpt>"Hello World"<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>If you want the string to span more than one line, precede it with an <bpt id="p1">**</bpt><ph id="ph1">"@"</ph><ept id="p1">**</ept> character.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>You can use strings in logical expressions, such as comparisons.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>You can also concatenate strings by using the + operator.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>The default value for a string is <bpt id="p1">**</bpt>empty <ept id="p1">**</ept>and the internal representation is that of a list of characters.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>There are no automatic conversions for strings but there are several explicit <bpt id="p1">[</bpt>conversion<ept id="p1">](https://docs.microsoft.com/en-us/dynamics365/operations/dev-itpro/dev-reference/x-conversion-run-time-functions)</ept> functions: <bpt id="p2">**</bpt>str2int<ept id="p2">**</ept>, <bpt id="p3">**</bpt>str2int64<ept id="p3">**</ept>, <bpt id="p4">**</bpt>int2str<ept id="p4">**</ept>, <bpt id="p5">**</bpt>str2num<ept id="p5">**</ept>, <bpt id="p6">**</bpt>num2str<ept id="p6">**</ept>, <bpt id="p7">**</bpt>str2date<ept id="p7">**</ept>, and <bpt id="p8">**</bpt>date2str<ept id="p8">**</ept>.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>A string can hold an unlimited number of characters.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>You can specify the maximum length of characters within a string in the variable declaration and force a truncation  to the maximum length of the string.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>An example is shown in the next section.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>str code examples</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>timeOfDay</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>timeOfDay<ept id="p1">**</ept> (time data type) is an integer value representing the number of seconds that have elapsed since midnight.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>timeOfDay<ept id="p1">**</ept> variables can be used as literals in the same way as integers are used as literals.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>timeOfDay<ept id="p1">**</ept> variables can have relational operators and arithmetic operators applied to them.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>They can also be used in expressions.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The range of a <bpt id="p1">**</bpt>timeOfDay<ept id="p1">**</ept> data type is in the closed interval <ph id="ph1">\[</ph>0; 86400<ph id="ph2">\]</ph>.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Values above 86400 (23:59:59) cannot be interpreted.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>timeOfDay<ept id="p1">**</ept> variables are automatically converted into <bpt id="p2">**</bpt>boolean<ept id="p2">**</ept>, <bpt id="p3">**</bpt>enum<ept id="p3">**</ept>, and <bpt id="p4">**</bpt>real<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>str2time<ept id="p1">**</ept> and <bpt id="p2">**</bpt>time2str<ept id="p2">**</ept> conversion functions to explicitly convert <bpt id="p3">**</bpt>timeOfDay.<ept id="p3">**</ept></source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>timeOfDay code examples</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>utcdatetime</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>utcdatetime<ept id="p1">**</ept> data type combines the <bpt id="p2">**</bpt>date<ept id="p2">**</ept> type and the <bpt id="p3">**</bpt>timeOfDay<ept id="p3">**</ept> type into one type.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>utcdatetime<ept id="p1">**</ept> variable also holds time zone information, though this information is not accessible in code.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The format for a <bpt id="p1">**</bpt>utcdatetime<ept id="p1">**</ept> literal is <bpt id="p2">**</bpt>yyyy-mm-ddThh:mm:ss. T<ept id="p2">**</ept>he uppercase <bpt id="p3">**</bpt>"T"<ept id="p3">**</ept> is required.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>This format can be written without quotes.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The minimum value is <bpt id="p1">**</bpt>1900-01-01T00:00:00<ept id="p1">**</ept> and the maximum value is <bpt id="p2">**</bpt>1900-01-01T00:00:00<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>This matches the upper range of <bpt id="p1">**</bpt>date<ept id="p1">**</ept> and <bpt id="p2">**</bpt>timeOfDay<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>The smallest unit of time in <bpt id="p1">**</bpt>utcdatetime<ept id="p1">**</ept> is <bpt id="p2">**</bpt>1 second<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>utcdatetime<ept id="p1">**</ept> variable that has been declared but not initialized has the default value of <bpt id="p2">**</bpt>1900-01-01T00:00:00<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>This is the value returned by <bpt id="p1">**</bpt>DateTimeUtil::minValue()<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Some functions treat an input parameter of this minimum value as null.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>For instance, the <bpt id="p1">**</bpt>DateTimeUtil::toStr<ept id="p1">**</ept> method returns an empty string, however, the <bpt id="p2">**</bpt>DateTimeUtil::addSeconds<ept id="p2">**</ept> method returns a usable utcdatetime value.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>There are no implicit conversion for the utcdatetime data type.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>DateTimeUtil<ept id="p1">**</ept> class provides many methods for manipulating utcdatetime values.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The explicit <bpt id="p1">[</bpt>conversion<ept id="p1">](https://docs.microsoft.com/en-us/dynamics365/operations/dev-itpro/dev-reference/x-conversion-run-time-functions)</ept> functions for utcdatetime are <bpt id="p2">**</bpt>str2datetime<ept id="p2">**</ept> and <bpt id="p3">**</bpt>datetime2str<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Also, the <bpt id="p1">**</bpt>Global<ept id="p1">**</ept> class provides the conversion methods <bpt id="p2">**</bpt>utcDateTime2SystemDateTime<ept id="p2">**</ept> and <bpt id="p3">**</bpt>CLRSystemDateTime2UtcDateTime<ept id="p3">**</ept> to support common language runtime (CLR) interop.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Comparison operators are the only kind of operators that can be used with the <bpt id="p1">**</bpt>utcdatetime<ept id="p1">**</ept> data type.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The following operators can be used to compare two <bpt id="p1">**</bpt>utcdatetime<ept id="p1">**</ept> values: !=, <ph id="ph1">&amp;lt;</ph>, <ph id="ph2">&amp;lt;</ph>=, == , <ph id="ph3">&amp;gt;</ph>, and <ph id="ph4">&amp;gt;</ph>=.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>When you add a <bpt id="p1">**</bpt>utcdatetime<ept id="p1">**</ept> field to a table, we recommend that you base the field on an extended data type (EDT).</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>utcdatetime code examples</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Composite data types</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The composite data types in X++ are arrays, containers, classes as data types, delegates as data types, and tables as data types.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Array</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">**</bpt>array<ept id="p1">**</ept> is a variable that contains a list of items that all have the same data type.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The elements of an array are accessed with integer indexes.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>You use a separate statement to initialize each element in an array.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>When you use a container data type or an array object to create a collection, you can initialize multiple elements by using a single statement.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>By default, all the items in an array have the default value of the data type in the array.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The three kinds of arrays are <bpt id="p1">**</bpt>dynamic arrays<ept id="p1">**</ept>, <bpt id="p2">**</bpt>fixed-length arrays<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>partly on disk arrays<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>dynamic array<ept id="p1">**</ept> is declared with an empty array option (that is, only square brackets).</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>fixed-length array<ept id="p1">**</ept> can hold the number of items that is specified in the declaration.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Fixed-length arrays are declared like dynamic arrays but with a length option in the square brackets.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Partly on disk arrays<ept id="p1">**</ept> are declared either as dynamic or fixed-length arrays with an extra option that declares how many items should be held in memory.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>The other items are stored on disk and automatically loaded when referenced.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>X++ only supports one-dimensional arrays.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>It is possible, however, to mimic the behavior of multiple array indices (see the next section on multiple array indices).</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Variables in objects and tables can be declared as arrays.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>For example, this is used in address lines in the standard application.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>An array collection class enables you to store objects in an array.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Array indices begin at 1.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>The first item in the array is referenced with <ph id="ph1">\[</ph>1<ph id="ph2">\]</ph>, the second <ph id="ph3">\[</ph>2<ph id="ph4">\]</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>The syntax for accessing an array element is <bpt id="p1">**</bpt>ArrayItemReference = ArrayVariable <ph id="ph1">\[</ph> Index <ph id="ph2">\]</ph> <ept id="p1">**</ept>where <bpt id="p2">**</bpt>ArrayVariable<ept id="p2">**</ept> is the identifier of the array, and <bpt id="p3">**</bpt>Index<ept id="p3">**</ept> is the number of the array element.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Index<ept id="p1">**</ept> can be an integer expression.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Item zero<ph id="ph1">\[</ph>0<ph id="ph2">\]</ph> is used to clear the array.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Assigning a value to index 0 in an array resets all elements in the array to the default value.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Array code examples</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Multiple array indices</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Some languages, such as C++ and C<ph id="ph1">\#</ph>, allow you to declare arrays with more than one index; that is, to define "arrays of arrays."</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>You cannot directly create multiple array indexes in X++, because only one-dimensional arrays are supported.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>However, you can implement multiple indexes by using the following scheme.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>For example, in C++ and C<ph id="ph1">\#</ph>, if you wanted to declare an array with two dimensions for holding an amount earned by country by dimension, and there were 10 countries and 3 dimensions, you would declare the following:</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>This is not possible in X++.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Instead, you can define a one-dimensional array with the number of elements that is the product of the elements in each dimension.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>An example of this is shown below.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>container</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>container<ept id="p1">**</ept> object is a dynamic list of items containing primitive data types or composite data types.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>A container is helpful when you must pass a variety of value types between the client and server tiers.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>A container is a poor choice when you intend to repeatedly add to a list in a loop because a container is best suited for processes that do not involve excessive modification to the size or contents of the container.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>When a container undergoes excessive additions of data, overall system performance can be decreased by the need to repeatedly copy container data and allocate new space.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>A container is not a class.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>A container contains an ordered sequence of primitive values or other containers.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>The flexibility of <bpt id="p1">**</bpt>anytype<ept id="p1">**</ept> makes container a good way to store values of different types together.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>A container can be stored in the database.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>A container is one of the column types that you can select when you use the Application Explorer to add a column to a table.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>A container slightly resembles an array, or collections such as the <bpt id="p1">**</bpt>List<ept id="p1">**</ept> or <bpt id="p2">**</bpt>Stack<ept id="p2">**</ept> classes.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>However, you can never change the size or content of a container after the container is created.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>X++ statements that appear to modify a container are internally building a new container and copying values as necessary.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Even an assignment of a container to another container variable creates a new copy of the container.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>All of this has performance implications.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>In the functions that provide access to a container (such as <bpt id="p1">**</bpt>conPeek<ept id="p1">**</ept>), the container is 1-based, not 0-based.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Indexing is 1-based for arrays.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>The default value of a container is <bpt id="p1">**</bpt>empty<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>The container does not contain any values.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Some statements with containers might appear like they modify a container, but inside the system this never occurs.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Instead, the data from the original container is combined with data from the command to build a new container.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>You can create a new container by using one of these functions: <bpt id="p1">**</bpt>conDel<ept id="p1">**</ept>, <bpt id="p2">**</bpt>conIns<ept id="p2">**</ept>, or <bpt id="p3">**</bpt>conPoke<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>The Global Class has static methods for handling containers.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>These methods include <bpt id="p1">**</bpt>con2ArraySource<ept id="p1">**</ept>, <bpt id="p2">**</bpt>con2Buf<ept id="p2">**</ept>, <bpt id="p3">**</bpt>con2List<ept id="p3">**</ept>, <bpt id="p4">**</bpt>con2Str<ept id="p4">**</ept>, <bpt id="p5">**</bpt>containerFromXmlNode<ept id="p5">**</ept>, <bpt id="p6">**</bpt>conView<ept id="p6">**</ept>, and <bpt id="p7">**</bpt>str2Con<ept id="p7">**</ept>.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>There are several intrinsic functions for handling a container, such as <bpt id="p1">**</bpt>conIns<ept id="p1">**</ept> and <bpt id="p2">**</bpt>conPeek<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>The X++ function <bpt id="p1">**</bpt>conPeek<ept id="p1">**</ept> returns an <bpt id="p2">**</bpt>anytype<ept id="p2">**</ept> type.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>This makes it easier to read the values from a container when you do not know what type each value is.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">**</bpt>anytype<ept id="p1">**</ept> can be assigned to any X++ value type, as long as the value can be converted.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Your code is easier to read when it avoids explicit data type conversions.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Assign values from a container to the same data type that was used to put the value into the container.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>You must not assign a container to an <bpt id="p1">**</bpt>anytype<ept id="p1">**</ept>, because the system is unable to determine the correct conversions in some cases.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>In these cases, unexpected behavior or errors might occur.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>Comparing container to other options</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>container<ept id="p1">**</ept> type resembles other constructs, such as arrays and collection classes like <bpt id="p2">**</bpt>List<ept id="p2">**</ept> and <bpt id="p3">**</bpt>Stack<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>The difference between <bpt id="p1">**</bpt>container<ept id="p1">**</ept> and <bpt id="p2">**</bpt>List<ept id="p2">**</ept> is that an instance of the <bpt id="p3">**</bpt>List<ept id="p3">**</ept> class is mutable.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>List<ept id="p1">**</ept> object first allocates more space than its data consumes.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>As data is added the space is filled.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>This is more efficient than allocating more space every time that an element is added.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>Updating a <bpt id="p1">**</bpt>List<ept id="p1">**</ept> performs faster than similar operations on a container.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>When you construct a <bpt id="p1">**</bpt>List<ept id="p1">**</ept> object, you determine the one type of data that the <bpt id="p2">**</bpt>List<ept id="p2">**</ept> object can store.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>This restriction is less flexible than for a container.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>However, you can choose to store objects in a <bpt id="p1">**</bpt>List<ept id="p1">**</ept>, whereas a container can only store value types.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>The difference between a container and an array is that an array can hold only items of its declared type.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>You can allocate memory space for an array and fill that space with values later, such as in a loop.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>This is efficient and performs well.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>When you want to build a new container by appending new data, you can use either the <bpt id="p1">**</bpt><ph id="ph1">+=</ph><ept id="p1">**</ept> operator or the <bpt id="p2">**</bpt>conIns<ept id="p2">**</ept> function.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">+=</ph><ept id="p1">**</ept> operator is the faster alternative.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>conIns<ept id="p1">**</ept> function only when you want to add new data before the last index of the original data.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>Using the X++ compiler with Dynamics AX 2012, it was possible to store object references into containers, even though this would fail at runtime.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>This is no longer possible with Dynamics AX and later versions.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>When the compiler sees an attempt to store an object reference into a container, it will issue an error message.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>If the type of the element that is added to the container is anytype the compiler can’t make the determination of whether or not the value is a reference type.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>The compiler will allow this under the assumption that the user knows what they’re doing.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>The compiler won't diagnose the code as erroneous but an error will be thrown at runtime.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>container code examples</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Classes as data types</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>class<ept id="p1">**</ept> is a type definition that describes both variables and methods for instances (objects) of the class.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>A class is only a definition for objects, and all objects are <bpt id="p1">**</bpt>null<ept id="p1">**</ept> when they are declared.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>Every application class in the Application Explorer under the <bpt id="p1">**</bpt>Classes<ept id="p1">**</ept> node is a data type.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>You can declare variables of these types in your code.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>You can construct instances of a class and assign the instances to variables.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The instances are also known as objects.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Classes can be nested in source code.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Nested classes are available only inside forms (such as a class that extends <bpt id="p1">**</bpt>FormRun)<ept id="p1">**</ept> to represent controls, data sources, or data fields.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>An attribute decoration, such as on a class or a method, can omit the suffix of the attribute name if the suffix is <bpt id="p1">**</bpt>Attribute<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>So X++ allows <bpt id="p1">**</bpt><ph id="ph1">\[</ph>MyFavorite<ph id="ph2">\]</ph><ept id="p1">**</ept> instead of requiring <bpt id="p2">**</bpt><ph id="ph3">\[</ph>MyFavoriteAttribute<ph id="ph4">\]</ph><ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Also, attributes are now applied to the handlers of delegates and methods, to map the handlers to those targets.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>In Dynamics AX 2012 and earlier, it was possible to designate a method to run either on the client or the server.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>With Dynamics AX and later, this is no longer possible.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>All compiled X++ code is executed as .NET CIL on the server.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>There is no longer any code that is evaluated at the client site or in the browser, therefore, the two keywords, <bpt id="p1">**</bpt>client<ept id="p1">**</ept> and <bpt id="p2">**</bpt>server,<ept id="p2">**</ept> are now ignored.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>Their use doesn’t cause a compile error, but they should not be used in any new code.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Private and protected  member variables</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Previously, all member variables defined in a class were protected.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>It’s now possible to make the visibility of member variables explicit by adding the <bpt id="p1">**</bpt>private, protected,<ept id="p1">**</ept> and <bpt id="p2">**</bpt>public<ept id="p2">**</ept> keywords.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>The interpretation of these modifiers is obvious and aligns with the semantics for methods:</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>private<ept id="p1">**</ept> member can only be used within the class where it’s defined.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>protected<ept id="p1">**</ept> member can be used in the class where it’s defined, and all subclasses of it.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>public<ept id="p1">**</ept> member can be used anywhere: it’s visible outside the confines of the class hierarchy in which it’s defined.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>The default for member variables that aren’t adorned with an explicit modifier is still protected.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>You should make it a habit of explicitly specifying the visibility.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>As described, when a member variable is defined as public, it may be accessed outside of the class in which it’s defined.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>In this case, a qualifier designating the object hosting the variable has to be specified, using the dot notation, as is the case for method calls.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>In the following code example, <bpt id="p1">**</bpt>field1<ept id="p1">**</ept> is accessed using the explicit <bpt id="p2">**</bpt>this<ept id="p2">**</ept> qualifier.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>Making a member variable public may not be a good idea since it exposes the internal workings of the class to its consumers, creating a strong dependency between the class implementation and its consumers.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>You should always strive to only depend on a contract, not an implementation.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>Static constructors and static fields</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>Static fields are fields that are declared using the <bpt id="p1">**</bpt>static<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>Conceptually they apply to the class, not instances of the class.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>Static constructors are guaranteed to run before any static or instance calls are made to the class.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>The execution of the static constructor is relative to the user’s session.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>You’ll never call the static constructor explicitly; the compiler will generate code to ensure that the constructor is called exactly once prior to any other method on the class.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>A static constructor is used to initialize any static data, or to perform a particular action that needs to be performed only once.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>No parameters can be provided for the static constructor, and it must be marked with the <bpt id="p1">**</bpt>static<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>Class elements in the Application Explorer</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>Under most class nodes there are two special nodes: a <bpt id="p1">**</bpt>classDeclaration<ept id="p1">**</ept> node and a <bpt id="p2">**</bpt>new<ept id="p2">**</ept> node.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>classDeclaration<ept id="p1">**</ept> contains the X++ <bpt id="p2">**</bpt>class<ept id="p2">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>It can also have additional keywords such as <bpt id="p1">**</bpt>extends<ept id="p1">**</ept> to modify the class.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>This node can also contain declarations of member variables.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>The member variables cannot be initialized to a value in <bpt id="p1">**</bpt>classDeclaration<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>The member variables cannot be <bpt id="p1">**</bpt>static<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>In the following example the variables <bpt id="p1">**</bpt>m<ph id="ph1">\_</ph>priority<ept id="p1">**</ept> and <bpt id="p2">**</bpt>m<ph id="ph2">\_</ph>rectangle<ept id="p2">**</ept> are members of the class:</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>new<ept id="p1">**</ept> operator contains logic that is run when the <bpt id="p2">**</bpt>new<ept id="p2">**</ept> operator is used to create an instance of the class.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>The logic in the <bpt id="p1">**</bpt>new<ept id="p1">**</ept> method might construct an object, and assign the object to a variable that is declared in the <bpt id="p2">**</bpt>classDeclaration<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Each class is limited to only one <bpt id="p1">**</bpt>new<ept id="p1">**</ept> method.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>However, in the <bpt id="p1">**</bpt>new<ept id="p1">**</ept> method you often should call the <bpt id="p2">**</bpt>new<ept id="p2">**</ept> method of the base class, and you do so by calling <bpt id="p3">**</bpt>super()<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>The following example is the <bpt id="p1">**</bpt>new<ept id="p1">**</ept> method for the <bpt id="p2">**</bpt>YourDerivedClass<ept id="p2">**</ept> class in the previous <bpt id="p3">**</bpt>classDeclaration<ept id="p3">**</ept> example.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>In this <bpt id="p1">**</bpt>new<ept id="p1">**</ept> method, the code constructs an instance of the Rectangle class.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>The instance is assigned to the <bpt id="p1">**</bpt>m<ph id="ph1">\_</ph>rectangle<ept id="p1">**</ept> variable.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>this<ept id="p1">**</ept> keyword that is used in the example below is optional, although in practice it sometimes enables IntelliSense to be more helpful.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>During run time, most objects eventually no longer have any variable pointing to them.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>The system scans for such objects and erases them from memory.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>This makes the memory space available for other uses.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> class has a method named <bpt id="p2">**</bpt>finalize<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>However, the <bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> method is not a destructor.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>The runtime never calls the <bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> method, even when an object is garbage collected.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>System classes</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>In the Application Explorer under <bpt id="p1">**</bpt>System Documentation<ept id="p1">**</ept> <ph id="ph1">&amp;gt;</ph> <bpt id="p2">**</bpt>Classes<ept id="p2">**</ept> you can see a list of the kernel or system classes.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>System classes are not written in X++, and you cannot see their source code.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>You cannot add any system classes.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>System classes usually have a <bpt id="p1">**</bpt>new<ept id="p1">**</ept> method, but they do not have a <bpt id="p2">**</bpt>classDeclaration<ept id="p2">**</ept> node.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>Every application class implicitly extends the <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> system class.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>Some system classes are extended by an application class of nearly the same name.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>For instance, <bpt id="p1">**</bpt>xClassFactory<ept id="p1">**</ept> is extended by <bpt id="p2">**</bpt>ClassFactory<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>In such cases you should not use the system class.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Substitute application classes for system classes<ept id="p1">](https://docs.microsoft.com/en-us/dynamics365/operations/dev-itpro/dev-reference/xpp-classes-and-methods#substitute-application-classes-for-system-classes)</ept>.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>Extension methods</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The extension method feature lets you add extension methods to a target class by writing the methods in a separate extension class.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>The extension class must be static.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>The name of the extension class must end with the ten-character suffix <bpt id="p1">**</bpt><ph id="ph1">\_</ph>Extension<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>However, there’s no restriction on the part of the name that precedes the suffix.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>Every extension method in the extension class must be declared with <bpt id="p1">**</bpt>public static<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>The first parameter in every extension method is the type that the extension method extends.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>However, when the extension method is called, the caller must not pass in anything for the first parameter.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>Instead, the system automatically passes in the required object for the first parameter.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>The target of an extension method must be a class, table, view, or map application object type.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>It’s perfectly valid to have private or protected static methods in an extension class.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>These are typically used for implementation details and are not exposed as extensions.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The extension method technique doesn’t affect the source code of the class it extends.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>Therefore, the addition to the class can be done without over-layering.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>Upgrades to the target class are never affected by any existing extension methods.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>However, if an upgrade to the target class adds a method that has the same name as your extension method, your extension method becomes unreachable through objects of the target class.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>The extension method technique uses the same dot-delimited syntax that you routinely use the call regular instance methods.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Extension methods can access all public artifacts of the target class, but they can’t access things that are protected or private.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>In this way, extension methods can be seen as a kind of syntactic sugar.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>Regardless of the target type, an extension class is used to add extension methods to the type.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>For example, an extension table is not used to add methods to a table, and there’s no such thing as an extension table.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>Delegates as data types</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>delegate<ept id="p1">**</ept> collects methods that subscribe to it.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>The delegate specifies the parameter signature that all its subscriber methods must share.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>When the delegate is called, the delegate calls each of its subscriber.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>A delegate never returns a value and <bpt id="p1">**</bpt>cannot<ept id="p1">**</ept> <bpt id="p2">**</bpt>have a default value<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>However, each delegate starts with zero methods subscribed to it.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>There is no limitation on the number of parameters a delegate can declare and there is no limitation on the type of those parameters.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>The delegate body is always empty because the delegate's only purpose is to define the contract that subscribers must conform to.</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>A delegate can be defined in a table, form, or query, and not just in a class.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>Delegates code examples</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>Tables as data types</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>All <bpt id="p1">**</bpt>tables<ept id="p1">**</ept> can be treated like class definitions.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>table<ept id="p1">**</ept> variable can be seen as an instance (an object) of the table (class) definition.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>For every field in a table variable, the default value is <bpt id="p1">**</bpt>empty<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>You can address fields and create methods on tables.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>The methods can be invoked on instances of the table.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>To manipulate (read, update, insert, and delete) records in tables, you must declare at least one table variable, which can hold the record in focus.</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>The best practice to use the name of the table as the name of the variable, but with an initial lowercase letter.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>Here are a few important differences between tables and objects:</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>You cannot allocate space for table variables—it is done implicitly.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>Fields in table variables are public—you can reference them anywhere.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>Fields in table variables can be referenced with expressions.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>There is no automatic conversion, but table variables that are declared as <bpt id="p1">**</bpt>Common<ept id="p1">**</ept> can hold data from any table.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>Scope of table variables</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>In most respects, table variables can be considered objects.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>Contrary to objects, they are not allocated explicitly.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>Only a variable declaration is required.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>All tables are compatible with the <bpt id="p1">**</bpt>Common<ept id="p1">**</ept> table in the same way that all objects are compatible with the <bpt id="p2">**</bpt>Object<ept id="p2">**</ept> class.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>Table variables, which are declared as common buffers, can be used to hold data from any table.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>You cannot access tables without table variables.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The principles for declaring table variables and objects are the same except for the allocation of space.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>Table code examples</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>The syntax, however, also allows various possibilities for referencing fields in records, for example by using the <bpt id="p1">**</bpt>TableName.(FieldId)<ept id="p1">**</ept> syntax.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>The following example prints the contents of the fields in the current record in the Customer table.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt>fieldCnt<ept id="p1">**</ept> and <bpt id="p2">**</bpt>fieldCnt2Id<ept id="p2">**</ept> methods.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>fieldCnt<ept id="p1">**</ept> method counts the number of fields in a table, while <bpt id="p2">**</bpt>fieldCnt2Id<ept id="p2">**</ept> returns the ID for a field number.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>For example, you can use the <bpt id="p1">**</bpt>fieldCnt2Id<ept id="p1">**</ept> method to find out that field number 6 in a table has the ID 54.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>It is necessary to perform this conversion because it is not guaranteed that the IDs of the fields in a table are consecutive.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>Collection classes</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>The X++ language syntax provides two composite types: arrays and containers.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>They are useful for aggregating values of primitive types.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>However, you cannot store class objects in arrays or containers.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Collection classes<ept id="p1">**</ept> are for storing objects by allowing you to create arrays, lists, sets, maps, and structs that can hold any data type, including objects.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>The classes are implemented in C++ to achieve the maximum performance (they are system classes).</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>Collection classes were formerly called Foundation classes.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>The collection classes are <bpt id="p1">**</bpt>Array, List, Map, Set,<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Struct.<ept id="p2">**</ept></source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Array<ept id="p1">**</ept> is similar to the X++ language array type except that it can hold values of any single type, including objects and records.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>Objects are accessed in a specific order.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>List<ept id="p1">**</ept> contains elements that are accessed sequentially.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>Unlike an array, the <bpt id="p1">**</bpt>List<ept id="p1">**</ept> class provides an <bpt id="p2">**</bpt>addStart<ept id="p2">**</ept> method.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>As with the <bpt id="p1">**</bpt>Set<ept id="p1">**</ept> class, the <bpt id="p2">**</bpt>List<ept id="p2">**</ept> class provides methods <bpt id="p3">**</bpt>getEnumerator<ept id="p3">**</ept> and <bpt id="p4">**</bpt>getIterator<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>You can use an iterator to insert and delete items from a <bpt id="p1">**</bpt>List<ept id="p1">**</ept> object.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Map<ept id="p1">**</ept> associates a key value with another value.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Set<ept id="p1">**</ept> holds values of any single type.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>Values are not stored in the sequence they are added.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>Instead, the <bpt id="p1">**</bpt>Set<ept id="p1">**</ept> object stores them in a manner that optimizes performance for the <bpt id="p2">**</bpt>in<ept id="p2">**</ept> method.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>When you add a value to a <bpt id="p1">**</bpt>Set<ept id="p1">**</ept> object which is already storing that same value, the add attempt is ignored by the <bpt id="p2">**</bpt>Set<ept id="p2">**</ept> object.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>Unlike the <bpt id="p1">**</bpt>Array<ept id="p1">**</ept> class, the <bpt id="p2">**</bpt>Set<ept id="p2">**</ept> class provides the methods <bpt id="p3">**</bpt>in<ept id="p3">**</ept> and <bpt id="p4">**</bpt>remove<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Struct<ept id="p1">**</ept> can contain values of more than one type.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>Used to group information about a specific entity.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>The constructor for each collection class, except <bpt id="p1">**</bpt>Struct<ept id="p1">**</ept>, takes in a type parameter that is an element of the <bpt id="p2">**</bpt>Types<ept id="p2">**</ept> system enum.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The collection instance can store items of that type only.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Types::AnyType<ept id="p1">**</ept> enum element is a special case and it cannot be used to construct a collection object, such as a <bpt id="p2">**</bpt>Set<ept id="p2">**</ept> object.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>null<ept id="p1">**</ept> value cannot be stored as an element in a <bpt id="p2">**</bpt>Set<ept id="p2">**</ept> object.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>And <bpt id="p1">**</bpt>null<ept id="p1">**</ept> cannot be a key in a <bpt id="p2">**</bpt>Map<ept id="p2">**</ept> object.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>You can iterate through a collection object with an iterator or enumerator.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>Here are typical examples of how you can obtain an iterator:</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">**</bpt>Set<ept id="p1">**</ept> objects, if any elements are added or removed after an iterator is created, the iterator instance can no longer be used to read from or step through the collection.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>For <bpt id="p1">**</bpt>Map<ept id="p1">**</ept> objects, element removals invalidate the iterator just as for <bpt id="p2">**</bpt>Set<ept id="p2">**</ept> objects.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>However, a <bpt id="p1">**</bpt>MapIterator<ept id="p1">**</ept> object remains valid even after a call to the <bpt id="p2">**</bpt>Map.insert<ept id="p2">**</ept> method.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>This is true whether the key is new, or whether the key already exists and only the value is actually being updated in the <bpt id="p1">**</bpt>Map<ept id="p1">**</ept> element.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>Code that calls <bpt id="p1">**</bpt>Map.insert<ept id="p1">**</ept> and relies on the iterator object remaining valid might fail if run as .NET Framework CIL.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>You can use the collection classes to form more complex classes.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>For example, a stack might easily be implemented by using a list where the elements are always added to the start of the list.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The newest element then occupies the top of the stack.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>You can also extend the collection classes.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>For example, you might extend the <bpt id="p1">**</bpt>List<ept id="p1">**</ept> class to create a list of customer records where the operations could be made type safe.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The derived collection class would accept only customer records, not just any record.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Extended data types (EDTs)</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Extended data types (EDTs)<ept id="p1">**</ept> are user-defined types, based on the primitive data types <bpt id="p2">**</bpt>boolean<ept id="p2">**</ept>, <bpt id="p3">**</bpt>int<ept id="p3">**</ept>, <bpt id="p4">**</bpt>int64,<ept id="p4">**</ept> <bpt id="p5">**</bpt>real<ept id="p5">**</ept>, <bpt id="p6">**</bpt>str<ept id="p6">**</ept>, and <bpt id="p7">**</bpt>date<ept id="p7">**</ept>, and the composite type <bpt id="p8">**</bpt>container<ept id="p8">**</ept>.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>An EDT is a primitive data type or container with a supplementary name and some additional properties.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>For example, you could create a new EDT called <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> and base it on a string.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>Thereafter you can use the new EDT in variable and field declarations in the development environment.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>You can also base EDTs on other EDTs.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>EDTs are standard data types, but with a specific name and additional properties.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>EDTs undergo the same value and type <bpt id="p1">[</bpt>conversions<ept id="p1">](https://docs.microsoft.com/en-us/dynamics365/operations/dev-itpro/dev-reference/x-conversion-run-time-functions)</ept> as do the standard data types they are based on.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>The benefits of EDTs are:</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>Code is easier to read because variables have a meaningful data type.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> instead of <bpt id="p2">**</bpt>str<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>The properties you set for an EDT are used by all instances of that type, which reduces work and promotes consistency.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>For example, account numbers (<bpt id="p1">**</bpt>AccountNum<ept id="p1">**</ept> data type) have the same properties throughout the system.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>You can create hierarchies of EDTs, inheriting the properties that are appropriate from the parent and changing the other properties.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">**</bpt>ItemCode<ept id="p1">**</ept> data type is used as the basis for the <bpt id="p2">**</bpt>MarkupItemCode<ept id="p2">**</ept> and <bpt id="p3">**</bpt>PriceDiscItemCode<ept id="p3">**</ept> data types.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>Create an extended data type</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>This feature is not implemented as a language construct.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>To create an EDT:</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>In <bpt id="p1">**</bpt>Solution Explorer,<ept id="p1">**</ept> right-click on the project, select <bpt id="p2">**</bpt>Add<ept id="p2">**</ept> and then <bpt id="p3">**</bpt>New item.<ept id="p3">**</ept></source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Add New Item<ept id="p1">**</ept> dialog, select Installed and then <bpt id="p2">**</bpt>Artifacts<ept id="p2">**</ept> in the left pane.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>In the middle pane, select the EDT type you want to create.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>Enter a name and click <bpt id="p1">**</bpt>Add.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>EDT code example</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>Null values for data types</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>Microsoft Dynamics 365 for Operations does not support the concept of <bpt id="p1">**</bpt>null<ept id="p1">**</ept> values that is available in many other Database Management Systems (DBMS).</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>A variable in X++ always has a type and a value.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>For each data type, however, one value is considered null (for example, when the <bpt id="p1">**</bpt>validateField<ept id="p1">**</ept> table method is executed).</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>Type</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>Value treated as null</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>Date</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>1900-01-01</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>Enum</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>Element with its value set to 0.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>Integer</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>Real</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>0.0</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>String</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>An empty string</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>Time</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>00:00:00</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>Utcdatetime</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>Any value with its date portion as 1900-01-01 is treated as <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, regardless of the time portion value.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>Therefore the value 1900-01-01T22:33:44 is treated as <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>Note that any <bpt id="p1">**</bpt>utcDateTime<ept id="p1">**</ept> value with its date portion as 1900-01-01 is displayed as blank by the X++ <bpt id="p2">**</bpt>print<ept id="p2">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>Only the value 1900-01-01T00:00:00 is displayed as blank by the <bpt id="p1">**</bpt>Global::info<ept id="p1">**</ept> method.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>That is the value from the <bpt id="p1">**</bpt>DateTimeUtil::MinValue<ept id="p1">**</ept> method.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>As a result, when the <bpt id="p1">**</bpt>validateField<ept id="p1">**</ept> method checks whether a user has entered a value in a mandatory field, 0 is not accepted in an integer type field, the first entry is not accepted in an enum type field, and so on.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>Also, the values that are listed in the previous table yield <bpt id="p1">**</bpt>false<ept id="p1">**</ept> in a Boolean comparison, in X++ SQL.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>In non-SQL X++ statements, the equal and relational operators work with these values the same normal way that they work with other values.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>Variables of type container, and classes and variables of table type can be null in the traditional database management system (DBMS) sense.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>A table type is <bpt id="p1">**</bpt>null<ept id="p1">**</ept> if all its fields have their null value.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>