{"content":"---\n# required metadata\n\ntitle: X++ and C# comparison\ndescription: This topic compares X++ and C# syntax and programming.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 04/04/2017\nms.topic: article\nms.prod: \nms.service: Dynamics365Operations\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \n# ms.reviewer: 2051\nms.search.scope: AX 7.0.0, Operations\n# ms.tgt_pltfrm: \nms.custom: 72424\nms.assetid: 9e0b3126-aa04-4b76-a254-bfbd3fcd6552\nms.search.region: Global\n# ms.search.industry: \nms.author: robinr\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# X++ and C# comparison\n\n[!include[banner](../includes/banner.md)]\n\n\nThis topic compares X++ and C# syntax and programming.\n\n# X++, C# Comparison: Hello World\n\nThis section compares the simplest X++ program to its counterpart in C#.\n\n## X++ to C# Comparisons\n\nThe following sections describe some basic similarities and differences between X++ and C\\#.\n\n## Similarities\n\nThe following X++ features are the same for C#:\n-   Single line (`//`) and multi-line (/\\* \\*/) comments.\n-   `==` (equal) operator for determining whether two values are equal.\n-   != (not equal to) operator for determining whether two values are not equivalent.\n-   + (plus sign) operator for string concatenation.\n\n## Differences\n\nThe following table lists X++ features that are different in C#.\n\n| Feature | X++ | C# | Comments |\n|---|---|---|---|\n| Declarations | All declarations must be at the start of the method, before any X++ statements. | Declarations can occur anywhere in the method. | Both languages permit multiple variables of the same type to be listed together in one declaration. Both languages allow you to assign an initial value in the declaration statement. |\n| `if` and `else` conditional statements | The `if` statement accepts any type of expression that it can automatically convert to a Boolean. Common examples include an `int` for which 0 means false, or an object for which null means false. | The `if` statement requires a Boolean expression. | The syntax structure regarding curly braces and parentheses is exactly the same between X++ and C#. |\n| Literal string | A literal string can be delimited by either of the following:<ul><li>A pair of double quotation mark (\") characters.</li><li>A pair of single quotation mark (') characters.</li></ul> | A literal string must be delimited by a pair of double quotation mark (\") characters. | For X++, the double quotation mark characters are usually used to delimit strings. However, it is convenient delimit a string with single quotation mark characters when your string must contain a double quotation mark character.|\n| char `type` | There is no `char` or character type in X++. You can declare a `str` of length one, but it is still a string:<br> `str 1 myString = \"a\";` | There is a `char` in C#. You cannot pass a `char` as the parameter to a method that inputs a `string` parameter, although you can first explicitly convert the `char` to a `string`.| For more information about X++ data types, see Primitive Data Types.|\n| Output of messages| X++ delivers messages to the user in the Infolog window. Common methods include the following:<ul><li>The <strong>print</strong> statement:</li><li>static methods on the `Global` class:<ul><li>Global::info</li><li>Global::warning</li><li>Global::error</li></ul></li></ul>| For a command line C# program, messages can be delivered to the console. Common methods include the following:<ul><li>`Console.Out.WriteLine`</li><li>`Console.Error.WriteLine`</li></ul>| The <strong>print</strong> statement is not a function nor a method. Recommended use would be `print mystring;` rather than `print(mystring);`. A `pause;` statement is always useful shortly after a <strong>print</strong> statement. The print statement is convenient for testing because it automatically converts <strong>int</strong> and other primitive values to strings for display. For more information, see Print Statements. The `Global` class has special recognition in the X++ compiler. The `info` method can be called without including the Global:: prefix.|\n\n### X++ and C++ Samples\n\nThis section contains two simple code samples. One sample is written in X++, and the other is in C\\#. Both samples achieve the same result. The following X++ features are demonstrated:\n-   `//` single line comment\n-   /\\* \\*/ multi-line comment\n-   `if` statement\n-   `==` operator\n-   != operator\n-   + operator to concatenate strings\n-   Global::info for message output, with and without the Global:: prefix\n-   Global::error for message output\n-   The use of single and double quotation characters (' and \") as string delimiters.\n\n**Note**: The best practice is to use double quotation marks for any string that might be displayed to the user.\n\n## X++ Sample\n\nThis X++ code sample is in the form of a job. There is a node titled Jobs in the Application Object Tree (AOT). This sample can be added under the Jobs node, and then the job can be run.\n\n    static void JobRs001a_HelloWorld(Args _args)\n    {\n        if (1 == 1) \n        {\n            // These two info() calls are identical to the X++ compiler.\n            // The second form is the one typically used in X++.\n            Global::info(\"Hello World, 1.\");\n            info('Hello World, 2.');\n        }\n        if (1 != 1)\n        {\n            error(\"This message will not appear.\");\n        }\n        else\n        {\n            // These two methods are also from the Global class.\n            // The + operator concatenates two strings.\n            warning(\"This is like info,\" + \" but is for warnings, 3.\");\n            error(\"This is like info,\" + \" but is for errors, 4.\");\n        }\n    }\n\n## Output\n\nHere is the output from the Infolog window:\n    Message (09:49:48)\n    Hello World, 1.\n    Hello World, 2.\n    This is like info, but is for warnings, 3.\n    This is like info, but is for errors, 4.\n\n## C# Sample\n\nThe following C# program is a rewrite of the previous X++ program. The differences between X++ and C# are highlighted by commenting out the X++ lines, and replacing them with the C# syntax.\n\nC#\n\n    using System;\n    class Pgm_CSharp\n    {\n        static void Main( string[] args )\n        {\n            new Pgm_CSharp().Rs001a_CSharp_HelloWorld();\n        }\n        void Rs001a_CSharp_HelloWorld()\n        {\n            if (1 == 1) \n            {\n                Console .Out .WriteLine(\n                    \"Hello World, Explicit .Out , 1.\");\n                Console .WriteLine(\n                    \"Hello World, Implicit default to .Out , 2.\");\n            }\n            if (1 != 1)\n            {\n                Console .Error .WriteLine(\n                    \"This message will not appear.\");\n            }\n            else\n            {\n                Console .Error .WriteLine(\".Error is like .Out,\"\n                    + \" but can be for warnings, 3.\");\n                Console .Error .WriteLine(\".Error is like .Out,\"\n                    + \" but is for errors, 4.\");\n            }\n        }\n    }\n\n## Output\n\nHere is the actual output to the C# console:\n\n    Hello World, Explicit .Out, 1. \n    Hello World, Implicit default to .Out, 2. \n    .Error is like .Out, but can be for warnings, 3. \n    .Error is like .Out, but is for errors, 4.\n\n# X++, C# Comparison: Loops\nThis section compares the loop features between X++ and C\\#.\n\n##  Similarities\n\nThe following features are the same in X++ and C\\#:\n-   Declarations for variables of the int primitive data type. Declarations for other primitive types are almost the same, but the types might have different names.\n-   while statement for loops.\n-   break statement to exit a loop.\n-   continue statement to jump up to the top of a loop.\n-   <= (less than or equal) comparison operator.\n\n##  Differences\n\nThe following table lists X++ features that are different in C#.\n\n| Features | X++ | C# | Comments |\n|---|---|---|---|\n| The `for` statement.| The for statement is available for loops.| The C# `for` statement is slightly different from `for` in X++.| In C# you can declare the counter integer in the `for` statement. But in X++ the counter must declared outside the `for` statement.|\n|++ increment operator.|An ++ increment operator is available in X++. But an <strong>int</strong> variable that is decorated with ++ can only be used as a statement, not as an expression. For example, the following lines of X++ code would not compile:<br>`int age=42;`<br> `print age++;`<br> However, the following lines of X++ code would compile:<br>`int age=42;`<br>`age++; print age;`|The C# ++ operator is more flexible than in X++.|The following lines of code are the same in both languages:<ul><li>++ myInteger;</li><li>myInteger++;</li></ul>But the following lines of code have a different effect from each other, and are valid only in C#:<ul><li>yourInt = ++myInt;</li><li>yourInt = myInt++;</li></ul>|\n| modulo operator.| In X++ the modulo operator is mod.| In C# the modulo operator is %.| The symbols for the modulo operator are different, but their behavior is the same in both languages.|\n| Temporarily suspend a console program that has already begun.| The `pause` statement.| In C#, a command line program can be paused by the following line of code:<br>`Console.In.Read();`| In X++ you continue by clicking an OK button on a modal dialog box. In C# you continue by pressing any keyboard on the keyboard.|\n| Display a message.| In X++, the `print` statement displays a message in the Print window.| In C# a message can be displayed on the console by the following line of code:<br>`Console.WriteLine();`| The X++ `print` function is used only when you test. An X++ program that uses `print` almost always uses the `pause` statement somewhere later in the code. For production X++ code, use the Global::info Method instead of `print`. The `strfmt` function is often used together with `info`. There is no reason to use `pause` after `info`.|\n| Make a sound.| The beep function makes a sound that you can hear. | In C# a sound that you can hear is issued by the following line of code:<br>`Console.Beep();`| The statements each produce a short tone.|\n\n\n## Print and Global::info\n\nThe X++ code samples for loops use the `print` function to display results. In X++ you can use the `print` statement can display any primitive data type without having to call functions that convert it to a string first. This makes `print` useful in quick test situations. Generally the Global::info method is used more often than `print`. The `info` method can only display strings. Therefore the strfmt function is often used together with `info`. A limitation of `print` is that you cannot copy the contents of the Print window to the clipboard (such as with Ctrl+C). Global::info writes to the Infolog window which does support copy to the clipboard.\n\n## Example 1: The while Loop\n\nThe **while** keyword supports looping in both X++ and C#.\n\n### X++ Sample of while\n\n    static void JobRs002a_LoopsWhile(Args _args)\n    {\n        int nLoops = 1;\n        while (nLoops &lt;= 88)\n        {\n            print nLoops;\n            pause;\n            // The X++ modulo operator is mod.\n            if ((nLoops mod 4) == 0)\n            {\n                break;\n            }\n            ++ nLoops;\n        }\n        beep(); // Function.\n        pause; // X++ keyword.\n} \n\n### Output\n\nThe output in the X++ Print window is as follows:\n\n    1\n    2\n    3\n    4\n\n### C# Sample of while\n\nC#\n\n    using System;\n    public class Pgm_CSharp\n    {\n        static void Main( string[] args )\n        {\n            new Pgm_CSharp().Rs002a_CSharp_ControlOFlowWhile();\n        }\n        void Rs002a_CSharp_ControlOFlowWhile()\n        {\n            int nLoops = 1;\n            while (nLoops <= 88)\n            {\n                Console.Out.WriteLine( nLoops.ToString() );\n                Console.Out.WriteLine( \"(Press any key to resume.)\" );\n                // Paused until user presses a key.\n                Console.In.Read();\n                if ((nLoops % 4) == 0) break;\n                ++ nLoops;\n            }\n            Console.Beep();\n            Console.In.Read();\n        }\n    }\n\n \n\n### Output\n\nThe console output from the C# program is as follows:\n\n    [C:\\MyDirectory\\]\n    >> Rosetta_CSharp_1.exe\n    1\n    (Press any key to resume.)\n    2\n    (Press any key to resume.)\n    3\n    (Press any key to resume.)\n    4\n    (Press any key to resume.)\n\n## Example 2: The for Loop\n\nThe **for** keyword supports looping in both X++ and C#.\n\n### X++ Sample of for\n\nIn X++ the counter variable cannot be declared as part of the **for** statement.\n\n    static void JobRs002a_LoopsWhileFor(Args _args)\n    {\n        int ii; // The counter.\n        for (ii=1; ii &lt; 5; ii++)\n        {\n            print ii;\n            pause;\n            // You must click the OK button to proceed\n            // beyond a pause statement.\n            // ii is always less than 99.\n            if (ii < 99)\n            {\n                continue;\n            }\n            print \"This message never appears.\";\n        }\n        pause;\n}\n\n \n\n### Output\n\nThe output in the X++ Print window is as follows:\n\n    1\n    2\n    3\n    4\n\n### C# Sample of for\n\nC#\n\n    using System;\n    public class Pgm_CSharp\n    {\n        static void Main( string[] args )\n        {\n            new Pgm_CSharp().Rs002a_CSharp_ControlOFlowFor();\n        }\n        void Rs002a_CSharp_ControlOFlowFor()\n        {\n            int nLoops = 1,\n                ii;\n            for (ii = 1; ii < 5; ii++)\n            {\n                Console.Out.WriteLine(ii.ToString());\n                Console.Out.WriteLine(\"(Press any key to resume.)\");\n                Console.In.Read();\n                if (ii < 99)\n                {\n                    continue;\n                }\n                Console.Out.WriteLine(\"This message never appears.\");\n            }\n            Console.Out.WriteLine(\"(Press any key to resume.)\");\n            Console.In.Read();\n        }\n    }\n\n \n\n### Output\n\nThe console output from the C# program is as follows:\n    1\n    (Press any key to resume.)\n    2\n    (Press any key to resume.)\n    3\n    (Press any key to resume.)\n    4\n    (Press any key to resume.)\n    (Press any key to resume.)\n\n## X++, C# Comparison: Switch\n\nIn both X++ and C#, the **switch** statement involves the keywords **case**, **break**, and **default**. The following table lists the differences in the **switch** statement between X++ and C\\#.\n\n| Feature  | X++ | C# | Comments |\n|--------|-----------|------------|-----|\n| `break;` at the end of each case block       | In X++, when any **case** block matches the expression value on the **switch** clause, all other **case** and **default** blocks are executed until a `break;` statement is reached. No `break;` statement is ever required in an X++ **switch** statement, but `break;` statements are important in almost all practical situations. | In C\\#, a `break;` statement is always needed after the statements in a **case** or **default** block. If a **case** clause has no statements between itself and the next **case** clause, a `break;` statement is not required between the two **case** clauses. | We recommend against omitting the `break;` statement after any case **block**, because it can confuse the next programmer who edits the code. |\n| `break;` at the end of the **default** block | In X++ there is no effect of adding a `break;` statement at the end of the **default** block.   | In C\\# the compiler requires a `break;` statement at the end of the **default** block. | For more information, see Switch Statements. |\n| Only constant values on a **case** block     | In X++ you can specify either a literal value or a variable on a case block. For example, you can write case myInteger:.  | In C\\# you must specify exactly one literal value on each **case** block, and no variables are allowed. | No comments.  |\n| Multiple values on one **case** block        | In X++ you can specify multiple values on each case block. The values must be separated by a comma. For example, you can write `case 4,5,myInteger:`.    | In C\\# you must specify exactly one value on each **case** block. | In X++ it is better to write multiple values on one **case** block than to omit the `break;` statement at the end of one or more case blocks. |\n\n## Code Examples for switch\n\nThe following sections show comparable switch statements in X++ and C\\#.\n\n### X++ switch Example\n\nThe X++ switch example shows the following:\n-   case iTemp: and case (93-90): to show that **case** expressions are not limited to constants, as they are in C\\#.\n-   `//break;` to show that `break;` statements are not required in X++, although they are almost always desirable.\n-   case 2, (93-90), 5: to show that multiple expressions can be listed on on **case** clause in X++.\n\nX++\n\n    static void GXppSwitchJob21(Args _args)  // X++ job in AOT &gt; Jobs.\n    {\n        int iEnum = 3;\n        int iTemp = 6;\n        switch (iEnum)\n        {\n            case 1:\n            case iTemp:  // 6\n                info(strFmt(\"iEnum is one of these values: 1,6: %1\", iEnum));\n                break;\n            case 2, (93-90), str2Int(\"5\"):  // Equivalent to three 'case' clauses stacked, valid in X++.\n                //case 2:\n                //case (93-90):  // Value after each 'case' can be a constant, variable, or expression; in X++.\n                //case str2Int(\"5\"):\n                info(strFmt(\"iEnum is one of these values: 2,3,5: %1\", iEnum));\n                //break;  // Not required in X++, but usually wanted.\n            case 4:\n                info(strFmt(\"iEnum is one of these values: 4: %1\", iEnum));\n                break;\n            default:\n                info(strFmt(\"iEnum is an unforeseen value: %1\", iEnum));\n                break;\n                // None of these 'break' occurrences in this example are required for X++ compiler.\n        }\n        return;\n    }\n\n    /*** Copied from the Infolog:\n    Message (02:32:08 pm)\n    iEnum is one of these values: 2,3,5: 3\n    iEnum is one of these values: 4: 3\n    ***\n\n\n### C# switch Example\n\nThe C\\# switch example shows the following:\n-   case 1: has a comment explaining that only constant expressions can be given on a **case** clause.\n-   `break;` statements occur after the last statement in each **case** block that has statements, as is required by C\\#.\n\nC#\n\n    using System;\n    namespace CSharpSwitch2\n    {\n      class Program\n      {\n        static void Main(string[] args)  // C#\n        {\n          int iEnum = 3;\n          switch (iEnum)\n          {\n            case 1:  // Value after each 'case' must be a constant.\n            case 6:\n              Console.WriteLine(\"iEnum is one of these values: 1,6: \" + iEnum.ToString());\n              break;\n            //case 2,3,5:  // In C# this syntax is invalid, and multiple 'case' clauses are needed.\n            case 2:\n            case 3:\n            case 5:\n              Console.WriteLine(\"iEnum is one of these values: 2,3,5: \" + iEnum.ToString());\n              break;\n            case 4:\n              Console.WriteLine(\"iEnum is one of these values: 4: \" + iEnum.ToString());\n              break;\n            default:\n              Console.WriteLine(\"iEnum is an unforeseen value: \" + iEnum.ToString());\n              break;\n            // All 'break' occurrences in this example are required for C# compiler.\n          }\n          return;\n        }\n      }\n    }\n    /*** Output copied from the console:\n    >> CSharpSwitch2.exe\n    iEnum is one of these values: 2,3,5: 3\n    >>\n    ***/\n\n \n\n# X++, C# Comparison: String Case and Delimiters\nThis section compares the treatment of strings with mixed casing in X++ and C\\#. It also explains the string delimiters that are available in X++.\n\n## Similarities\n\nThe following X++ features are the same as in C\\#:\n-   The backslash (\\\\) is the escape operator for string delimiters.\n-   The at sign (@) nullifies the escape effect of the backslash when the at sign is written immediately before the open quotation mark of a string.\n-   The plus sign (+) is the string concatenation operator.\n\n## Differences\n\nX++ features that are different in C\\# are listed in the following table.\n\n| Feature | X++ | C# | Comments |\n|---|---|---|---|\n| `== `comparison operator| Insensitive: the `==` operator is insensitive to differences in string casing.| In C#, the `==` operator is sensitive to differences in string casing.| In X++ you can use the strCmp Function for case sensitive comparisons between strings.|\n| String delimiters| In X++ you can use either the single (') or double (`\"`) quotation mark as the string delimiter. **Note**: Usually the best practice is to use double quotation marks for strings that might be displayed to the user. However, it is convenient to delimit a string with single quotation marks when a double quotation mark is one of the characters in the string.| In C# you must use the double quotation mark as the string delimiter. This refers to the type `System.String`.| In X++ and C# you have the option of embedding a delimiter in a literal string and escaping it with \\. <br>In X++ you also have the alternative of embedding single quotation marks in a string that is delimited by double quotation marks (or the reverse), without having to use the escape.|\n| Character delimiters| X++ has a string data type (`str`), but no character type.| In C# you must use the single quotation mark as the character delimiter. This refers to the type `System.Char`.| In the .NET Framework, a `System.String` of length one is a different data type than a `System.Char` character.|\n\n## Example 1: Case Sensitivity of the == Operator\n\nThe `==` and != operators are case insensitive in X++, but are case sensitive in C\\#, as is illustrated by the following example.\n\n| X++    | C#  | Comments       |\n|----------------|---------|-----------|\n| `\"HELLO\" == \"hello\"` <br>True in X++. | `\"HELLO\" == \"hello\"` <br>False in C#. | Different case comparisons between X++ and C#. |\n\n## Example 2: The + String Concatenation Operator\n\nThe + and += operators are used to concatenate strings in both X++ and C\\#, as is shown by the examples in the following table.\n\n| X++  | C#   | Comments |\n|---------|--------------------|----------------------------|\n| `myString1 = \"Hello\" + \" world\";` <br>Result is equality: <br>`myString1 == \"Hello world\"`  | (Same as for X++.) | In both X++ and C#, the behavior of the + operator depends on the data type of its operands. The operator concatenates strings, or adds numbers. |\n| `mystring2 = \"Hello\";` <br>`myString2 += \" world\";` <br>Result is equality: `myString2 == \"Hello world\"` | (Same as for X++.) | In both X++ and C#, the following statements are equivalent: <br>`a = a + b;` <br>`a += b;`  |\n\n## Example 3: Embedding and Escaping String Delimiters\n\nEither single or double quotation marks can be used to delimit strings in X++. The escape character (\\\\) can be used to embed delimiters in a string. These are illustrated in the following table.\n\n| X++ | C#         | Comments   |\n|---------|-----|--------------------------------------|\n| `myString1 = \"He said \\\"yes\\\".\";` <br>Result: <br>`He said \"yes\".`  | (Same as for X++.)  | The escape character enables you to embed string delimiters inside strings.   |\n| `myString2 = 'He said \"yes\".';` <br>Result: <br>`He said \"yes\".`  | C# syntax does not allow for single quotation marks to delimit strings.    | For strings that may be seen by the user, it is considered a best practice to use the escape character instead of the single quotation marks as shown in the example.   |\n| `myString3 = \"He said 'yes'.\";` <br>Result: <br>`He said 'yes'.` | (Same as for X++.) | In X++, the single quotation marks are not treated as delimiters unless the string starts with a single quotation mark delimiter. In C# the single quotation mark has no special meaning for strings, and it cannot be used to delimit strings. In C# the single quotation mark is the required delimiter for literals of type `System.Char`. X++ has no character data type. |\n| `str myString4 = 'C';` <br>Here the single quotation is a string delimiter. | `char myChar4 = 'C';` <br>Here the single quotation mark is a `System.Char` delimiter, not a `System.String` delimiter. | X++ has no data type that corresponds to `System.Char` in the .NET Framework. An X++ string that is limited to a length of one is still a string, not a character data type. |\n\n## Example 4: Single Escape Character\n\nExamples that illustrate the single escape character in either the input or the output are shown in the following table.\n\n| X++    | C# | Comments     |\n|-----------------------|--------|------------------|\n| `myString1 = \"Red\\ shoe\";` <br>Result: <br>`Red shoe`     | A literal string in C# cannot contain the two character sequence of escape followed by a space, such as \"\\ \". A compiler error occurs. | When the X++ compiler encounters the two character sequence of \"\\ \", it discards the single escape character. |\n| `myString2 = \"Red\\\\ shoe\";` <br>Result: <br>`Red\\ shoe` | (Same as for X++.)  | In a pair of escape characters, the first negates the special meaning of the second.     |\n\n# Comparison: Array Syntax\n\nThere are similarities and differences in the features and syntax for arrays in X++ versus C\\#.\n\n## Similarities\n\nOverall there is much similarity in the syntax and treatment of arrays in X++ and C#. However there are many differences.\n\n## Differences\n\nThe following table lists areas in the [] syntax for arrays that are different for X++ and C#.\n\n| Category | X++ | C# | Comments |\n|---|---|---|---|\n| Declaration| An array is declared with square brackets appended to the variable name.| An array is declared with square brackets appended to the data type.| `int myInts[]; // X++` <br>**Note**: An X++ array cannot be a parameter in a method.<br>`int[] myInts; // C#`|\n| Declaration| The array syntax supports only primitive data types, such as `int` and `str`. The syntax does not support classes or tables.|The array syntax supports primitive data types and classes.| In X++ you can use the `Array` Array for an array of objects.|\n| Declaration| X++ is limited to single dimension arrays (myStrings[8]).| C# adds support for multi-dimensional arrays (myStrings[8,3]) and for jagged arrays (myStrings[8][3]).| In X++ you cannot have an array of arrays. However, there is advanced syntax for limiting the amount of active memory that a large array can consume, which looks like the multi-dimensional syntax in C#: int intArray[1024,16];. For more information, see Best Practice Performance Optimizations: Swapping Arrays to Disk.|\n| Declaration| In X++ an array is a special construct but it is not an object.| In C# all arrays are objects regardless of syntax variations.| X++ does have an Array class, but its underlying mechanism differs from arrays created by using the [] syntax. In C# all arrays use the same underlying mechanism, regardless of whether [] syntax of the `System.Array` class is used in your code.|\n| Length| In X++ the length of a static sized array is determined in the declaration syntax.| In C# the size of an array is determined when the array object is constructed.| When you use the [] declaration syntax in X++, no more preparation is needed before you assign values to the array. <br>In C# you must declare and then construct the array before assigning to it.|\n| Length| An X++ array can have a dynamic length that can be increased even after population has begun. This applies only when the array is declared without a number inside the []. Performance might be slowed if the length of the dynamic array is increased many times.| In C# the length of an array cannot be changed after the length is set.| In the following fragment of X++ code, only the `myInts` array is dynamic and can increase in size. <br>`int myInts[];` <br>`int myBools[5];` <br>`myInts[2] = 12;` <br>`myInts[3] = 13;` <br>`myBools[6] = 26; //Error`|\n| Length| You can get the length of some arrays by using the `dimOf` function.| C# arrays are objects that have a `Length` property.| No comments.|\n| Indexing| Array indexing is 1 based.| Array indexing is 0 based.\n| mtIntArray[0] would cause an error in X++.|\n| Constant| In X++ a constant value is best achieved by using the <strong>#define</strong> precompiler directive.| In C# you can decorate your variable declaration with the keyword <strong>const</strong>, to achieve a constant value.| X++ has no <strong>const</strong> keyword. C# cannot assign values to variables that are created by its #define precompiler directive.|\n\n## X++ and C\\# Samples\n\nThe following code samples show how arrays of primitive data types are handled. The first sample is in X++, and the second sample is in C\\#. Both samples achieve the same results.\n\n## X++ Sample\n\n<pre>\nstatic void JobRs005a_ArraySimple(Args _args)\n{\n    #define.macroArrayLength(3)\n    // Static length.\n    str sSports[#macroArrayLength];\n    // Dynamic length, changeable during run time.\n    int years[];\n    int xx;\n    Global::warning(\"-------- SPORTS --------\");\n    sSports[#macroArrayLength] = \"Baseball\";\n    for (xx=1; xx <= #macroArrayLength; xx++)\n    {\n        info(int2str(xx) + \" , [\" + sSports[xx] + \"]\");\n    }\n    warning(\"-------- YEARS --------\");\n    years[ 4] = 2008;\n    years[10] = 1930;\n    for (xx=1; xx <= 10; xx++)\n    {\n        info(int2str(xx) + \" , \" + int2str(years[xx]));\n    }\n}\n</pre>\n\n### Output\n\nThe output to the Infolog is as follows:\n<pre>\nMessage (14:16:08)\n-------- SPORTS --------\n1 , []\n2 , []\n3 , [Baseball]\n-------- YEARS --------\n1 , 0\n2 , 0\n3 , 0\n4 , 2008\n5 , 0\n6 , 0\n7 , 0\n8 , 0\n9 , 0\n10 , 1930\n</pre>\n\n## C\\# Sample\n\nC#\n\n    using System;\n    public class Pgm_CSharp\n    {\n        static public void Main( string[] args )\n        {\n            new Pgm_CSharp().Rs005a_CSharp_ArraySimple();\n        }\n        private void Rs005a_CSharp_ArraySimple()\n        {\n            const int const_iMacroArrayLength = 3;\n            // In C# the length is set at construction during run.\n            string[] sSports;\n            int[] years;\n            int xx;\n            Console.WriteLine(\"-------- SPORTS --------\");\n            sSports = new string[const_iMacroArrayLength];\n            sSports[const_iMacroArrayLength - 1] = \"Baseball\";\n            for (xx=0; xx < const_iMacroArrayLength; xx++)\n            {\n                Console.WriteLine( xx.ToString()\n                    + \" , [\" + sSports[xx] + \"]\" );\n            }\n            Console.WriteLine(\"-------- YEARS --------\");\n            // In C# you must construct the array before assigning to it.\n            years = new int[10];\n            years[ 4] = 2008;\n            years[10 - 1] = 1930;\n            for (xx=0; xx < 10; xx++)\n            {\n                Console.WriteLine( xx.ToString()\n                    + \" , [\" + years[xx].ToString() + \"]\" );\n            }\n        }\n    } // EOClass\n\n### Output\n\nThe output from the C# program to the command line console is as follows:\n<pre>\n-------- SPORTS --------\n0 , []\n1 , []\n2 , [Baseball]\n-------- YEARS --------\n0 , [0]\n1 , [0]\n2 , [0]\n3 , [0]\n4 , [2008]\n5 , [0]\n6 , [0]\n7 , [0]\n8 , [0]\n9 , [1930]\n</pre>\n\n# Additional array-like X++ features\n\nThe **container** is a special data type that is available in X++. It can be considered as similar to an array, or similar to a `List` collection.\n\n# Comparison: Collections\nMicrosoft Dynamics 365 for Operations provides the X++ `List` collection class. The .NET Framework that is used in C# has a similar class named `System.Collections.Generic.List`.\n\n## Comparing the Use of the List Classes\n\nThe following table compares methods on the X++ `List` class to the methods on `System.Collections.Generic.List` from the .NET Framework and C\\#.\n\n| Feature | X++ | C# | Comments |\n|---|---|---|---|\n| Declaration of collection| `List myList;`| `List<string> myList;`| The X++ declaration does not include the type of elements to be stored.|\n| Declaration of iterator|`ListIterator iter`<br>`ListEnumerator enumer;`| IEnumerator&lt;string&gt; iter;| In X++ the `ListIterator` object has methods that can `insert` and `delete` items from the `List`. The X++ `ListEnumerator` cannot modify the contents of the `List`. In X++ the `ListEnumerator` object is always created on the same tier as the `List`. This is not always true for `ListIterator`.|\n| Obtaining an iterator|`new ListIterator (myList)`<br>`myList.getEnumerator()`| `myList.GetEnumerator()`| In both X++ and C#, the List object has a getter method for an associated enumerator.|\n| Constructor| `new List(Types::String)`| `new List<string>()`|Information about the type of objects to be stored inside the `List` classes is given to the constructor in both X++ and C#.|\n| Updating data|Enumerator – the enumerator becomes invalid if any items in the `List` are added or removed.<br>Iterator – the iterator has methods that insert and delete items from the `List`. The iterator remains valid.| Enumerator – the enumerator becomes invalid if any items in the `List` are added or removed.| Enumerators become invalid after items are added or deleted from the `List`, in both X++ and C#.|\n| Updating data| In X++ the `List` class has methods for adding items at the start or end of the list.| In C# the `List` class has methods for adding members at any position in the list. It also has methods for removing items from any position.| In X++ items can be removed from the `List` only by an iterator.|\n\n## Example 1: Declaration of a List\n\nThe following table displays code examples in X++ and C# that declare `List` collections.\n\n    // X++\n    List listStrings ,list2 ,listMerged;\n    ListIterator literator;\n\n    // C#\n    using System;\n    using SysCollGen = System.Collections.Generic;\n    SysCollGen.List<string> listStrings ,list2 ,listMerged; SysCollGen.IEnumerator<string> literator;\n\n## Example 2: Construction of a List\n\nIn both languages, the type of items that the collection stores must be specified at the time of construction. For class types, X++ can get no more specific than whether the type is a class (Types::Class). Code examples are in the following table.\n\n    // X++\n    listStrings = new List( Types::String );\n    \n    // C#\n    listStrings = new SysCollGen.List<string>;\n\n## Example 3: Add Items to a List\n\nIn both X++ and C#, the collection provides a method for appending an item to the end of the collection, and for inserting an item the start. In C# the collection provides a method for inserting at any point in the collection based on an index value. In X++ a collection iterator can insert an item at its current position. Code examples are in the following table.\n\n    // X++\n    listStrings.addEnd (\"String\\_BB.\"); \n    listStrings.addStart (\"String\\_AA.\");\n    // Iterator performs a midpoint insert at current position. \n    listIterator.insert (\"dog\");\n\n    // C#\n    listStrings.Add (\"String\\_BB.\"); \n    listStrings.Insert (0 ,\"String\\_AA.\");\n    // Index 7 determines the insertion point.\n    listStrings.Insert (7 ,\"dog\");\n\n## Example 4: Iterate Through a List\n\nBoth X++ and C\\# have iterator classes that you can use to step through the items in a collection. Code examples are in the following table.\n\n    // X++\n    literator = new ListIterator (listStrings); \n    // Now the iterator points at the first item.\n\n    // The more method answers whether \n    // the iterator currently points \n    // at an item. \n    while (literator.more()) \n    { \n        info(any2str (literator.value())); \n        literator.next(); \n    }\n\n    // C#\n    literator = listStrings .GetEnumerator(); \n    // Now enumerator points before the first item, not at the first item.\n    \n    // The MoveNext method both advances the item pointer, and \n    // answers whether the pointer is pointing at an item. \n    while (literator.MoveNext()) \n    { \n        Console.WriteLine (literator.Current); \n    }\n\n\n## Example 4b: foreach in C\\#\n\nIn C\\# the **foreach** keyword is often used to simplify the task of iterating through a list. The following code example behaves the same as the previous C\\# example. \n\n    foreach (string currentString in listStrings)\n    { \n        Console.WriteLine(currentString);\n    }\n\n##  Example 5: Delete the Second Item\n\nThe following table contains code examples that delete the second item from the collection. In X++ this requires an iterator. In C\\# the collection itself provides the method for removing an item.\n\n    // X++\n    literator.begin(); \n    literator.next(); \n    literator.delete();\n\n    // C#\n    listStrings.RemoveAt(1);\n\n##  Example 6: Combine Two Collections\n\nThe following table contains code examples that combine the contents of two collections into one.\n\n    // X++\n    listStrings = List::merge(listStrings ,listStr3);\n    // Or use the .appendList method:\n    listStrings.appendList (listStr3);\n\n    // C#\n    listStrings.InsertRange(listStrings.Count ,listStr3);\n\n# Comparison: Collections of keys with values\n\nMicrosoft Dynamics 365 for Operations provides the `Map` collection class. The `Map` collection holds pairs of values, the key value plus a data value. This resembles the .NET Framework class named `System.Collections.Generic.Dictionary`.\n\n## Similarities\n\nThe following list describes similarities between X++ and C\\# regarding their collections that store key-value pairs:\n-   Both prevent duplicate keys.\n-   Both use an enumerator (or iterator) to loop through the items.\n-   Both key-value collection objects are constructed with designations of the types that are stored as key and value.\n-   Both can store class objects, and are not limited to storing primitives like **int**.\n\n## Differences\n\nThe following table describes differences between X++ and C\\# regarding their collections classes that store key-value pairs:\n\n| Feature        | X++     | C#  | Comments |\n|---|---|---|---|\n| Duplicate keys | In X++ the `Map` class prevents duplicate keys by implicitly treating your call to its `insert` method as an operation to update only the value associated with the key. | In C\\# the `Dictionary` class throws an exception when you try to add a duplicate key. | Duplicate keys are prevented in both languages, although by different techniques.               |\n| Delete items   | In X++ the `delete` method on an iterator object is used to remove an unwanted key-value pair from a `Map`.    | In C\\# the `Dictionary` class has a `remove` method.      | In both languages, an enumerator is made invalid if the collection item count is modified during the life of the enumerator. |\n\n### Example 1: Declaration of a Key-Value Collection\n\nIn both languages, the type of items that the key-value collection stores must be specified. In X++ the type is specified at time of construction. In C\\# the type is specified at both the time of declaration and the time of construction. Code examples are in the following table.\n\n    // X++\n    Map mapKeyValue;\n    MapEnumerator enumer;\n    MapIterator mapIter;\n\n    // C#\n    SysCollGen.Dictionary<int,string> dictKeyValue;\n    SysCollGen.IEnumerator<SysCollGen.KeyValuePair<int,string>> enumer;\n    SysCollGen.KeyValuePair<int,string> kvpCurrentKeyValuePair;\n\n## Example 2: Construction of the Collection\n\nIn both languages, the type of items that the key-value collection stores specified during construction. For class types, X++ can get no more specific than whether the type is a class (Types::Class). Code examples are in the following table.\n\n    // X++\n    mapKeyValue = new Map(Types::Integer, Types::String);\n\n    // C#\n    dictKeyValue = new SysCollGen.Dictionary<int,string>();\n\n## Example 3: Add an Item to the Collection\n\nThere is almost no difference in how an item is added to a key-value collection, in X++ and C\\#. Code examples are in the following table.\n\n    // X++\n    mapKeyValue.insert(xx ,int2str(xx) + “_Value”);\n\n    // C#\n    dictKeyValue.Add(xx ,xx.ToString() + “_Value”);\n\n## Example 4: Iterate Through a Key-Value Collection\n\nEnumerators are used to loop through the key-value collections in both X++ and C\\#. Code examples are in the following table.\n\n    // X++ \n    enumer = mapKeyValue.getEnumerator();\n    while (enumer.moveNext())\n    {\n        iCurrentKey = enumer.currentKey();\n        sCurrentValue = enumer.currentValue();\n        // Display key and value here.\n    }\n\n    // C#\n    enumer = dictKeyValue.GetEnumerator();\n    while (enumer.MoveNext())\n    {\n        kvpCurrentKeyValuePair = enumer.Current;\n        // Display .Key and .Value properties=\n        // of kvpCurrentKeyValuePair here.\n    }\n\n## Example 5: Update the Value Associated with a Key\n\nThe syntax is very different between the two languages for an update of the value associated to a given key. Code examples for the key 102 are in the following table.\n\n    // X++\n    mapKeyValue.insert(\n        102 ,\n        ”.insert(), Re-inserted” + ” key 102 with a different value.”);\n\n    // C#\n    dictKeyValue[102] = \n        “The semi-hidden .item property” \n        + ” in C#, Updated the value for key 102.”;\n\n##  Example 6: Delete One Item\n\nThe syntax is very different between the two languages to delete one key-value pair from a collection, while iterating through the collection members. Code examples for the key 102 are shown below.\n\n    // X++\n    mapIter = new MapIterator(mapKeyValue);\n    //mapIter.begin();\n    while (mapIter.more())\n    {\n        iCurrentKey = mapIter.key();\n        if (104 == iCurrentKey)\n        {\n            // mapKeyValue.remove would invalidate the iterator.\n            mapIter.delete();\n            break;\n        }\n        mapIter.next();\n    }\n\n    // C#\n    dictKeyValue.Remove(104);\n\n\n# Comparison: Exceptions\nThere are some similarities but many differences when we compare exception related behavior between X++ and C\\#. The **try**, **catch**, and **throw** keywords behave the same in X++ and C#. But the types of exceptions thrown and caught are different for the two languages.\n\n## Similarities\n\nSimilarities between X++ and C\\# regarding their exception features include the following:\n-   Both languages have the same **try** keyword.\n-   Both have the same **catch** keyword.\n-   Both enable for a **catch** statement that does not specify any particular exception. Such a **catch** statement catches all exceptions that reach it.\n-   Both have the same **throw** keyword.\n\n## Differences\n\nException-related differences between X++ and C\\# are described in the following table.\n\n| Feature | X++ | C# | Comments |\n|---|---|---|---|\n| <strong>retry</strong>| Jumps to the first instruction in the associated <strong>try</strong> block. For more information, see Exception Handling with try and catch Keywords.| The functionality of the <strong>retry</strong> keyword can be mimicked in C# code, but there is no corresponding keyword.| Only X++ has a <strong>retry</strong> keyword. C# has no counterpart. For more information, see X++, C# Comparison: Automated Retry After an Exception.|\n| <strong>finally</strong>| The `finally` keyword is supported to follow the `try` and `catch` keywords.| The <strong>finally</strong> keyword marks a block of code that follows the <strong>try</strong> and <strong>catch</strong> blocks. The finally will be executed regardless of whether any exception is thrown or caught.| The semantics are identical to the semantics in C#.|\n| Specific exceptions| In X++ an exception is an element of the `Exception` enum, such as **Error**, **Deadlock**, or **CodeAccessSecurity**.No exception can contain another.| In C# an exception is an instance of the `System.Exception` base class, or any class that inherits from it. An exception can be contained in the `InnerException` property of the thrown exception.| In X++ each thrown exception is a value of the Exception enum. For more information, see Exception Enumeration.|\n| Exception message| In X++ the message that is created when an exception is raised is available only in the Infolog, and the message is not directly tied to the exception.| In C# the message is the `Message` member of the `System.Exception` object.| In X++ the Global::error method is the mechanism that display exception messages in the Infolog. For more information, see Exception Handling with try and catch Keywords.|\n| Exception conditions| In X++ an error occurs when you call an instance method on an object variable that has not yet had anything assigned to it. However, no exception is raised along with this error. Therefore no `catch` block can gain control even if the unassigned variable is misused in a `try` block. In the following code example, the error caused by the code `box4.toString();` does not cause control to transfer to any `catch` block: `DialogBox box4;` `try` { ` box4.toString();` ` info(\"toString did not error, but expected an error.\");` } catch (Exception::Error) // No Exception value catches this. { ` info(\"Invalid use of box4 gave control to catch, unexpected.\");` }| In C# a `System.NullReferenceException` is raised when an uninitialized variable is treated as an object reference.\n| There might be several other differences in the conditions that raise exceptions.|\n| SQL transactions| In X++ when an SQL exception occurs in a <strong>ttsBegin</strong> - <strong>ttsCommit</strong> transaction, no <strong>catch</strong> statement inside the transaction block can process the exception.| In C# a catch block inside an SQL transaction can catch the exception.| |\n\n## Examples\n\nThe following X++ features are demonstrated:\n-   **try** keyword.\n-   **catch** keyword.\n-   The behavior after an Exception::Error exception occurs.\n\n## X++ Example\n\n<pre>\n// X++\nstatic void JobRs008a_Exceptions(Args _args)\n{\n    str sStrings[4];\n    int iIndex = 77;\n    try\n    {\n        info(\"On purpose, this uses an invalid index for this array: \"\n            + sStrings[iIndex]);\n        warning(\"This message does not appear in the Infolog,\"\n            + \" it is unreached code.\");\n    }\n    // Next is a catch for some of the values of\n    // the X++ Exception enumeration.\n    catch (Exception::CodeAccessSecurity)\n    {\n        info(\"In catch block for -- Exception::CodeAccessSecurity\");\n    }\n    catch (Exception::Error)\n    {\n        info(\"In catch block for -- Exception::Error\");\n    }\n    catch (Exception::Warning)\n    {\n        info(\"In catch block for -- Exception::Warning\");\n    }\n    catch\n    {\n        info(\"This last 'catch' is of an unspecified exception.\");\n    }\n    //finally\n    //{\n    //    //Global::Warning(\"'finally' is not an X++ keyword, although it is in C#.\");\n    //}\n    info(\"End of program.\");\n}</pre>\n \n\n### Output\n\nHere is the output from the Infolog window:\n\n<pre>Message (18:07:24)\nError executing code: Array index 77 is out of bounds.\nStack trace\n(C)\\Jobs\\JobRs008a_Exceptions - line 8\nIn catch block for -- Exception::Error\nEnd of program.\n</pre>\n\n## C# Sample\n\nThe following C\\# program is a rewrite of the previous X++ program.\n\n    // C#\n    using System;\n    public class Pgm_CSharp\n    {\n        static void Main( string[] args )\n        {\n            new Pgm_CSharp().Rs008a_CSharp_Exceptions();\n        }\n        void Rs008a_CSharp_Exceptions()\n        {\n            //str sStrings[4];\n            string[] sStrings = new string[4];\n            try\n            {\n                Console.WriteLine\n                    (\"On purpose, this uses an invalid index\"\n                    + \" for this array: \" + sStrings[77]);\n                Console.Error.WriteLine\n                    (\"This message does not appear in the Infolog,\"\n                    + \" it is unreached code.\");\n            }\n            catch (NullReferenceException exc)\n            {\n                Console.WriteLine(\"(e1) In catch block for -- \"\n                    + exc.GetType().ToString() );\n            }\n            catch (IndexOutOfRangeException exc)\n            {\n                Console.WriteLine(\"(e2) In catch block for -- \"\n                    + exc.GetType().ToString() );\n            }\n            // In C#, System.Exception is the base of all\n            // .NET Framework exception classes.\n            // No as yet uncaught exception can get beyond\n            // this next catch.\n            catch (Exception exc)\n            {\n                Console.WriteLine\n                    (\"This last 'catch' is of the abstract\"\n                    + \" base type Exception: \"\n                    + exc.GetType().ToString());\n            }\n            // The preceding catch of System.Exception makes this catch of\n            // an unspecified exception redundant and unnecessary.\n            //catch\n            //{\n            //    Console.WriteLine(\"This last 'catch' is\"\n            //        + \" of an unspecified exception.\");\n            //}\n            finally\n            {\n                Console.WriteLine\n                    (\"'finally' is not an X++ keyword,\"\n                    + \" although it is in C#.\");\n            }\n            Console.WriteLine(\"End of program.\");\n        }\n    } // EOClass\n\n \n\n### Output\n\nHere is the actual output to the C\\# console:\n\n<pre>\n\n(e2) In catch block for -- System.IndexOutOfRangeException\n'finally' is not an X++ keyword, although it is in C#.\nEnd of program.\n</pre>\n\n# Comparison: Automated Retry After an Exception\nSometimes you can write code in a catch block that fixes the cause of an exception that occurs during run time. X++ provides a **retry** keyword that can be used only inside a **catch** block. The **retry** keyword enables a program to jump back to the start of the **try** block after the problem has been corrected by code in the **catch** block. C# does not have a **retry** keyword. However, C# code can be written to provide equivalent behavior.\n\n## Code Samples for Retry\n\nThe following X++ sample program causes an Exception::Error to be raised. This occurs when it first tries to read an element from the `sStrings` array by using an invalid index value. When the exception is caught, corrective action is taken during run time inside the **catch** block. The retry statement then jumps back to the first statement in the **try** block. This second iteration works without encountering any exception.\n\n<pre>\nstatic void JobRs008b_ExceptionsAndRetry(Args _args)\n{\n    str sStrings[4];\n    str sTemp;\n    int iIndex = 0;\n    ;\n    sStrings[1] = \"First array element.\";\n    try\n    {\n        print(\"At top of try block: \" + int2str(iIndex));\n        sTemp = sStrings[iIndex];\n        print( \"The array element is: \" + sTemp );\n    }\n    catch (Exception::Error)\n    {\n        print(\"In catch of -- Exception::Error (will retry).\"\n            + \" Entering catch.\");\n        ++iIndex;\n        print(\"In catch of -- Exception::Error (will retry).\n            + \" Leaving catch.\");\n        // Here is the retry statement.\n        retry;\n    }\n    print(\"End of X++ retry program.\");\n    pause;\n}\n</pre>\n\n### Output\n\nHere is the output to the Print window:\n\n<pre>\nAt top of try block: 0\nIn catch of -- Exception::Error (will retry). Entering catch.\nIn catch of -- Exception::Error (will retry). Leaving catch.\nAt top of try block: 1\nThe array element is: First array element.\nEnd of X++ retry program.\n</pre>\n\n## C# Sample\n\nThe following C\\# sample is not a line-by-line translation from the previous X++ sample. Instead the C\\# program has a different structure so that it mimics the behavior of the **retry** keyword that the X++ program relies on. The **try** and **catch** blocks are in a called method. The variables that are used in the **try** block are stored in the caller method. The caller method passes the variables as parameters that are decorated with the **ref** keyword, so that their values can be corrected inside the **catch** block of the called method. The called method captures all exceptions, and returns a **boolean** to communicate back to the caller whether a second call is required.\n\n    // C#\n    using System;\n    public class Pgm_CSharp\n    {\n        static void Main(string[] args)\n        {\n            new Pgm_CSharp() .Rs008b_CSharp_ExceptionsAndRetry();\n        }\n        void Rs008b_CSharp_ExceptionsAndRetry() // Caller\n        {\n            int iIndex = -1\n                , iNumRetriesAllowed = 3;\n            bool bReturnCode = true; // Means call the callee method.\n            for (int xx=0; xx <= iNumRetriesAllowed; xx++)\n            {\n                if (bReturnCode)\n                {\n                    bReturnCode = this\n  .Rs008b_CSharp_ExceptionsAndRetry_Callee\n  (ref iIndex);\n                }\n                else\n                {\n                    break;\n                }\n            }\n            Console.WriteLine(\"End of C# caller method.\");\n        }\n        private bool Rs008b_CSharp_ExceptionsAndRetry_Callee\n                (ref int iIndex)\n        {\n            bool bReturnCode = true; // Means call this method again.\n            string[] sStrings = new string[4];\n            string sTemp;\n            sStrings[0] = \"First array element.\";\n            try\n            {\n                Console.WriteLine(\"At top of try block: \"\n                    + iIndex.ToString());\n                sTemp = sStrings[iIndex];\n                Console.WriteLine( \"The array element is: \" + sTemp );\n                bReturnCode = false; // Means do not call this method again.\n            }\n            catch (Exception)\n            {\n                Console.WriteLine\n                    (\"In catch of -- Exception. Entering catch.\");\n                ++iIndex; // The 'ref' parameter in C#.\n                Console.WriteLine\n                    (\"In catch of -- Exception. Leaving catch.\");\n                //retry;\n                // In C# we let the caller method do the work\n                // that the retry keyword does in X++.\n            }\n            Console.WriteLine(\"End of C# callee method.\");\n            return bReturnCode;\n        }\n    }\n\n \n\n### Output\n\nHere is the output to the console:\n\n<pre>\nAt top of try block: -1\nIn catch of -- Exception. Entering catch.\nIn catch of -- Exception. Leaving catch.\nEnd of C# callee method.\nAt top of try block: 0\nThe array element is: First array element.\nEnd of C# callee method.\nEnd of C# caller method.\n</pre>\n\n# Comparison: Operators\nThis section compares the operators between X++ and C\\#.\n\n### Assignment Operators\n\nThe following table displays the differences between the assignment operators in X++ and C\\#.\n\n| X++ and C# | Differences |\n|---|---|\n| `=`| In X++ this operator causes an implicit conversion whenever a loss of precision might occur, such for an assignment from an <strong>int64</strong> to an <strong>int</strong>. But in C# the assignment causes a compile error.|\n| `+=` and `-=`| The only difference is that in C# these operators are also used in delegate manipulation.|\n| ++ and --| These are the increment and decrement operators in both languages. The following line is identical in both languages:<br>`++myInteger;`<br>But in X++ these two operators are for statements, not for expressions. Therefore the following lines generate compile errors in X++:<br>`myStr = int2str(++myInteger);`<br>`myIntA = myIntBB++;`|\n\n### Arithmetic Operators\n\nThe following table lists the arithmetic operators.\n\n|X++ and C# | Differences |\n|---|---|\n| *| As the multiplication operator, there are no differences.<br>**Note**: The asterisk is also used in the SQL statements that are part of the X++ language. In these SQL statements the asterisk can also be one of the following:<ul><li>A wildcard indicating that all the columns should be returned.</li><li>A wildcard for characters in a string that is used on a <strong>like</strong> clause.</li></ul>|\n| `/`| The division operator is the same in X++ and C#.|\n| `MOD`| For modulo operations, the only difference is that the % symbol is used in C#.|\n| +| The addition operator is the same in X++ and C#. The plus sign is also used for string concatenation. This operator adds numbers and concatenates strings in both languages.|\n| -| The subtraction operator is the same in X++ and C#.|\n\n\n### Bitwise Operators\n\nThe following table compares the bitwise operators between X++ and C\\#.\n\n| X++ and C\\# | Differences             |\n|-------------|------------------------------------------------------|\n| &lt;&lt;    | The left shift operator is the same in X++ and C\\#.  |\n| &gt;&gt;    | The right shift operator is the same in X++ and C\\#. |\n| ~           | The bitwise NOT operator is the same in X++ and C\\#. |\n| &           | The binary AND operator is the same in X++ and C\\#.  |\n| ^           | The binary XOR operator is the same in X++ and C\\#.  |\n| |           | The binary OR operator is the same in X++ and C\\#.   |\n\n### Relational Operators\n\nThe following relational operators are the same in X++ and C\\#:\n-   `==`\n-   `<=`\n-   `<=`\n-   `>`\n-   `<`\n-   `!=`\n-   `&&`\n-   `||`\n-   `!`\n-   `? :`\n\n# Comparison: Events\n\nThere are some differences in how X++ and C# implement the event design pattern. For more information, see Event Terminology and Keywords.\n\n### Comparison of Events between X++ and C\\#\n\nThere are differences in the way delegates are used for events in X++ versus C#.\n\n| Concept | X++ | C# | Comments|\n|---|---|---|---|\n| <strong>delegate</strong>| In X++, a delegate can be declared only as a member on a class. A delegate cannot be a member on a table. All delegates are instance members of their class, not <strong>static</strong> members. No access modifier can be used on a delegate declaration, because all delegates are <strong>protected</strong> members. Therefore, the event can be raised only by code within the same class where the delegate is a member. However, the one exception to the private nature of a delegate is that code outside their class can operate on the delegates by using the += and -= operators.| In C#, each <strong>delegate</strong> is a type, just as every <strong>class</strong> is a type. A delegate is declared independently of any class. Without the <strong>event</strong> keyword, you can have a delegate as a parameter type on a method, just as you can have a class as a parameter type. You can construct an instance of a delegate to pass in for the parameter value.| In X++, each class is a type, but no delegate is a type. You cannot construct an instance of a delegate. No delegate can be a parameter for a method. But you can create a class that has a delegate member, and you can pass instances of the class as parameter values. For more information, see X++ Keywords.|\n| <strong>event</strong>| In X++ code, an event is one of the following:<ul><li>An explicit call to a delegate.</li><li>The start or end of a method.</li></ul>There is no <strong>event</strong> keyword in X++.| In C#, the <strong>event</strong> keyword is used to declare a <strong>delegate</strong> type as a member of a class. The effect of the <strong>event</strong> keyword is to make the delegate <strong>protected</strong>, yet still accessible for the += and -= operators. You can subscribe event handler methods to an <strong>event</strong> by using the += operator. A <strong>delegate</strong> can be useful without the <strong>event</strong> keyword, as a technique for passing a function pointer as a parameter into a method.| The automatic events that occur before the start of a method, and after the end of a method, can be subscribed to only by using the AOT.|\n| += and -= operators| In X++, you use the += operator to subscribe methods to a <strong>delegate</strong>. The -= operator unsubscribes a method from a delegate.| In C#, you use the += operator to subscribe methods to an <strong>event</strong>, or to a <strong>delegate</strong> that is not used with the <strong>event</strong> keyword.| The delegate contains a reference to all the objects that have methods subscribed to the delegate. Those objects are not eligible for garbage collection while delegate holds those references.|\n| `eventHandler`| In X++, the <strong>eventHandler</strong> keyword is required when you use either the += or -= operator to subscribe or unsubscribe a method from a delegate.| `System.EventHandler` is a delegate type in the .NET Framework.| This term is used differently in X++ than it is in C# or the .NET Framework. For more information, see X++ Keywords.|\n\n## X++ Example\n\nThe important things to notice in the X++ example are the following:\n\n-   The `XppClass` has a delegate member that is named `myDelegate`. **Note**: The AOT contains a node for the delegate. The node is located at AOT > Classes > XppClass > myDelegate. Several event handler nodes can be located under the myDelegate node. Event handlers that are represented by nodes in the AOT cannot be removed by the -= operator during run time. \n-   The {} braces at the end of the delegate declaration are required, but they cannot have any code in them.\n-   The `XppClass` has two methods whose parameter signatures are compatible with the delegate. One method is static.\n-   The two compatible methods are added to the delegate with the += operator and the **eventHandler** keyword. These statements do not call the event handler methods, the statements only add the methods to the delegate.\n-   The event is raised by one call to the delegate.\n-   The parameter value that passed in to the delegate is received by each event handler method.\n-   The short X++ job at the top of the example starts the test.\n\n<pre>\n    // X++\n    // Simple job to start the delegate event test.\n    static void DelegateEventTestJob()\n    {\n        XppClass::runTheTest(\"The information from the X++ job.\");\n    }\n    // The X++ class that contains the delegate and the event handlers.\n    class XppClass\n    {\n        delegate void myDelegate(str _information)\n        {\n        }\n        public void myEventSubscriberMethod2(str _information)\n        {\n            info(\"X++, hello from instance event handler 2: \" + _information);\n        }\n        static public void myEventSubscriberMethod3(str _information)\n        {\n            info(\"X++, hello from static event handler 3: \" + _information);\n        }\n        static public void runTheTest(str _stringFromJob)\n        {\n            XppClass myXppClass = new XppClass();\n            // Subscribe two event handler methods to the delegate.\n            myXppClass.myDelegate += eventHandler\n                    (myXppClass.myEventSubscriberMethod2);\n            myXppClass.myDelegate += eventHandler\n                    (XppClass::myEventSubscriberMethod3);\n            // Raise the event by calling the delegate one time,\n            // which calls all the subscribed event handler methods.\n            myXppClass.myDelegate(_stringFromJob);\n        }\n    }\n</pre> \n\nThe output from the previous X++ job is as follows:\n\n    X++, hello from static event handler \n    3: The information from the X++ job. X++, hello from instance event handler \n    2: The information from the X++ job.\n\n## C# Sample\n\nThis section contains a C\\# code sample for the event design pattern of the previous X++ sample.\n\n    // C#\n    using System;\n    // Define the delegate type named MyDelegate.\n    public delegate void MyDelegate(string _information);\n    public class CsClass\n    {\n        protected event MyDelegate MyEvent;\n        static public void Main()\n        {\n            CsClass myCsClass = new CsClass();\n            // Subscribe two event handler methods to the delegate.\n            myCsClass.MyEvent += new MyDelegate\n                    (myCsClass.MyEventSubscriberMethod2);\n            myCsClass.MyEvent += new MyDelegate\n                    (CsClass.MyEventSubscriberMethod3);\n            // Raise the event by calling the event one time, which\n            // then calls all the subscribed event handler methods.\n            myCsClass.MyEvent(\"The information from the C# Main.\");\n        }\n        public void MyEventSubscriberMethod2(string _information)\n        {\n            Console.WriteLine(\"C#, hello from instance event handler 2: \" + _information);\n        }\n        static public void MyEventSubscriberMethod3(string _information)\n        {\n            Console.WriteLine(\"C#, hello from static event handler 3: \" + _information);\n        }\n    }\n\nThe output from the previous C\\# sample is as follows:\n\n    CsClass.exe C#, hello from instance event handler \n    2: The information from the C\\# Main. C\\#, hello from static event handler \n    3: The information from the C\\# Main. |\n\n## Events and the AOT\n\nMicrosoft Dynamics 365 for Operations has other event systems that apply only to items in the AOT. For more information, see Event Handler Nodes in the AOT.\n\n# Comparison: Precompiler Directives\n\nX++ and C# share some keywords for their precompiler directive syntax, but the meanings are not always the same.\n\n## Similarities\n\nThe X++ and C\\# compilers recognize many of the same keywords. In most cases, the keywords mean the same for both language compilers.\n\n## Differences\n\nA fundamental difference between the precompiler directives in X++ versus C\\# is the \\#define keyword that both language precompilers recognize. Unlike C\\#, in X++ the \\#define directive requires a dot in its syntax. In X++, parentheses can be used to give the defined symbol a value. These differences are shown in the following examples:\n-   In X++: \\#define.InitialYear(2003)\n-   In C\\#: \\#define InitialYear\n\nA minor difference is that in C\\# there can be spaces and tab characters between the \\# character and the directive keyword, such as \\# define Testing.\n\n## Identical Keywords\n\nThe following table lists precompiler directives that are similar in X++ and C\\#.\n\n| Keyword | X++ | C# | Comments |\n|---|---|---|---|\n| `#define` | In X++, a precompiler variable name can be defined, and a value can be given to that variable.                | In C\\#, a precompiler variable name can be defined, but no value can be given to that variable. Also, any \\#define in C\\# must occur at the top of the file, and cannot occur after any code such as a using statement or a class declaration. | The C\\# compiler can input a command line parameter of `/define` to define a precompiler variable name without defining the variable in any C\\# code file. The X++ compiler has no counterpart to `/define`. |\n|`#if`     | In X++, \\#if can determine whether a precompiler variable exists, and whether the variable has a given value. | In C\\#, \\#if can only determine whether a precompiler variable exists. It cannot test for any value because no value can be assigned. |      |\n| `#endif`  | In X++, \\#endif marks the end of an \\#if block. It also ends an \\#ifnot block.   | In C\\#, \\#endif marks the end of an \\#if block, regardless of whether the block includes a \\#else.       |   |\n\n## Different Keywords with the Same Processing Result\n\nThe following table lists precompiler directives that are named differently in X++ and C\\#, but that give the same results when processed.\n\n| X++ | C# | Comments |\n|---|---|---|\n| \\#ifnot                     | \\#if \\#else      | There is no \\#else directive in X++, but the \\#ifnot provides similar functionality. In X++, \\#ifnot can determine whether a precompiler variable exists, and whether the variable does not have a specific given value. In C\\#, \\#if can determine whether a precompiler variable exists when the ‘!’ symbol is prefixed to the variable name. |\n| `//BP Deviation documented` | \\#pragma warning | These X++ and C\\# entries are not equivalent, but there is a partial similarity. Both suppress compiler warning messages.                    |\n| \\#macrolib                  | .HPP file in C++ | There is a partial similarity between the X++ directive \\#macrolib versus an .HPP file in C++. Both can contain several \\#define statements.            |\n\n## Precompiler Directives Exclusive to X++\n\nThe following table lists X++ precompiler directives that have no direct counterpart in C\\#.\n\n| X++                  | Comments    |\n|---|---|\n| \\#linenumber         | The \\#linenumber directive is for obtaining the line number, so that it can be output to the Infolog. <br>The C\\# directive \\#line is different because its purpose is for setting the line number. |\n| \\#defdec \\#definc    |         |\n| \\#globaldefine       | In X++, there is a small difference between \\#globaldefine versus \\#define. The difference is that \\#globaldefine never overwrites a current nonnull value that was assigned to a precompiler variable by \\#define. <br>C\\# has nothing similar to this difference, because in C\\#, a precompiler variable name cannot be given a value. |\n| \\#localmacro \\#macro | In X++, \\#localmacro enables you to assign a multiline value to a precompiler variable. \\#macro is a synonym, but \\#localmacro is recommended. <br>In C\\#, the \\#define directive has part of this functionality, but it cannot assign a value to a precompiler variable.      |\n| \\#globalmacro        | In X++, \\#globalmacro is almost the same as the preferred \\#localmacro.          |\n\n# Comparison: Object Oriented Programming\nThe object oriented programming (OOP) principles of X++ differ from C\\#.\n\n## Conceptual Comparisons\n\nThe following table compares the implementation of OOP principles between X++ and C\\#.\n\n|Feature|X++|C#|Comments|\n|---|---|---|---|\n| Casting | The X++ language has the keywords <strong>is</strong> and <strong>as</strong>, which are used to make downcasts safe and explicit. **Tip**: X++ does not require the use of the <strong>as</strong> keyword when you downcast a base class variable to a derived class variable. However, we recommend that all downcast statements use the <strong>as</strong> keyword.| An object can be cast either up or down the inheritance path. Downcasts require the <strong>as</strong> keyword.| For more information about the X++ keywords <strong>is</strong> and <strong>as</strong>, see Expression Operators: Is and As for Inheritance.|\n| Local functions| A method can contain a declaration and code body for zero or more local functions. Only that method can have calls to the local function.| C# 3.0 supports lambda expressions, which have some similarity to anonymous functions and local functions. Lambda expressions are often used with delegates.| |\n| Method overloading | Method overloading is not supported. A method name can occur only one time per class.| Method overloading is supported. A method name can occur multiple times in one class, with different parameter signatures in each case.| X++ does support optional parameters on methods. Optional parameters can partially mimic method overloading. For more information, see the row for optional parameters in this table.|\n| Method overriding | Method overriding is supported. A derived class can have a method by the same name as in the base class, as long as the parameter signature is the same in both cases. The only exception is that the overriding method can add a default value to a parameter.| Method overriding is supported. The <strong>virtual</strong> keyword must be applied to a method before the method can be overridden in a derived class.| The concept of overriding a method includes the method name, its parameter signature, and its return type. The concept of method overriding does not apply if the base method and the overriding method differ in any of these aspects.|\n| Optional parameters| A parameter declaration can be followed by a default value assignment. The method caller has the option of passing a value for that parameter, or ignoring the parameter to accept the default value. This feature mimics method overloading because two calls to the same method name can pass different numbers of parameters. Each parameter that has a default value must follow the last parameter that does not have a default value.| Optional parameters are supported by the <strong>params</strong> keyword. Even without the <strong>params</strong> keyword, from the point of view of the caller, method overloading can provide partially similar functionality.| For more information, see Parameters and Scoping and Using Optional Parameters.|\n| Single inheritance| You can derive your X++ class from another X++ class by using the <strong>extends</strong> keyword in the classDeclaration node of your class, in the AOT. No class implicitly derives directly from another class. If you want your class to directly derive from the `Object` class, you must use the <strong>extends</strong> keyword. You can specify only one class on the <strong>extends</strong> keyword.<br><br>**Caution**: When you modify an X++ base class that other classes derive from, you must recompile that base class using the Compile forward. This option ensures that the derived classes are also recompiled. To ensure the derived classes are also recompiled, right-click the base class node, and then click Add-Ins > Compile forward. The alternative of clicking Build > Compile (or pressing the F7 key) is sometimes insufficientfor a base class change.<br><br>A class can implement zero to many interfaces. <br><br>An X++ table implicitly inherits from the `Common` table, and from the `xRecord` class.| C# uses the <strong>extends</strong> keyword to derive from another class. All .NET Framework classes implicitly derive from the `System.Object` class, unless they explicitly derive from another class.| |\n\n## Keyword Comparisons\n\nThe following table lists the OOP-related keywords in X++ and C#.\n\n|Keyword|X++|C#|Comments|\n|---|---|---|---|\n| <strong>abstract</strong>| | | No difference.|\n| <strong>class</strong>| The modifiers <strong>public</strong> and <strong>private</strong> are ignored on class declarations. There is no concept of a namespace grouping of classes. There are no dots (.) in any class names.| The modifiers <strong>public</strong> and <strong>private</strong> can be used to modify class declarations. C# also has the keyword <strong>internal</strong>, which relates to how classes are grouped together in assembly files.| There is no concept of a <strong>protected</strong> class, only <strong>protected</strong> members of a class.|\n| <strong>extends</strong>| A class declaration can inherit from another class by using the <strong>extends</strong> keyword.| A colon (:) is used where the keywords <strong>extends</strong> and <strong>implements</strong> are used in X++.| |\n| <strong>final</strong>| A <strong>final</strong> method cannot be overridden in a derived class. A <strong>final</strong> class cannot be extended.| The keyword <strong>sealed</strong> on a class means the same thing that <strong>final</strong> means on an X++ class.| |\n| <strong>implements</strong>| A class declaration can implement an <strong>interface</strong> by using the <strong>implements</strong> keyword.| | |\n| <strong>interface</strong>| An <strong>interface</strong> can specify methods that the class must implement.| An <strong>interface</strong> can specify methods that the class must implement.| |\n| <strong>new</strong>| The <strong>new</strong> keyword is used to allocate a new instance of a class. Then the constructor is automatically called. Each class has exactly one constructor, and the constructor is named `new`. You can decide what parameters the constructor should input.| The <strong>new</strong> keyword is used to create a new instance of a class. Then the constructor is automatically called. Constructor methods themselves are not named `new`, they have the same name as the class.<br>**Note**: The <strong>new</strong> keyword can also be used on a method, to modify the way in which the method overrides the same method in the base class.| Both X++ and C# assume a default constructor for classes that have no constructor explicitly written in their code.|\n| <strong>null</strong>| | | No difference.|\n| <strong>private</strong> and <strong>protected</strong>| The <strong>private</strong> and <strong>protected</strong> keywords can be used to modify the declaration of a class member.| The <strong>private</strong> and <strong>protected</strong> keywords can be used to modify the declaration of a class member.||\n| <strong>public</strong>| A method that is not modified with <strong>public</strong>, <strong>protected</strong>, or <strong>private</strong> has the default access level of <strong>public</strong>.| A method that is not modified with <strong>public</strong>, <strong>protected</strong>, or <strong>private</strong> has the default access level of <strong>private</strong>.||\n| <strong>static</strong>| A method can be <strong>static</strong>, but a field cannot.| Both methods and fields can be <strong>static</strong>.| |\n| <strong>super</strong>| The <strong>super</strong> keyword is used in a derived class to access the same method on its base class. `void method2()`<br>`{`<br>`    // Call method2 method`<br> `    // on the base class.`<br> `    super();` <br>`}`<br>| The <strong>base</strong> keyword is used in a derived class to access various methods in its base class. <br>`void method2()` <br>`{`<br> `    // Call methods on`<br> `    // the base class.`<br> `    base.method2();`<br> `    base.method3();` <br>`}`| In C#, there is special syntax for using <strong>base</strong> to call the base constructor.|\n| <strong>this</strong>| For a call from one instance method to another on the same object, a qualifier for the called method is required. The keyword <strong>this</strong> is available as a qualifier for the current object.| For a call from one instance method to another on the same object, a qualifier for the called method is not required. However, the <strong>this</strong> keyword is available as a qualifier for the current object. In practice, the keyword <strong>this</strong> can be helpful by displaying IntelliSense information.| |\n| `finalize`| The `Object` class contains the `finalize` method. The `finalize` method is not <strong>final</strong>, and it can be overridden. The `finalize` method appears to resemble the `System.Object.Finalize` method in C#, but in X++ the `finalize` method has no special meaning of any kind. An object is automatically removed from memory when the last reference to the object stops referencing the object. For example, this can happen when the last reference goes out of scope or is assigned another object to reference.| The methods `Finalize` and `Dispose` are common on some types of classes. The garbage collector calls the `Finalize` and `Dispose` methods when it destroys and object.| In C#, the `System.GC.Collect` method in the .NET Framework can be called to start the garbage collector. There is no similar function in X++ because X++ uses a deterministic garbage collector.|\n| `main`| Classes that are invoked from a menu have their `main` method called by the system.| Classes that are invoked from a command line console have their `Main` method called by the system.| |\n\n# Comparison: Classes\nWhen you use C\\# in the .NET Framework, classes are grouped into namespaces. Each namespace focuses on a functional area such as file operations or reflection. However, when you use the classes in X++, there are no visible groupings like a namespace.\n\n## Comparison: Classes about Reflection\nIn X++ the `TreeNode` class provides access to the Application Object Tree (AOT). The `TreeNode` class is the center of reflection functionality in X++. The `TreeNode` class and its methods can be compared to the `System.Reflection` namespace in the .NET Framework that C\\# uses.\n\nThe following table lists several classes that are available to you when you write C\\# code. These are .NET Framework classes. For this table, all C\\# classes are in the `System.Reflection` namespace unless otherwise specified. Each row shows the corresponding class, or class member, that is available to you when your write X++ code.\n\n|X++|C#|Comments|\n|---|---|---|\n| `TreeNode` | `System .Assembly`   | Assembly is the first class to use when a C\\# program must gather reflection information. Static methods on the X++ class `TreeNode` are the starting point for reflection in X++.    |\n| `TreeNode` | `System .Type`       | Instance methods on `TreeNode` correspond to instance methods on `System.Type`.                |\n| `TreeNode .AOTgetSource`         | `MethodInfo`         | The `AOTgetSource` method returns several pieces of information together in one string. This includes the X++ source code in the method. In contrast, `MethodInfo` has a separate member for each piece of information.                  |\n| `TreeNode .AOTfirstChild` `TreeNode .AOTnextSibling` `TreeNode .AOTiterator` `AOTiterator` | MethodInfo\\[\\] (an array)   | In C\\#, the `GetMethods` method on `System.Type` returns an array of MethodInfo objects. You can loop through the array by the common technique of incrementing an indexer. In contrast, the X++ model is to navigate the tree control of the AOT. The `TreeNode` methods of `AOTfirstChild` and `AOTnextSibling` accomplish the navigation. As an equivalent alternative, the X++ `AOTiterator` class is designed to navigate the tree control of the AOT. A class node is the parent over several method nodes. The `AOTiterator` steps through child nodes, returning each as another `TreeNode` instance. See also the `TreeNode` methods that are named `AOTparent` and `AOTprevious`. |\n| `TreeNode .AOTgetProperty` `TreeNode .AOTgetProperties` `TreeNode .AOTname`                | `PropertyInfo`       | In X++, the `AOTgetProperties` method returns a long string that contains name-value pairs for all the properties of the `TreeNode`. The `AOTname` method returns a string that contains only the value for the name property.                  |\n| `TreeNode .AOTsave` `TreeNode .AOTinsert`                     | `System .Reflection .Emit` (namespace of classes) | The `AOTsave` method applies changes from a `TreeNode` object in your X++ code to the AOT, and the changes are persisted. For a large code sample, see TreeNode.AOTsave Method.       |\n\n## Comparison: Classes about File IO\nThere are several classes that perform file input and output (IO) operations. In the .NET Framework that is used in C\\#, the counterparts to these classes reside in the `System.IO` namespace.\n\nThe following table lists several .NET Framework classes for C\\# that are in the `System.IO` namespace. Each row in the table shows the X++ class or method that best corresponds to the .NET Framework class.\n\n|X++|C#|Comments|\n|---|---|---|\n| `BinaryIo`| `FileStream` `BinaryReader` `BinaryWriter`\n| X++ classes such as `BinaryIo` that extend from the abstract class `Io` serve as a stream, and they also serve as a reader and writer for that stream. In C# the stream is a separate class the from the class that has the more specific read and write methods.|\n| `TextBuffer`| `MemoryStream`| These classes contain an in-memory buffer, and some of the methods treat the buffer as if it were a file on the hard disk.|\n| WINAPI::createDirectory WINAPI::folderExists WINAPI::removeDirectory| `Directory` `DirectoryInfo` `Path`| X++ can use static methods in the `WINAPI` class for many basic operating system functions that involve directories.|\n| WINAPI::getDriveType| `DriveInfo` `DriveType`| These classes and methods are used to obtain drive related information.|\n| WINAPI::copyFile WINAPI::createFile WINAPI::deleteFile WINAPI::fileExists| `File` `FileAttributes` `FileInfo`| X++ can use static methods in the `WINAPI` class for many basic operating system functions that involve files.|\n| `CommaIo` `Comma7Io`| (No corresponding class.)| These X++ classes can generate files that Microsoft Excel can import. In X++ an <a href=\"http://epplus.codeplex.com/\">EPPlus</a> library reference is available for additional interaction with Excel.|\n| `AsciiIo` `TextIo`| `FileStream` `TextReader` `TextWriter`| These classes use different code pages.|\n| `Io`| `Stream` `StreamReader` `StreamWriter` `FileStream`| These are often used as base classes that other classes extend.|\n| `CodeAccessPermission` `FileIoPermission`| `System.Security` `.CodeAccessPermission` The namespace `System.Security.Permissions` includes the following classes:<ul><li>`CodeAccessSecurityAttribute`</li><li>`FileIOPermissionAttribute`</li><li>`FileIOPermission`</li><li>`FileIOPermissionAccess`</li></ul>| The concepts and methods of `assert`, `demand`, and `revertAssert` apply to both languages. However, the `deny` and `revertDeny` methods that are available in C# are not available in X++.|\n\n# X++, ANSI SQL Comparison: SQL Select\nIn X++, the SQL **select** statement syntax differs from the American National Standards Institute (ANSI) specification.\n\n## Single Table Select\n\nThe following table lists differences between the select statements of X++ SQL and ANSI SQL.\n\n|Feature|X++ SQL|ANSI SQL|Comments|\n|---|---|---|---|\n| Table name on the <strong>from</strong> clause.| The <strong>from</strong> clause lists a record buffer instance that is declared from a table, such as from the `CustTable` table.| The <strong>from</strong> clause lists a table name, not the name of a buffer.| The record buffer has all the methods that the `xRecord`class has in X++.|\n| Syntax sequence of the order by versus <strong>where</strong> clauses.| The order by clause must appear before the <strong>where</strong> clause. The order by clause must appear after the <strong>from</strong> or <strong>join</strong> clause. The group by clause must follow the same syntax positioning rules that the order by follows.| The order by clause must appear after the <strong>where</strong> clause. The <strong>where</strong> clause must appear after the <strong>from</strong> or <strong>join</strong> clause.| In both X++ and ANSI SQL, the <strong>from</strong> and <strong>join</strong> clauses must appear before the order by and <strong>where</strong> clauses.|\n| Condition negation.| The exclamation mark ('!') is used for negation.| The <strong>not</strong> keyword is used for negation.| X++ does not support the syntax !like. Instead, you must apply the ! operator to a clause.|\n| Wildcard characters for the <strong>like</strong> operator.|0 to many – Asterisk ('*')<br>Exactly 1 – Question mark ('?')|0 to many – Percent sign ('%')<br>Exactly 1 – Underbar ('_')| |\n| Logical operators in the <strong>where</strong> clause.|And – &&<br>Or – \\|\\| |And – <strong>and</strong><br>Or – <strong>or</strong>| |\n\n## Code Example\n\nThe following code example illustrates features in the previous table.\n<pre>\nstatic void OByWhere452Job(Args _args)\n{\n    // Declare the table buffer variable.\n    CustTable tCustTable;\n    ;\n    while\n    SELECT * from tCustTable\n        order by tCustTable.AccountNum desc\n        where (!(tCustTable.Name like '*i*i*') &amp;&amp; tCustTable.Name like 'T?e *')\n    {\n        info(tCustTable.AccountNum + \" , \" + tCustTable.Name);\n    }\n}\n/*** InfoLog output\nMessage (04:02:29 pm)\n4010 , The Lamp Shop\n4008 , The Warehouse\n4001 , The Bulb\n***/\n</pre>\n \n## X++ SQL Keywords\n\nThe following X++ SQL keywords are among those that are not part of ANSI SQL:\n-   crosscompany\n-   firstonly100\n-   forceliterals\n-   forcenestedloop\n-   forceplaceholders\n-   forceselectorder\n-   validtimestate\n\n### Join Clause\n\nThe following table lists differences about the **join** keyword of X++ SQL and ANSI SQL.\n\n|Feature|X++ SQL|ANSI SQL|Comments|\n|---|---|---|---|\n| Columns list.                    | The columns in the columns list must all come from the table listed in the **from** clause, and not from any table in a **join** clause. Columns in the list cannot be qualified by their table name. | The columns in the columns list can come from any table in the **from** or **join** clauses. It helps others to maintain your code when you qualify the columns in the list with their table name. | For more information, see Select Statements on Fields.    |\n| **Join** clause syntax.          | The **join** clause follows the **where** clause.           | The **join** clause follows a table in the **from** clause.                    | In the X++ code example, the **join** criteria is an equality of `SalesPoolId` values. |\n| **Inner** keyword.               | The default **join** mode is inner join. There is no **inner** keyword.           | The default **join** mode is inner join. The **inner** keyword is available to make the code explicit.      | The **outer** keyword exists in both X++ SQL and ANSI SQL.       |\n| **Left** and **right** keywords. | The **left** and **right** keywords are not available. All joins are left.        | The **left** and **right** keywords are available to modify the **join** keyword.     | No comments.                 |\n| Equality operator.               | The double equal sign operator ('`==`') is used to test for the equality of two values.  | The single equal sign operator ('`=`') is used to test for the equality of two values.                      | No comments.                 |\n\n## Code Example\n\nThe following code example illustrates the **join** syntax in X++ SQL.\n<pre>\nstatic void OByWhere453Job(Args _args)\n{\n    // Declare table buffer variables.\n    CustTable tCustTable;\n    SalesPool tSalesPool;\n    ;\n    while\n    SELECT\n            // Not allowed to qualify by table buffer.\n            // These fields must be from the table\n            // in the from clause.\n            AccountNum,\n            Name\n        from tCustTable\n            order by tCustTable.AccountNum desc\n            where (tCustTable.Name like 'The *')\n        join tSalesPool\n            where tCustTable.SalesPoolId == tSalesPool.SalesPoolId\n    {\n        info(tCustTable.AccountNum + \" , \" + tCustTable.Name);\n    }\n}\n</pre>\n \n## Aggregate Fields\n\nThe following table lists some differences in how aggregate fields in the **select** column list are referenced between X++ SQL and ANSI SQL. Aggregate fields are those that are derived by functions such as **sum** or **avg**.\n\n|Feature|X++ SQL|ANSI SQL|Comments|\n|---|---|---|---|\n| Aggregate field name alias. | The aggregate value is in the field that was aggregated. | You can use the **as** keyword to tag an aggregate field with a name alias. The alias can be referenced in subsequent code. | For more information, see Aggregate Functions: Differences Between X++ and SQL |\n\n## Code Example\n\nIn the following code example, the call to the info method illustrates the way to reference aggregate fields (see `tPurchLine.QtyOrdered`).\n\n<pre>\nstatic void Null673Job(Args _args)\n{\n    PurchLine tPurchLine;\n    ;\n    while\n    select\n        // This aggregate field cannot be assigned an alias name.\n        sum(QtyOrdered)\n        from tPurchLine\n    {\n        info(\n            // QtyOrdered is used to reference the sum.\n            \"QtyOrdered:  \" + num2str(tPurchLine.QtyOrdered, \n            3,  // Minimum number of output characters.\n            2,  // Required number of decimal places in the output.\n            1,  // '.'  Separator to mark the start of the decimal places.\n            2   // ','  The thousands separator.\n            ));\n    }\n    info(\"End.\");\n}\n/***\nMessage (12:23:08 pm)\nQtyOrdered:  261,550.00\nEnd.\n***/\n</pre>\n\n## Other Differences\n\nThe following table lists other differences of the **select** statement between the X++ SQL and ANSI SQL.\n\n|Feature|X++ SQL|ANSI SQL|Comments|\n|---|---|---|---|\n|The **having** keyword.|There is no **having** keyword.|The **having** keyword enables you to specify filter criteria for rows that are generated by the group by clause.|No comments.|\n|Null results.|In a **while** select statement, if the **where** clause filters out all rows, no special count row is returned to report that.|In a **select**, if the **where** clause filters out all rows, a special count row is returned. The count value is 0.|No comments.|\n|Cursors for navigating returned rows.|The while select statement provides cursor functionality. The alternative is to use the **next** keyword.|You can declare a **cursor** for looping through the rows that are returned from a **select** statement.||\n|**From** clause.|The **from** keyword is optional when no columns are listed and only one table is referenced. The following two syntax options are equivalent: <br>`select \\* from tCustTable;` <br>`select tCustTable;`|A **select** statement cannot read from a table unless the **from** clause is used.|In X++ SQL, the simple **select** statement fills the table buffer variable with the first row that was returned. This is illustrated by the following code fragment: <br>`select \\* from tCustTable;` <br>`info(tCustTable.Name);`|\n\n\n","nodes":[{"pos":[4,611],"content":"# required metadata\n\ntitle: X++ and C# comparison\ndescription: This topic compares X++ and C# syntax and programming.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 04/04/2017\nms.topic: article\nms.prod: \nms.service: Dynamics365Operations\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \n# ms.reviewer: 2051\nms.search.scope: AX 7.0.0, Operations\n# ms.tgt_pltfrm: \nms.custom: 72424\nms.assetid: 9e0b3126-aa04-4b76-a254-bfbd3fcd6552\nms.search.region: Global\n# ms.search.industry: \nms.author: robinr\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n","nodes":[{"content":"X++ and C# comparison","nodes":[{"pos":[0,21],"content":"X++ and C# comparison","nodes":[{"content":"X++ and C# comparison","pos":[0,21]}]}],"path":["title"]},{"content":"This topic compares X++ and C# syntax and programming.","nodes":[{"pos":[0,54],"content":"This topic compares X++ and C# syntax and programming.","nodes":[{"content":"This topic compares X++ and C# syntax and programming.","pos":[0,54]}]}],"path":["description"]}],"header":"# required metadata\n","yml":true},{"pos":[619,640],"content":"X++ and C# comparison","linkify":"X++ and C# comparison","nodes":[{"content":"X++ and C# comparison","pos":[0,21]}]},{"content":"This topic compares X++ and C# syntax and programming.","pos":[686,740]},{"pos":[744,775],"content":"X++, C# Comparison: Hello World","linkify":"X++, C# Comparison: Hello World","nodes":[{"content":"X++, C# Comparison: Hello World","pos":[0,31]}]},{"content":"This section compares the simplest X++ program to its counterpart in C#.","pos":[777,849]},{"pos":[854,875],"content":"X++ to C# Comparisons","linkify":"X++ to C# Comparisons","nodes":[{"content":"X++ to C# Comparisons","pos":[0,21]}]},{"content":"The following sections describe some basic similarities and differences between X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[877,969],"source":"The following sections describe some basic similarities and differences between X++ and C\\#."},{"pos":[974,986],"content":"Similarities","linkify":"Similarities","nodes":[{"content":"Similarities","pos":[0,12]}]},{"content":"The following X++ features are the same for C#:","pos":[988,1035]},{"pos":[1040,1093],"content":"Single line (<ph id=\"ph1\">`//`</ph>) and multi-line (/<ph id=\"ph2\">\\*</ph> <ph id=\"ph3\">\\*</ph>/) comments.","source":"Single line (`//`) and multi-line (/\\* \\*/) comments."},{"pos":[1098,1165],"content":"<ph id=\"ph1\">`==`</ph> (equal) operator for determining whether two values are equal.","source":"`==` (equal) operator for determining whether two values are equal."},{"content":"!= (not equal to) operator for determining whether two values are not equivalent.","pos":[1170,1251]},{"content":"(plus sign) operator for string concatenation.","pos":[1258,1304]},{"pos":[1309,1320],"content":"Differences","linkify":"Differences","nodes":[{"content":"Differences","pos":[0,11]}]},{"content":"The following table lists X++ features that are different in C#.","pos":[1322,1386]},{"content":"Feature","pos":[1390,1397]},{"content":"X++","pos":[1400,1403]},{"content":"C#","pos":[1406,1408]},{"content":"Comments","pos":[1411,1419]},{"content":"Declarations","pos":[1442,1454]},{"content":"All declarations must be at the start of the method, before any X++ statements.","pos":[1457,1536]},{"content":"Declarations can occur anywhere in the method.","pos":[1539,1585]},{"content":"Both languages permit multiple variables of the same type to be listed together in one declaration.","pos":[1588,1687]},{"content":"Both languages allow you to assign an initial value in the declaration statement.","pos":[1688,1769]},{"pos":[1774,1812],"content":"<ph id=\"ph1\">`if`</ph> and <ph id=\"ph2\">`else`</ph> conditional statements","source":"`if` and `else` conditional statements"},{"content":"The <ph id=\"ph1\">`if`</ph> statement accepts any type of expression that it can automatically convert to a Boolean.","pos":[1815,1912],"source":"The `if` statement accepts any type of expression that it can automatically convert to a Boolean."},{"content":"Common examples include an <ph id=\"ph1\">`int`</ph> for which 0 means false, or an object for which null means false.","pos":[1913,2011],"source":" Common examples include an `int` for which 0 means false, or an object for which null means false."},{"pos":[2014,2063],"content":"The <ph id=\"ph1\">`if`</ph> statement requires a Boolean expression.","source":"The `if` statement requires a Boolean expression."},{"content":"The syntax structure regarding curly braces and parentheses is exactly the same between X++ and C#.","pos":[2066,2165]},{"content":"Literal string","pos":[2170,2184]},{"content":"A literal string can be delimited by either of the following:","pos":[2187,2248]},{"content":"A pair of double quotation mark (\") characters.","pos":[2256,2303]},{"content":"A pair of single quotation mark (') characters.","pos":[2312,2359]},{"content":"A literal string must be delimited by a pair of double quotation mark (\") characters.","pos":[2372,2457]},{"content":"For X++, the double quotation mark characters are usually used to delimit strings.","pos":[2460,2542]},{"content":"However, it is convenient delimit a string with single quotation mark characters when your string must contain a double quotation mark character.","pos":[2543,2688]},{"pos":[2692,2703],"content":"char <ph id=\"ph1\">`type`</ph>","source":"char `type`"},{"content":"There is no <ph id=\"ph1\">`char`</ph> or character type in X++.","pos":[2706,2750],"source":"There is no `char` or character type in X++."},{"content":"You can declare a <ph id=\"ph1\">`str`</ph> of length one, but it is still a string:","pos":[2751,2815],"source":" You can declare a `str` of length one, but it is still a string:"},{"content":"There is a <ph id=\"ph1\">`char`</ph> in C#.","pos":[2846,2870],"source":"There is a `char` in C#."},{"content":"You cannot pass a <ph id=\"ph1\">`char`</ph> as the parameter to a method that inputs a <ph id=\"ph2\">`string`</ph> parameter, although you can first explicitly convert the <ph id=\"ph3\">`char`</ph> to a <ph id=\"ph4\">`string`</ph>.","pos":[2871,3026],"source":" You cannot pass a `char` as the parameter to a method that inputs a `string` parameter, although you can first explicitly convert the `char` to a `string`."},{"content":"For more information about X++ data types, see Primitive Data Types.","pos":[3028,3096]},{"content":"Output of messages","pos":[3100,3118]},{"content":"X++ delivers messages to the user in the Infolog window.","pos":[3120,3176]},{"content":"Common methods include the following:","pos":[3177,3214]},{"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>print<ept id=\"p1\">&lt;/strong&gt;</ept> statement:","pos":[3222,3259],"source":"The <strong>print</strong> statement:"},{"content":"static methods on the <ph id=\"ph1\">`Global`</ph> class:","pos":[3268,3305],"source":"static methods on the `Global` class:"},{"content":"Global::info","pos":[3313,3325]},{"content":"Global::warning","pos":[3334,3349]},{"content":"Global::error","pos":[3358,3371]},{"content":"For a command line C# program, messages can be delivered to the console.","pos":[3393,3465]},{"content":"Common methods include the following:","pos":[3466,3503]},{"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>print<ept id=\"p1\">&lt;/strong&gt;</ept> statement is not a function nor a method.","pos":[3580,3648],"source":"The <strong>print</strong> statement is not a function nor a method."},{"content":"Recommended use would be <ph id=\"ph1\">`print mystring;`</ph> rather than <ph id=\"ph2\">`print(mystring);`</ph>.","pos":[3649,3723],"source":" Recommended use would be `print mystring;` rather than `print(mystring);`."},{"content":"A <ph id=\"ph1\">`pause;`</ph> statement is always useful shortly after a <bpt id=\"p1\">&lt;strong&gt;</bpt>print<ept id=\"p1\">&lt;/strong&gt;</ept> statement.","pos":[3724,3811],"source":" A `pause;` statement is always useful shortly after a <strong>print</strong> statement."},{"content":"The print statement is convenient for testing because it automatically converts <bpt id=\"p1\">&lt;strong&gt;</bpt>int<ept id=\"p1\">&lt;/strong&gt;</ept> and other primitive values to strings for display.","pos":[3812,3963],"source":" The print statement is convenient for testing because it automatically converts <strong>int</strong> and other primitive values to strings for display."},{"content":"For more information, see Print Statements.","pos":[3964,4007]},{"content":"The <ph id=\"ph1\">`Global`</ph> class has special recognition in the X++ compiler.","pos":[4008,4071],"source":" The `Global` class has special recognition in the X++ compiler."},{"content":"The <ph id=\"ph1\">`info`</ph> method can be called without including the Global:: prefix.","pos":[4072,4142],"source":" The `info` method can be called without including the Global:: prefix."},{"pos":[4149,4168],"content":"X++ and C++ Samples","linkify":"X++ and C++ Samples","nodes":[{"content":"X++ and C++ Samples","pos":[0,19]}]},{"content":"This section contains two simple code samples.","pos":[4170,4216]},{"content":"One sample is written in X++, and the other is in C<ph id=\"ph1\">\\#</ph>.","pos":[4217,4271],"source":" One sample is written in X++, and the other is in C\\#."},{"content":"Both samples achieve the same result.","pos":[4272,4309]},{"content":"The following X++ features are demonstrated:","pos":[4310,4354]},{"pos":[4359,4383],"content":"<ph id=\"ph1\">`//`</ph> single line comment","source":"`//` single line comment"},{"content":"<ph id=\"ph1\">/</ph><ph id=\"ph2\">\\*</ph> <ph id=\"ph3\">\\*</ph>/ multi-line comment","pos":[4388,4414],"source":"/\\* \\*/ multi-line comment"},{"pos":[4419,4433],"content":"<ph id=\"ph1\">`if`</ph> statement","source":"`if` statement"},{"pos":[4438,4451],"content":"<ph id=\"ph1\">`==`</ph> operator","source":"`==` operator"},{"content":"!= operator","pos":[4456,4467]},{"content":"operator to concatenate strings","pos":[4474,4505]},{"content":"Global::info for message output, with and without the Global:: prefix","pos":[4510,4579]},{"content":"Global::error for message output","pos":[4584,4616]},{"content":"The use of single and double quotation characters (' and \") as string delimiters.","pos":[4621,4702]},{"pos":[4704,4816],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>: The best practice is to use double quotation marks for any string that might be displayed to the user.","source":"**Note**: The best practice is to use double quotation marks for any string that might be displayed to the user."},{"pos":[4821,4831],"content":"X++ Sample","linkify":"X++ Sample","nodes":[{"content":"X++ Sample","pos":[0,10]}]},{"content":"This X++ code sample is in the form of a job.","pos":[4833,4878]},{"content":"There is a node titled Jobs in the Application Object Tree (AOT).","pos":[4879,4944]},{"content":"This sample can be added under the Jobs node, and then the job can be run.","pos":[4945,5019]},{"pos":[5733,5739],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"Here is the output from the Infolog window: Message (09:49:48) Hello World, 1.","pos":[5741,5827],"source":"Here is the output from the Infolog window:\n    Message (09:49:48)\n    Hello World, 1."},{"content":"Hello World, 2.","pos":[5828,5847],"source":"\n    Hello World, 2."},{"content":"This is like info, but is for warnings, 3.","pos":[5848,5894],"source":"\n    This is like info, but is for warnings, 3."},{"content":"This is like info, but is for errors, 4.","pos":[5895,5939],"source":"\n    This is like info, but is for errors, 4."},{"pos":[5944,5953],"content":"C# Sample","linkify":"C# Sample","nodes":[{"content":"C# Sample","pos":[0,9]}]},{"content":"The following C# program is a rewrite of the previous X++ program.","pos":[5955,6021]},{"content":"The differences between X++ and C# are highlighted by commenting out the X++ lines, and replacing them with the C# syntax.","pos":[6022,6144]},{"content":"C#","pos":[6146,6148]},{"pos":[7065,7071],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"Here is the actual output to the C# console:","pos":[7073,7117]},{"pos":[7306,7331],"content":"X++, C# Comparison: Loops","linkify":"X++, C# Comparison: Loops","nodes":[{"content":"X++, C# Comparison: Loops","pos":[0,25]}]},{"content":"This section compares the loop features between X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[7332,7392],"source":"This section compares the loop features between X++ and C\\#."},{"pos":[7398,7410],"content":"Similarities","linkify":"Similarities","nodes":[{"content":"Similarities","pos":[0,12]}]},{"content":"The following features are the same in X++ and C<ph id=\"ph1\">\\#</ph>:","pos":[7412,7463],"source":"The following features are the same in X++ and C\\#:"},{"content":"Declarations for variables of the int primitive data type.","pos":[7468,7526]},{"content":"Declarations for other primitive types are almost the same, but the types might have different names.","pos":[7527,7628]},{"content":"while statement for loops.","pos":[7633,7659]},{"content":"break statement to exit a loop.","pos":[7664,7695]},{"content":"continue statement to jump up to the top of a loop.","pos":[7700,7751]},{"content":"&lt;= (less than or equal) comparison operator.","pos":[7756,7800],"source":"<= (less than or equal) comparison operator."},{"pos":[7806,7817],"content":"Differences","linkify":"Differences","nodes":[{"content":"Differences","pos":[0,11]}]},{"content":"The following table lists X++ features that are different in C#.","pos":[7819,7883]},{"content":"Features","pos":[7887,7895]},{"content":"X++","pos":[7898,7901]},{"content":"C#","pos":[7904,7906]},{"content":"Comments","pos":[7909,7917]},{"pos":[7940,7960],"content":"The <ph id=\"ph1\">`for`</ph> statement.","source":"The `for` statement."},{"content":"The for statement is available for loops.","pos":[7962,8003]},{"pos":[8005,8068],"content":"The C# <ph id=\"ph1\">`for`</ph> statement is slightly different from <ph id=\"ph2\">`for`</ph> in X++.","source":"The C# `for` statement is slightly different from `for` in X++."},{"content":"In C# you can declare the counter integer in the <ph id=\"ph1\">`for`</ph> statement.","pos":[8070,8135],"source":"In C# you can declare the counter integer in the `for` statement."},{"content":"But in X++ the counter must declared outside the <ph id=\"ph1\">`for`</ph> statement.","pos":[8136,8201],"source":" But in X++ the counter must declared outside the `for` statement."},{"content":"++ increment operator.","pos":[8204,8226]},{"content":"An ++ increment operator is available in X++.","pos":[8227,8272]},{"content":"But an <bpt id=\"p1\">&lt;strong&gt;</bpt>int<ept id=\"p1\">&lt;/strong&gt;</ept> variable that is decorated with ++ can only be used as a statement, not as an expression.","pos":[8273,8390],"source":" But an <strong>int</strong> variable that is decorated with ++ can only be used as a statement, not as an expression."},{"content":"For example, the following lines of X++ code would not compile:","pos":[8391,8454]},{"content":"However, the following lines of X++ code would compile:","pos":[8495,8550]},{"content":"The C# ++ operator is more flexible than in X++.","pos":[8591,8639]},{"content":"The following lines of code are the same in both languages:","pos":[8640,8699]},{"content":"++ myInteger;","pos":[8707,8720]},{"content":"myInteger++;","pos":[8729,8741]},{"content":"But the following lines of code have a different effect from each other, and are valid only in C#:","pos":[8751,8849]},{"content":"yourInt = ++myInt;","pos":[8857,8875]},{"content":"yourInt = myInt++;","pos":[8884,8902]},{"content":"modulo operator.","pos":[8916,8932]},{"content":"In X++ the modulo operator is mod.","pos":[8934,8968]},{"content":"In C# the modulo operator is %.","pos":[8970,9001]},{"content":"The symbols for the modulo operator are different, but their behavior is the same in both languages.","pos":[9003,9103]},{"content":"Temporarily suspend a console program that has already begun.","pos":[9107,9168]},{"pos":[9170,9192],"content":"The <ph id=\"ph1\">`pause`</ph> statement.","source":"The `pause` statement."},{"content":"In C#, a command line program can be paused by the following line of code:","pos":[9194,9268]},{"content":"In X++ you continue by clicking an OK button on a modal dialog box.","pos":[9294,9361]},{"content":"In C# you continue by pressing any keyboard on the keyboard.","pos":[9362,9422]},{"content":"Display a message.","pos":[9426,9444]},{"pos":[9446,9515],"content":"In X++, the <ph id=\"ph1\">`print`</ph> statement displays a message in the Print window.","source":"In X++, the `print` statement displays a message in the Print window."},{"content":"In C# a message can be displayed on the console by the following line of code:","pos":[9517,9595]},{"content":"The X++ <ph id=\"ph1\">`print`</ph> function is used only when you test.","pos":[9623,9675],"source":"The X++ `print` function is used only when you test."},{"content":"An X++ program that uses <ph id=\"ph1\">`print`</ph> almost always uses the <ph id=\"ph2\">`pause`</ph> statement somewhere later in the code.","pos":[9676,9778],"source":" An X++ program that uses `print` almost always uses the `pause` statement somewhere later in the code."},{"content":"For production X++ code, use the Global::info Method instead of <ph id=\"ph1\">`print`</ph>.","pos":[9779,9851],"source":" For production X++ code, use the Global::info Method instead of `print`."},{"content":"The <ph id=\"ph1\">`strfmt`</ph> function is often used together with <ph id=\"ph2\">`info`</ph>.","pos":[9852,9909],"source":" The `strfmt` function is often used together with `info`."},{"content":"There is no reason to use <ph id=\"ph1\">`pause`</ph> after <ph id=\"ph2\">`info`</ph>.","pos":[9910,9957],"source":" There is no reason to use `pause` after `info`."},{"content":"Make a sound.","pos":[9961,9974]},{"content":"The beep function makes a sound that you can hear.","pos":[9976,10026]},{"content":"In C# a sound that you can hear is issued by the following line of code:","pos":[10029,10101]},{"content":"The statements each produce a short tone.","pos":[10124,10165]},{"pos":[10172,10194],"content":"Print and Global::info","linkify":"Print and Global::info","nodes":[{"content":"Print and Global::info","pos":[0,22]}]},{"content":"The X++ code samples for loops use the <ph id=\"ph1\">`print`</ph> function to display results.","pos":[10196,10271],"source":"The X++ code samples for loops use the `print` function to display results."},{"content":"In X++ you can use the <ph id=\"ph1\">`print`</ph> statement can display any primitive data type without having to call functions that convert it to a string first.","pos":[10272,10416],"source":" In X++ you can use the `print` statement can display any primitive data type without having to call functions that convert it to a string first."},{"content":"This makes <ph id=\"ph1\">`print`</ph> useful in quick test situations.","pos":[10417,10468],"source":" This makes `print` useful in quick test situations."},{"content":"Generally the Global::info method is used more often than <ph id=\"ph1\">`print`</ph>.","pos":[10469,10535],"source":" Generally the Global::info method is used more often than `print`."},{"content":"The <ph id=\"ph1\">`info`</ph> method can only display strings.","pos":[10536,10579],"source":" The `info` method can only display strings."},{"content":"Therefore the strfmt function is often used together with <ph id=\"ph1\">`info`</ph>.","pos":[10580,10645],"source":" Therefore the strfmt function is often used together with `info`."},{"content":"A limitation of <ph id=\"ph1\">`print`</ph> is that you cannot copy the contents of the Print window to the clipboard (such as with Ctrl+C).","pos":[10646,10766],"source":" A limitation of `print` is that you cannot copy the contents of the Print window to the clipboard (such as with Ctrl+C)."},{"content":"Global::info writes to the Infolog window which does support copy to the clipboard.","pos":[10767,10850]},{"pos":[10855,10880],"content":"Example 1: The while Loop","linkify":"Example 1: The while Loop","nodes":[{"content":"Example 1: The while Loop","pos":[0,25]}]},{"pos":[10882,10940],"content":"The <bpt id=\"p1\">**</bpt>while<ept id=\"p1\">**</ept> keyword supports looping in both X++ and C#.","source":"The **while** keyword supports looping in both X++ and C#."},{"pos":[10946,10965],"content":"X++ Sample of while","linkify":"X++ Sample of while","nodes":[{"content":"X++ Sample of while","pos":[0,19]}]},{"content":"}","pos":[11361,11362]},{"pos":[11369,11375],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"The output in the X++ Print window is as follows:","pos":[11377,11426]},{"pos":[11457,11475],"content":"C# Sample of while","linkify":"C# Sample of while","nodes":[{"content":"C# Sample of while","pos":[0,18]}]},{"content":"C#","pos":[11477,11479]},{"pos":[12179,12185],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"The console output from the C# program is as follows:","pos":[12187,12240]},{"pos":[12444,12467],"content":"Example 2: The for Loop","linkify":"Example 2: The for Loop","nodes":[{"content":"Example 2: The for Loop","pos":[0,23]}]},{"pos":[12469,12525],"content":"The <bpt id=\"p1\">**</bpt>for<ept id=\"p1\">**</ept> keyword supports looping in both X++ and C#.","source":"The **for** keyword supports looping in both X++ and C#."},{"pos":[12531,12548],"content":"X++ Sample of for","linkify":"X++ Sample of for","nodes":[{"content":"X++ Sample of for","pos":[0,17]}]},{"pos":[12550,12630],"content":"In X++ the counter variable cannot be declared as part of the <bpt id=\"p1\">**</bpt>for<ept id=\"p1\">**</ept> statement.","source":"In X++ the counter variable cannot be declared as part of the **for** statement."},{"content":"}","pos":[13100,13101]},{"pos":[13110,13116],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"The output in the X++ Print window is as follows:","pos":[13118,13167]},{"pos":[13198,13214],"content":"C# Sample of for","linkify":"C# Sample of for","nodes":[{"content":"C# Sample of for","pos":[0,16]}]},{"content":"C#","pos":[13216,13218]},{"pos":[14009,14015],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"pos":[14017,14249],"content":"The console output from the C# program is as follows: 1 (Press any key to resume.) 2 (Press any key to resume.) 3 (Press any key to resume.) 4 (Press any key to resume.) (Press any key to resume.)","source":"The console output from the C# program is as follows:\n    1\n    (Press any key to resume.)\n    2\n    (Press any key to resume.)\n    3\n    (Press any key to resume.)\n    4\n    (Press any key to resume.)\n    (Press any key to resume.)"},{"pos":[14254,14280],"content":"X++, C# Comparison: Switch","linkify":"X++, C# Comparison: Switch","nodes":[{"content":"X++, C# Comparison: Switch","pos":[0,26]}]},{"content":"In both X++ and C#, the <bpt id=\"p1\">**</bpt>switch<ept id=\"p1\">**</ept> statement involves the keywords <bpt id=\"p2\">**</bpt>case<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>break<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>default<ept id=\"p4\">**</ept>.","pos":[14282,14386],"source":"In both X++ and C#, the **switch** statement involves the keywords **case**, **break**, and **default**."},{"content":"The following table lists the differences in the <bpt id=\"p1\">**</bpt>switch<ept id=\"p1\">**</ept> statement between X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[14387,14477],"source":" The following table lists the differences in the **switch** statement between X++ and C\\#."},{"content":"Feature","pos":[14481,14488]},{"content":"X++","pos":[14492,14495]},{"content":"C#","pos":[14498,14500]},{"content":"Comments","pos":[14503,14511]},{"pos":[14558,14596],"content":"<ph id=\"ph1\">`break;`</ph> at the end of each case block","source":"`break;` at the end of each case block"},{"content":"In X++, when any <bpt id=\"p1\">**</bpt>case<ept id=\"p1\">**</ept> block matches the expression value on the <bpt id=\"p2\">**</bpt>switch<ept id=\"p2\">**</ept> clause, all other <bpt id=\"p3\">**</bpt>case<ept id=\"p3\">**</ept> and <bpt id=\"p4\">**</bpt>default<ept id=\"p4\">**</ept> blocks are executed until a <ph id=\"ph1\">`break;`</ph> statement is reached.","pos":[14605,14785],"source":"In X++, when any **case** block matches the expression value on the **switch** clause, all other **case** and **default** blocks are executed until a `break;` statement is reached."},{"content":"No <ph id=\"ph1\">`break;`</ph> statement is ever required in an X++ <bpt id=\"p1\">**</bpt>switch<ept id=\"p1\">**</ept> statement, but <ph id=\"ph2\">`break;`</ph> statements are important in almost all practical situations.","pos":[14786,14930],"source":" No `break;` statement is ever required in an X++ **switch** statement, but `break;` statements are important in almost all practical situations."},{"content":"In C<ph id=\"ph1\">\\#</ph>, a <ph id=\"ph2\">`break;`</ph> statement is always needed after the statements in a <bpt id=\"p1\">**</bpt>case<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>default<ept id=\"p2\">**</ept> block.","pos":[14933,15035],"source":"In C\\#, a `break;` statement is always needed after the statements in a **case** or **default** block."},{"content":"If a <bpt id=\"p1\">**</bpt>case<ept id=\"p1\">**</ept> clause has no statements between itself and the next <bpt id=\"p2\">**</bpt>case<ept id=\"p2\">**</ept> clause, a <ph id=\"ph1\">`break;`</ph> statement is not required between the two <bpt id=\"p3\">**</bpt>case<ept id=\"p3\">**</ept> clauses.","pos":[15036,15190],"source":" If a **case** clause has no statements between itself and the next **case** clause, a `break;` statement is not required between the two **case** clauses."},{"pos":[15193,15334],"content":"We recommend against omitting the <ph id=\"ph1\">`break;`</ph> statement after any case <bpt id=\"p1\">**</bpt>block<ept id=\"p1\">**</ept>, because it can confuse the next programmer who edits the code.","source":"We recommend against omitting the `break;` statement after any case **block**, because it can confuse the next programmer who edits the code."},{"pos":[15339,15383],"content":"<ph id=\"ph1\">`break;`</ph> at the end of the <bpt id=\"p1\">**</bpt>default<ept id=\"p1\">**</ept> block","source":"`break;` at the end of the **default** block"},{"pos":[15386,15479],"content":"In X++ there is no effect of adding a <ph id=\"ph1\">`break;`</ph> statement at the end of the <bpt id=\"p1\">**</bpt>default<ept id=\"p1\">**</ept> block.","source":"In X++ there is no effect of adding a `break;` statement at the end of the **default** block."},{"pos":[15484,15570],"content":"In C<ph id=\"ph1\">\\#</ph> the compiler requires a <ph id=\"ph2\">`break;`</ph> statement at the end of the <bpt id=\"p1\">**</bpt>default<ept id=\"p1\">**</ept> block.","source":"In C\\# the compiler requires a `break;` statement at the end of the **default** block."},{"content":"For more information, see Switch Statements.","pos":[15573,15617]},{"pos":[15622,15662],"content":"Only constant values on a <bpt id=\"p1\">**</bpt>case<ept id=\"p1\">**</ept> block","source":"Only constant values on a **case** block"},{"content":"In X++ you can specify either a literal value or a variable on a case block.","pos":[15669,15745]},{"content":"For example, you can write case myInteger:.","pos":[15746,15789]},{"pos":[15793,15896],"content":"In C<ph id=\"ph1\">\\#</ph> you must specify exactly one literal value on each <bpt id=\"p1\">**</bpt>case<ept id=\"p1\">**</ept> block, and no variables are allowed.","source":"In C\\# you must specify exactly one literal value on each **case** block, and no variables are allowed."},{"content":"No comments.","pos":[15899,15911]},{"pos":[15917,15954],"content":"Multiple values on one <bpt id=\"p1\">**</bpt>case<ept id=\"p1\">**</ept> block","source":"Multiple values on one **case** block"},{"content":"In X++ you can specify multiple values on each case block.","pos":[15964,16022]},{"content":"The values must be separated by a comma.","pos":[16023,16063]},{"content":"For example, you can write <ph id=\"ph1\">`case 4,5,myInteger:`</ph>.","pos":[16064,16113],"source":" For example, you can write `case 4,5,myInteger:`."},{"pos":[16119,16184],"content":"In C<ph id=\"ph1\">\\#</ph> you must specify exactly one value on each <bpt id=\"p1\">**</bpt>case<ept id=\"p1\">**</ept> block.","source":"In C\\# you must specify exactly one value on each **case** block."},{"pos":[16187,16328],"content":"In X++ it is better to write multiple values on one <bpt id=\"p1\">**</bpt>case<ept id=\"p1\">**</ept> block than to omit the <ph id=\"ph1\">`break;`</ph> statement at the end of one or more case blocks.","source":"In X++ it is better to write multiple values on one **case** block than to omit the `break;` statement at the end of one or more case blocks."},{"pos":[16335,16359],"content":"Code Examples for switch","linkify":"Code Examples for switch","nodes":[{"content":"Code Examples for switch","pos":[0,24]}]},{"content":"The following sections show comparable switch statements in X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[16361,16433],"source":"The following sections show comparable switch statements in X++ and C\\#."},{"pos":[16439,16457],"content":"X++ switch Example","linkify":"X++ switch Example","nodes":[{"content":"X++ switch Example","pos":[0,18]}]},{"content":"The X++ switch example shows the following:","pos":[16459,16502]},{"pos":[16507,16620],"content":"case iTemp: and case (93-90): to show that <bpt id=\"p1\">**</bpt>case<ept id=\"p1\">**</ept> expressions are not limited to constants, as they are in C<ph id=\"ph1\">\\#</ph>.","source":"case iTemp: and case (93-90): to show that **case** expressions are not limited to constants, as they are in C\\#."},{"pos":[16625,16736],"content":"<ph id=\"ph1\">`//break;`</ph> to show that <ph id=\"ph2\">`break;`</ph> statements are not required in X++, although they are almost always desirable.","source":"`//break;` to show that `break;` statements are not required in X++, although they are almost always desirable."},{"pos":[16741,16838],"content":"case 2, (93-90), 5: to show that multiple expressions can be listed on on <bpt id=\"p1\">**</bpt>case<ept id=\"p1\">**</ept> clause in X++.","source":"case 2, (93-90), 5: to show that multiple expressions can be listed on on **case** clause in X++."},{"content":"X++","pos":[16840,16843]},{"pos":[18110,18127],"content":"C# switch Example","linkify":"C# switch Example","nodes":[{"content":"C# switch Example","pos":[0,17]}]},{"content":"The C<ph id=\"ph1\">\\#</ph> switch example shows the following:","pos":[18129,18172],"source":"The C\\# switch example shows the following:"},{"pos":[18177,18275],"content":"case 1: has a comment explaining that only constant expressions can be given on a <bpt id=\"p1\">**</bpt>case<ept id=\"p1\">**</ept> clause.","source":"case 1: has a comment explaining that only constant expressions can be given on a **case** clause."},{"pos":[18280,18397],"content":"<ph id=\"ph1\">`break;`</ph> statements occur after the last statement in each <bpt id=\"p1\">**</bpt>case<ept id=\"p1\">**</ept> block that has statements, as is required by C<ph id=\"ph2\">\\#</ph>.","source":"`break;` statements occur after the last statement in each **case** block that has statements, as is required by C\\#."},{"content":"C#","pos":[18399,18401]},{"pos":[19604,19650],"content":"X++, C# Comparison: String Case and Delimiters","linkify":"X++, C# Comparison: String Case and Delimiters","nodes":[{"content":"X++, C# Comparison: String Case and Delimiters","pos":[0,46]}]},{"content":"This section compares the treatment of strings with mixed casing in X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[19651,19731],"source":"This section compares the treatment of strings with mixed casing in X++ and C\\#."},{"content":"It also explains the string delimiters that are available in X++.","pos":[19732,19797]},{"pos":[19802,19814],"content":"Similarities","linkify":"Similarities","nodes":[{"content":"Similarities","pos":[0,12]}]},{"content":"The following X++ features are the same as in C<ph id=\"ph1\">\\#</ph>:","pos":[19816,19866],"source":"The following X++ features are the same as in C\\#:"},{"content":"The backslash (<ph id=\"ph1\">\\\\</ph>) is the escape operator for string delimiters.","pos":[19871,19935],"source":"The backslash (\\\\) is the escape operator for string delimiters."},{"content":"The at sign (@) nullifies the escape effect of the backslash when the at sign is written immediately before the open quotation mark of a string.","pos":[19940,20084]},{"content":"The plus sign (+) is the string concatenation operator.","pos":[20089,20144]},{"pos":[20149,20160],"content":"Differences","linkify":"Differences","nodes":[{"content":"Differences","pos":[0,11]}]},{"content":"X++ features that are different in C<ph id=\"ph1\">\\#</ph> are listed in the following table.","pos":[20162,20235],"source":"X++ features that are different in C\\# are listed in the following table."},{"content":"Feature","pos":[20239,20246]},{"content":"X++","pos":[20249,20252]},{"content":"C#","pos":[20255,20257]},{"content":"Comments","pos":[20260,20268]},{"pos":[20291,20315],"content":"<ph id=\"ph1\">`== `</ph>comparison operator","source":"`== `comparison operator"},{"pos":[20317,20395],"content":"Insensitive: the <ph id=\"ph1\">`==`</ph> operator is insensitive to differences in string casing.","source":"Insensitive: the `==` operator is insensitive to differences in string casing."},{"pos":[20397,20467],"content":"In C#, the <ph id=\"ph1\">`==`</ph> operator is sensitive to differences in string casing.","source":"In C#, the `==` operator is sensitive to differences in string casing."},{"content":"In X++ you can use the strCmp Function for case sensitive comparisons between strings.","pos":[20469,20555]},{"content":"String delimiters","pos":[20559,20576]},{"content":"In X++ you can use either the single (') or double (<ph id=\"ph1\">`\"`</ph>) quotation mark as the string delimiter.","pos":[20578,20674],"source":"In X++ you can use either the single (') or double (`\"`) quotation mark as the string delimiter."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>: Usually the best practice is to use double quotation marks for strings that might be displayed to the user.","pos":[20675,20792],"source":"**Note**: Usually the best practice is to use double quotation marks for strings that might be displayed to the user."},{"content":"However, it is convenient to delimit a string with single quotation marks when a double quotation mark is one of the characters in the string.","pos":[20793,20935]},{"content":"In C# you must use the double quotation mark as the string delimiter.","pos":[20937,21006]},{"content":"This refers to the type <ph id=\"ph1\">`System.String`</ph>.","pos":[21007,21047],"source":" This refers to the type `System.String`."},{"content":"In X++ and C# you have the option of embedding a delimiter in a literal string and escaping it with \\.","pos":[21049,21151]},{"content":"In X++ you also have the alternative of embedding single quotation marks in a string that is delimited by double quotation marks (or the reverse), without having to use the escape.","pos":[21156,21336]},{"content":"Character delimiters","pos":[21340,21360]},{"pos":[21362,21420],"content":"X++ has a string data type (<ph id=\"ph1\">`str`</ph>), but no character type.","source":"X++ has a string data type (`str`), but no character type."},{"content":"In C# you must use the single quotation mark as the character delimiter.","pos":[21422,21494]},{"content":"This refers to the type <ph id=\"ph1\">`System.Char`</ph>.","pos":[21495,21533],"source":" This refers to the type `System.Char`."},{"pos":[21535,21646],"content":"In the .NET Framework, a <ph id=\"ph1\">`System.String`</ph> of length one is a different data type than a <ph id=\"ph2\">`System.Char`</ph> character.","source":"In the .NET Framework, a `System.String` of length one is a different data type than a `System.Char` character."},{"pos":[21652,21698],"content":"Example 1: Case Sensitivity of the == Operator","linkify":"Example 1: Case Sensitivity of the == Operator","nodes":[{"content":"Example 1: Case Sensitivity of the == Operator","pos":[0,46]}]},{"pos":[21700,21829],"content":"The <ph id=\"ph1\">`==`</ph> and != operators are case insensitive in X++, but are case sensitive in C<ph id=\"ph2\">\\#</ph>, as is illustrated by the following example.","source":"The `==` and != operators are case insensitive in X++, but are case sensitive in C\\#, as is illustrated by the following example."},{"content":"X++","pos":[21833,21836]},{"content":"C#","pos":[21842,21844]},{"content":"Comments","pos":[21848,21856]},{"content":"True in X++.","pos":[21933,21945]},{"content":"False in C#.","pos":[21973,21985]},{"content":"Different case comparisons between X++ and C#.","pos":[21988,22034]},{"pos":[22041,22087],"content":"Example 2: The + String Concatenation Operator","linkify":"Example 2: The + String Concatenation Operator","nodes":[{"content":"Example 2: The + String Concatenation Operator","pos":[0,46]}]},{"content":"The + and += operators are used to concatenate strings in both X++ and C<ph id=\"ph1\">\\#</ph>, as is shown by the examples in the following table.","pos":[22089,22216],"source":"The + and += operators are used to concatenate strings in both X++ and C\\#, as is shown by the examples in the following table."},{"content":"X++","pos":[22220,22223]},{"content":"C#","pos":[22227,22229]},{"content":"Comments","pos":[22234,22242]},{"content":"Result is equality:","pos":[22347,22366]},{"content":"(Same as for X++.)","pos":[22403,22421]},{"content":"In both X++ and C#, the behavior of the + operator depends on the data type of its operands.","pos":[22424,22516]},{"content":"The operator concatenates strings, or adds numbers.","pos":[22517,22568]},{"content":"Result is equality: <ph id=\"ph1\">`myString2 == \"Hello world\"`</ph>","pos":[22629,22677],"source":"Result is equality: `myString2 == \"Hello world\"`"},{"content":"(Same as for X++.)","pos":[22680,22698]},{"content":"In both X++ and C#, the following statements are equivalent:","pos":[22701,22761]},{"pos":[22800,22851],"content":"Example 3: Embedding and Escaping String Delimiters","linkify":"Example 3: Embedding and Escaping String Delimiters","nodes":[{"content":"Example 3: Embedding and Escaping String Delimiters","pos":[0,51]}]},{"content":"Either single or double quotation marks can be used to delimit strings in X++.","pos":[22853,22931]},{"content":"The escape character (<ph id=\"ph1\">\\\\</ph>) can be used to embed delimiters in a string.","pos":[22932,23002],"source":" The escape character (\\\\) can be used to embed delimiters in a string."},{"content":"These are illustrated in the following table.","pos":[23003,23048]},{"content":"X++","pos":[23052,23055]},{"content":"C#","pos":[23058,23060]},{"content":"Comments","pos":[23071,23079]},{"content":"Result:","pos":[23181,23188]},{"content":"(Same as for X++.)","pos":[23213,23231]},{"content":"The escape character enables you to embed string delimiters inside strings.","pos":[23235,23310]},{"content":"Result:","pos":[23353,23360]},{"content":"C# syntax does not allow for single quotation marks to delimit strings.","pos":[23385,23456]},{"content":"For strings that may be seen by the user, it is considered a best practice to use the escape character instead of the single quotation marks as shown in the example.","pos":[23462,23627]},{"content":"Result:","pos":[23670,23677]},{"content":"(Same as for X++.)","pos":[23701,23719]},{"content":"In X++, the single quotation marks are not treated as delimiters unless the string starts with a single quotation mark delimiter.","pos":[23722,23851]},{"content":"In C# the single quotation mark has no special meaning for strings, and it cannot be used to delimit strings.","pos":[23852,23961]},{"content":"In C# the single quotation mark is the required delimiter for literals of type <ph id=\"ph1\">`System.Char`</ph>.","pos":[23962,24055],"source":" In C# the single quotation mark is the required delimiter for literals of type `System.Char`."},{"content":"X++ has no character data type.","pos":[24056,24087]},{"content":"Here the single quotation is a string delimiter.","pos":[24119,24167]},{"content":"Here the single quotation mark is a <ph id=\"ph1\">`System.Char`</ph> delimiter, not a <ph id=\"ph2\">`System.String`</ph> delimiter.","pos":[24196,24289],"source":"Here the single quotation mark is a `System.Char` delimiter, not a `System.String` delimiter."},{"content":"X++ has no data type that corresponds to <ph id=\"ph1\">`System.Char`</ph> in the .NET Framework.","pos":[24292,24369],"source":"X++ has no data type that corresponds to `System.Char` in the .NET Framework."},{"content":"An X++ string that is limited to a length of one is still a string, not a character data type.","pos":[24370,24464]},{"pos":[24471,24505],"content":"Example 4: Single Escape Character","linkify":"Example 4: Single Escape Character","nodes":[{"content":"Example 4: Single Escape Character","pos":[0,34]}]},{"content":"Examples that illustrate the single escape character in either the input or the output are shown in the following table.","pos":[24507,24627]},{"content":"X++","pos":[24631,24634]},{"content":"C#","pos":[24640,24642]},{"content":"Comments","pos":[24645,24653]},{"content":"Result:","pos":[24747,24754]},{"content":"A literal string in C# cannot contain the two character sequence of escape followed by a space, such as \"\\ \".","pos":[24776,24885]},{"content":"A compiler error occurs.","pos":[24886,24910]},{"content":"When the X++ compiler encounters the two character sequence of \"\\ \", it discards the single escape character.","pos":[24913,25022]},{"content":"Result:","pos":[25059,25066]},{"content":"(Same as for X++.)","pos":[25085,25103]},{"content":"In a pair of escape characters, the first negates the special meaning of the second.","pos":[25107,25191]},{"pos":[25201,25225],"content":"Comparison: Array Syntax","linkify":"Comparison: Array Syntax","nodes":[{"content":"Comparison: Array Syntax","pos":[0,24]}]},{"content":"There are similarities and differences in the features and syntax for arrays in X++ versus C<ph id=\"ph1\">\\#</ph>.","pos":[25227,25322],"source":"There are similarities and differences in the features and syntax for arrays in X++ versus C\\#."},{"pos":[25327,25339],"content":"Similarities","linkify":"Similarities","nodes":[{"content":"Similarities","pos":[0,12]}]},{"content":"Overall there is much similarity in the syntax and treatment of arrays in X++ and C#.","pos":[25341,25426]},{"content":"However there are many differences.","pos":[25427,25462]},{"pos":[25467,25478],"content":"Differences","linkify":"Differences","nodes":[{"content":"Differences","pos":[0,11]}]},{"content":"The following table lists areas in the [] syntax for arrays that are different for X++ and C#.","pos":[25480,25574]},{"content":"Category","pos":[25578,25586]},{"content":"X++","pos":[25589,25592]},{"content":"C#","pos":[25595,25597]},{"content":"Comments","pos":[25600,25608]},{"content":"Declaration","pos":[25631,25642]},{"content":"An array is declared with square brackets appended to the variable name.","pos":[25644,25716]},{"content":"An array is declared with square brackets appended to the data type.","pos":[25718,25786]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>: An X++ array cannot be a parameter in a method.","pos":[25815,25872],"source":"**Note**: An X++ array cannot be a parameter in a method."},{"content":"Declaration","pos":[25901,25912]},{"content":"The array syntax supports only primitive data types, such as <ph id=\"ph1\">`int`</ph> and <ph id=\"ph2\">`str`</ph>.","pos":[25914,25991],"source":"The array syntax supports only primitive data types, such as `int` and `str`."},{"content":"The syntax does not support classes or tables.","pos":[25992,26038]},{"content":"The array syntax supports primitive data types and classes.","pos":[26039,26098]},{"pos":[26100,26161],"content":"In X++ you can use the <ph id=\"ph1\">`Array`</ph> Array for an array of objects.","source":"In X++ you can use the `Array` Array for an array of objects."},{"content":"Declaration","pos":[26165,26176]},{"content":"X++ is limited to single dimension arrays (myStrings[8]).","pos":[26178,26235]},{"content":"C# adds support for multi-dimensional arrays (myStrings[8,3]) and for jagged arrays (myStrings[8][3]).","pos":[26237,26339]},{"content":"In X++ you cannot have an array of arrays.","pos":[26341,26383]},{"content":"However, there is advanced syntax for limiting the amount of active memory that a large array can consume, which looks like the multi-dimensional syntax in C#: int intArray[1024,16];.","pos":[26384,26567]},{"content":"For more information, see Best Practice Performance Optimizations: Swapping Arrays to Disk.","pos":[26568,26659]},{"content":"Declaration","pos":[26663,26674]},{"content":"In X++ an array is a special construct but it is not an object.","pos":[26676,26739]},{"content":"In C# all arrays are objects regardless of syntax variations.","pos":[26741,26802]},{"content":"X++ does have an Array class, but its underlying mechanism differs from arrays created by using the [] syntax.","pos":[26804,26914]},{"content":"In C# all arrays use the same underlying mechanism, regardless of whether [] syntax of the <ph id=\"ph1\">`System.Array`</ph> class is used in your code.","pos":[26915,27048],"source":" In C# all arrays use the same underlying mechanism, regardless of whether [] syntax of the `System.Array` class is used in your code."},{"content":"Length","pos":[27052,27058]},{"content":"In X++ the length of a static sized array is determined in the declaration syntax.","pos":[27060,27142]},{"content":"In C# the size of an array is determined when the array object is constructed.","pos":[27144,27222]},{"content":"When you use the [] declaration syntax in X++, no more preparation is needed before you assign values to the array.","pos":[27224,27339]},{"content":"In C# you must declare and then construct the array before assigning to it.","pos":[27344,27419]},{"content":"Length","pos":[27423,27429]},{"content":"An X++ array can have a dynamic length that can be increased even after population has begun.","pos":[27431,27524]},{"content":"This applies only when the array is declared without a number inside the [].","pos":[27525,27601]},{"content":"Performance might be slowed if the length of the dynamic array is increased many times.","pos":[27602,27689]},{"content":"In C# the length of an array cannot be changed after the length is set.","pos":[27691,27762]},{"content":"In the following fragment of X++ code, only the <ph id=\"ph1\">`myInts`</ph> array is dynamic and can increase in size.","pos":[27764,27863],"source":"In the following fragment of X++ code, only the `myInts` array is dynamic and can increase in size."},{"content":"Length","pos":[27984,27990]},{"pos":[27992,28060],"content":"You can get the length of some arrays by using the <ph id=\"ph1\">`dimOf`</ph> function.","source":"You can get the length of some arrays by using the `dimOf` function."},{"pos":[28062,28114],"content":"C# arrays are objects that have a <ph id=\"ph1\">`Length`</ph> property.","source":"C# arrays are objects that have a `Length` property."},{"content":"No comments.","pos":[28116,28128]},{"content":"Indexing","pos":[28132,28140]},{"content":"Array indexing is 1 based.","pos":[28142,28168]},{"content":"Array indexing is 0 based.","pos":[28170,28196]},{"content":"mtIntArray[0] would cause an error in X++.","pos":[28199,28241]},{"content":"Constant","pos":[28245,28253]},{"pos":[28255,28356],"content":"In X++ a constant value is best achieved by using the <bpt id=\"p1\">&lt;strong&gt;</bpt>#define<ept id=\"p1\">&lt;/strong&gt;</ept> precompiler directive.","source":"In X++ a constant value is best achieved by using the <strong>#define</strong> precompiler directive."},{"pos":[28358,28476],"content":"In C# you can decorate your variable declaration with the keyword <bpt id=\"p1\">&lt;strong&gt;</bpt>const<ept id=\"p1\">&lt;/strong&gt;</ept>, to achieve a constant value.","source":"In C# you can decorate your variable declaration with the keyword <strong>const</strong>, to achieve a constant value."},{"content":"X++ has no <bpt id=\"p1\">&lt;strong&gt;</bpt>const<ept id=\"p1\">&lt;/strong&gt;</ept> keyword.","pos":[28478,28520],"source":"X++ has no <strong>const</strong> keyword."},{"content":"C# cannot assign values to variables that are created by its #define precompiler directive.","pos":[28521,28612]},{"pos":[28618,28637],"content":"X++ and C\\# Samples","linkify":"X++ and C\\# Samples","nodes":[{"content":"X++ and C<ph id=\"ph1\">\\#</ph> Samples","pos":[0,19],"source":"X++ and C\\# Samples"}]},{"content":"The following code samples show how arrays of primitive data types are handled.","pos":[28639,28718]},{"content":"The first sample is in X++, and the second sample is in C<ph id=\"ph1\">\\#</ph>.","pos":[28719,28779],"source":" The first sample is in X++, and the second sample is in C\\#."},{"content":"Both samples achieve the same results.","pos":[28780,28818]},{"pos":[28823,28833],"content":"X++ Sample","linkify":"X++ Sample","nodes":[{"content":"X++ Sample","pos":[0,10]}]},{"pos":[29464,29470],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"The output to the Infolog is as follows:","pos":[29472,29512]},{"pos":[29694,29704],"content":"C\\# Sample","linkify":"C\\# Sample","nodes":[{"content":"C<ph id=\"ph1\">\\#</ph> Sample","pos":[0,10],"source":"C\\# Sample"}]},{"content":"C#","pos":[29706,29708]},{"pos":[30947,30953],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"The output from the C# program to the command line console is as follows:","pos":[30955,31028]},{"pos":[31209,31243],"content":"Additional array-like X++ features","linkify":"Additional array-like X++ features","nodes":[{"content":"Additional array-like X++ features","pos":[0,34]}]},{"content":"The <bpt id=\"p1\">**</bpt>container<ept id=\"p1\">**</ept> is a special data type that is available in X++.","pos":[31245,31311],"source":"The **container** is a special data type that is available in X++."},{"content":"It can be considered as similar to an array, or similar to a <ph id=\"ph1\">`List`</ph> collection.","pos":[31312,31391],"source":" It can be considered as similar to an array, or similar to a `List` collection."},{"pos":[31395,31418],"content":"Comparison: Collections","linkify":"Comparison: Collections","nodes":[{"content":"Comparison: Collections","pos":[0,23]}]},{"content":"Microsoft Dynamics 365 for Operations provides the X++ <ph id=\"ph1\">`List`</ph> collection class.","pos":[31419,31498],"source":"Microsoft Dynamics 365 for Operations provides the X++ `List` collection class."},{"content":"The .NET Framework that is used in C# has a similar class named <ph id=\"ph1\">`System.Collections.Generic.List`</ph>.","pos":[31499,31597],"source":" The .NET Framework that is used in C# has a similar class named `System.Collections.Generic.List`."},{"pos":[31602,31639],"content":"Comparing the Use of the List Classes","linkify":"Comparing the Use of the List Classes","nodes":[{"content":"Comparing the Use of the List Classes","pos":[0,37]}]},{"pos":[31641,31786],"content":"The following table compares methods on the X++ <ph id=\"ph1\">`List`</ph> class to the methods on <ph id=\"ph2\">`System.Collections.Generic.List`</ph> from the .NET Framework and C<ph id=\"ph3\">\\#</ph>.","source":"The following table compares methods on the X++ `List` class to the methods on `System.Collections.Generic.List` from the .NET Framework and C\\#."},{"content":"Feature","pos":[31790,31797]},{"content":"X++","pos":[31800,31803]},{"content":"C#","pos":[31806,31808]},{"content":"Comments","pos":[31811,31819]},{"content":"Declaration of collection","pos":[31842,31867]},{"content":"The X++ declaration does not include the type of elements to be stored.","pos":[31909,31980]},{"content":"Declaration of iterator","pos":[31984,32007]},{"content":"IEnumerator<ph id=\"ph1\">&amp;lt;</ph>string<ph id=\"ph2\">&amp;gt;</ph> iter;","pos":[32057,32088],"source":"IEnumerator&lt;string&gt; iter;"},{"content":"In X++ the <ph id=\"ph1\">`ListIterator`</ph> object has methods that can <ph id=\"ph2\">`insert`</ph> and <ph id=\"ph3\">`delete`</ph> items from the <ph id=\"ph4\">`List`</ph>.","pos":[32090,32188],"source":"In X++ the `ListIterator` object has methods that can `insert` and `delete` items from the `List`."},{"content":"The X++ <ph id=\"ph1\">`ListEnumerator`</ph> cannot modify the contents of the <ph id=\"ph2\">`List`</ph>.","pos":[32189,32255],"source":" The X++ `ListEnumerator` cannot modify the contents of the `List`."},{"content":"In X++ the <ph id=\"ph1\">`ListEnumerator`</ph> object is always created on the same tier as the <ph id=\"ph2\">`List`</ph>.","pos":[32256,32340],"source":" In X++ the `ListEnumerator` object is always created on the same tier as the `List`."},{"content":"This is not always true for <ph id=\"ph1\">`ListIterator`</ph>.","pos":[32341,32384],"source":" This is not always true for `ListIterator`."},{"content":"Obtaining an iterator","pos":[32388,32409]},{"content":"In both X++ and C#, the List object has a getter method for an associated enumerator.","pos":[32493,32578]},{"content":"Constructor","pos":[32582,32593]},{"pos":[32643,32767],"content":"Information about the type of objects to be stored inside the <ph id=\"ph1\">`List`</ph> classes is given to the constructor in both X++ and C#.","source":"Information about the type of objects to be stored inside the `List` classes is given to the constructor in both X++ and C#."},{"content":"Updating data","pos":[32771,32784]},{"content":"Enumerator – the enumerator becomes invalid if any items in the <ph id=\"ph1\">`List`</ph> are added or removed.","pos":[32785,32877],"source":"Enumerator – the enumerator becomes invalid if any items in the `List` are added or removed."},{"content":"Iterator – the iterator has methods that insert and delete items from the <ph id=\"ph1\">`List`</ph>.","pos":[32881,32962],"source":"Iterator – the iterator has methods that insert and delete items from the `List`."},{"content":"The iterator remains valid.","pos":[32963,32990]},{"pos":[32992,33084],"content":"Enumerator – the enumerator becomes invalid if any items in the <ph id=\"ph1\">`List`</ph> are added or removed.","source":"Enumerator – the enumerator becomes invalid if any items in the `List` are added or removed."},{"pos":[33086,33182],"content":"Enumerators become invalid after items are added or deleted from the <ph id=\"ph1\">`List`</ph>, in both X++ and C#.","source":"Enumerators become invalid after items are added or deleted from the `List`, in both X++ and C#."},{"content":"Updating data","pos":[33186,33199]},{"pos":[33201,33286],"content":"In X++ the <ph id=\"ph1\">`List`</ph> class has methods for adding items at the start or end of the list.","source":"In X++ the `List` class has methods for adding items at the start or end of the list."},{"content":"In C# the <ph id=\"ph1\">`List`</ph> class has methods for adding members at any position in the list.","pos":[33288,33370],"source":"In C# the `List` class has methods for adding members at any position in the list."},{"content":"It also has methods for removing items from any position.","pos":[33371,33428]},{"pos":[33430,33494],"content":"In X++ items can be removed from the <ph id=\"ph1\">`List`</ph> only by an iterator.","source":"In X++ items can be removed from the `List` only by an iterator."},{"pos":[33500,33532],"content":"Example 1: Declaration of a List","linkify":"Example 1: Declaration of a List","nodes":[{"content":"Example 1: Declaration of a List","pos":[0,32]}]},{"pos":[33534,33623],"content":"The following table displays code examples in X++ and C# that declare <ph id=\"ph1\">`List`</ph> collections.","source":"The following table displays code examples in X++ and C# that declare `List` collections."},{"pos":[33891,33924],"content":"Example 2: Construction of a List","linkify":"Example 2: Construction of a List","nodes":[{"content":"Example 2: Construction of a List","pos":[0,33]}]},{"content":"In both languages, the type of items that the collection stores must be specified at the time of construction.","pos":[33926,34036]},{"content":"For class types, X++ can get no more specific than whether the type is a class (Types::Class).","pos":[34037,34131]},{"content":"Code examples are in the following table.","pos":[34132,34173]},{"pos":[34297,34327],"content":"Example 3: Add Items to a List","linkify":"Example 3: Add Items to a List","nodes":[{"content":"Example 3: Add Items to a List","pos":[0,30]}]},{"content":"In both X++ and C#, the collection provides a method for appending an item to the end of the collection, and for inserting an item the start.","pos":[34329,34470]},{"content":"In C# the collection provides a method for inserting at any point in the collection based on an index value.","pos":[34471,34579]},{"content":"In X++ a collection iterator can insert an item at its current position.","pos":[34580,34652]},{"content":"Code examples are in the following table.","pos":[34653,34694]},{"pos":[35066,35099],"content":"Example 4: Iterate Through a List","linkify":"Example 4: Iterate Through a List","nodes":[{"content":"Example 4: Iterate Through a List","pos":[0,33]}]},{"content":"Both X++ and C<ph id=\"ph1\">\\#</ph> have iterator classes that you can use to step through the items in a collection.","pos":[35101,35199],"source":"Both X++ and C\\# have iterator classes that you can use to step through the items in a collection."},{"content":"Code examples are in the following table.","pos":[35200,35241]},{"pos":[35928,35954],"content":"Example 4b: foreach in C\\#","linkify":"Example 4b: foreach in C\\#","nodes":[{"content":"Example 4b: foreach in C<ph id=\"ph1\">\\#</ph>","pos":[0,26],"source":"Example 4b: foreach in C\\#"}]},{"content":"In C<ph id=\"ph1\">\\#</ph> the <bpt id=\"p1\">**</bpt>foreach<ept id=\"p1\">**</ept> keyword is often used to simplify the task of iterating through a list.","pos":[35956,36050],"source":"In C\\# the **foreach** keyword is often used to simplify the task of iterating through a list."},{"content":"The following code example behaves the same as the previous C<ph id=\"ph1\">\\#</ph> example.","pos":[36051,36123],"source":" The following code example behaves the same as the previous C\\# example."},{"pos":[36236,36269],"content":"Example 5: Delete the Second Item","linkify":"Example 5: Delete the Second Item","nodes":[{"content":"Example 5: Delete the Second Item","pos":[0,33]}]},{"content":"The following table contains code examples that delete the second item from the collection.","pos":[36271,36362]},{"content":"In X++ this requires an iterator.","pos":[36363,36396]},{"content":"In C<ph id=\"ph1\">\\#</ph> the collection itself provides the method for removing an item.","pos":[36397,36467],"source":" In C\\# the collection itself provides the method for removing an item."},{"pos":[36596,36630],"content":"Example 6: Combine Two Collections","linkify":"Example 6: Combine Two Collections","nodes":[{"content":"Example 6: Combine Two Collections","pos":[0,34]}]},{"content":"The following table contains code examples that combine the contents of two collections into one.","pos":[36632,36729]},{"pos":[36945,36988],"content":"Comparison: Collections of keys with values","linkify":"Comparison: Collections of keys with values","nodes":[{"content":"Comparison: Collections of keys with values","pos":[0,43]}]},{"content":"Microsoft Dynamics 365 for Operations provides the <ph id=\"ph1\">`Map`</ph> collection class.","pos":[36990,37064],"source":"Microsoft Dynamics 365 for Operations provides the `Map` collection class."},{"content":"The <ph id=\"ph1\">`Map`</ph> collection holds pairs of values, the key value plus a data value.","pos":[37065,37141],"source":" The `Map` collection holds pairs of values, the key value plus a data value."},{"content":"This resembles the .NET Framework class named <ph id=\"ph1\">`System.Collections.Generic.Dictionary`</ph>.","pos":[37142,37228],"source":" This resembles the .NET Framework class named `System.Collections.Generic.Dictionary`."},{"pos":[37233,37245],"content":"Similarities","linkify":"Similarities","nodes":[{"content":"Similarities","pos":[0,12]}]},{"content":"The following list describes similarities between X++ and C<ph id=\"ph1\">\\#</ph> regarding their collections that store key-value pairs:","pos":[37247,37364],"source":"The following list describes similarities between X++ and C\\# regarding their collections that store key-value pairs:"},{"content":"Both prevent duplicate keys.","pos":[37369,37397]},{"content":"Both use an enumerator (or iterator) to loop through the items.","pos":[37402,37465]},{"content":"Both key-value collection objects are constructed with designations of the types that are stored as key and value.","pos":[37470,37584]},{"pos":[37589,37674],"content":"Both can store class objects, and are not limited to storing primitives like <bpt id=\"p1\">**</bpt>int<ept id=\"p1\">**</ept>.","source":"Both can store class objects, and are not limited to storing primitives like **int**."},{"pos":[37679,37690],"content":"Differences","linkify":"Differences","nodes":[{"content":"Differences","pos":[0,11]}]},{"content":"The following table describes differences between X++ and C<ph id=\"ph1\">\\#</ph> regarding their collections classes that store key-value pairs:","pos":[37692,37817],"source":"The following table describes differences between X++ and C\\# regarding their collections classes that store key-value pairs:"},{"content":"Feature","pos":[37821,37828]},{"content":"X++","pos":[37838,37841]},{"content":"C#","pos":[37848,37850]},{"content":"Comments","pos":[37854,37862]},{"content":"Duplicate keys","pos":[37885,37899]},{"pos":[37902,38070],"content":"In X++ the <ph id=\"ph1\">`Map`</ph> class prevents duplicate keys by implicitly treating your call to its <ph id=\"ph2\">`insert`</ph> method as an operation to update only the value associated with the key.","source":"In X++ the `Map` class prevents duplicate keys by implicitly treating your call to its `insert` method as an operation to update only the value associated with the key."},{"pos":[38073,38159],"content":"In C<ph id=\"ph1\">\\#</ph> the <ph id=\"ph2\">`Dictionary`</ph> class throws an exception when you try to add a duplicate key.","source":"In C\\# the `Dictionary` class throws an exception when you try to add a duplicate key."},{"content":"Duplicate keys are prevented in both languages, although by different techniques.","pos":[38162,38243]},{"content":"Delete items","pos":[38262,38274]},{"pos":[38279,38386],"content":"In X++ the <ph id=\"ph1\">`delete`</ph> method on an iterator object is used to remove an unwanted key-value pair from a <ph id=\"ph2\">`Map`</ph>.","source":"In X++ the `delete` method on an iterator object is used to remove an unwanted key-value pair from a `Map`."},{"pos":[38392,38444],"content":"In C<ph id=\"ph1\">\\#</ph> the <ph id=\"ph2\">`Dictionary`</ph> class has a <ph id=\"ph3\">`remove`</ph> method.","source":"In C\\# the `Dictionary` class has a `remove` method."},{"content":"In both languages, an enumerator is made invalid if the collection item count is modified during the life of the enumerator.","pos":[38452,38576]},{"pos":[38584,38632],"content":"Example 1: Declaration of a Key-Value Collection","linkify":"Example 1: Declaration of a Key-Value Collection","nodes":[{"content":"Example 1: Declaration of a Key-Value Collection","pos":[0,48]}]},{"content":"In both languages, the type of items that the key-value collection stores must be specified.","pos":[38634,38726]},{"content":"In X++ the type is specified at time of construction.","pos":[38727,38780]},{"content":"In C<ph id=\"ph1\">\\#</ph> the type is specified at both the time of declaration and the time of construction.","pos":[38781,38871],"source":" In C\\# the type is specified at both the time of declaration and the time of construction."},{"content":"Code examples are in the following table.","pos":[38872,38913]},{"pos":[39201,39242],"content":"Example 2: Construction of the Collection","linkify":"Example 2: Construction of the Collection","nodes":[{"content":"Example 2: Construction of the Collection","pos":[0,41]}]},{"content":"In both languages, the type of items that the key-value collection stores specified during construction.","pos":[39244,39348]},{"content":"For class types, X++ can get no more specific than whether the type is a class (Types::Class).","pos":[39349,39443]},{"content":"Code examples are in the following table.","pos":[39444,39485]},{"pos":[39631,39671],"content":"Example 3: Add an Item to the Collection","linkify":"Example 3: Add an Item to the Collection","nodes":[{"content":"Example 3: Add an Item to the Collection","pos":[0,40]}]},{"content":"There is almost no difference in how an item is added to a key-value collection, in X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[39673,39769],"source":"There is almost no difference in how an item is added to a key-value collection, in X++ and C\\#."},{"content":"Code examples are in the following table.","pos":[39770,39811]},{"pos":[39943,39992],"content":"Example 4: Iterate Through a Key-Value Collection","linkify":"Example 4: Iterate Through a Key-Value Collection","nodes":[{"content":"Example 4: Iterate Through a Key-Value Collection","pos":[0,49]}]},{"content":"Enumerators are used to loop through the key-value collections in both X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[39994,40077],"source":"Enumerators are used to loop through the key-value collections in both X++ and C\\#."},{"content":"Code examples are in the following table.","pos":[40078,40119]},{"pos":[40585,40634],"content":"Example 5: Update the Value Associated with a Key","linkify":"Example 5: Update the Value Associated with a Key","nodes":[{"content":"Example 5: Update the Value Associated with a Key","pos":[0,49]}]},{"content":"The syntax is very different between the two languages for an update of the value associated to a given key.","pos":[40636,40744]},{"content":"Code examples for the key 102 are in the following table.","pos":[40745,40802]},{"pos":[41060,41086],"content":"Example 6: Delete One Item","linkify":"Example 6: Delete One Item","nodes":[{"content":"Example 6: Delete One Item","pos":[0,26]}]},{"content":"The syntax is very different between the two languages to delete one key-value pair from a collection, while iterating through the collection members.","pos":[41088,41238]},{"content":"Code examples for the key 102 are shown below.","pos":[41239,41285]},{"pos":[41676,41698],"content":"Comparison: Exceptions","linkify":"Comparison: Exceptions","nodes":[{"content":"Comparison: Exceptions","pos":[0,22]}]},{"content":"There are some similarities but many differences when we compare exception related behavior between X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[41699,41811],"source":"There are some similarities but many differences when we compare exception related behavior between X++ and C\\#."},{"content":"The <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>throw<ept id=\"p3\">**</ept> keywords behave the same in X++ and C#.","pos":[41812,41889],"source":" The **try**, **catch**, and **throw** keywords behave the same in X++ and C#."},{"content":"But the types of exceptions thrown and caught are different for the two languages.","pos":[41890,41972]},{"pos":[41977,41989],"content":"Similarities","linkify":"Similarities","nodes":[{"content":"Similarities","pos":[0,12]}]},{"content":"Similarities between X++ and C<ph id=\"ph1\">\\#</ph> regarding their exception features include the following:","pos":[41991,42081],"source":"Similarities between X++ and C\\# regarding their exception features include the following:"},{"pos":[42086,42131],"content":"Both languages have the same <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> keyword.","source":"Both languages have the same **try** keyword."},{"pos":[42136,42173],"content":"Both have the same <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> keyword.","source":"Both have the same **catch** keyword."},{"content":"Both enable for a <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> statement that does not specify any particular exception.","pos":[42178,42263],"source":"Both enable for a **catch** statement that does not specify any particular exception."},{"content":"Such a <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> statement catches all exceptions that reach it.","pos":[42264,42328],"source":" Such a **catch** statement catches all exceptions that reach it."},{"pos":[42333,42370],"content":"Both have the same <bpt id=\"p1\">**</bpt>throw<ept id=\"p1\">**</ept> keyword.","source":"Both have the same **throw** keyword."},{"pos":[42375,42386],"content":"Differences","linkify":"Differences","nodes":[{"content":"Differences","pos":[0,11]}]},{"content":"Exception-related differences between X++ and C<ph id=\"ph1\">\\#</ph> are described in the following table.","pos":[42388,42475],"source":"Exception-related differences between X++ and C\\# are described in the following table."},{"content":"Feature","pos":[42479,42486]},{"content":"X++","pos":[42489,42492]},{"content":"C#","pos":[42495,42497]},{"content":"Comments","pos":[42500,42508]},{"pos":[42531,42553],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>retry<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>retry</strong>"},{"content":"Jumps to the first instruction in the associated <bpt id=\"p1\">&lt;strong&gt;</bpt>try<ept id=\"p1\">&lt;/strong&gt;</ept> block.","pos":[42555,42631],"source":"Jumps to the first instruction in the associated <strong>try</strong> block."},{"content":"For more information, see Exception Handling with try and catch Keywords.","pos":[42632,42705]},{"pos":[42707,42829],"content":"The functionality of the <bpt id=\"p1\">&lt;strong&gt;</bpt>retry<ept id=\"p1\">&lt;/strong&gt;</ept> keyword can be mimicked in C# code, but there is no corresponding keyword.","source":"The functionality of the <strong>retry</strong> keyword can be mimicked in C# code, but there is no corresponding keyword."},{"content":"Only X++ has a <bpt id=\"p1\">&lt;strong&gt;</bpt>retry<ept id=\"p1\">&lt;/strong&gt;</ept> keyword.","pos":[42831,42877],"source":"Only X++ has a <strong>retry</strong> keyword."},{"content":"C# has no counterpart.","pos":[42878,42900]},{"content":"For more information, see X++, C# Comparison: Automated Retry After an Exception.","pos":[42901,42982]},{"pos":[42986,43010],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>finally<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>finally</strong>"},{"pos":[43012,43088],"content":"The <ph id=\"ph1\">`finally`</ph> keyword is supported to follow the <ph id=\"ph2\">`try`</ph> and <ph id=\"ph3\">`catch`</ph> keywords.","source":"The `finally` keyword is supported to follow the `try` and `catch` keywords."},{"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>finally<ept id=\"p1\">&lt;/strong&gt;</ept> keyword marks a block of code that follows the <bpt id=\"p2\">&lt;strong&gt;</bpt>try<ept id=\"p2\">&lt;/strong&gt;</ept> and <bpt id=\"p3\">&lt;strong&gt;</bpt>catch<ept id=\"p3\">&lt;/strong&gt;</ept> blocks.","pos":[43090,43221],"source":"The <strong>finally</strong> keyword marks a block of code that follows the <strong>try</strong> and <strong>catch</strong> blocks."},{"content":"The finally will be executed regardless of whether any exception is thrown or caught.","pos":[43222,43307]},{"content":"The semantics are identical to the semantics in C#.","pos":[43309,43360]},{"content":"Specific exceptions","pos":[43364,43383]},{"pos":[43385,43536],"content":"In X++ an exception is an element of the <ph id=\"ph1\">`Exception`</ph> enum, such as <bpt id=\"p1\">**</bpt>Error<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Deadlock<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>CodeAccessSecurity<ept id=\"p3\">**</ept>.No exception can contain another.","source":"In X++ an exception is an element of the `Exception` enum, such as **Error**, **Deadlock**, or **CodeAccessSecurity**.No exception can contain another."},{"content":"In C# an exception is an instance of the <ph id=\"ph1\">`System.Exception`</ph> base class, or any class that inherits from it.","pos":[43538,43645],"source":"In C# an exception is an instance of the `System.Exception` base class, or any class that inherits from it."},{"content":"An exception can be contained in the <ph id=\"ph1\">`InnerException`</ph> property of the thrown exception.","pos":[43646,43733],"source":" An exception can be contained in the `InnerException` property of the thrown exception."},{"content":"In X++ each thrown exception is a value of the Exception enum.","pos":[43735,43797]},{"content":"For more information, see Exception Enumeration.","pos":[43798,43846]},{"content":"Exception message","pos":[43850,43867]},{"content":"In X++ the message that is created when an exception is raised is available only in the Infolog, and the message is not directly tied to the exception.","pos":[43869,44020]},{"pos":[44022,44097],"content":"In C# the message is the <ph id=\"ph1\">`Message`</ph> member of the <ph id=\"ph2\">`System.Exception`</ph> object.","source":"In C# the message is the `Message` member of the `System.Exception` object."},{"content":"In X++ the Global::error method is the mechanism that display exception messages in the Infolog.","pos":[44099,44195]},{"content":"For more information, see Exception Handling with try and catch Keywords.","pos":[44196,44269]},{"content":"Exception conditions","pos":[44273,44293]},{"content":"In X++ an error occurs when you call an instance method on an object variable that has not yet had anything assigned to it.","pos":[44295,44418]},{"content":"However, no exception is raised along with this error.","pos":[44419,44473]},{"content":"Therefore no <ph id=\"ph1\">`catch`</ph> block can gain control even if the unassigned variable is misused in a <ph id=\"ph2\">`try`</ph> block.","pos":[44474,44578],"source":" Therefore no `catch` block can gain control even if the unassigned variable is misused in a `try` block."},{"content":"In the following code example, the error caused by the code <ph id=\"ph1\">`box4.toString();`</ph> does not cause control to transfer to any <ph id=\"ph2\">`catch`</ph> block: <ph id=\"ph3\">`DialogBox box4;`</ph> <ph id=\"ph4\">`try`</ph> { <ph id=\"ph5\">` box4.toString();`</ph> <ph id=\"ph6\">` info(\"toString did not error, but expected an error.\");`</ph> } catch (Exception::Error) // No Exception value catches this.","pos":[44579,44882],"source":" In the following code example, the error caused by the code `box4.toString();` does not cause control to transfer to any `catch` block: `DialogBox box4;` `try` { ` box4.toString();` ` info(\"toString did not error, but expected an error.\");` } catch (Exception::Error) // No Exception value catches this."},{"content":"{ <ph id=\"ph1\">` info(\"Invalid use of box4 gave control to catch, unexpected.\");`</ph> }","pos":[44883,44953],"source":" { ` info(\"Invalid use of box4 gave control to catch, unexpected.\");` }"},{"pos":[44955,45070],"content":"In C# a <ph id=\"ph1\">`System.NullReferenceException`</ph> is raised when an uninitialized variable is treated as an object reference.","source":"In C# a `System.NullReferenceException` is raised when an uninitialized variable is treated as an object reference."},{"content":"There might be several other differences in the conditions that raise exceptions.","pos":[45073,45154]},{"content":"SQL transactions","pos":[45158,45174]},{"pos":[45176,45376],"content":"In X++ when an SQL exception occurs in a <bpt id=\"p1\">&lt;strong&gt;</bpt>ttsBegin<ept id=\"p1\">&lt;/strong&gt;</ept><ph id=\"ph1\"> - </ph><bpt id=\"p2\">&lt;strong&gt;</bpt>ttsCommit<ept id=\"p2\">&lt;/strong&gt;</ept> transaction, no <bpt id=\"p3\">&lt;strong&gt;</bpt>catch<ept id=\"p3\">&lt;/strong&gt;</ept> statement inside the transaction block can process the exception.","source":"In X++ when an SQL exception occurs in a <strong>ttsBegin</strong> - <strong>ttsCommit</strong> transaction, no <strong>catch</strong> statement inside the transaction block can process the exception."},{"content":"In C# a catch block inside an SQL transaction can catch the exception.","pos":[45378,45448]},{"pos":[45456,45464],"content":"Examples","linkify":"Examples","nodes":[{"content":"Examples","pos":[0,8]}]},{"content":"The following X++ features are demonstrated:","pos":[45466,45510]},{"pos":[45515,45531],"content":"<bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> keyword.","source":"**try** keyword."},{"pos":[45536,45554],"content":"<bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> keyword.","source":"**catch** keyword."},{"content":"The behavior after an Exception::Error exception occurs.","pos":[45559,45615]},{"pos":[45620,45631],"content":"X++ Example","linkify":"X++ Example","nodes":[{"content":"X++ Example","pos":[0,11]}]},{"pos":[46621,46627],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"Here is the output from the Infolog window:","pos":[46629,46672]},{"pos":[46870,46879],"content":"C# Sample","linkify":"C# Sample","nodes":[{"content":"C# Sample","pos":[0,9]}]},{"content":"The following C<ph id=\"ph1\">\\#</ph> program is a rewrite of the previous X++ program.","pos":[46881,46948],"source":"The following C\\# program is a rewrite of the previous X++ program."},{"pos":[49028,49034],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"Here is the actual output to the C<ph id=\"ph1\">\\#</ph> console:","pos":[49036,49081],"source":"Here is the actual output to the C\\# console:"},{"pos":[49230,49276],"content":"Comparison: Automated Retry After an Exception","linkify":"Comparison: Automated Retry After an Exception","nodes":[{"content":"Comparison: Automated Retry After an Exception","pos":[0,46]}]},{"content":"Sometimes you can write code in a catch block that fixes the cause of an exception that occurs during run time.","pos":[49277,49388]},{"content":"X++ provides a <bpt id=\"p1\">**</bpt>retry<ept id=\"p1\">**</ept> keyword that can be used only inside a <bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> block.","pos":[49389,49469],"source":" X++ provides a **retry** keyword that can be used only inside a **catch** block."},{"content":"The <bpt id=\"p1\">**</bpt>retry<ept id=\"p1\">**</ept> keyword enables a program to jump back to the start of the <bpt id=\"p2\">**</bpt>try<ept id=\"p2\">**</ept> block after the problem has been corrected by code in the <bpt id=\"p3\">**</bpt>catch<ept id=\"p3\">**</ept> block.","pos":[49470,49625],"source":" The **retry** keyword enables a program to jump back to the start of the **try** block after the problem has been corrected by code in the **catch** block."},{"content":"C# does not have a <bpt id=\"p1\">**</bpt>retry<ept id=\"p1\">**</ept> keyword.","pos":[49626,49663],"source":" C# does not have a **retry** keyword."},{"content":"However, C# code can be written to provide equivalent behavior.","pos":[49664,49727]},{"pos":[49732,49754],"content":"Code Samples for Retry","linkify":"Code Samples for Retry","nodes":[{"content":"Code Samples for Retry","pos":[0,22]}]},{"content":"The following X++ sample program causes an Exception::Error to be raised.","pos":[49756,49829]},{"content":"This occurs when it first tries to read an element from the <ph id=\"ph1\">`sStrings`</ph> array by using an invalid index value.","pos":[49830,49939],"source":" This occurs when it first tries to read an element from the `sStrings` array by using an invalid index value."},{"content":"When the exception is caught, corrective action is taken during run time inside the <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> block.","pos":[49940,50040],"source":" When the exception is caught, corrective action is taken during run time inside the **catch** block."},{"content":"The retry statement then jumps back to the first statement in the <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> block.","pos":[50041,50121],"source":" The retry statement then jumps back to the first statement in the **try** block."},{"content":"This second iteration works without encountering any exception.","pos":[50122,50185]},{"pos":[50886,50892],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"Here is the output to the Print window:","pos":[50894,50933]},{"pos":[51190,51199],"content":"C# Sample","linkify":"C# Sample","nodes":[{"content":"C# Sample","pos":[0,9]}]},{"content":"The following C<ph id=\"ph1\">\\#</ph> sample is not a line-by-line translation from the previous X++ sample.","pos":[51201,51289],"source":"The following C\\# sample is not a line-by-line translation from the previous X++ sample."},{"content":"Instead the C<ph id=\"ph1\">\\#</ph> program has a different structure so that it mimics the behavior of the <bpt id=\"p1\">**</bpt>retry<ept id=\"p1\">**</ept> keyword that the X++ program relies on.","pos":[51290,51427],"source":" Instead the C\\# program has a different structure so that it mimics the behavior of the **retry** keyword that the X++ program relies on."},{"content":"The <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> blocks are in a called method.","pos":[51428,51484],"source":" The **try** and **catch** blocks are in a called method."},{"content":"The variables that are used in the <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> block are stored in the caller method.","pos":[51485,51566],"source":" The variables that are used in the **try** block are stored in the caller method."},{"content":"The caller method passes the variables as parameters that are decorated with the <bpt id=\"p1\">**</bpt>ref<ept id=\"p1\">**</ept> keyword, so that their values can be corrected inside the <bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> block of the called method.","pos":[51567,51751],"source":" The caller method passes the variables as parameters that are decorated with the **ref** keyword, so that their values can be corrected inside the **catch** block of the called method."},{"content":"The called method captures all exceptions, and returns a <bpt id=\"p1\">**</bpt>boolean<ept id=\"p1\">**</ept> to communicate back to the caller whether a second call is required.","pos":[51752,51889],"source":" The called method captures all exceptions, and returns a **boolean** to communicate back to the caller whether a second call is required."},{"content":".Rs008b_CSharp_ExceptionsAndRetry_Callee (ref iIndex); } else { break; } } Console.WriteLine(\"End of C# caller method.\"); } private bool Rs008b_CSharp_ExceptionsAndRetry_Callee (ref int iIndex) { bool bReturnCode = true; // Means call this method again.","pos":[52452,52867],"source":".Rs008b_CSharp_ExceptionsAndRetry_Callee\n  (ref iIndex);\n                }\n                else\n                {\n                    break;\n                }\n            }\n            Console.WriteLine(\"End of C# caller method.\");\n        }\n        private bool Rs008b_CSharp_ExceptionsAndRetry_Callee\n                (ref int iIndex)\n        {\n            bool bReturnCode = true; // Means call this method again."},{"content":"string[] sStrings = new string[4]; string sTemp; sStrings[0] = \"First array element.\"; try { Console.WriteLine(\"At top of try block: \" + iIndex.ToString()); sTemp = sStrings[iIndex]; Console.WriteLine( \"The array element is: \" + sTemp ); bReturnCode = false; // Means do not call this method again.","pos":[52868,53310],"source":"\n            string[] sStrings = new string[4];\n            string sTemp;\n            sStrings[0] = \"First array element.\";\n            try\n            {\n                Console.WriteLine(\"At top of try block: \"\n                    + iIndex.ToString());\n                sTemp = sStrings[iIndex];\n                Console.WriteLine( \"The array element is: \" + sTemp );\n                bReturnCode = false; // Means do not call this method again."},{"content":"} catch (Exception) { Console.WriteLine (\"In catch of -- Exception.","pos":[53311,53450],"source":"\n            }\n            catch (Exception)\n            {\n                Console.WriteLine\n                    (\"In catch of -- Exception."},{"content":"Entering catch.\"); ++iIndex; // The 'ref' parameter in C#.","pos":[53451,53525],"source":" Entering catch.\");\n                ++iIndex; // The 'ref' parameter in C#."},{"content":"Console.WriteLine (\"In catch of -- Exception.","pos":[53526,53607],"source":"\n                Console.WriteLine\n                    (\"In catch of -- Exception."},{"content":"Leaving catch.\"); //retry; // In C# we let the caller method do the work // that the retry keyword does in X++.","pos":[53608,53767],"source":" Leaving catch.\");\n                //retry;\n                // In C# we let the caller method do the work\n                // that the retry keyword does in X++."},{"content":"} Console.WriteLine(\"End of C# callee method.\"); return bReturnCode; } }","pos":[53768,53888],"source":"\n            }\n            Console.WriteLine(\"End of C# callee method.\");\n            return bReturnCode;\n        }\n    }"},{"pos":[53897,53903],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"Here is the output to the console:","pos":[53905,53939]},{"pos":[54205,54226],"content":"Comparison: Operators","linkify":"Comparison: Operators","nodes":[{"content":"Comparison: Operators","pos":[0,21]}]},{"content":"This section compares the operators between X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[54227,54283],"source":"This section compares the operators between X++ and C\\#."},{"pos":[54289,54309],"content":"Assignment Operators","linkify":"Assignment Operators","nodes":[{"content":"Assignment Operators","pos":[0,20]}]},{"content":"The following table displays the differences between the assignment operators in X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[54311,54404],"source":"The following table displays the differences between the assignment operators in X++ and C\\#."},{"content":"X++ and C#","pos":[54408,54418]},{"content":"Differences","pos":[54421,54432]},{"content":"In X++ this operator causes an implicit conversion whenever a loss of precision might occur, such for an assignment from an <bpt id=\"p1\">&lt;strong&gt;</bpt>int64<ept id=\"p1\">&lt;/strong&gt;</ept> to an <bpt id=\"p2\">&lt;strong&gt;</bpt>int<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[54452,54626],"source":"In X++ this operator causes an implicit conversion whenever a loss of precision might occur, such for an assignment from an <strong>int64</strong> to an <strong>int</strong>."},{"content":"But in C# the assignment causes a compile error.","pos":[54627,54675]},{"pos":[54679,54692],"content":"<ph id=\"ph1\">`+=`</ph> and <ph id=\"ph2\">`-=`</ph>","source":"`+=` and `-=`"},{"content":"The only difference is that in C# these operators are also used in delegate manipulation.","pos":[54694,54783]},{"content":"++ and --","pos":[54787,54796]},{"content":"These are the increment and decrement operators in both languages.","pos":[54798,54864]},{"content":"The following line is identical in both languages:","pos":[54865,54915]},{"content":"But in X++ these two operators are for statements, not for expressions.","pos":[54937,55008]},{"content":"Therefore the following lines generate compile errors in X++:","pos":[55009,55070]},{"pos":[55137,55157],"content":"Arithmetic Operators","linkify":"Arithmetic Operators","nodes":[{"content":"Arithmetic Operators","pos":[0,20]}]},{"content":"The following table lists the arithmetic operators.","pos":[55159,55210]},{"content":"X++ and C#","pos":[55213,55223]},{"content":"Differences","pos":[55226,55237]},{"content":"As the multiplication operator, there are no differences.","pos":[55255,55312]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>: The asterisk is also used in the SQL statements that are part of the X++ language.","pos":[55316,55408],"source":"**Note**: The asterisk is also used in the SQL statements that are part of the X++ language."},{"content":"In these SQL statements the asterisk can also be one of the following:","pos":[55409,55479]},{"content":"A wildcard indicating that all the columns should be returned.","pos":[55487,55549]},{"content":"A wildcard for characters in a string that is used on a <bpt id=\"p1\">&lt;strong&gt;</bpt>like<ept id=\"p1\">&lt;/strong&gt;</ept> clause.","pos":[55558,55643],"source":"A wildcard for characters in a string that is used on a <strong>like</strong> clause."},{"content":"The division operator is the same in X++ and C#.","pos":[55662,55710]},{"content":"For modulo operations, the only difference is that the % symbol is used in C#.","pos":[55721,55799]},{"content":"The addition operator is the same in X++ and C#.","pos":[55806,55854]},{"content":"The plus sign is also used for string concatenation.","pos":[55855,55907]},{"content":"This operator adds numbers and concatenates strings in both languages.","pos":[55908,55978]},{"content":"The subtraction operator is the same in X++ and C#.","pos":[55985,56036]},{"pos":[56044,56061],"content":"Bitwise Operators","linkify":"Bitwise Operators","nodes":[{"content":"Bitwise Operators","pos":[0,17]}]},{"content":"The following table compares the bitwise operators between X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[56063,56134],"source":"The following table compares the bitwise operators between X++ and C\\#."},{"content":"X++ and C<ph id=\"ph1\">\\#</ph>","pos":[56138,56149],"source":"X++ and C\\#"},{"content":"Differences","pos":[56152,56163]},{"content":"The left shift operator is the same in X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[56265,56316],"source":"The left shift operator is the same in X++ and C\\#."},{"content":"The right shift operator is the same in X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[56336,56388],"source":"The right shift operator is the same in X++ and C\\#."},{"content":"The bitwise NOT operator is the same in X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[56407,56459],"source":"The bitwise NOT operator is the same in X++ and C\\#."},{"content":"The binary AND operator is the same in X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[56478,56529],"source":"The binary AND operator is the same in X++ and C\\#."},{"content":"The binary XOR operator is the same in X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[56549,56600],"source":"The binary XOR operator is the same in X++ and C\\#."},{"content":"The binary OR operator is the same in X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[56620,56670],"source":"The binary OR operator is the same in X++ and C\\#."},{"pos":[56680,56700],"content":"Relational Operators","linkify":"Relational Operators","nodes":[{"content":"Relational Operators","pos":[0,20]}]},{"content":"The following relational operators are the same in X++ and C<ph id=\"ph1\">\\#</ph>:","pos":[56702,56765],"source":"The following relational operators are the same in X++ and C\\#:"},{"pos":[56857,56875],"content":"Comparison: Events","linkify":"Comparison: Events","nodes":[{"content":"Comparison: Events","pos":[0,18]}]},{"content":"There are some differences in how X++ and C# implement the event design pattern.","pos":[56877,56957]},{"content":"For more information, see Event Terminology and Keywords.","pos":[56958,57015]},{"pos":[57021,57061],"content":"Comparison of Events between X++ and C\\#","linkify":"Comparison of Events between X++ and C\\#","nodes":[{"content":"Comparison of Events between X++ and C<ph id=\"ph1\">\\#</ph>","pos":[0,40],"source":"Comparison of Events between X++ and C\\#"}]},{"content":"There are differences in the way delegates are used for events in X++ versus C#.","pos":[57063,57143]},{"content":"Concept","pos":[57147,57154]},{"content":"X++","pos":[57157,57160]},{"content":"C#","pos":[57163,57165]},{"content":"Comments","pos":[57168,57176]},{"pos":[57198,57223],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>delegate<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>delegate</strong>"},{"content":"In X++, a delegate can be declared only as a member on a class.","pos":[57225,57288]},{"content":"A delegate cannot be a member on a table.","pos":[57289,57330]},{"content":"All delegates are instance members of their class, not <bpt id=\"p1\">&lt;strong&gt;</bpt>static<ept id=\"p1\">&lt;/strong&gt;</ept> members.","pos":[57331,57418],"source":" All delegates are instance members of their class, not <strong>static</strong> members."},{"content":"No access modifier can be used on a delegate declaration, because all delegates are <bpt id=\"p1\">&lt;strong&gt;</bpt>protected<ept id=\"p1\">&lt;/strong&gt;</ept> members.","pos":[57419,57538],"source":" No access modifier can be used on a delegate declaration, because all delegates are <strong>protected</strong> members."},{"content":"Therefore, the event can be raised only by code within the same class where the delegate is a member.","pos":[57539,57640]},{"content":"However, the one exception to the private nature of a delegate is that code outside their class can operate on the delegates by using the += and -= operators.","pos":[57641,57799]},{"content":"In C#, each <bpt id=\"p1\">&lt;strong&gt;</bpt>delegate<ept id=\"p1\">&lt;/strong&gt;</ept> is a type, just as every <bpt id=\"p2\">&lt;strong&gt;</bpt>class<ept id=\"p2\">&lt;/strong&gt;</ept> is a type.","pos":[57801,57897],"source":"In C#, each <strong>delegate</strong> is a type, just as every <strong>class</strong> is a type."},{"content":"A delegate is declared independently of any class.","pos":[57898,57948]},{"content":"Without the <bpt id=\"p1\">&lt;strong&gt;</bpt>event<ept id=\"p1\">&lt;/strong&gt;</ept> keyword, you can have a delegate as a parameter type on a method, just as you can have a class as a parameter type.","pos":[57949,58099],"source":" Without the <strong>event</strong> keyword, you can have a delegate as a parameter type on a method, just as you can have a class as a parameter type."},{"content":"You can construct an instance of a delegate to pass in for the parameter value.","pos":[58100,58179]},{"content":"In X++, each class is a type, but no delegate is a type.","pos":[58181,58237]},{"content":"You cannot construct an instance of a delegate.","pos":[58238,58285]},{"content":"No delegate can be a parameter for a method.","pos":[58286,58330]},{"content":"But you can create a class that has a delegate member, and you can pass instances of the class as parameter values.","pos":[58331,58446]},{"content":"For more information, see X++ Keywords.","pos":[58447,58486]},{"pos":[58490,58512],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>event<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>event</strong>"},{"content":"In X++ code, an event is one of the following:","pos":[58514,58560]},{"content":"An explicit call to a delegate.","pos":[58568,58599]},{"content":"The start or end of a method.","pos":[58608,58637]},{"content":"There is no <bpt id=\"p1\">&lt;strong&gt;</bpt>event<ept id=\"p1\">&lt;/strong&gt;</ept> keyword in X++.","pos":[58647,58697],"source":"There is no <strong>event</strong> keyword in X++."},{"content":"In C#, the <bpt id=\"p1\">&lt;strong&gt;</bpt>event<ept id=\"p1\">&lt;/strong&gt;</ept> keyword is used to declare a <bpt id=\"p2\">&lt;strong&gt;</bpt>delegate<ept id=\"p2\">&lt;/strong&gt;</ept> type as a member of a class.","pos":[58699,58816],"source":"In C#, the <strong>event</strong> keyword is used to declare a <strong>delegate</strong> type as a member of a class."},{"content":"The effect of the <bpt id=\"p1\">&lt;strong&gt;</bpt>event<ept id=\"p1\">&lt;/strong&gt;</ept> keyword is to make the delegate <bpt id=\"p2\">&lt;strong&gt;</bpt>protected<ept id=\"p2\">&lt;/strong&gt;</ept>, yet still accessible for the += and -= operators.","pos":[58817,58967],"source":" The effect of the <strong>event</strong> keyword is to make the delegate <strong>protected</strong>, yet still accessible for the += and -= operators."},{"content":"You can subscribe event handler methods to an <bpt id=\"p1\">&lt;strong&gt;</bpt>event<ept id=\"p1\">&lt;/strong&gt;</ept> by using the += operator.","pos":[58968,59062],"source":" You can subscribe event handler methods to an <strong>event</strong> by using the += operator."},{"content":"A <bpt id=\"p1\">&lt;strong&gt;</bpt>delegate<ept id=\"p1\">&lt;/strong&gt;</ept> can be useful without the <bpt id=\"p2\">&lt;strong&gt;</bpt>event<ept id=\"p2\">&lt;/strong&gt;</ept> keyword, as a technique for passing a function pointer as a parameter into a method.","pos":[59063,59224],"source":" A <strong>delegate</strong> can be useful without the <strong>event</strong> keyword, as a technique for passing a function pointer as a parameter into a method."},{"content":"The automatic events that occur before the start of a method, and after the end of a method, can be subscribed to only by using the AOT.","pos":[59226,59362]},{"content":"+= and -= operators","pos":[59366,59385]},{"content":"In X++, you use the += operator to subscribe methods to a <bpt id=\"p1\">&lt;strong&gt;</bpt>delegate<ept id=\"p1\">&lt;/strong&gt;</ept>.","pos":[59387,59471],"source":"In X++, you use the += operator to subscribe methods to a <strong>delegate</strong>."},{"content":"The -= operator unsubscribes a method from a delegate.","pos":[59472,59526]},{"pos":[59528,59701],"content":"In C#, you use the += operator to subscribe methods to an <bpt id=\"p1\">&lt;strong&gt;</bpt>event<ept id=\"p1\">&lt;/strong&gt;</ept>, or to a <bpt id=\"p2\">&lt;strong&gt;</bpt>delegate<ept id=\"p2\">&lt;/strong&gt;</ept> that is not used with the <bpt id=\"p3\">&lt;strong&gt;</bpt>event<ept id=\"p3\">&lt;/strong&gt;</ept> keyword.","source":"In C#, you use the += operator to subscribe methods to an <strong>event</strong>, or to a <strong>delegate</strong> that is not used with the <strong>event</strong> keyword."},{"content":"The delegate contains a reference to all the objects that have methods subscribed to the delegate.","pos":[59703,59801]},{"content":"Those objects are not eligible for garbage collection while delegate holds those references.","pos":[59802,59894]},{"pos":[59914,60071],"content":"In X++, the <bpt id=\"p1\">&lt;strong&gt;</bpt>eventHandler<ept id=\"p1\">&lt;/strong&gt;</ept> keyword is required when you use either the += or -= operator to subscribe or unsubscribe a method from a delegate.","source":"In X++, the <strong>eventHandler</strong> keyword is required when you use either the += or -= operator to subscribe or unsubscribe a method from a delegate."},{"pos":[60073,60136],"content":"<ph id=\"ph1\">`System.EventHandler`</ph> is a delegate type in the .NET Framework.","source":"`System.EventHandler` is a delegate type in the .NET Framework."},{"content":"This term is used differently in X++ than it is in C# or the .NET Framework.","pos":[60138,60214]},{"content":"For more information, see X++ Keywords.","pos":[60215,60254]},{"pos":[60260,60271],"content":"X++ Example","linkify":"X++ Example","nodes":[{"content":"X++ Example","pos":[0,11]}]},{"content":"The important things to notice in the X++ example are the following:","pos":[60273,60341]},{"content":"The <ph id=\"ph1\">`XppClass`</ph> has a delegate member that is named <ph id=\"ph2\">`myDelegate`</ph>.","pos":[60347,60411],"source":"The `XppClass` has a delegate member that is named `myDelegate`."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>: The AOT contains a node for the delegate.","pos":[60412,60463],"source":"**Note**: The AOT contains a node for the delegate."},{"content":"The node is located at AOT &gt; Classes &gt; XppClass &gt; myDelegate.","pos":[60464,60525],"source":" The node is located at AOT > Classes > XppClass > myDelegate."},{"content":"Several event handler nodes can be located under the myDelegate node.","pos":[60526,60595]},{"content":"Event handlers that are represented by nodes in the AOT cannot be removed by the -= operator during run time.","pos":[60596,60705]},{"content":"The {} braces at the end of the delegate declaration are required, but they cannot have any code in them.","pos":[60711,60816]},{"content":"The <ph id=\"ph1\">`XppClass`</ph> has two methods whose parameter signatures are compatible with the delegate.","pos":[60821,60912],"source":"The `XppClass` has two methods whose parameter signatures are compatible with the delegate."},{"content":"One method is static.","pos":[60913,60934]},{"content":"The two compatible methods are added to the delegate with the += operator and the <bpt id=\"p1\">**</bpt>eventHandler<ept id=\"p1\">**</ept> keyword.","pos":[60939,61046],"source":"The two compatible methods are added to the delegate with the += operator and the **eventHandler** keyword."},{"content":"These statements do not call the event handler methods, the statements only add the methods to the delegate.","pos":[61047,61155]},{"content":"The event is raised by one call to the delegate.","pos":[61160,61208]},{"content":"The parameter value that passed in to the delegate is received by each event handler method.","pos":[61213,61305]},{"content":"The short X++ job at the top of the example starts the test.","pos":[61310,61370]},{"content":"The output from the previous X++ job is as follows:","pos":[62669,62720]},{"pos":[62890,62899],"content":"C# Sample","linkify":"C# Sample","nodes":[{"content":"C# Sample","pos":[0,9]}]},{"content":"This section contains a C<ph id=\"ph1\">\\#</ph> code sample for the event design pattern of the previous X++ sample.","pos":[62901,62997],"source":"This section contains a C\\# code sample for the event design pattern of the previous X++ sample."},{"content":"The output from the previous C<ph id=\"ph1\">\\#</ph> sample is as follows:","pos":[64159,64213],"source":"The output from the previous C\\# sample is as follows:"},{"pos":[64398,64416],"content":"Events and the AOT","linkify":"Events and the AOT","nodes":[{"content":"Events and the AOT","pos":[0,18]}]},{"content":"Microsoft Dynamics 365 for Operations has other event systems that apply only to items in the AOT.","pos":[64418,64516]},{"content":"For more information, see Event Handler Nodes in the AOT.","pos":[64517,64574]},{"pos":[64578,64612],"content":"Comparison: Precompiler Directives","linkify":"Comparison: Precompiler Directives","nodes":[{"content":"Comparison: Precompiler Directives","pos":[0,34]}]},{"content":"X++ and C# share some keywords for their precompiler directive syntax, but the meanings are not always the same.","pos":[64614,64726]},{"pos":[64731,64743],"content":"Similarities","linkify":"Similarities","nodes":[{"content":"Similarities","pos":[0,12]}]},{"content":"The X++ and C<ph id=\"ph1\">\\#</ph> compilers recognize many of the same keywords.","pos":[64745,64807],"source":"The X++ and C\\# compilers recognize many of the same keywords."},{"content":"In most cases, the keywords mean the same for both language compilers.","pos":[64808,64878]},{"pos":[64883,64894],"content":"Differences","linkify":"Differences","nodes":[{"content":"Differences","pos":[0,11]}]},{"content":"A fundamental difference between the precompiler directives in X++ versus C<ph id=\"ph1\">\\#</ph> is the <ph id=\"ph2\">\\#</ph>define keyword that both language precompilers recognize.","pos":[64896,65040],"source":"A fundamental difference between the precompiler directives in X++ versus C\\# is the \\#define keyword that both language precompilers recognize."},{"content":"Unlike C<ph id=\"ph1\">\\#</ph>, in X++ the <ph id=\"ph2\">\\#</ph>define directive requires a dot in its syntax.","pos":[65041,65112],"source":" Unlike C\\#, in X++ the \\#define directive requires a dot in its syntax."},{"content":"In X++, parentheses can be used to give the defined symbol a value.","pos":[65113,65180]},{"content":"These differences are shown in the following examples:","pos":[65181,65235]},{"content":"In X++: <ph id=\"ph1\">\\#</ph>define.InitialYear(2003)","pos":[65240,65274],"source":"In X++: \\#define.InitialYear(2003)"},{"content":"In C<ph id=\"ph1\">\\#</ph>: <ph id=\"ph2\">\\#</ph>define InitialYear","pos":[65279,65307],"source":"In C\\#: \\#define InitialYear"},{"content":"A minor difference is that in C<ph id=\"ph1\">\\#</ph> there can be spaces and tab characters between the <ph id=\"ph2\">\\#</ph> character and the directive keyword, such as <ph id=\"ph3\">\\#</ph> define Testing.","pos":[65309,65460],"source":"A minor difference is that in C\\# there can be spaces and tab characters between the \\# character and the directive keyword, such as \\# define Testing."},{"pos":[65465,65483],"content":"Identical Keywords","linkify":"Identical Keywords","nodes":[{"content":"Identical Keywords","pos":[0,18]}]},{"content":"The following table lists precompiler directives that are similar in X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[65485,65566],"source":"The following table lists precompiler directives that are similar in X++ and C\\#."},{"content":"Keyword","pos":[65570,65577]},{"content":"X++","pos":[65580,65583]},{"content":"C#","pos":[65586,65588]},{"content":"Comments","pos":[65591,65599]},{"content":"In X++, a precompiler variable name can be defined, and a value can be given to that variable.","pos":[65634,65728]},{"content":"In C<ph id=\"ph1\">\\#</ph>, a precompiler variable name can be defined, but no value can be given to that variable.","pos":[65746,65841],"source":"In C\\#, a precompiler variable name can be defined, but no value can be given to that variable."},{"content":"Also, any <ph id=\"ph1\">\\#</ph>define in C<ph id=\"ph2\">\\#</ph> must occur at the top of the file, and cannot occur after any code such as a using statement or a class declaration.","pos":[65842,65984],"source":" Also, any \\#define in C\\# must occur at the top of the file, and cannot occur after any code such as a using statement or a class declaration."},{"content":"The C<ph id=\"ph1\">\\#</ph> compiler can input a command line parameter of <ph id=\"ph2\">`/define`</ph> to define a precompiler variable name without defining the variable in any C<ph id=\"ph3\">\\#</ph> code file.","pos":[65987,66141],"source":"The C\\# compiler can input a command line parameter of `/define` to define a precompiler variable name without defining the variable in any C\\# code file."},{"content":"The X++ compiler has no counterpart to <ph id=\"ph1\">`/define`</ph>.","pos":[66142,66191],"source":" The X++ compiler has no counterpart to `/define`."},{"content":"In X++, <ph id=\"ph1\">\\#</ph>if can determine whether a precompiler variable exists, and whether the variable has a given value.","pos":[66207,66316],"source":"In X++, \\#if can determine whether a precompiler variable exists, and whether the variable has a given value."},{"content":"In C<ph id=\"ph1\">\\#</ph>, <ph id=\"ph2\">\\#</ph>if can only determine whether a precompiler variable exists.","pos":[66319,66389],"source":"In C\\#, \\#if can only determine whether a precompiler variable exists."},{"content":"It cannot test for any value because no value can be assigned.","pos":[66390,66452]},{"content":"In X++, <ph id=\"ph1\">\\#</ph>endif marks the end of an <ph id=\"ph2\">\\#</ph>if block.","pos":[66476,66523],"source":"In X++, \\#endif marks the end of an \\#if block."},{"content":"It also ends an <ph id=\"ph1\">\\#</ph>ifnot block.","pos":[66524,66554],"source":" It also ends an \\#ifnot block."},{"content":"In C<ph id=\"ph1\">\\#</ph>, <ph id=\"ph2\">\\#</ph>endif marks the end of an <ph id=\"ph3\">\\#</ph>if block, regardless of whether the block includes a <ph id=\"ph4\">\\#</ph>else.","pos":[66559,66657],"source":"In C\\#, \\#endif marks the end of an \\#if block, regardless of whether the block includes a \\#else."},{"pos":[66674,66724],"content":"Different Keywords with the Same Processing Result","linkify":"Different Keywords with the Same Processing Result","nodes":[{"content":"Different Keywords with the Same Processing Result","pos":[0,50]}]},{"content":"The following table lists precompiler directives that are named differently in X++ and C<ph id=\"ph1\">\\#</ph>, but that give the same results when processed.","pos":[66726,66864],"source":"The following table lists precompiler directives that are named differently in X++ and C\\#, but that give the same results when processed."},{"content":"X++","pos":[66868,66871]},{"content":"C#","pos":[66874,66876]},{"content":"Comments","pos":[66879,66887]},{"content":"<ph id=\"ph1\">\\#</ph>ifnot","pos":[66906,66913],"source":"\\#ifnot"},{"content":"<ph id=\"ph1\">\\#</ph>if <ph id=\"ph2\">\\#</ph>else","pos":[66936,66947],"source":"\\#if \\#else"},{"content":"There is no <ph id=\"ph1\">\\#</ph>else directive in X++, but the <ph id=\"ph2\">\\#</ph>ifnot provides similar functionality.","pos":[66955,67039],"source":"There is no \\#else directive in X++, but the \\#ifnot provides similar functionality."},{"content":"In X++, <ph id=\"ph1\">\\#</ph>ifnot can determine whether a precompiler variable exists, and whether the variable does not have a specific given value.","pos":[67040,67171],"source":" In X++, \\#ifnot can determine whether a precompiler variable exists, and whether the variable does not have a specific given value."},{"content":"In C<ph id=\"ph1\">\\#</ph>, <ph id=\"ph2\">\\#</ph>if can determine whether a precompiler variable exists when the ‘!’","pos":[67172,67249],"source":" In C\\#, \\#if can determine whether a precompiler variable exists when the ‘!’"},{"content":"symbol is prefixed to the variable name.","pos":[67250,67290]},{"content":"<ph id=\"ph1\">\\#</ph>pragma warning","pos":[67325,67341],"source":"\\#pragma warning"},{"content":"These X++ and C<ph id=\"ph1\">\\#</ph> entries are not equivalent, but there is a partial similarity.","pos":[67344,67424],"source":"These X++ and C\\# entries are not equivalent, but there is a partial similarity."},{"content":"Both suppress compiler warning messages.","pos":[67425,67465]},{"content":"<ph id=\"ph1\">\\#</ph>macrolib","pos":[67489,67499],"source":"\\#macrolib"},{"content":".HPP file in C++","pos":[67519,67535]},{"content":"There is a partial similarity between the X++ directive <ph id=\"ph1\">\\#</ph>macrolib versus an .HPP file in C++.","pos":[67538,67632],"source":"There is a partial similarity between the X++ directive \\#macrolib versus an .HPP file in C++."},{"content":"Both can contain several <ph id=\"ph1\">\\#</ph>define statements.","pos":[67633,67678],"source":" Both can contain several \\#define statements."},{"pos":[67696,67735],"content":"Precompiler Directives Exclusive to X++","linkify":"Precompiler Directives Exclusive to X++","nodes":[{"content":"Precompiler Directives Exclusive to X++","pos":[0,39]}]},{"content":"The following table lists X++ precompiler directives that have no direct counterpart in C<ph id=\"ph1\">\\#</ph>.","pos":[67737,67829],"source":"The following table lists X++ precompiler directives that have no direct counterpart in C\\#."},{"content":"X++","pos":[67833,67836]},{"content":"Comments","pos":[67856,67864]},{"content":"<ph id=\"ph1\">\\#</ph>linenumber","pos":[67882,67894],"source":"\\#linenumber"},{"content":"The <ph id=\"ph1\">\\#</ph>linenumber directive is for obtaining the line number, so that it can be output to the Infolog.","pos":[67905,68006],"source":"The \\#linenumber directive is for obtaining the line number, so that it can be output to the Infolog."},{"content":"The C<ph id=\"ph1\">\\#</ph> directive <ph id=\"ph2\">\\#</ph>line is different because its purpose is for setting the line number.","pos":[68011,68100],"source":"The C\\# directive \\#line is different because its purpose is for setting the line number."},{"content":"<ph id=\"ph1\">\\#</ph>defdec <ph id=\"ph2\">\\#</ph>definc","pos":[68105,68122],"source":"\\#defdec \\#definc"},{"content":"<ph id=\"ph1\">\\#</ph>globaldefine","pos":[68140,68154],"source":"\\#globaldefine"},{"content":"In X++, there is a small difference between <ph id=\"ph1\">\\#</ph>globaldefine versus <ph id=\"ph2\">\\#</ph>define.","pos":[68163,68238],"source":"In X++, there is a small difference between \\#globaldefine versus \\#define."},{"content":"The difference is that <ph id=\"ph1\">\\#</ph>globaldefine never overwrites a current nonnull value that was assigned to a precompiler variable by <ph id=\"ph2\">\\#</ph>define.","pos":[68239,68374],"source":" The difference is that \\#globaldefine never overwrites a current nonnull value that was assigned to a precompiler variable by \\#define."},{"content":"C<ph id=\"ph1\">\\#</ph> has nothing similar to this difference, because in C<ph id=\"ph2\">\\#</ph>, a precompiler variable name cannot be given a value.","pos":[68379,68491],"source":"C\\# has nothing similar to this difference, because in C\\#, a precompiler variable name cannot be given a value."},{"content":"<ph id=\"ph1\">\\#</ph>localmacro <ph id=\"ph2\">\\#</ph>macro","pos":[68496,68516],"source":"\\#localmacro \\#macro"},{"content":"In X++, <ph id=\"ph1\">\\#</ph>localmacro enables you to assign a multiline value to a precompiler variable.","pos":[68519,68606],"source":"In X++, \\#localmacro enables you to assign a multiline value to a precompiler variable."},{"content":"<ph id=\"ph1\">\\#</ph>macro is a synonym, but <ph id=\"ph2\">\\#</ph>localmacro is recommended.","pos":[68607,68661],"source":" \\#macro is a synonym, but \\#localmacro is recommended."},{"content":"In C<ph id=\"ph1\">\\#</ph>, the <ph id=\"ph2\">\\#</ph>define directive has part of this functionality, but it cannot assign a value to a precompiler variable.","pos":[68666,68784],"source":"In C\\#, the \\#define directive has part of this functionality, but it cannot assign a value to a precompiler variable."},{"content":"<ph id=\"ph1\">\\#</ph>globalmacro","pos":[68794,68807],"source":"\\#globalmacro"},{"content":"In X++, <ph id=\"ph1\">\\#</ph>globalmacro is almost the same as the preferred <ph id=\"ph2\">\\#</ph>localmacro.","pos":[68817,68888],"source":"In X++, \\#globalmacro is almost the same as the preferred \\#localmacro."},{"pos":[68903,68942],"content":"Comparison: Object Oriented Programming","linkify":"Comparison: Object Oriented Programming","nodes":[{"content":"Comparison: Object Oriented Programming","pos":[0,39]}]},{"content":"The object oriented programming (OOP) principles of X++ differ from C<ph id=\"ph1\">\\#</ph>.","pos":[68943,69015],"source":"The object oriented programming (OOP) principles of X++ differ from C\\#."},{"pos":[69020,69042],"content":"Conceptual Comparisons","linkify":"Conceptual Comparisons","nodes":[{"content":"Conceptual Comparisons","pos":[0,22]}]},{"content":"The following table compares the implementation of OOP principles between X++ and C<ph id=\"ph1\">\\#</ph>.","pos":[69044,69130],"source":"The following table compares the implementation of OOP principles between X++ and C\\#."},{"content":"Feature","pos":[69133,69140]},{"content":"X++","pos":[69141,69144]},{"content":"C#","pos":[69145,69147]},{"content":"Comments","pos":[69148,69156]},{"content":"Casting","pos":[69178,69185]},{"content":"The X++ language has the keywords <bpt id=\"p1\">&lt;strong&gt;</bpt>is<ept id=\"p1\">&lt;/strong&gt;</ept> and <bpt id=\"p2\">&lt;strong&gt;</bpt>as<ept id=\"p2\">&lt;/strong&gt;</ept>, which are used to make downcasts safe and explicit.","pos":[69188,69318],"source":"The X++ language has the keywords <strong>is</strong> and <strong>as</strong>, which are used to make downcasts safe and explicit."},{"content":"<bpt id=\"p1\">**</bpt>Tip<ept id=\"p1\">**</ept>: X++ does not require the use of the <bpt id=\"p2\">&lt;strong&gt;</bpt>as<ept id=\"p2\">&lt;/strong&gt;</ept> keyword when you downcast a base class variable to a derived class variable.","pos":[69319,69460],"source":"**Tip**: X++ does not require the use of the <strong>as</strong> keyword when you downcast a base class variable to a derived class variable."},{"content":"However, we recommend that all downcast statements use the <bpt id=\"p1\">&lt;strong&gt;</bpt>as<ept id=\"p1\">&lt;/strong&gt;</ept> keyword.","pos":[69461,69548],"source":" However, we recommend that all downcast statements use the <strong>as</strong> keyword."},{"content":"An object can be cast either up or down the inheritance path.","pos":[69550,69611]},{"content":"Downcasts require the <bpt id=\"p1\">&lt;strong&gt;</bpt>as<ept id=\"p1\">&lt;/strong&gt;</ept> keyword.","pos":[69612,69662],"source":" Downcasts require the <strong>as</strong> keyword."},{"pos":[69664,69805],"content":"For more information about the X++ keywords <bpt id=\"p1\">&lt;strong&gt;</bpt>is<ept id=\"p1\">&lt;/strong&gt;</ept> and <bpt id=\"p2\">&lt;strong&gt;</bpt>as<ept id=\"p2\">&lt;/strong&gt;</ept>, see Expression Operators: Is and As for Inheritance.","source":"For more information about the X++ keywords <strong>is</strong> and <strong>as</strong>, see Expression Operators: Is and As for Inheritance."},{"content":"Local functions","pos":[69809,69824]},{"content":"A method can contain a declaration and code body for zero or more local functions.","pos":[69826,69908]},{"content":"Only that method can have calls to the local function.","pos":[69909,69963]},{"content":"C# 3.0 supports lambda expressions, which have some similarity to anonymous functions and local functions.","pos":[69965,70071]},{"content":"Lambda expressions are often used with delegates.","pos":[70072,70121]},{"content":"Method overloading","pos":[70127,70145]},{"content":"Method overloading is not supported.","pos":[70148,70184]},{"content":"A method name can occur only one time per class.","pos":[70185,70233]},{"content":"Method overloading is supported.","pos":[70235,70267]},{"content":"A method name can occur multiple times in one class, with different parameter signatures in each case.","pos":[70268,70370]},{"content":"X++ does support optional parameters on methods.","pos":[70372,70420]},{"content":"Optional parameters can partially mimic method overloading.","pos":[70421,70480]},{"content":"For more information, see the row for optional parameters in this table.","pos":[70481,70553]},{"content":"Method overriding","pos":[70557,70574]},{"content":"Method overriding is supported.","pos":[70577,70608]},{"content":"A derived class can have a method by the same name as in the base class, as long as the parameter signature is the same in both cases.","pos":[70609,70743]},{"content":"The only exception is that the overriding method can add a default value to a parameter.","pos":[70744,70832]},{"content":"Method overriding is supported.","pos":[70834,70865]},{"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>virtual<ept id=\"p1\">&lt;/strong&gt;</ept> keyword must be applied to a method before the method can be overridden in a derived class.","pos":[70866,70986],"source":" The <strong>virtual</strong> keyword must be applied to a method before the method can be overridden in a derived class."},{"content":"The concept of overriding a method includes the method name, its parameter signature, and its return type.","pos":[70988,71094]},{"content":"The concept of method overriding does not apply if the base method and the overriding method differ in any of these aspects.","pos":[71095,71219]},{"content":"Optional parameters","pos":[71223,71242]},{"content":"A parameter declaration can be followed by a default value assignment.","pos":[71244,71314]},{"content":"The method caller has the option of passing a value for that parameter, or ignoring the parameter to accept the default value.","pos":[71315,71441]},{"content":"This feature mimics method overloading because two calls to the same method name can pass different numbers of parameters.","pos":[71442,71564]},{"content":"Each parameter that has a default value must follow the last parameter that does not have a default value.","pos":[71565,71671]},{"content":"Optional parameters are supported by the <bpt id=\"p1\">&lt;strong&gt;</bpt>params<ept id=\"p1\">&lt;/strong&gt;</ept> keyword.","pos":[71673,71746],"source":"Optional parameters are supported by the <strong>params</strong> keyword."},{"content":"Even without the <bpt id=\"p1\">&lt;strong&gt;</bpt>params<ept id=\"p1\">&lt;/strong&gt;</ept> keyword, from the point of view of the caller, method overloading can provide partially similar functionality.","pos":[71747,71898],"source":" Even without the <strong>params</strong> keyword, from the point of view of the caller, method overloading can provide partially similar functionality."},{"content":"For more information, see Parameters and Scoping and Using Optional Parameters.","pos":[71900,71979]},{"content":"Single inheritance","pos":[71983,72001]},{"content":"You can derive your X++ class from another X++ class by using the <bpt id=\"p1\">&lt;strong&gt;</bpt>extends<ept id=\"p1\">&lt;/strong&gt;</ept> keyword in the classDeclaration node of your class, in the AOT.","pos":[72003,72157],"source":"You can derive your X++ class from another X++ class by using the <strong>extends</strong> keyword in the classDeclaration node of your class, in the AOT."},{"content":"No class implicitly derives directly from another class.","pos":[72158,72214]},{"content":"If you want your class to directly derive from the <ph id=\"ph1\">`Object`</ph> class, you must use the <bpt id=\"p1\">&lt;strong&gt;</bpt>extends<ept id=\"p1\">&lt;/strong&gt;</ept> keyword.","pos":[72215,72332],"source":" If you want your class to directly derive from the `Object` class, you must use the <strong>extends</strong> keyword."},{"content":"You can specify only one class on the <bpt id=\"p1\">&lt;strong&gt;</bpt>extends<ept id=\"p1\">&lt;/strong&gt;</ept> keyword.","pos":[72333,72404],"source":" You can specify only one class on the <strong>extends</strong> keyword."},{"content":"<bpt id=\"p1\">**</bpt>Caution<ept id=\"p1\">**</ept>: When you modify an X++ base class that other classes derive from, you must recompile that base class using the Compile forward.","pos":[72412,72552],"source":"**Caution**: When you modify an X++ base class that other classes derive from, you must recompile that base class using the Compile forward."},{"content":"This option ensures that the derived classes are also recompiled.","pos":[72553,72618]},{"content":"To ensure the derived classes are also recompiled, right-click the base class node, and then click Add-Ins &gt; Compile forward.","pos":[72619,72744],"source":" To ensure the derived classes are also recompiled, right-click the base class node, and then click Add-Ins > Compile forward."},{"content":"The alternative of clicking Build &gt; Compile (or pressing the F7 key) is sometimes insufficientfor a base class change.","pos":[72745,72863],"source":" The alternative of clicking Build > Compile (or pressing the F7 key) is sometimes insufficientfor a base class change."},{"content":"A class can implement zero to many interfaces.","pos":[72871,72917]},{"content":"An X++ table implicitly inherits from the <ph id=\"ph1\">`Common`</ph> table, and from the <ph id=\"ph2\">`xRecord`</ph> class.","pos":[72926,73013],"source":"An X++ table implicitly inherits from the `Common` table, and from the `xRecord` class."},{"content":"C# uses the <bpt id=\"p1\">&lt;strong&gt;</bpt>extends<ept id=\"p1\">&lt;/strong&gt;</ept> keyword to derive from another class.","pos":[73015,73089],"source":"C# uses the <strong>extends</strong> keyword to derive from another class."},{"content":"All .NET Framework classes implicitly derive from the <ph id=\"ph1\">`System.Object`</ph> class, unless they explicitly derive from another class.","pos":[73090,73216],"source":" All .NET Framework classes implicitly derive from the `System.Object` class, unless they explicitly derive from another class."},{"pos":[73224,73243],"content":"Keyword Comparisons","linkify":"Keyword Comparisons","nodes":[{"content":"Keyword Comparisons","pos":[0,19]}]},{"content":"The following table lists the OOP-related keywords in X++ and C#.","pos":[73245,73310]},{"content":"Keyword","pos":[73313,73320]},{"content":"X++","pos":[73321,73324]},{"content":"C#","pos":[73325,73327]},{"content":"Comments","pos":[73328,73336]},{"pos":[73358,73383],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>abstract<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>abstract</strong>"},{"content":"No difference.","pos":[73389,73403]},{"pos":[73407,73429],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>class<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>class</strong>"},{"content":"The modifiers <bpt id=\"p1\">&lt;strong&gt;</bpt>public<ept id=\"p1\">&lt;/strong&gt;</ept> and <bpt id=\"p2\">&lt;strong&gt;</bpt>private<ept id=\"p2\">&lt;/strong&gt;</ept> are ignored on class declarations.","pos":[73431,73532],"source":"The modifiers <strong>public</strong> and <strong>private</strong> are ignored on class declarations."},{"content":"There is no concept of a namespace grouping of classes.","pos":[73533,73588]},{"content":"There are no dots (.) in any class names.","pos":[73589,73630]},{"content":"The modifiers <bpt id=\"p1\">&lt;strong&gt;</bpt>public<ept id=\"p1\">&lt;/strong&gt;</ept> and <bpt id=\"p2\">&lt;strong&gt;</bpt>private<ept id=\"p2\">&lt;/strong&gt;</ept> can be used to modify class declarations.","pos":[73632,73740],"source":"The modifiers <strong>public</strong> and <strong>private</strong> can be used to modify class declarations."},{"content":"C# also has the keyword <bpt id=\"p1\">&lt;strong&gt;</bpt>internal<ept id=\"p1\">&lt;/strong&gt;</ept>, which relates to how classes are grouped together in assembly files.","pos":[73741,73860],"source":" C# also has the keyword <strong>internal</strong>, which relates to how classes are grouped together in assembly files."},{"pos":[73862,73972],"content":"There is no concept of a <bpt id=\"p1\">&lt;strong&gt;</bpt>protected<ept id=\"p1\">&lt;/strong&gt;</ept> class, only <bpt id=\"p2\">&lt;strong&gt;</bpt>protected<ept id=\"p2\">&lt;/strong&gt;</ept> members of a class.","source":"There is no concept of a <strong>protected</strong> class, only <strong>protected</strong> members of a class."},{"pos":[73976,74000],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>extends<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>extends</strong>"},{"pos":[74002,74099],"content":"A class declaration can inherit from another class by using the <bpt id=\"p1\">&lt;strong&gt;</bpt>extends<ept id=\"p1\">&lt;/strong&gt;</ept> keyword.","source":"A class declaration can inherit from another class by using the <strong>extends</strong> keyword."},{"pos":[74101,74213],"content":"A colon (:) is used where the keywords <bpt id=\"p1\">&lt;strong&gt;</bpt>extends<ept id=\"p1\">&lt;/strong&gt;</ept> and <bpt id=\"p2\">&lt;strong&gt;</bpt>implements<ept id=\"p2\">&lt;/strong&gt;</ept> are used in X++.","source":"A colon (:) is used where the keywords <strong>extends</strong> and <strong>implements</strong> are used in X++."},{"pos":[74219,74241],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>final<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>final</strong>"},{"content":"A <bpt id=\"p1\">&lt;strong&gt;</bpt>final<ept id=\"p1\">&lt;/strong&gt;</ept> method cannot be overridden in a derived class.","pos":[74243,74315],"source":"A <strong>final</strong> method cannot be overridden in a derived class."},{"content":"A <bpt id=\"p1\">&lt;strong&gt;</bpt>final<ept id=\"p1\">&lt;/strong&gt;</ept> class cannot be extended.","pos":[74316,74366],"source":" A <strong>final</strong> class cannot be extended."},{"pos":[74368,74486],"content":"The keyword <bpt id=\"p1\">&lt;strong&gt;</bpt>sealed<ept id=\"p1\">&lt;/strong&gt;</ept> on a class means the same thing that <bpt id=\"p2\">&lt;strong&gt;</bpt>final<ept id=\"p2\">&lt;/strong&gt;</ept> means on an X++ class.","source":"The keyword <strong>sealed</strong> on a class means the same thing that <strong>final</strong> means on an X++ class."},{"pos":[74492,74519],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>implements<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>implements</strong>"},{"pos":[74521,74634],"content":"A class declaration can implement an <bpt id=\"p1\">&lt;strong&gt;</bpt>interface<ept id=\"p1\">&lt;/strong&gt;</ept> by using the <bpt id=\"p2\">&lt;strong&gt;</bpt>implements<ept id=\"p2\">&lt;/strong&gt;</ept> keyword.","source":"A class declaration can implement an <strong>interface</strong> by using the <strong>implements</strong> keyword."},{"pos":[74642,74668],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>interface<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>interface</strong>"},{"pos":[74670,74750],"content":"An <bpt id=\"p1\">&lt;strong&gt;</bpt>interface<ept id=\"p1\">&lt;/strong&gt;</ept> can specify methods that the class must implement.","source":"An <strong>interface</strong> can specify methods that the class must implement."},{"pos":[74752,74832],"content":"An <bpt id=\"p1\">&lt;strong&gt;</bpt>interface<ept id=\"p1\">&lt;/strong&gt;</ept> can specify methods that the class must implement.","source":"An <strong>interface</strong> can specify methods that the class must implement."},{"pos":[74838,74858],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>new<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>new</strong>"},{"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>new<ept id=\"p1\">&lt;/strong&gt;</ept> keyword is used to allocate a new instance of a class.","pos":[74860,74939],"source":"The <strong>new</strong> keyword is used to allocate a new instance of a class."},{"content":"Then the constructor is automatically called.","pos":[74940,74985]},{"content":"Each class has exactly one constructor, and the constructor is named <ph id=\"ph1\">`new`</ph>.","pos":[74986,75061],"source":" Each class has exactly one constructor, and the constructor is named `new`."},{"content":"You can decide what parameters the constructor should input.","pos":[75062,75122]},{"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>new<ept id=\"p1\">&lt;/strong&gt;</ept> keyword is used to create a new instance of a class.","pos":[75124,75201],"source":"The <strong>new</strong> keyword is used to create a new instance of a class."},{"content":"Then the constructor is automatically called.","pos":[75202,75247]},{"content":"Constructor methods themselves are not named <ph id=\"ph1\">`new`</ph>, they have the same name as the class.","pos":[75248,75337],"source":" Constructor methods themselves are not named `new`, they have the same name as the class."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>: The <bpt id=\"p2\">&lt;strong&gt;</bpt>new<ept id=\"p2\">&lt;/strong&gt;</ept> keyword can also be used on a method, to modify the way in which the method overrides the same method in the base class.","pos":[75341,75496],"source":"**Note**: The <strong>new</strong> keyword can also be used on a method, to modify the way in which the method overrides the same method in the base class."},{"content":"Both X++ and C# assume a default constructor for classes that have no constructor explicitly written in their code.","pos":[75498,75613]},{"pos":[75617,75638],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>null<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>null</strong>"},{"content":"No difference.","pos":[75644,75658]},{"pos":[75662,75717],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>private<ept id=\"p1\">&lt;/strong&gt;</ept> and <bpt id=\"p2\">&lt;strong&gt;</bpt>protected<ept id=\"p2\">&lt;/strong&gt;</ept>","source":"<strong>private</strong> and <strong>protected</strong>"},{"pos":[75719,75844],"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>private<ept id=\"p1\">&lt;/strong&gt;</ept> and <bpt id=\"p2\">&lt;strong&gt;</bpt>protected<ept id=\"p2\">&lt;/strong&gt;</ept> keywords can be used to modify the declaration of a class member.","source":"The <strong>private</strong> and <strong>protected</strong> keywords can be used to modify the declaration of a class member."},{"pos":[75846,75971],"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>private<ept id=\"p1\">&lt;/strong&gt;</ept> and <bpt id=\"p2\">&lt;strong&gt;</bpt>protected<ept id=\"p2\">&lt;/strong&gt;</ept> keywords can be used to modify the declaration of a class member.","source":"The <strong>private</strong> and <strong>protected</strong> keywords can be used to modify the declaration of a class member."},{"pos":[75976,75999],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>public<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>public</strong>"},{"pos":[76001,76173],"content":"A method that is not modified with <bpt id=\"p1\">&lt;strong&gt;</bpt>public<ept id=\"p1\">&lt;/strong&gt;</ept>, <bpt id=\"p2\">&lt;strong&gt;</bpt>protected<ept id=\"p2\">&lt;/strong&gt;</ept>, or <bpt id=\"p3\">&lt;strong&gt;</bpt>private<ept id=\"p3\">&lt;/strong&gt;</ept> has the default access level of <bpt id=\"p4\">&lt;strong&gt;</bpt>public<ept id=\"p4\">&lt;/strong&gt;</ept>.","source":"A method that is not modified with <strong>public</strong>, <strong>protected</strong>, or <strong>private</strong> has the default access level of <strong>public</strong>."},{"pos":[76175,76348],"content":"A method that is not modified with <bpt id=\"p1\">&lt;strong&gt;</bpt>public<ept id=\"p1\">&lt;/strong&gt;</ept>, <bpt id=\"p2\">&lt;strong&gt;</bpt>protected<ept id=\"p2\">&lt;/strong&gt;</ept>, or <bpt id=\"p3\">&lt;strong&gt;</bpt>private<ept id=\"p3\">&lt;/strong&gt;</ept> has the default access level of <bpt id=\"p4\">&lt;strong&gt;</bpt>private<ept id=\"p4\">&lt;/strong&gt;</ept>.","source":"A method that is not modified with <strong>public</strong>, <strong>protected</strong>, or <strong>private</strong> has the default access level of <strong>private</strong>."},{"pos":[76353,76376],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>static<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>static</strong>"},{"pos":[76378,76438],"content":"A method can be <bpt id=\"p1\">&lt;strong&gt;</bpt>static<ept id=\"p1\">&lt;/strong&gt;</ept>, but a field cannot.","source":"A method can be <strong>static</strong>, but a field cannot."},{"pos":[76440,76495],"content":"Both methods and fields can be <bpt id=\"p1\">&lt;strong&gt;</bpt>static<ept id=\"p1\">&lt;/strong&gt;</ept>.","source":"Both methods and fields can be <strong>static</strong>."},{"pos":[76501,76523],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>super<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>super</strong>"},{"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>super<ept id=\"p1\">&lt;/strong&gt;</ept> keyword is used in a derived class to access the same method on its base class.","pos":[76525,76631],"source":"The <strong>super</strong> keyword is used in a derived class to access the same method on its base class."},{"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>base<ept id=\"p1\">&lt;/strong&gt;</ept> keyword is used in a derived class to access various methods in its base class.","pos":[76752,76857],"source":"The <strong>base</strong> keyword is used in a derived class to access various methods in its base class."},{"pos":[77006,77098],"content":"In C#, there is special syntax for using <bpt id=\"p1\">&lt;strong&gt;</bpt>base<ept id=\"p1\">&lt;/strong&gt;</ept> to call the base constructor.","source":"In C#, there is special syntax for using <strong>base</strong> to call the base constructor."},{"pos":[77102,77123],"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>this<ept id=\"p1\">&lt;/strong&gt;</ept>","source":"<strong>this</strong>"},{"content":"For a call from one instance method to another on the same object, a qualifier for the called method is required.","pos":[77125,77238]},{"content":"The keyword <bpt id=\"p1\">&lt;strong&gt;</bpt>this<ept id=\"p1\">&lt;/strong&gt;</ept> is available as a qualifier for the current object.","pos":[77239,77324],"source":" The keyword <strong>this</strong> is available as a qualifier for the current object."},{"content":"For a call from one instance method to another on the same object, a qualifier for the called method is not required.","pos":[77326,77443]},{"content":"However, the <bpt id=\"p1\">&lt;strong&gt;</bpt>this<ept id=\"p1\">&lt;/strong&gt;</ept> keyword is available as a qualifier for the current object.","pos":[77444,77538],"source":" However, the <strong>this</strong> keyword is available as a qualifier for the current object."},{"content":"In practice, the keyword <bpt id=\"p1\">&lt;strong&gt;</bpt>this<ept id=\"p1\">&lt;/strong&gt;</ept> can be helpful by displaying IntelliSense information.","pos":[77539,77640],"source":" In practice, the keyword <strong>this</strong> can be helpful by displaying IntelliSense information."},{"content":"The <ph id=\"ph1\">`Object`</ph> class contains the <ph id=\"ph2\">`finalize`</ph> method.","pos":[77658,77708],"source":"The `Object` class contains the `finalize` method."},{"content":"The <ph id=\"ph1\">`finalize`</ph> method is not <bpt id=\"p1\">&lt;strong&gt;</bpt>final<ept id=\"p1\">&lt;/strong&gt;</ept>, and it can be overridden.","pos":[77709,77787],"source":" The `finalize` method is not <strong>final</strong>, and it can be overridden."},{"content":"The <ph id=\"ph1\">`finalize`</ph> method appears to resemble the <ph id=\"ph2\">`System.Object.Finalize`</ph> method in C#, but in X++ the <ph id=\"ph3\">`finalize`</ph> method has no special meaning of any kind.","pos":[77788,77941],"source":" The `finalize` method appears to resemble the `System.Object.Finalize` method in C#, but in X++ the `finalize` method has no special meaning of any kind."},{"content":"An object is automatically removed from memory when the last reference to the object stops referencing the object.","pos":[77942,78056]},{"content":"For example, this can happen when the last reference goes out of scope or is assigned another object to reference.","pos":[78057,78171]},{"content":"The methods <ph id=\"ph1\">`Finalize`</ph> and <ph id=\"ph2\">`Dispose`</ph> are common on some types of classes.","pos":[78173,78246],"source":"The methods `Finalize` and `Dispose` are common on some types of classes."},{"content":"The garbage collector calls the <ph id=\"ph1\">`Finalize`</ph> and <ph id=\"ph2\">`Dispose`</ph> methods when it destroys and object.","pos":[78247,78340],"source":" The garbage collector calls the `Finalize` and `Dispose` methods when it destroys and object."},{"content":"In C#, the <ph id=\"ph1\">`System.GC.Collect`</ph> method in the .NET Framework can be called to start the garbage collector.","pos":[78342,78447],"source":"In C#, the `System.GC.Collect` method in the .NET Framework can be called to start the garbage collector."},{"content":"There is no similar function in X++ because X++ uses a deterministic garbage collector.","pos":[78448,78535]},{"pos":[78547,78630],"content":"Classes that are invoked from a menu have their <ph id=\"ph1\">`main`</ph> method called by the system.","source":"Classes that are invoked from a menu have their `main` method called by the system."},{"pos":[78632,78731],"content":"Classes that are invoked from a command line console have their <ph id=\"ph1\">`Main`</ph> method called by the system.","source":"Classes that are invoked from a command line console have their `Main` method called by the system."},{"pos":[78738,78757],"content":"Comparison: Classes","linkify":"Comparison: Classes","nodes":[{"content":"Comparison: Classes","pos":[0,19]}]},{"content":"When you use C<ph id=\"ph1\">\\#</ph> in the .NET Framework, classes are grouped into namespaces.","pos":[78758,78834],"source":"When you use C\\# in the .NET Framework, classes are grouped into namespaces."},{"content":"Each namespace focuses on a functional area such as file operations or reflection.","pos":[78835,78917]},{"content":"However, when you use the classes in X++, there are no visible groupings like a namespace.","pos":[78918,79008]},{"pos":[79013,79049],"content":"Comparison: Classes about Reflection","linkify":"Comparison: Classes about Reflection","nodes":[{"content":"Comparison: Classes about Reflection","pos":[0,36]}]},{"content":"In X++ the <ph id=\"ph1\">`TreeNode`</ph> class provides access to the Application Object Tree (AOT).","pos":[79050,79131],"source":"In X++ the `TreeNode` class provides access to the Application Object Tree (AOT)."},{"content":"The <ph id=\"ph1\">`TreeNode`</ph> class is the center of reflection functionality in X++.","pos":[79132,79202],"source":" The `TreeNode` class is the center of reflection functionality in X++."},{"content":"The <ph id=\"ph1\">`TreeNode`</ph> class and its methods can be compared to the <ph id=\"ph2\">`System.Reflection`</ph> namespace in the .NET Framework that C<ph id=\"ph3\">\\#</ph> uses.","pos":[79203,79329],"source":" The `TreeNode` class and its methods can be compared to the `System.Reflection` namespace in the .NET Framework that C\\# uses."},{"content":"The following table lists several classes that are available to you when you write C<ph id=\"ph1\">\\#</ph> code.","pos":[79331,79423],"source":"The following table lists several classes that are available to you when you write C\\# code."},{"content":"These are .NET Framework classes.","pos":[79424,79457]},{"content":"For this table, all C<ph id=\"ph1\">\\#</ph> classes are in the <ph id=\"ph2\">`System.Reflection`</ph> namespace unless otherwise specified.","pos":[79458,79558],"source":" For this table, all C\\# classes are in the `System.Reflection` namespace unless otherwise specified."},{"content":"Each row shows the corresponding class, or class member, that is available to you when your write X++ code.","pos":[79559,79666]},{"content":"X++","pos":[79669,79672]},{"content":"C#","pos":[79673,79675]},{"content":"Comments","pos":[79676,79684]},{"content":"Assembly is the first class to use when a C<ph id=\"ph1\">\\#</ph> program must gather reflection information.","pos":[79738,79827],"source":"Assembly is the first class to use when a C\\# program must gather reflection information."},{"content":"Static methods on the X++ class <ph id=\"ph1\">`TreeNode`</ph> are the starting point for reflection in X++.","pos":[79828,79916],"source":" Static methods on the X++ class `TreeNode` are the starting point for reflection in X++."},{"pos":[79960,80039],"content":"Instance methods on <ph id=\"ph1\">`TreeNode`</ph> correspond to instance methods on <ph id=\"ph2\">`System.Type`</ph>.","source":"Instance methods on `TreeNode` correspond to instance methods on `System.Type`."},{"content":"The <ph id=\"ph1\">`AOTgetSource`</ph> method returns several pieces of information together in one string.","pos":[80117,80204],"source":"The `AOTgetSource` method returns several pieces of information together in one string."},{"content":"This includes the X++ source code in the method.","pos":[80205,80253]},{"content":"In contrast, <ph id=\"ph1\">`MethodInfo`</ph> has a separate member for each piece of information.","pos":[80254,80332],"source":" In contrast, `MethodInfo` has a separate member for each piece of information."},{"pos":[80354,80444],"content":"<ph id=\"ph1\">`TreeNode .AOTfirstChild`</ph> <ph id=\"ph2\">`TreeNode .AOTnextSibling`</ph> <ph id=\"ph3\">`TreeNode .AOTiterator`</ph> <ph id=\"ph4\">`AOTiterator`</ph>","source":"`TreeNode .AOTfirstChild` `TreeNode .AOTnextSibling` `TreeNode .AOTiterator` `AOTiterator`"},{"content":"MethodInfo<ph id=\"ph1\">\\[</ph><ph id=\"ph2\">\\]</ph> (an array)","pos":[80447,80472],"source":"MethodInfo\\[\\] (an array)"},{"content":"In C<ph id=\"ph1\">\\#</ph>, the <ph id=\"ph2\">`GetMethods`</ph> method on <ph id=\"ph3\">`System.Type`</ph> returns an array of MethodInfo objects.","pos":[80477,80565],"source":"In C\\#, the `GetMethods` method on `System.Type` returns an array of MethodInfo objects."},{"content":"You can loop through the array by the common technique of incrementing an indexer.","pos":[80566,80648]},{"content":"In contrast, the X++ model is to navigate the tree control of the AOT.","pos":[80649,80719]},{"content":"The <ph id=\"ph1\">`TreeNode`</ph> methods of <ph id=\"ph2\">`AOTfirstChild`</ph> and <ph id=\"ph3\">`AOTnextSibling`</ph> accomplish the navigation.","pos":[80720,80809],"source":" The `TreeNode` methods of `AOTfirstChild` and `AOTnextSibling` accomplish the navigation."},{"content":"As an equivalent alternative, the X++ <ph id=\"ph1\">`AOTiterator`</ph> class is designed to navigate the tree control of the AOT.","pos":[80810,80920],"source":" As an equivalent alternative, the X++ `AOTiterator` class is designed to navigate the tree control of the AOT."},{"content":"A class node is the parent over several method nodes.","pos":[80921,80974]},{"content":"The <ph id=\"ph1\">`AOTiterator`</ph> steps through child nodes, returning each as another <ph id=\"ph2\">`TreeNode`</ph> instance.","pos":[80975,81066],"source":" The `AOTiterator` steps through child nodes, returning each as another `TreeNode` instance."},{"content":"See also the <ph id=\"ph1\">`TreeNode`</ph> methods that are named <ph id=\"ph2\">`AOTparent`</ph> and <ph id=\"ph3\">`AOTprevious`</ph>.","pos":[81067,81144],"source":" See also the `TreeNode` methods that are named `AOTparent` and `AOTprevious`."},{"pos":[81149,81224],"content":"<ph id=\"ph1\">`TreeNode .AOTgetProperty`</ph> <ph id=\"ph2\">`TreeNode .AOTgetProperties`</ph> <ph id=\"ph3\">`TreeNode .AOTname`</ph>","source":"`TreeNode .AOTgetProperty` `TreeNode .AOTgetProperties` `TreeNode .AOTname`"},{"content":"In X++, the <ph id=\"ph1\">`AOTgetProperties`</ph> method returns a long string that contains name-value pairs for all the properties of the <ph id=\"ph2\">`TreeNode`</ph>.","pos":[81265,81397],"source":"In X++, the `AOTgetProperties` method returns a long string that contains name-value pairs for all the properties of the `TreeNode`."},{"content":"The <ph id=\"ph1\">`AOTname`</ph> method returns a string that contains only the value for the name property.","pos":[81398,81487],"source":" The `AOTname` method returns a string that contains only the value for the name property."},{"pos":[81509,81550],"content":"<ph id=\"ph1\">`TreeNode .AOTsave`</ph> <ph id=\"ph2\">`TreeNode .AOTinsert`</ph>","source":"`TreeNode .AOTsave` `TreeNode .AOTinsert`"},{"pos":[81573,81622],"content":"<ph id=\"ph1\">`System .Reflection .Emit`</ph> (namespace of classes)","source":"`System .Reflection .Emit` (namespace of classes)"},{"content":"The <ph id=\"ph1\">`AOTsave`</ph> method applies changes from a <ph id=\"ph2\">`TreeNode`</ph> object in your X++ code to the AOT, and the changes are persisted.","pos":[81625,81746],"source":"The `AOTsave` method applies changes from a `TreeNode` object in your X++ code to the AOT, and the changes are persisted."},{"content":"For a large code sample, see TreeNode.AOTsave Method.","pos":[81747,81800]},{"pos":[81813,81846],"content":"Comparison: Classes about File IO","linkify":"Comparison: Classes about File IO","nodes":[{"content":"Comparison: Classes about File IO","pos":[0,33]}]},{"content":"There are several classes that perform file input and output (IO) operations.","pos":[81847,81924]},{"content":"In the .NET Framework that is used in C<ph id=\"ph1\">\\#</ph>, the counterparts to these classes reside in the <ph id=\"ph2\">`System.IO`</ph> namespace.","pos":[81925,82038],"source":" In the .NET Framework that is used in C\\#, the counterparts to these classes reside in the `System.IO` namespace."},{"content":"The following table lists several .NET Framework classes for C<ph id=\"ph1\">\\#</ph> that are in the <ph id=\"ph2\">`System.IO`</ph> namespace.","pos":[82040,82143],"source":"The following table lists several .NET Framework classes for C\\# that are in the `System.IO` namespace."},{"content":"Each row in the table shows the X++ class or method that best corresponds to the .NET Framework class.","pos":[82144,82246]},{"content":"X++","pos":[82249,82252]},{"content":"C#","pos":[82253,82255]},{"content":"Comments","pos":[82256,82264]},{"pos":[82294,82336],"content":"<ph id=\"ph1\">`FileStream`</ph> <ph id=\"ph2\">`BinaryReader`</ph> <ph id=\"ph3\">`BinaryWriter`</ph>","source":"`FileStream` `BinaryReader` `BinaryWriter`"},{"content":"X++ classes such as <ph id=\"ph1\">`BinaryIo`</ph> that extend from the abstract class <ph id=\"ph2\">`Io`</ph> serve as a stream, and they also serve as a reader and writer for that stream.","pos":[82339,82489],"source":"X++ classes such as `BinaryIo` that extend from the abstract class `Io` serve as a stream, and they also serve as a reader and writer for that stream."},{"content":"In C# the stream is a separate class the from the class that has the more specific read and write methods.","pos":[82490,82596]},{"content":"These classes contain an in-memory buffer, and some of the methods treat the buffer as if it were a file on the hard disk.","pos":[82630,82752]},{"content":"WINAPI::createDirectory WINAPI::folderExists WINAPI::removeDirectory","pos":[82756,82824]},{"pos":[82826,82860],"content":"<ph id=\"ph1\">`Directory`</ph> <ph id=\"ph2\">`DirectoryInfo`</ph> <ph id=\"ph3\">`Path`</ph>","source":"`Directory` `DirectoryInfo` `Path`"},{"pos":[82862,82978],"content":"X++ can use static methods in the <ph id=\"ph1\">`WINAPI`</ph> class for many basic operating system functions that involve directories.","source":"X++ can use static methods in the `WINAPI` class for many basic operating system functions that involve directories."},{"content":"WINAPI::getDriveType","pos":[82982,83002]},{"pos":[83004,83027],"content":"<ph id=\"ph1\">`DriveInfo`</ph> <ph id=\"ph2\">`DriveType`</ph>","source":"`DriveInfo` `DriveType`"},{"content":"These classes and methods are used to obtain drive related information.","pos":[83029,83100]},{"content":"WINAPI::copyFile WINAPI::createFile WINAPI::deleteFile WINAPI::fileExists","pos":[83104,83177]},{"pos":[83179,83213],"content":"<ph id=\"ph1\">`File`</ph> <ph id=\"ph2\">`FileAttributes`</ph> <ph id=\"ph3\">`FileInfo`</ph>","source":"`File` `FileAttributes` `FileInfo`"},{"pos":[83215,83325],"content":"X++ can use static methods in the <ph id=\"ph1\">`WINAPI`</ph> class for many basic operating system functions that involve files.","source":"X++ can use static methods in the `WINAPI` class for many basic operating system functions that involve files."},{"pos":[83329,83349],"content":"<ph id=\"ph1\">`CommaIo`</ph> <ph id=\"ph2\">`Comma7Io`</ph>","source":"`CommaIo` `Comma7Io`"},{"content":"(No corresponding class.)","pos":[83351,83376]},{"content":"These X++ classes can generate files that Microsoft Excel can import.","pos":[83378,83447]},{"content":"In X++ an <bpt id=\"p1\">&lt;a href=\"http://epplus.codeplex.com/\"&gt;</bpt>EPPlus<ept id=\"p1\">&lt;/a&gt;</ept> library reference is available for additional interaction with Excel.","pos":[83448,83576],"source":" In X++ an <a href=\"http://epplus.codeplex.com/\">EPPlus</a> library reference is available for additional interaction with Excel."},{"pos":[83580,83598],"content":"<ph id=\"ph1\">`AsciiIo`</ph> <ph id=\"ph2\">`TextIo`</ph>","source":"`AsciiIo` `TextIo`"},{"pos":[83600,83638],"content":"<ph id=\"ph1\">`FileStream`</ph> <ph id=\"ph2\">`TextReader`</ph> <ph id=\"ph3\">`TextWriter`</ph>","source":"`FileStream` `TextReader` `TextWriter`"},{"content":"These classes use different code pages.","pos":[83640,83679]},{"pos":[83689,83740],"content":"<ph id=\"ph1\">`Stream`</ph> <ph id=\"ph2\">`StreamReader`</ph> <ph id=\"ph3\">`StreamWriter`</ph> <ph id=\"ph4\">`FileStream`</ph>","source":"`Stream` `StreamReader` `StreamWriter` `FileStream`"},{"content":"These are often used as base classes that other classes extend.","pos":[83742,83805]},{"pos":[83809,83850],"content":"<ph id=\"ph1\">`CodeAccessPermission`</ph> <ph id=\"ph2\">`FileIoPermission`</ph>","source":"`CodeAccessPermission` `FileIoPermission`"},{"content":"<ph id=\"ph1\">`System.Security`</ph> <ph id=\"ph2\">`.CodeAccessPermission`</ph> The namespace <ph id=\"ph3\">`System.Security.Permissions`</ph> includes the following classes:","pos":[83852,83969],"source":"`System.Security` `.CodeAccessPermission` The namespace `System.Security.Permissions` includes the following classes:"},{"content":"The concepts and methods of <ph id=\"ph1\">`assert`</ph>, <ph id=\"ph2\">`demand`</ph>, and <ph id=\"ph3\">`revertAssert`</ph> apply to both languages.","pos":[84114,84205],"source":"The concepts and methods of `assert`, `demand`, and `revertAssert` apply to both languages."},{"content":"However, the <ph id=\"ph1\">`deny`</ph> and <ph id=\"ph2\">`revertDeny`</ph> methods that are available in C# are not available in X++.","pos":[84206,84301],"source":" However, the `deny` and `revertDeny` methods that are available in C# are not available in X++."},{"pos":[84306,84342],"content":"X++, ANSI SQL Comparison: SQL Select","linkify":"X++, ANSI SQL Comparison: SQL Select","nodes":[{"content":"X++, ANSI SQL Comparison: SQL Select","pos":[0,36]}]},{"pos":[84343,84463],"content":"In X++, the SQL <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement syntax differs from the American National Standards Institute (ANSI) specification.","source":"In X++, the SQL **select** statement syntax differs from the American National Standards Institute (ANSI) specification."},{"pos":[84468,84487],"content":"Single Table Select","linkify":"Single Table Select","nodes":[{"content":"Single Table Select","pos":[0,19]}]},{"content":"The following table lists differences between the select statements of X++ SQL and ANSI SQL.","pos":[84489,84581]},{"content":"Feature","pos":[84584,84591]},{"content":"X++ SQL","pos":[84592,84599]},{"content":"ANSI SQL","pos":[84600,84608]},{"content":"Comments","pos":[84609,84617]},{"pos":[84639,84686],"content":"Table name on the <bpt id=\"p1\">&lt;strong&gt;</bpt>from<ept id=\"p1\">&lt;/strong&gt;</ept> clause.","source":"Table name on the <strong>from</strong> clause."},{"pos":[84688,84818],"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>from<ept id=\"p1\">&lt;/strong&gt;</ept> clause lists a record buffer instance that is declared from a table, such as from the <ph id=\"ph1\">`CustTable`</ph> table.","source":"The <strong>from</strong> clause lists a record buffer instance that is declared from a table, such as from the `CustTable` table."},{"pos":[84820,84898],"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>from<ept id=\"p1\">&lt;/strong&gt;</ept> clause lists a table name, not the name of a buffer.","source":"The <strong>from</strong> clause lists a table name, not the name of a buffer."},{"pos":[84900,84973],"content":"The record buffer has all the methods that the <ph id=\"ph1\">`xRecord`</ph>class has in X++.","source":"The record buffer has all the methods that the `xRecord`class has in X++."},{"pos":[84977,85047],"content":"Syntax sequence of the order by versus <bpt id=\"p1\">&lt;strong&gt;</bpt>where<ept id=\"p1\">&lt;/strong&gt;</ept> clauses.","source":"Syntax sequence of the order by versus <strong>where</strong> clauses."},{"content":"The order by clause must appear before the <bpt id=\"p1\">&lt;strong&gt;</bpt>where<ept id=\"p1\">&lt;/strong&gt;</ept> clause.","pos":[85049,85122],"source":"The order by clause must appear before the <strong>where</strong> clause."},{"content":"The order by clause must appear after the <bpt id=\"p1\">&lt;strong&gt;</bpt>from<ept id=\"p1\">&lt;/strong&gt;</ept> or <bpt id=\"p2\">&lt;strong&gt;</bpt>join<ept id=\"p2\">&lt;/strong&gt;</ept> clause.","pos":[85123,85219],"source":" The order by clause must appear after the <strong>from</strong> or <strong>join</strong> clause."},{"content":"The group by clause must follow the same syntax positioning rules that the order by follows.","pos":[85220,85312]},{"content":"The order by clause must appear after the <bpt id=\"p1\">&lt;strong&gt;</bpt>where<ept id=\"p1\">&lt;/strong&gt;</ept> clause.","pos":[85314,85386],"source":"The order by clause must appear after the <strong>where</strong> clause."},{"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>where<ept id=\"p1\">&lt;/strong&gt;</ept> clause must appear after the <bpt id=\"p2\">&lt;strong&gt;</bpt>from<ept id=\"p2\">&lt;/strong&gt;</ept> or <bpt id=\"p3\">&lt;strong&gt;</bpt>join<ept id=\"p3\">&lt;/strong&gt;</ept> clause.","pos":[85387,85497],"source":" The <strong>where</strong> clause must appear after the <strong>from</strong> or <strong>join</strong> clause."},{"pos":[85499,85652],"content":"In both X++ and ANSI SQL, the <bpt id=\"p1\">&lt;strong&gt;</bpt>from<ept id=\"p1\">&lt;/strong&gt;</ept> and <bpt id=\"p2\">&lt;strong&gt;</bpt>join<ept id=\"p2\">&lt;/strong&gt;</ept> clauses must appear before the order by and <bpt id=\"p3\">&lt;strong&gt;</bpt>where<ept id=\"p3\">&lt;/strong&gt;</ept> clauses.","source":"In both X++ and ANSI SQL, the <strong>from</strong> and <strong>join</strong> clauses must appear before the order by and <strong>where</strong> clauses."},{"content":"Condition negation.","pos":[85656,85675]},{"content":"The exclamation mark ('!') is used for negation.","pos":[85677,85725]},{"pos":[85727,85781],"content":"The <bpt id=\"p1\">&lt;strong&gt;</bpt>not<ept id=\"p1\">&lt;/strong&gt;</ept> keyword is used for negation.","source":"The <strong>not</strong> keyword is used for negation."},{"content":"X++ does not support the syntax !like.","pos":[85783,85821]},{"content":"Instead, you must apply the !","pos":[85822,85851]},{"content":"operator to a clause.","pos":[85852,85873]},{"pos":[85877,85936],"content":"Wildcard characters for the <bpt id=\"p1\">&lt;strong&gt;</bpt>like<ept id=\"p1\">&lt;/strong&gt;</ept> operator.","source":"Wildcard characters for the <strong>like</strong> operator."},{"content":"0 to many – Asterisk ('*')","pos":[85937,85963]},{"content":"Exactly 1 – Question mark ('?')","pos":[85967,85998]},{"content":"0 to many – Percent sign ('%')","pos":[85999,86029]},{"content":"Exactly 1 – Underbar ('_')","pos":[86033,86059]},{"pos":[86065,86120],"content":"Logical operators in the <bpt id=\"p1\">&lt;strong&gt;</bpt>where<ept id=\"p1\">&lt;/strong&gt;</ept> clause.","source":"Logical operators in the <strong>where</strong> clause."},{"content":"And – &amp;&amp;","pos":[86121,86129],"source":"And – &&"},{"content":"Or – \\","pos":[86133,86139]},{"content":"And – <bpt id=\"p1\">&lt;strong&gt;</bpt>and<ept id=\"p1\">&lt;/strong&gt;</ept>","pos":[86144,86170],"source":"And – <strong>and</strong>"},{"content":"Or – <bpt id=\"p1\">&lt;strong&gt;</bpt>or<ept id=\"p1\">&lt;/strong&gt;</ept>","pos":[86174,86198],"source":"Or – <strong>or</strong>"},{"pos":[86206,86218],"content":"Code Example","linkify":"Code Example","nodes":[{"content":"Code Example","pos":[0,12]}]},{"content":"The following code example illustrates features in the previous table.","pos":[86220,86290]},{"pos":[86777,86793],"content":"X++ SQL Keywords","linkify":"X++ SQL Keywords","nodes":[{"content":"X++ SQL Keywords","pos":[0,16]}]},{"content":"The following X++ SQL keywords are among those that are not part of ANSI SQL:","pos":[86795,86872]},{"content":"crosscompany","pos":[86877,86889]},{"content":"firstonly100","pos":[86894,86906]},{"content":"forceliterals","pos":[86911,86924]},{"content":"forcenestedloop","pos":[86929,86944]},{"content":"forceplaceholders","pos":[86949,86966]},{"content":"forceselectorder","pos":[86971,86987]},{"content":"validtimestate","pos":[86992,87006]},{"pos":[87012,87023],"content":"Join Clause","linkify":"Join Clause","nodes":[{"content":"Join Clause","pos":[0,11]}]},{"pos":[87025,87114],"content":"The following table lists differences about the <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> keyword of X++ SQL and ANSI SQL.","source":"The following table lists differences about the **join** keyword of X++ SQL and ANSI SQL."},{"content":"Feature","pos":[87117,87124]},{"content":"X++ SQL","pos":[87125,87132]},{"content":"ANSI SQL","pos":[87133,87141]},{"content":"Comments","pos":[87142,87150]},{"content":"Columns list.","pos":[87172,87185]},{"content":"The columns in the columns list must all come from the table listed in the <bpt id=\"p1\">**</bpt>from<ept id=\"p1\">**</ept> clause, and not from any table in a <bpt id=\"p2\">**</bpt>join<ept id=\"p2\">**</ept> clause.","pos":[87207,87343],"source":"The columns in the columns list must all come from the table listed in the **from** clause, and not from any table in a **join** clause."},{"content":"Columns in the list cannot be qualified by their table name.","pos":[87344,87404]},{"content":"The columns in the columns list can come from any table in the <bpt id=\"p1\">**</bpt>from<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>join<ept id=\"p2\">**</ept> clauses.","pos":[87407,87499],"source":"The columns in the columns list can come from any table in the **from** or **join** clauses."},{"content":"It helps others to maintain your code when you qualify the columns in the list with their table name.","pos":[87500,87601]},{"content":"For more information, see Select Statements on Fields.","pos":[87604,87658]},{"pos":[87666,87689],"content":"<bpt id=\"p1\">**</bpt>Join<ept id=\"p1\">**</ept> clause syntax.","source":"**Join** clause syntax."},{"pos":[87701,87750],"content":"The <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> clause follows the <bpt id=\"p2\">**</bpt>where<ept id=\"p2\">**</ept> clause.","source":"The **join** clause follows the **where** clause."},{"pos":[87763,87822],"content":"The <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> clause follows a table in the <bpt id=\"p2\">**</bpt>from<ept id=\"p2\">**</ept> clause.","source":"The **join** clause follows a table in the **from** clause."},{"pos":[87844,87930],"content":"In the X++ code example, the <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> criteria is an equality of <ph id=\"ph1\">`SalesPoolId`</ph> values.","source":"In the X++ code example, the **join** criteria is an equality of `SalesPoolId` values."},{"pos":[87935,87953],"content":"<bpt id=\"p1\">**</bpt>Inner<ept id=\"p1\">**</ept> keyword.","source":"**Inner** keyword."},{"content":"The default <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> mode is inner join.","pos":[87970,88010],"source":"The default **join** mode is inner join."},{"content":"There is no <bpt id=\"p1\">**</bpt>inner<ept id=\"p1\">**</ept> keyword.","pos":[88011,88041],"source":" There is no **inner** keyword."},{"content":"The default <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> mode is inner join.","pos":[88054,88094],"source":"The default **join** mode is inner join."},{"content":"The <bpt id=\"p1\">**</bpt>inner<ept id=\"p1\">**</ept> keyword is available to make the code explicit.","pos":[88095,88156],"source":" The **inner** keyword is available to make the code explicit."},{"pos":[88164,88222],"content":"The <bpt id=\"p1\">**</bpt>outer<ept id=\"p1\">**</ept> keyword exists in both X++ SQL and ANSI SQL.","source":"The **outer** keyword exists in both X++ SQL and ANSI SQL."},{"pos":[88233,88265],"content":"<bpt id=\"p1\">**</bpt>Left<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>right<ept id=\"p2\">**</ept> keywords.","source":"**Left** and **right** keywords."},{"content":"The <bpt id=\"p1\">**</bpt>left<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>right<ept id=\"p2\">**</ept> keywords are not available.","pos":[88268,88322],"source":"The **left** and **right** keywords are not available."},{"content":"All joins are left.","pos":[88323,88342]},{"pos":[88352,88433],"content":"The <bpt id=\"p1\">**</bpt>left<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>right<ept id=\"p2\">**</ept> keywords are available to modify the <bpt id=\"p3\">**</bpt>join<ept id=\"p3\">**</ept> keyword.","source":"The **left** and **right** keywords are available to modify the **join** keyword."},{"content":"No comments.","pos":[88440,88452]},{"content":"Equality operator.","pos":[88473,88491]},{"pos":[88508,88595],"content":"The double equal sign operator ('<ph id=\"ph1\">`==`</ph>') is used to test for the equality of two values.","source":"The double equal sign operator ('`==`') is used to test for the equality of two values."},{"pos":[88599,88685],"content":"The single equal sign operator ('<ph id=\"ph1\">`=`</ph>') is used to test for the equality of two values.","source":"The single equal sign operator ('`=`') is used to test for the equality of two values."},{"content":"No comments.","pos":[88709,88721]},{"pos":[88744,88756],"content":"Code Example","linkify":"Code Example","nodes":[{"content":"Code Example","pos":[0,12]}]},{"pos":[88758,88828],"content":"The following code example illustrates the <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> syntax in X++ SQL.","source":"The following code example illustrates the **join** syntax in X++ SQL."},{"pos":[89477,89493],"content":"Aggregate Fields","linkify":"Aggregate Fields","nodes":[{"content":"Aggregate Fields","pos":[0,16]}]},{"content":"The following table lists some differences in how aggregate fields in the <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> column list are referenced between X++ SQL and ANSI SQL.","pos":[89495,89636],"source":"The following table lists some differences in how aggregate fields in the **select** column list are referenced between X++ SQL and ANSI SQL."},{"content":"Aggregate fields are those that are derived by functions such as <bpt id=\"p1\">**</bpt>sum<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>avg<ept id=\"p2\">**</ept>.","pos":[89637,89721],"source":" Aggregate fields are those that are derived by functions such as **sum** or **avg**."},{"content":"Feature","pos":[89724,89731]},{"content":"X++ SQL","pos":[89732,89739]},{"content":"ANSI SQL","pos":[89740,89748]},{"content":"Comments","pos":[89749,89757]},{"content":"Aggregate field name alias.","pos":[89779,89806]},{"content":"The aggregate value is in the field that was aggregated.","pos":[89809,89865]},{"content":"You can use the <bpt id=\"p1\">**</bpt>as<ept id=\"p1\">**</ept> keyword to tag an aggregate field with a name alias.","pos":[89868,89943],"source":"You can use the **as** keyword to tag an aggregate field with a name alias."},{"content":"The alias can be referenced in subsequent code.","pos":[89944,89991]},{"content":"For more information, see Aggregate Functions: Differences Between X++ and SQL","pos":[89994,90072]},{"pos":[90079,90091],"content":"Code Example","linkify":"Code Example","nodes":[{"content":"Code Example","pos":[0,12]}]},{"pos":[90093,90232],"content":"In the following code example, the call to the info method illustrates the way to reference aggregate fields (see <ph id=\"ph1\">`tPurchLine.QtyOrdered`</ph>).","source":"In the following code example, the call to the info method illustrates the way to reference aggregate fields (see `tPurchLine.QtyOrdered`)."},{"pos":[90944,90961],"content":"Other Differences","linkify":"Other Differences","nodes":[{"content":"Other Differences","pos":[0,17]}]},{"pos":[90963,91068],"content":"The following table lists other differences of the <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement between the X++ SQL and ANSI SQL.","source":"The following table lists other differences of the **select** statement between the X++ SQL and ANSI SQL."},{"content":"Feature","pos":[91071,91078]},{"content":"X++ SQL","pos":[91079,91086]},{"content":"ANSI SQL","pos":[91087,91095]},{"content":"Comments","pos":[91096,91104]},{"pos":[91125,91148],"content":"The <bpt id=\"p1\">**</bpt>having<ept id=\"p1\">**</ept> keyword.","source":"The **having** keyword."},{"pos":[91149,91180],"content":"There is no <bpt id=\"p1\">**</bpt>having<ept id=\"p1\">**</ept> keyword.","source":"There is no **having** keyword."},{"pos":[91181,91294],"content":"The <bpt id=\"p1\">**</bpt>having<ept id=\"p1\">**</ept> keyword enables you to specify filter criteria for rows that are generated by the group by clause.","source":"The **having** keyword enables you to specify filter criteria for rows that are generated by the group by clause."},{"content":"No comments.","pos":[91295,91307]},{"content":"Null results.","pos":[91310,91323]},{"pos":[91324,91451],"content":"In a <bpt id=\"p1\">**</bpt>while<ept id=\"p1\">**</ept> select statement, if the <bpt id=\"p2\">**</bpt>where<ept id=\"p2\">**</ept> clause filters out all rows, no special count row is returned to report that.","source":"In a **while** select statement, if the **where** clause filters out all rows, no special count row is returned to report that."},{"content":"In a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept>, if the <bpt id=\"p2\">**</bpt>where<ept id=\"p2\">**</ept> clause filters out all rows, a special count row is returned.","pos":[91452,91547],"source":"In a **select**, if the **where** clause filters out all rows, a special count row is returned."},{"content":"The count value is 0.","pos":[91548,91569]},{"content":"No comments.","pos":[91570,91582]},{"content":"Cursors for navigating returned rows.","pos":[91585,91622]},{"content":"The while select statement provides cursor functionality.","pos":[91623,91680]},{"content":"The alternative is to use the <bpt id=\"p1\">**</bpt>next<ept id=\"p1\">**</ept> keyword.","pos":[91681,91728],"source":" The alternative is to use the **next** keyword."},{"pos":[91729,91833],"content":"You can declare a <bpt id=\"p1\">**</bpt>cursor<ept id=\"p1\">**</ept> for looping through the rows that are returned from a <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement.","source":"You can declare a **cursor** for looping through the rows that are returned from a **select** statement."},{"pos":[91837,91853],"content":"<bpt id=\"p1\">**</bpt>From<ept id=\"p1\">**</ept> clause.","source":"**From** clause."},{"content":"The <bpt id=\"p1\">**</bpt>from<ept id=\"p1\">**</ept> keyword is optional when no columns are listed and only one table is referenced.","pos":[91854,91947],"source":"The **from** keyword is optional when no columns are listed and only one table is referenced."},{"content":"The following two syntax options are equivalent:","pos":[91948,91996]},{"pos":[92055,92138],"content":"A <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement cannot read from a table unless the <bpt id=\"p2\">**</bpt>from<ept id=\"p2\">**</ept> clause is used.","source":"A **select** statement cannot read from a table unless the **from** clause is used."},{"content":"In X++ SQL, the simple <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement fills the table buffer variable with the first row that was returned.","pos":[92139,92252],"source":"In X++ SQL, the simple **select** statement fills the table buffer variable with the first row that was returned."},{"content":"This is illustrated by the following code fragment:","pos":[92253,92304]}]}