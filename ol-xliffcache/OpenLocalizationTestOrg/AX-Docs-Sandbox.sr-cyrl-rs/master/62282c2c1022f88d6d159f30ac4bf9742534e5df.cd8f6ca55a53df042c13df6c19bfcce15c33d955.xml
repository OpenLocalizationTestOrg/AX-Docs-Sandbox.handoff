{"content":"---\n# required metadata\n\ntitle: X++ data selection and manipulation\ndescription: This topic describes the support for data selection and manipulation in the X++ language.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 04/21/2017\nms.topic: article\nms.prod: \nms.service: Dynamics365Operations\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: annbe\nms.search.scope: AX 7.0.0, Operations\n# ms.tgt_pltfrm: \nms.custom: 150273\nms.assetid: 999a5ecf-559b-4d66-8b05-9a8e477e0518\nms.search.region: Global\n# ms.search.industry: \nms.author: robinr\nms.dyn365.ops.intro: AX 7.0.0\nms.search.validFrom: 2016-02-28\n\n---\n\n# X++ data selection and manipulation\n\n[!include[banner](../includes/banner.md)]\n\n\nThis topic describes the support for data selection and manipulation in the X++ language.\n\nYou can use SQL statements, either interactively or within source code, to access and retrieve data that is stored in the database. You use the following statements for data manipulation:\n\n-   **select** – Select the data to modify.\n-   **insert** – Add one or more new records to a table.\n-   **update** – Modify data in existing table records.\n-   **delete** – Remove existing records from a table.\n\nBefore any data can be changed, you must use a **select** statement to select the data to update. The **select forUpdate** command selects records for update only. The **insert**, **update**, and **delete** statements perform operations on one record at a time. The **array insert**, **insert\\_recordset**, **RecordInsertList**, and **update\\_recordset** statements perform operations on multiple records at the same time.\n\n## select statements\nThe **select** statement fetches or manipulates data from the database. All **select** statements use a table variable to fetch records. This variable must be declared before a **select** statement can be run. The **select** statement fetches only one record, or field. To fetch additional records, you can use the **next** statement. The **next** statement fetches the next record in the table. If no **select** statement precedes the **next** statement, an error occurs. If you use a **next** statement, don't use the **firstOnly** find option. If you must traverse several records, it's more appropriate to use a **while** **select** statement. The results of a **select** statement are returned in a table buffer variable. If you use a field list in the **select** statement, only those fields are available in the table variable. If you use aggregate functions, such as **sum** or **count**, the results are returned in the fields that you perform the **sum** or **count** over. You can count, average, or sum only integer and real fields.\n\n## Syntax of select statements\n|                   |     |                                                                                                                                                                                                                                                                                                    |\n|-------------------|-----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| *SelectStatement* | =   | **select** *Parameters*                                                                                                                                                                                                                                                                            |\n| *Parameters*      |     | **\\[ \\[** *FindOptions* **\\]** **\\[** *FieldList* **from \\] \\]** *TableBufferVariable* **\\[** *IndexClause* **\\]** **\\[** *Options* **\\]** **\\[** *WhereClause* **\\]** **\\[** *JoinClause* **\\]**                                                                                                  |\n| *FindOptions*     | =   | **crossCompany** | **reverse** | **firstFast** | \\[ **firstOnly** | **firstOnly10** | **firstOnly100** | **firstOnly1000** \\] | **forUpdate** | **noFetch** | \\[**forcePlaceholders** | **forceLiterals**\\] | **forceselectorder** | **forceNestedLoop** | **repeatableRead** | **validTimeState** |\n| *FieldList*       | =   | *Field* **{ ,** *Field* **}** | **\\***                                                                                                                                                                                                                                                             |\n| *Field*           | =   | *Aggregate* **(** *FieldIdentifier* **) |** *FieldIdentifier*                                                                                                                                                                                                                                      |\n| *Aggregate*       | =   | **sum** | **avg** | **minof** | **maxof** | **count**                                                                                                                                                                                                                                              |\n| *Options*         | =   | **\\[ order by** , **group by ,** *FieldIdentifier* **\\[ asc** | **desc \\] { ,** *FieldIdentifier* **\\[ asc** | **desc \\] }\\]** | **\\[** *IndexClause* **\\]**                                                                                                                                       |\n| *IndexClause*     | =   | **index** *IndexName* | **index hint** *IndexName*                                                                                                                                                                                                                                                 |\n| *WhereClause*     | =   | **where** *Expression*                                                                                                                                                                                                                                                                             |\n| *JoinClause*      | =   | \\[**exists** | **notexists** | **outer** \\] **join** *Parameters*                                                                                                                                                                                                                                  |\n\n### Keywords that are used in select statements\n\n| Keyword           | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n|-------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| asc               | This keyword is an option on the **order by** or **group by** clause. It specifies an ascending sort. If neither **asc** nor **desc** is specified, the sort is ascending.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| avg               | This keyword returns the average of the fields.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| count             | This keyword returns the number of records.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| crossCompany      | This keyword returns data for all companies that the user is authorized to read from. You can add a container to reduce the number of companies that are involved.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n| desc              | This keyword is an option on the **order by** or **group by** clause. It specifies a descending sort. If neither **asc** nor **desc** is specified, the sort is ascending.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| exists            | This keyword is a method that returns a Boolean value and a **join** clause.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| firstFast         | This keyword is a priority hint. Although the first row appears more quickly, but the total return time for this option might be slower. The **firstFast** hint is automatically issued from all pages.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| firstOnly         | This keyword helps speed up the fetch by returning only the first row.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\n| firstOnly10       | This keyword is the same as **firstOnly**, but it returns 10 rows instead of one.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n| firstOnly100      | This keyword is the same as **firstOnly**, but it returns 100 rows instead of one.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n| firstOnly1000     | This keyword is the same as **firstOnly**, but it returns 1,000 rows instead of one.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| forceLiterals     | This keyword instructs the kernel to reveal the actual values that are used in **where** clauses to the Microsoft SQL Server database at the time of optimization. The **forceLiterals** and **forcePlaceholders** keywords are mutually exclusive. You should not to use the **forceLiterals** keyword in **select** statements, because it could expose code to an SQL injection security threat.                                                                                                                                                                                                                                                                                                                                                              |\n| forceNestedLoop   | This keyword forces the SQL Server database to use a nested-loop algorithm to process a particular SQL statement that contains a join algorithm. Therefore, a record from the first table is fetched before any records from the second table are fetched. Typically, other join algorithms, such as hash joins and merge joins, are considered. This keyword is often combined with the **forceSelectOrder** keyword.                                                                                                                                                                                                                                                                                                                                           |\n| forcePlaceholders | This keyword instructs the kernel *not* to reveal the actual values that are used in **where** clauses to the SQL Server database at the time of optimization. By default, this behavior is used in all statements that aren't **join** statements. The advantage of using this keyword is that the kernel can reuse the access plan for similar statements that have other search values. The disadvantage is that the access plan is computed, but the fact that data distribution might be uneven isn't considered. The access plan is an on-average access plan. The **forcePlaceholders** and **forceLiterals** keywords are mutually exclusive.                                                                                                            |\n| forceSelectOrder  | This keyword forces the SQL Server database to access the tables in a join in the specified order. If two tables are joined, the first table in the statement is always accessed first. This keyword is often combined with the **forceNestedLoop** keyword.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| forUpdate         | This keyword selects records for update only. Depending on the underlying database, the records might be locked for other users.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n| group by          | This keyword instructs the database to group selected records by fields.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| index             | This keyword instructs the database to sort the selected records in the manner that is defined by the index.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| index hint        | This keyword gives the database a hint to use this index to sort the selected records in the manner that is defined by the index. The database can ignore the hint. An incorrect index hint can greatly affect performance. Index hints should be applied only to SQL statements that don't have dynamic **where** clauses or **order by** clauses, and where the effect of the hint can be verified.                                                                                                                                                                                                                                                                                                                                                            |\n| join              | This keyword is used to join tables on a column that is shared by both tables. The join criteria are specified in a **where** clause, because there is no **on**. This keyword reduces the number of SQL statements that are required if you want to loop through a table and update transactions in a related table. For example, you process 500 records in a table and want to update related records in another table. If you use a nested **while select**, there will be 501 trips to the database. However, if you use a **join**, there will be just one trip to the database.                                                                                                                                                                           |\n| maxof             | This keyword returns the maximum of the fields.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| minof             | This keyword returns the minimum of the fields.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| noFetch           | This keyword indicates that no records should be fetched now. Typically, this keyword is used when the result of the **select** statement is passed on to another application object, such as a query that performs the actual fetch.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n| notExists         | This keyword is selected only if there are no posts.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| optimisticLock    | This keyword forces a statement to run by using optimistic concurrency control, even if a different value is set on the table.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| order by          | This keyword instructs the database to sort the selected records by the fields in the **order by** list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| outer             | This keyword returns all rows from the table that is named first, even if rows have no match in the table that is named second. This join is a left outer join, even though there is no **left**. There is no right outer join.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| pessimisticLock   | This keyword forces a statement to run by using pessimistic concurrency control, even if a different value is set on the table.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| repeatableRead    | This keyword specifies that the current transaction must be completed before other transactions can modify data that has been read by logic inside the current transaction. An explicit transaction is completed at either **ttsAbort** or the outermost **ttsCommit**. For a stand-alone **select** statement, the transaction duration is the duration of the **select** command. However, the database sometimes enforces the equivalent of **repeatableRead** in individual **select** statements, even if this keyword doesn't appear in your code. (The behavior depends on the method that the database uses to determine whether it should scan the tables.) For more information, see the documentation for the underlying relational database product. |\n| reverse           | Records are returned in reverse order.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\n| sum               | This keyword returns the sum of the fields. It can be used to sum all accounts, order lines, and so on.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| validTimeState    | This keyword filters rows from a table where the **ValidTimeStateFieldType** property is set to a value other than **None**.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n\n#### Keyword examples\n\n    // asc keyword example.\n    select * from custTable\n        order by Name asc;\n\n    // avg keyword example. \n    CustTable custTable;;\n    select avg(value) from custTable;\n    print custTable.value;\n\n    // count keyword example. \n    CustTable xCT;int64 iCountRows; ;\n    Select COUNT(RecID) from xCT;\n    iCountRows = xCT.RecID;\n\n    // crossCompany keyword example.\n    CustTable custTable;\n    container conCompanies = ['dat','dmo'];\n    select crossCompany :conCompanies\n        * from custTable;\n\n    // desc keyword example.\n    select * from custTable\n        order by Name desc;\n\n    // exists keyword example. \n    while select AccountNum, Name from custTable\n        order by AccountNum\n        exists join * from ctr\n        where (ctr.AccountNum ==\n            custTable.AccountNum)\n\n    // firstFast keyword example.\n    select firstFast custTable\n        order by AccountNum;\n\n    // firstOnly keyword example.\n    static InventTable find(ItemIditemId, boolean update = false)\n    {\n        InventTable inventTable;\n        inventTable.selectForUpdate(update);\n        if (itemId)\n        {\n            select firstonly inventTable\n                index hint ItemIdx\n                where inventTable.itemId == itemId;\n        }\n        return inventTable;\n    }\n\n    // forceNestedLoop keyword example.\n    while select forceSelectOrder\n        forceNestedLoop inventTransThis\n    index hint TransIdIdx\n    where inventTransThis.InventTransId\n        == inventTrans.InventTransId\n        && inventTransThis.StatusIssue\n        <= StatusIssue::ReservOrdered\n\n    // forcePlaceholders keyword example.\n    static void forcePlaceHoldersExample(Args _args){\n        SalesTable salesTable;\n        SalesLine salesLine;\n        while select forcePlaceholders salesLine\n            join salesTable\n                where salesTable.SalesId ==\n                    salesLine.SalesId\n                    && salesTable.SalesId == '10'\n        {\n            //more code\n        }\n    }\n\n    // forceSelectOrder keyword example.\n    display ForecastHasPurch hasForecastPurch(){\n        ForecastPurch forecastPurch;\n        InventDim nventDim;\n    select firstOnly forcePlaceholders\n        forceSelectOrder recId\n        from forecastPurch\n        index hint ItemIdx\n        where forecastPurch.itemId == this.itemId\n    exists join inventDim\n        index hint DimIdIdx\n        where inventDim.inventDimId == forecastPurch.inventDimId\n            && inventDim.configId == this.configId;\n        return forecastPurch.recId;\n    }\n\n    // forUpdate keyword example.\n    ttsBegin; while select forUpdate ledgerJournalTrans\n        index hint NumVoucherIdx\n        where ledgerJournalTrans.journalNum ==\n        _journalNum &&\n        ledgerJournalTrans.voucher == _voucher\n    {\n        ledgerJournalTrans.doDelete();\n        counter++;\n    }\n    if (counter\n        && ledgerJournalTable.journalType\n        != LedgerJournalType::Periodic)\n    {\n        NumberSeq::release(\n            ledgerJournalTable.voucherSeries,\n            _voucher);\n    }\n    ttsCommit;\n\n    // group by keyword example.\n    CustTable custTable;;\n    while select sum(CreditMax) from custTable\n        group by CustGroup\n    {\n        print custTable.CustGroup, \" \",custTable.CreditMax;\n    }\n\n    // index keyword example.\n    CustTable custTable;;\n    while select AccountNum, Name from custTable\n        index AccountIdx\n    {\n        print custTable.AccountNum, \" \", custTable.Name;\n    }\n\n    // index hint keyword example.\n    while select forUpdate ledgerJournalTrans\n        index hint NumVoucherIdx\n        where ledgerJournalTrans.journalNum\n            == _journalNum\n\n    // join keyword example.\n    while select ledgerTable\n        join ledgerTrans\n        where ledgerTrans.accountNum == ledgerTable.accountNum\n    {\n        amountMST += ledgerTrans.amountMST;\n    }\n\n    // maxof keyword example.\n    CustTable custTable;;\n    select maxof(CreditMax) from custTable;\n\n    // minof keyword example.\n    CustTable custTable;;\n    select minof(CreditMax) from custTable;\n\n    // noFetch keyword example.\n    select noFetch custTable\n        order by AccountNum\n\n    // notExists keyword example.\n    while select AccountNum, Name from custTable\n        order by AccountNum\n        notExists join * from ctr\n        where (ctr.AccountNum ==\n            custTable.AccountNum)\n\n    // optimisticLock keyword example.\n    select optimisticLock custTable\n        where custTable.AccountNum > '1000'\n\n    // order by keyword example.\n    select * from custTable\n        order by accountNum desc\n        where custTable.AccountNum > \"100\";\n\n    // outer keyword example.\n    while select AccountNum\n        from custTable\n        order by AccountNum\n        outer join * from custBankAccount\n        where custBankAccount.AccountNum ==\n            custTable.AccountNum\n    {\n        print custTable.AccountNum,\n        \" , \", custBankAccount.DlvMode;\n    } \n\n    // pessimisticLock keyword example.\n    select pessimisticLock custTable\n        where custTable.AccountNum > '1000';\n\n    // reverse keyword example.\n    select reverse custTable\n        order by AccountNum;\n\n    // sum keyword example.\n    CustTable custTable;;\n    select sum(CreditMax) from custTable;\n\n    // validTimeState keyword example.\n    static void VtsJob1(Args _args)\n    {\n        // A validTimeState table.\n        CustPackingSlipTransHistory xrec1;\n        utcDateTime myDateFrom , myDateTo;\n        anytype myAnytype = -1;\n        myDateFrom = DateTimeUtil::utcNow();\n        myDateTo = myDateFrom;\n        SELECT\n            validTimeState(myDateFrom, myDateTo)\n                *\n                FROM xrec1;\n        myAnytype = xrec1.getFieldValue(\"RecId\");\n        info(myAnytype);\n    }\n\n## select statement examples\nThe following examples show how you can use **select** statements.\n\n    CustTable custTable;\n    // A customer is found and returned in custTable\n    select * from custTable;\n    info(\"A: \" + custTable.AccountNum);\n\n    // A customer with account number > \"100\" is found\n    select * from custTable\n        where custTable.AccountNum > \"100\";\n    info(\"B: \" + custTable.AccountNum);\n\n    // Customer with the lowest account number > \"100\" found:\n    select *\n        from custTable \n        order by accountNum\n        where custTable.AccountNum > \"100\";\n    info(\"C1: \" + custTable.AccountNum);\n\n    // The next customer is read\n    next custTable;\n    info(\"C2: \" + custTable.AccountNum);\n\n    // Customer with highest account number\n    // (greater than 100) found: Fourth Coffee\n    select *\n        from custTable \n        order by accountNum desc\n        where custTable.accountNum > \"100\";\n    info(\"D1: \" + custTable.AccountNum);\n\n    // The next record is read (DESC): Fabrikam, Inc.\n    next custTable;\n    info(\"D2: \" + custTable.AccountNum);\n\n    // Customer with highest account number found: Fourth Coffee\n    select reverse custTable\n        order by accountNum;\n    info(\"E: \" + custTable.AccountNum);\n\n    // Customer with \"lowest\" name and account number\n    // in the interval 100 to 1000 is found. This is Coho Winery.\n    select *\n        from custTable\n        order by DlvMode\n        where custTable.accountNum > \"100\"\n            && custTable.accountNum < \"1000\";\n    info(\"F: \" + custTable.AccountNum);\n\n    // The count select returns the number of customers.\n    select count(AccountNum)\n        from custTable;\n\n    // Prints the result of the count\n    info(strFmt(\"G: %1 = Count of AccountNums\", custTable.accountNum));\n\n    // Returns the average credit max for non-blocked customers.\n    select avg(CreditMax)\n        from custTable\n        where custTable.blocked == CustVendorBlocked::No;\n\n    // Prints the result of the avg\n    info(strFmt(\"H: %1 = Average CreditMax\", custTable.CreditMax));\n\n    /*** Display from infolog:\n    Message (02:00:34 pm)\n    A: 4000\n    B: 4000\n    C1: 4000\n    C2: 4001\n    D1: 4507\n    D2: 4506\n    E: 4507\n    F: \n    G: 29 = Count of AccountNums\n    H: 103.45 = Average CreditMax\n    ***/\n\n### join example\n\nThe following example shows how an inner join can be performed as part of an SQL **select** statement. The example also shows an **order by** clause, where each field is qualified by a table name. Therefore, you can use just one **order by** clause to control how the retrieved records are sorted.\n\n    CustTable xrecCustTable;\n    CashDisc xrecCashDisc;\n    struct sut4;\n    sut4 = new struct(\"str AccountNum; str CashDisc; str Description\");\n    while select firstOnly10 *\n        from xrecCustTable\n        order by xrecCashDisc.Description\n        join xrecCashDisc\n        where xrecCustTable.CashDisc ==\n            xrecCashDisc.CashDiscCode\n            && xrecCashDisc.Description LIKE \"*Days*\"\n        {\n            sut4.value(\"AccountNum\", xrecCustTable.AccountNum );\n            sut4.value(\"CashDisc\", xrecCashDisc.CashDiscCode );\n            sut4.value(\"Description\", xrecCashDisc.Description );\n            info(sut4.toString());\n        }\n    /*********  Actual Infolog output\n    Message (02:29:37 pm)\n    (AccountNum:\"1101\"; CashDisc:\"0.5%D10\"; Description:\"0.5% 10 days\")\n    (AccountNum:\"4001\"; CashDisc:\"0.5%D10\"; Description:\"0.5% 10 days\")\n    (AccountNum:\"1102\"; CashDisc:\"0.5%D30\"; Description:\"0.5% 30 days\")\n    (AccountNum:\"1201\"; CashDisc:\"0.5%D30\"; Description:\"0.5% 30 days\")\n    (AccountNum:\"2211\"; CashDisc:\"0.5%D30\"; Description:\"0.5% 30 days\")\n    (AccountNum:\"1202\"; CashDisc:\"1%D15\"; Description:\"1% 15 days\")\n    (AccountNum:\"1203\"; CashDisc:\"1%D07\"; Description:\"1% 7 days\")\n    (AccountNum:\"2212\"; CashDisc:\"1%D07\"; Description:\"1% 7 days\")\n    (AccountNum:\"2213\"; CashDisc:\"1%D07\"; Description:\"1% 7 days\")\n    (AccountNum:\"2214\"; CashDisc:\"1%D07\"; Description:\"1% 7 days\")\n    *********/\n    }\n\n### group by and order by example\n\nThe following example shows that the fields in the **group by** clause can be qualified by a table name. There can be multiple **group by** clauses. However, the fields can be qualified by a table name in only one **group by** clause. We recommend that you use table name qualifiers. The **order by** clause follows the same syntax patterns as **group by**. Both clauses, if they are provided, must appear after the **join** (or **from**) clause, and both must appear before any **where** clause that exists on the same **join** clause. We recommend that all **group by**, **order by**, and **where** clauses appear immediately after the last **join** clause.\n\n    CustTable xrecCustTable;\n    CashDisc xrecCashDisc;\n    struct sut4;\n    sut4 = new struct(\"str AccountNum_Count; str CashDisc; str Description\");\n    while select count(AccountNum)\n        from xrecCustTable\n        order by xrecCashDisc.Description\n        join xrecCashDisc\n            group by xrecCashDisc.CashDiscCode\n                where xrecCustTable.CashDisc ==\n                    xrecCashDisc.CashDiscCode\n                    && xrecCashDisc.Description LIKE \"*Days*\"\n        {\n            sut4.value(\"AccountNum_Count\", xrecCustTable.AccountNum );\n            sut4.value(\"CashDisc\", xrecCashDisc.CashDiscCode );\n            sut4.value(\"Description\", xrecCashDisc.Description );\n            info(sut4.toString());\n        }\n    /*********  Actual Infolog output\n    Message (02:45:26 pm)\n    (AccountNum_Count:\"2\"; CashDisc:\"0.5%D10\"; Description:\"\")\n    (AccountNum_Count:\"3\"; CashDisc:\"0.5%D30\"; Description:\"\")\n    (AccountNum_Count:\"4\"; CashDisc:\"1%D07\"; Description:\"\")\n    (AccountNum_Count:\"1\"; CashDisc:\"1%D15\"; Description:\"\")\n    (AccountNum_Count:\"1\"; CashDisc:\"2%D30\"; Description:\"\")\n    (AccountNum_Count:\"1\"; CashDisc:\"3%D10\"; Description:\"\")\n    *********/\n    }\n\n### select statement that has an outer join\n\nThe **select** statement supports filtering an outer join in the **where** clause. In the **join** clause of standard SQL, there is an **on** keyword for filter criteria. However, this keyword isn't supported in X++. An inner join rejects all table rows that don't match a row in the other joined table. However, an outer join includes rows from the first table, even if there is no matching row in the other joined table. Default values are substituted for the data that couldn't be obtained from a matching row in the other joined table. You can filter an outer join at the equivalent of an **on** clause that is part of the **join** clause. For an inner join, the behavior if you filter on an **on** clause is the same as the behavior if you filter on the **where** clause.\n\n#### select statement example\n\nThe following example is based on two tables. The field types and example data are included. There is a one-to-many relationship between the SalesOrder parent table and the SalesOrderLine child table. For each row in the SalesOrder table, there are 0 (zero) or more rows in the SalesOrderLine table. There are two rows in the SalesOrder table.\n\n| SalesOrderID (integer, primary key) | DateAdded (date) |\n|-------------------------------------|------------------|\n| 1                                   | 2010-01-01       |\n| 2                                   | 2010-02-02       |\n\nThe SalesOrderLine table contains a foreign key field that is named **SalesOrderID**. This field references the primary key column of the SalesOrder table. A **SalesOrderID** value of **2** doesn't occur in the data for the SalesOrderLine table.\n\n| SalesOrderLineID (string, primary key) | Quantity (integer) | SalesOrderID (integer, foreign key) |\n|----------------------------------------|--------------------|-------------------------------------|\n| AA                                     | 32                 | 1                                   |\n| BB                                     | 67                 | 1                                   |\n| CC                                     | 66                 | 1                                   |\n\nThe following code has a **select** statement that reads the two tables. The **select** statement includes a left **outer join** clause. Both the join criteria and the data filter are on the **where** clause. The output from the code is also shown. The second record in the output has a **SalesOrderID** value of **2**. However, that value isn't present in the SalesOrderLine table. Therefore, some of the fields in the second record have default values: **0** for an integer and a zero-length string for a string.\n\n    static void SelectOuterJoinExample(Args _args)\n    {\n        SalesOrder recSalesOrder;\n        SalesOrderLine recSalesOrderLine;\n        struct struct4;\n\n        struct4 = new struct\n            (\"int SalesOrderID;\"\n            + \"date DateAdded;\"\n            + \"str SalesOrderLineID;\"\n            + \"int Quantity\"\n            );\n        while\n        select\n            *\n            from\n                recSalesOrder\n                OUTER JOIN recSalesOrderLine\n            where\n                recSalesOrder.SalesOrderID == recSalesOrderLine.SalesOrderID\n                && recSalesOrderLine.Quantity == 66\n        {\n            struct4.value(\"SalesOrderID\", recSalesOrder.SalesOrderID);\n            struct4.value(\"DateAdded\", recSalesOrder.DateAdded);\n            struct4.value(\"SalesOrderLineID\", recSalesOrderLine.SalesOrderLineID);\n            struct4.value(\"Quantity\", recSalesOrderLine.Quantity);\n            info(struct4.toString());\n        }\n    }\n    /*********  Actual Infolog output (with break spaces entered in between each output)\n    (SalesOrderID:1;\n    DateAdded:2010/1/1;\n    SalesOrderLineID:\"CC\";\n    Quantity:66)\n    (SalesOrderID:2;\n    DateAdded:2010/2/2;\n    SalesOrderLineID:\"\";\n    Quantity:0)\n    *********/\n\n## while select statements\nA **while select** statement is used to handle data. It's the most widely used form of the **select** statement. The **while select** statement loops over many records that meet specific criteria, and can run a statement on each record. Typically, when you use the **while select** statement for data manipulation, you do it in a transaction to ensure data integrity. The results of a **while select** statement are returned in a table buffer variable. If you use a field list in the **select** statement, only those fields are available in the table variable. If you use aggregate functions, such as **sum** or **count**, the results are returned in the fields that you perform the **sum** or **count** over. You can count, average, or sum only integer and real fields. The syntax of a **while select** statement resembles the syntax of a **select** statement, but the statement is preceded by **while select** instead of **select**. The **select** statement itself is run only one time, immediately before the first iteration of the statements in the loop. Any Boolean expressions (such as **iCounter &lt; 1**) that are added to the **while select** are tested only one time. This behavior differs from the behavior of the **while** statement in languages such as C++ and C\\#. For example, the following loop can have more than one iteration.\n\n    static void JobWhileSelect(Args _args)\n    {\n        int iCounter = 0;\n        BankAccountTable xrecBAT;\n        while select * from xrecBAT\n            where iCounter < 1\n        {\n            iCounter++;\n            Global::info(strFmt(\"%1 , %2\", iCounter, xrecBAT.AccountID));\n        }\n    }\n     \n    /*** Display from infolog:\n    Message (04:59:38 pm)\n    1 , Cash1\n    2 , STB-DKK\n    3 , STB-EUR\n    ***/\n\n### while select example\n\nThe following example prints the name reference and telephone number of every customer in the CustTable table whose account number is within a specified range.\n\n    static void JobPrintTel(Args _args)\n    {\n        CustTable xrecCT;\n        while select xrecCT\n            order by xrecCT.AccountNum\n                where  xrecCT.AccountNum >= \"4010\"\n                    && xrecCT.AccountNum <= \"4100\"\n        {\n            Global::info(strFmt(\"%1 , %2\",\n                xrecCT.AccountNum, xrecCT.SalesGroup));\n        }\n    }\n\n    /*** Display from Infolog:\n    Message (06:04:03 pm)\n    4010 , CSG-EU\n    4011 , CSG-EU\n    4012 , CSG-OTH\n    4013 , CSG-OTH\n    4014 , CSG-OTH\n    4015 , CSG-OTH\n    4016 , CSG-EU\n    4017 , CSG-EU\n    4018 , CSG-EU\n    4020 , \n    4024 , \n    ***/\n\n### while select example\n\nThe following example uses the **forUpdate** keyword.\n\n    static void LedgerJob(Args _args)\n    {\n        LedgerJournalTrans ledgerJournalTrans;\n        LedgerJournalTable ledgerJournalTable;\n        LedgerJournalId    jnJournalNum;\n        Voucher            vVoucher;\n        Counter            counter = 0;\n        jnJournalNum = \"999999_999\"; //\"000012_003\";\n        vVoucher = \"88888_888\"; //\"00001_IRG\";\n        ledgerJournalTable =\n            ledgerJournalTable::find(jnJournalNum);\n        ttsBegin;\n        while select forUpdate ledgerJournalTrans\n            index hint NumVoucherIdx\n                where ledgerJournalTrans.journalNum == jnJournalNum\n                    && ledgerJournalTrans.voucher == vVoucher\n        {\n            ledgerJournalTrans.doDelete();\n            counter++;\n        }\n        //NumberSeq updates needed?\n        ttsCommit;\n        Global::info(strFmt(\"counter = %1\", counter));\n    }\n\n### Deleting a set of records\n\nYou can use a **while select** statement to loop over a set of records that meet some criteria, and perform an action on each record. In the following example, the statement is used to delete a set of records.\n\n    TableName myXrec;\n    while select myXrec where conditions // conditions is a Boolean variable defined elsewhere.\n    {\n        myXrec.delete();\n    }\n\nYou can achieve the same effect by using the **delete\\_from** keyword.\n\n    TableName myXrec;\n    delete_from myXrec where conditions; // conditions is a Boolean variable defined elsewhere.\n\n### select statements on fields\n\nYou can use a **select** statement in a lookup on a field. After a **select** statement that fetches a record in a table, you can enter **.fieldName** to reference a field in the table. These **select** statements must be used in expressions. A *normal **select** statement* differs from a *field **select** statement*:\n\n-   The field **select** statement operates directly on a table.\n-   The normal **select** statement operates on a table buffer variable.\n\n### select field example\n\n    void selectFieldExamples ()\n    {\n        // Prints the NameRef field from the selected customer\n        print (select CustTable order by AccountStatement).AccountStatement;\n\n        // Uses the balance field from the customer with AccountNum 3000\n        if ((select custTable where CustTable.AccountNum == '3000').CreditMax < 50000)\n            print \"This customer has a credit maximum less than $50,000.\";\n    }\n\n### Aggregate functions: Differences between X++ and SQL\n\nIn industry-standard SQL, a database query can contain *aggregate functions*. Examples include **count(RecID)** and **sum(columnA)**. When an aggregate function is used, but no rows match the **where** clause, a row must be returned to hold the result of the aggregates. The row that is returned shows the value **0** (zero) for the **count** function and **null** for the **sum** function. X++ doesn't support the concept of **null** values for the database. Therefore, in cases where the **sum** function will return **null**, no row is returned to the user. Additionally, every data type has a specific value that is treated as a **null** value in some circumstances.\n\n### index and order by keywords in select statements\n\nYou use the **order by** keyword in **select** statements to order the data that is returned. Use the **index hint** keyword to specify the index that should be used in the query and to sort the selected records in the manner that is defined by the index. Indexes optimize the selection of records. To select records in a specific order, combine the **index hint** keyword with an **order by** expression. If you want the output to be sorted in reverse order, use the **reverse** keyword. If a table index has been disabled (that is, if the index's **Enabled** property is set to **No**), the **select** statement that references the index is still valid. However, the database can't use the index as a hint to sort the data, because the index doesn't exist in the database. The following table shows how to use the **index hint** and **order by** keywords in **select** statements.\n\n| Task                                                                                 | Use                                             |\n|--------------------------------------------------------------------------------------|-------------------------------------------------|\n| Select records when the order isn't significant.                                     | select .. where ...                             |\n| Select records when the order is significant.                                        | select .. order by ... where ...                |\n| Select records, and force a specific index to be used.                               | select .. index hint ... where ...              |\n| Select records when the order is significant, and force a specific index to be used. | select .. index hint ... order by ... where ... |\n\n### index and order by example\n\nThe following example shows how to select transactions from the SalesTable table, based on a range of customers and due dates.\n\n    SalesTable salesTable;\n        select salesTable\n        index hint CustIdx\n        order by CustAccount\n        where salesTable.CustAccount >= '3000'\n            && salesTable.CustAccount <= '4000'\n            && salesTable.FixedDueDate >= 12\\12\\2004\n            && salesTable.FixedDueDate <= 05\\05\\2009;\n\n### index hint\n\nBefore you can use **index hint** in queries, you must specify that hints can be used on the server.\n\n1.  Go to **Start** &gt; **Administrative Tools** &gt; **Microsoft Dynamics AX Server Configuration**.\n2.  On the **Database Tuning** tab, select **Allow INDEX hints in queries**, and then click **OK**.\n3.  When a message box prompts you to restart the Application Object Server (AOS) service, click **Yes**. Index hints won't be enabled until the service is restarted.\n\nWhen an **index hint** in a **select** statement refers to a non-clustered index, and the **where** clause contains only the fields that are found in a clustered index on the same table, the clustered index is used instead of the index that is specified in the hint. For example, you run **sp\\_helpindex InventTable** in SQL Server Management Studio and you see that the InventTable table has a clustered index on the **DataAreaId** and **ItemId** columns, and a non-clustered index on the **DataAreaId**, **ItemProductId**, and **ItemType** columns.\n\n| Index name       | Description                                        | Key columns                         |\n|------------------|----------------------------------------------------|-------------------------------------|\n| I\\_175ITEMIDX    | Clustered, unique, primary key, located on PRIMARY | DATAAREAID, ITEMID                  |\n| I\\_175PRODUCTIDX | Non-clustered, located on PRIMARY                  | DATAAREAID, ITEMPRODUCTID, ITEMTYPE |\n\nIn the following code, the clustered index is used instead of the non-clustered index that is specified by **index hint**.\n\n    static void IndexHint(Args _args)\n    {\n        InventTable inv;\n        select * from inv index hint GroupItemIdx\n            where inv.ItemId == 'B-R14';\n    }\n\n### Writing a select statement as an expression\n\nYou can use a **select** statement as an expression. This type of **select** statement is known as an *expression **select** statement*. A table buffer variable can't be used in an expression **select** statement. The name of the table must be used in the **from** clause. One limitation of expression **select** statements is that the **join** keyword isn't supported in an expression join.\n\n### expression select examples\n\nIn the following example, the **select** statement inside the parentheses returns one row. The only column that can be populated with data is the column that is named before the **from** clause in the **select** clause. After the closing parenthesis, the name of that column is used to reference the data value: **).AccountNum;**. This example returns a maximum of one row, because it uses the **firstonly** keyword. However, the value that is assigned to **sAccountNum** is the same, even if the **firstonly** keyword is omitted. The **where** clause in this example serves no purpose except to show that the **where** clause must occur after the **order by** clause. The table name can't be used to qualify a field name in the **order by** clause.\n\n    int64 nRecId, nCount;\n    str sAccountNum, sName;\n    sAccountNum = (select firstonly AccountNum from CustTable\n        order by AccountNum desc\n        where 0 == 0 // 'where' must occur after 'order by'. )\n        .AccountNum;\n    info(strFmt(\"Test_1.a: %1\", sAccountNum));\n\nHere is a simpler way to achieve the same result as the previous example.\n\n    /********* Actual Infolog output\n     Test_1.a: 4507Test_1.b: 4507\n     *********/\n\n    int64 nRecId, nCount;\n    str sAccountNum, sName;\n    sAccountNum = (select maxof(AccountNum) from CustTable).AccountNum;\n    info(strFmt(\"Test_1.b: %1\", sAccountNum));\n\nThe following example includes a **where** clause. In a **where** clause, the table name must be used as a qualifier of the field. Here, the **maxof** aggregate function is used, and the **RecId** field is mentioned in the function. The field that is mentioned in the aggregate function must be the same as the field name that is used to reference the data value after the closing parenthesis. Otherwise, empty data is returned.\n\n    int64 nRecId, nCount;\n    str sAccountNum, sName;\n    nRecId = (select maxof(RecId) from CustTable\n        where CustTable.Blocked == CustVendorBlocked::No)\n        .RecId;\n    info(strFmt(\"Test_2.c: %1\", nRecId));\n\n    /********* Actual Infolog output\n    Test_2.c: 5637144604\n    *********/\n\nIn the following example, a field name (in this case, **RecId**) is used to reference a data value that isn't a **RecId** value. The **count** aggregate function doesn't return a **RecId** value. Typically, the **RecId** field is used with the **count** function.\n\n    int64 nRecId, nCount;\n    str sAccountNum, sName;\n    nRecId = (select count(RecId) from CustTable\n        where CustTable.Blocked == CustVendorBlocked::No)\n        .RecId;\n    info(strFmt(\"Test_2.d: %1\", nRecId));\n\n    /********* Actual Infolog output\n    Test_2.d: 29\n    *********/\n\nThe **join** keyword isn't supported in expression **select** statements. The following example shows a subselect. However, expression select **statements** don't support subselects that are equivalent to a standard inner join. Therefore, the following example doesn't compile, because it mentions two tables inside one expression **select** statement (that is, inside the subselect). As this example shows, subselects are supported, but only in a limited manner.\n\n    // This job does not compile.\n    static void BadJob(Args _args)\n    {\n        sName = (select Name from AssetTable\n            where AssetTable.AssetId ==\n                // Here starts the subselect.\n                (select AssetId from AssetTrans\n                    where AssetTrans.AssetId ==\n                        AssetTable.AssetId // Compiler rejects this line.\n                ).AssetId).Name;\n        info(strFmt(\"Test_3: %1\", sName));\n    }\n\n    /********* Actual Infolog output\n    Test_3: CNC-Metal shade\n    *********/\n\n## update method\nThe **update** table method updates the current record with the contents of the buffer. It also updates the appropriate system fields. The **where** clause is optional. When it's used, the **where** clause specifies a condition that **update** tests as it processes each row of the table. Only those rows that test **true** against the condition are updated with the new values. The **update\\_recordset** operator is a record set–based operator that updates multiple records at the same time. To override the behavior of **update**, use the **doUpdate** method. The following example selects the custTable table for update. Any records where the value of the **AccountNum** field is equal to **4000** are updated. (In this case, only one record is updated.) The value of the **CreditMax** field is changed to **5000**.\n\n    CustTable custTable;\n    ttsBegin;\n        select forUpdate custTable\n        where custTable.AccountNum == '4000';\n        custTable.CreditMax = 5000;\n        custTable.update();\n    ttsCommit;\n\n## doUpdate method\nThe **doUpdate** method updates the current record with the contents of the buffer. This method also updates the appropriate system fields. You should use the **doUpdate** method when the **update** method on the table must be bypassed. The syntax for a **doUpdate** table method is **void doUpdate()**. In the following example, the value of the **CreditMax** field is increased by 1,000.\n\n    static void Job1(Args _args)\n    {\n        CustTable custTable;\n        ttsBegin;\n        select forUpdate custTable\n        where custTable.CreditMax == 3000;\n        if (custTable)\n        {\n            custTable.CreditMax += 1000;\n            custTable.doUpdate();\n        }\n        ttsCommit;\n    }\n\n## delete method\nThe **delete** table method deletes the current record from the database. To use this method, use a **where** clause to specify the rows to delete. One record at a time is then removed from the specified table. The **delete\\_from** operator is a record set–based operator that removes multiple records at the same time. The **delete** method can be overridden. For example, you might want to add extra validation before records are deleted. If you override the **delete** method, you can run the original (base) version of the **delete** method by calling the **doDelete** method. Therefore, a call to the **doDelete** method is equivalent to a call to **super()** in the **delete** method. In the following example, all records in the MyTable table that satisfy the criterion in the **where** clause (that is, all records where the value of the **AccountNum** field is equal to **1000**) are deleted from the database. One record is deleted at a time.\n\n    ttsBegin;\n    while select forUpdate myTable\n        where myTable.AccountNum == '1000'\n    {\n        myTable.delete();\n    }\n    ttsCommit;\n\n## doDelete method\nLike the **delete** table method, the **doDelete** table method deletes the current record from the database. Use the **doDelete** method if the **delete** table method has been overridden, and you want to run the original (base) version of the **delete** method instead of the overridden version. Therefore, a call to the **doDelete** method is equivalent to a call to **super()** in the **delete** method. The following example deletes all records in the myTable table that have an account number that is more than or equal to **200**.\n\n    ttsBegin;\n    while select forUpdate myTable\n        where myTable.AccountNum >='200';\n    {\n        myTable.doDelete();\n    }\n    ttsCommit;\n\n## insert method\nThe **insert** method updates one record at a time. To insert multiple records at a time, use array inserts, **insert\\_recordset**, or **RecordSortedList.insertDatabase**. To override the behavior of the **insert** method, use the **doInsert** method. The **xRecord .insert** method generates values for the **RecId** field and system fields, and then inserts the contents of the buffer into the database. Here is how the **insert** method works:\n\n-   Only the specified columns of the rows that have been selected by the query are inserted into the named table.\n-   The columns of the table that is copied from and the columns of the table that is copied to must be type-compatible.\n-   If the columns of both tables match in type and order, column list can be omitted from the **insert** clause.\n\n### insert example: Inserting a new record\n\nThe following example inserts a new record into the CustTable table. The **AccountNum** field of the new record is set to **5000**, and the **Name** field is set to **MyCompany**. (Other fields in the record will be blank.)\n\n    CustTable custTable;\n    ttsBegin;\n    select forUpdate custTable;\n    custTable.AccountNum = '5000';\n    custTable.insert();\n    ttsCommit;\n\n### insert example: Transaction and duplicate key\n\nThe following example shows how you can catch a **DuplicateKeyException** exception in the context of an explicit transaction. The exception is thrown when a call to **xRecord .insert** fails because an existing unique value is duplicated. In the **catch** block, your code can either take corrective action or log the error for later analysis. Your code can then continue without losing all the pending work of the transaction. You can't catch a duplicate key exception that is caused by a set-based operation such as **insert\\_recordset**. This example depends on two tables: TableNumberA and TableNumberB. Both tables have one mandatory integer field. These fields are named **NumberAKey** and **NumberBKey**, respectively. A unique index is defined on each key field. The TableNumberA table must have at least one record in it.\n\n    static void JobDuplicKeyException44Job(Args _args)\n    {\n        TableNumberA tabNumA; // Has one record, key = 11.\n        TableNumberB tabNumB;\n        int iCountTries = 0, iNumberAdjust = 0, iNewKey, ii;\n        container ctNotes;\n        // Empty the B table.\n        delete_from tabNumB;\n        // Insert a copy of one record.\n        insert_recordset tabNumB (NumberBKey)\n        select firstOnly NumberAKey from tabNumA order by NumberAKey asc;\n        ttsBegin;\n        try\n        {\n            iCountTries++;\n            ctNotes += strFmt(\"---- Inside the try block, try count is %1. ----\", iCountTries);\n            while select * from tabNumA order by NumberAKey asc\n            {\n                tabNumB .clear();\n                iNewKey = tabNumA .NumberAKey + iNumberAdjust;\n                tabNumB .NumberBKey = iNewKey;\n                ctNotes += strFmT (\"-- %1 is the key to be tried. --\" ,iNewKey);\n                tabNumB .insert();\n                ctNotes += \"-- .insert() successful. --\";\n                break; // Keeps demo simple.\n            }\n            ttsCommit;\n        }\n        catch (Exception ::DuplicateKeyException, tabNumB) // Table is optional.\n        {\n            ctNotes += \"---- Inside the catch block. ----\";\n            ctNotes += infolog .text();\n            if (iCountTries <= 1)\n            {\n                ctNotes += \"-- Will issue retry. --\";\n                iNumberAdjust = 1;\n                retry; // Erases Infolog.\n            }\n            else\n            {\n                ctNotes += \"-- Aborting the transaction. --\";\n                ttsAbort;\n            }\n        }\n        for (ii=1; ii <= conLen(ctNotes); ii++)\n        {\n            info(conPeek(ctNotes ,ii));\n        }\n    }\n\n    /*********Actual Infolog output\n            Message (10:53:13 am)\n        ---- Inside the try block, try count is 1. ----\n        -- 11 is the key to be tried. --\n        ---- Inside the catch block. ----\n        Cannot create a record in TableNumberB (TableNumberB).\n        The record already exists.\n        -- Will issue retry. --\n        ---- Inside the try block, try count is 2. ----\n        -- 12 is the key to be tried. --\n        -- .insert() successful. --\n    *********/\n\n## doInsert method\nThe **doInsert** method generates values for the **RecId** field and other system fields, and then inserts the contents of the buffer into the database. Use this method when the **insert** method on the table must be bypassed. In the following example, a new record is inserted. The **name** field of the record is set to **Warren Langer**, and the **value** field is set to **100**.\n\n    ttsBegin;\n    myTable.name = 'Warren Langer';\n    myTable.value = 100;\n    myTable.doInsert();\n    ttsCommit;\n\n## Transactional integrity\nIf steps aren't taken to help guarantee the integrity of transactions, data corruption could occur. At the very least, you might experience poor scalability with respect to concurrent users on the system. Two internal checking features help guarantee the integrity of transactions: the **forUpdate** check and the **tssLevel** check. A **forUpdate** check helps guarantee that a record can be updated or deleted only if it has first been selected for update. You can select a record for update by using either the **forUpdate** keyword in the **select** statement or the **selectForUpdate** method on tables. A **ttsLevel** check helps guarantee that a record can be updated or deleted only within the same transaction scope where it was selected for update. The following statements are used to help guarantee integrity:\n\n-   **ttsBegin** – This statement marks the beginning of a transaction. It helps guarantee data integrity, and also helps guarantees that all updates that are done until the transaction ends (through **ttsCommit** or **ttsAbort**) are consistent (all or none).\n-   **ttsCommit** – This statement marks the successful end of a transaction. It ends and commits a transaction. Microsoft Dynamics 365 for Operations helps guarantee that a transaction that has been committed will be performed according to intentions.\n-   **ttsAbort** – This statement lets you explicitly discard all changes in the current transaction. In this case, the database is rolled back to the original state where nothing has been changed. Typically, you use this statement if you've detected that the user wants to break the current job. The **ttsAbort** statement helps guarantee that the database is consistent.\n\nUsually, it's a better idea to use exception handling instead of **ttsAbort**. The **throw** statement automatically aborts the current transaction. As the following example shows, statements between **ttsBegin** and **ttsCommit** can include one or more transaction blocks. In these cases, nothing is actually committed until the successful exit from the final **ttsCommit** statement.\n\n    ttsBegin;\n        // Some statements.\n    ttsBegin;\n        // More statements.\n    ttsCommit;\n    ttsCommit;\n\nThe following example selects a set of records and updates the **NameAlias** field.\n\n    Custtable custTable;\n    ttsBegin;\n    select forUpdate custTable where custTable.AccountNum == '4000';\n    custTable.NameAlias = custTable.Name;\n    custTable.update();\n    ttsCommit;\n\n### Example of code that is rejected by the two transaction integrity checks\n\nIn this example, the first failure occurs because the **forupdate** keyword is missing. The second failure occurs because the transaction scope of the update differs from the transaction scope where the record was selected for update in **ttsCommit**.\n\n    ttsBegin;\n    select myTable; // Rejected by the forUpdate check.\n    mytable.myField = 'xyz';\n    myTable.update();\n    ttsCommit;\n    ttsBegin;\n    select forUpdate * from myTable;\n    myTable.myField = 'xyz';\n    ttsCommit;\n    ...\n    ttsBegin;\n    myTable.update(); // Rejected by the ttsLevel check.\n    ttsCommit;\n\n## Speeding up SQL operations\nThe following constructs let you insert, update, or delete multiple records. By using these constructs, you reduce communication between the application and the database, and therefore help increase performance. In some situations, record set–based operations can fall back to record-by-record operations.\n\n| Construct         | Description                                                                                                                                                                                                      |\n|-------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| RecordSortedList  | Insert multiple records in one database trip. Use this construct when you want a subset of data from a specific table, and you want that data to be sorted in an order that doesn't currently exist as an index. |\n| RecordInsertList  | Insert multiple records in one database trip. Use this construct when you don't have to sort the data.                                                                                                           |\n| insert\\_recordset | Copy multiple records directly from one or more tables into another table in one database trip.                                                                                                                  |\n| update\\_recordset | Update multiple rows in a table in one database trip.                                                                                                                                                            |\n| delete\\_from      | Delete multiple records from the database in one database trip.                                                                                                                                                  |\n\n## insert\\_recordset\nThe **insert\\_recordset** statement copies data directly from one or more source tables into one destination table in one server trip. It's faster to use **insert\\_recordset** than an array insert. However, array inserts are more flexible if you want to handle the data before you insert it. **insert\\_recordset** is a record set–based operator that performs operations on multiple records at a time. However, it can fall back to record-by-record operations in many situations.\n\n### insert\\_recordset syntax\n\n*ListOfFields* in the destination table must match the list of fields in the source tables. Data is transferred in the order in which it appears in the list of fields. Fields in the destination table that aren't present in the list of fields are assigned **0** (zero) values, as in other areas. System fields, such as **RecId**, are assigned transparently by the kernel in the destination table. **insert\\_recordset** *DestinationTable* **(** *ListOfFields* **)** **select** *ListOfFields1* **from** *SourceTable* **\\[ where** *WhereClause* **\\]** **\\[ join** *ListOfFields2* **from** *JoinedSourceTable* **\\[ where** *JoinedWhereClause* **\\]\\]**\n\n### Example: Inserting data from another table\n\nIn this example, the **myNum** and **mySum** records are retrieved from the anotherTable table and inserted into the myTable table. The records are grouped according to **myNum**, and only **myNum** records that have a value that is less than or equal to **100** are included in the insertion.\n\n    insert_recordset myTable (myNum, mySum)\n        select myNum, sum(myValue)\n            from anotherTable\n            group by myNum\n            where myNum <= 100;\n\n### Example: Inserting data from variables\n\nThe following example shows that the **insert\\_recordset** statement can insert data that is provided in variables. In this example, the **firstonly** keyword is used so that only one row is inserted. Literals, such as **128** or **\"this literal string\"**, can't be used as a source of data that is inserted.\n\n    static void InsertVariable3Job(Args _args)\n    {\n        TableAlphabet    tabA2;\n        BankAccountTable tabB3;\n        str  1 sLetter = \"a\";\n        str 16 sExampleWord = \"apple\";\n        DELETE_FROM tabA2;\n        INSERT_RECORDSET tabA2\n            (Letter ,ExampleWord)\n        select firstonly\n            sLetter ,sExampleWord // Variables.\n        from tabB3;\n        WHILE SELECT * from tabA2\n        {\n            info(tabA2 .Letter + \" , \" + tabA2 .ExampleWord);\n        }\n\n    /***********  Actual Infolog output\n    Message (04:03:52 pm)\n    a , apple\n    ***********/\n    }\n\n### Example: Inserting data by using a join\n\nThe following example shows a join of three tables on an **insert\\_recordset** statement that has a subselect. It also shows a **while** **select** statement that has a similar join. A variable is used to supply the inserted value for one column. The **str** variable must be declared, and must have a length that is less than or equal to the maximum length of the corresponding database field. In this example, there is an **insert\\_recordset** statement for the tabEmplProj5 table. One of the target fields is named **Description**, and the field's data comes from the local variable **sDescriptionVariable**. The **insert\\_recordset** statement succeeds even when the configuration key for the **Description** field is turned off. The system ignores both the **Description** field and the **sDescriptionVariable** variable. Therefore, this code provides an example of *configuration key automation*. Configuration key automation occurs when the system can automatically adjust the behavior of an **insert\\_recordset** statement that inserts data into fields that the configuration key is turned off for.\n\n    static void InsertJoin42Job(Args _args)\n    {\n        GmTabDepartment tabDept2;\n        GmTabEmployee tabEmpl3;\n        GmTabProject tabProj4;\n        GmTabEmployeeProject tabEmplProj5;\n        str 64 sDescriptionVariable = \"From variable.\";\n        DELETE_FROM tabEmplProj5;\n        INSERT_RECORDSET tabEmplProj5\n            (\n            Description\n            , EmployeeRecId\n            , ProjectRecId\n            )\n        Select\n            sDescriptionVariable\n            , RecId\n        from\n            tabEmpl3\n            join\n                tabDept2\n                where tabEmpl3 .DepartmentGuid == tabDept2 .DepartmentGuid\n            join RecId\n                from tabProj4\n                where tabDept2 .DepartmentGuid == tabProj4 .DepartmentGuid\n        info(int642str(tabEmplProj5 .rowCount())\n            + \" ==Number of rows inserted.\");\n        WHILE SELECT *\n            from\n                tabEmplProj5\n                join tabEmpl3\n                    where tabEmplProj5 .EmployeeRecId == tabEmpl3 .RecId\n                join tabProj4\n                    where tabEmplProj5 .ProjectRecId == tabProj4 .RecId\n        {\n            info(\n                tabEmpl3 .EmployeeName\n                + \"  --works on--  \"\n                + tabProj4 .ProjectName\n                + \" (\" + tabEmplProj5 .Description + \").\"\n                );\n        }\n\n    /*****************  Actual Infolog output\n    Message (01:05:41 pm)\n    4 ==Number of rows inserted.\n    Alice  --works on--  Project ZZZ (From variable.).\n    Alice  --works on--  Project YY (From variable.).\n    Beth  --works on--  Project ZZZ (From variable.).\n    Beth  --works on--  Project YY (From variable.).\n    *****************/\n    }\n\n## update\\_recordset\nThe **update\\_recordset** statement lets you update multiple rows in one trip to the server. Therefore, the power of SQL Server can help improve the performance of some tasks. The ****update\\_recordset**** statement resembles **delete\\_from** in X++ and **update set** in SQL. It doesn't retrieve each record separately by fetching, changing, and updating, Instead, it works on an SQL-style record set on the database server side. If the **update** method is overridden, the implementation falls back to a classic looping construction, where one record at a time is updated. (This behavior resembles the behavior of **delete\\_from** for deletions.) Therefore, the construction works on temporary tables and whole table–cached tables by using the looping construction.\n\n### Example: Update that is based on a calculated value\n\nThe following example updates the myTableBuffer table and increments the value of the **field1** field by ten percent in all records in the table.\n\n    MyTable myTableBuffer;\n    update_recordset myTableBuffer\n    setting field1 = field1 * 1.10;\n\n### Example: Update that uses a where clause\n\nThe following example updates all records in the myTable table where the **field1** field has the value **0**. The **field1** field is assigned a new value of **1**. The **field2** field is assigned a value that is the sum of **fieldX** and **fieldY**. This example updates multiple fields at the same time, and it updates only those rows that satisfy the **where** clause.\n\n    MyTable myTableBuffer;\n    update_recordset myTableBuffer\n    setting\n        field1 = 1,\n        field2 = fieldX + fieldY\n    where field1 == 0;\n\n### Example: Updating joined tables\n\nThe following example shows that the **update\\_recordset** statement supports joins of several tables. Data from the joined tables can be used to assign values to fields in the table that is being updated.\n\n    static void Join22aJob(Args _args)\n    {\n        TableEmployee tabEmpl;\n        TableDepartment tabDept;\n        TableProject tabProj;\n        update_recordset tabEmpl\n        setting\n            currentStatusDescription = tabDept .DeptName\n                + \", \" + tabProj .ProjName\n        join tabDept\n            where tabDept .DeptId == tabEmpl .DeptId\n        join tabProj\n            where tabProj .ProjId == tabEmpl .ProjId;\n        info(strFmt(\"Number of records updated is %1.\"\n            ,tabEmpl .rowCount()));\n    }\n\n## delete\\_from\nYou can delete multiple records from a database table by using a **delete\\_from** statement. This approach can be more efficient and faster than an approach that uses the **xRecord .delete** method in a loop to delete one record at a time. If you've overridden the **delete** method, the system interprets the **delete\\_from** statement into code that calls the **delete** method one time for each row that is deleted.\n\n### Example: Efficiently deleting records by using delete\\_from\n\nThe following example shows an efficient way to delete multiple records.\n\n    static void DeleteMultiRow1aJob(Args _args)\n    {\n        MyWidgetTable tabWidget;\n        delete_from tabWidget\n            where tabWidget .quantity <= 100;\n    }\n\n#### Example: Inefficiently deleting records by using forUpdate\n\nThe following example is inefficient. It issues a separate SQL **delete** call to the database server for every record. The **xRecord** **.delete** method never deletes more than one record per call.\n\n    static void DeleteMultiRow1bJob(Args _args)\n    {\n        MyWidgetTable tabWidget; // extends xRecord.\n        ttsBegin;\n        while select\n            forUpdated\n            tabWidget\n            where tabWidget .quantity <= 100\n        {\n            tabWidget .delete();\n        }\n        ttsCommit;\n    }\n\n### Example: A delete operation that has an inner join\n\nInner joins aren't supported on the **delete\\_from** statement. Therefore, you can't use the unmodified **join** keyword on the **delete\\_from** statement. However, you can logically accomplish an inner join by using other techniques. The following example shows the new and old techniques for achieving inner join logic through a sequence of statements.\n\n    // This is the new and recommended way of using the delete_from method and inner joins.\n    // The following code example is relatively efficient. It issues a\n    // separate delete_from statement for each loop iteration. However, each\n    // delete_from statement can delete multiple records, a subset of all the\n    // records that the job deletes.\n    static void DeleteInnerJoin2bJob(Args _args)\n    {\n        MyWidgetTable tabWidget; // extends xRecord.\n        ttsBegin;\n        while select\n            from tabGalaxy\n                where tabGalaxy .isTrusted == 0\n        {\n            delete_from tabWidget\n                where tabWidget .GalaxyRecId ==\n                    tabGalaxy .RecId;\n        }\n        ttsCommit;\n    }\n\n    // This is the old way of using the delete method and inner joins.\n    // The following delete method is inefficient. It issues a\n    // separate SQL delete call to the database server for each record.\n    static void DeleteInnerJoin2aJob(Args _args)\n    {\n        MyWidgetTable tabWidget; // extends xRecord.\n        ttsBegin;\n        while select\n            forUpdate\n            tabWidget\n            join tabGalaxy\n                where\n                    tabWidget .GalaxyRecId == tabGalaxy .RecId\n                    && tabGalaxy .isTrusted == 0\n        {\n            tabWidget .delete();\n        }\n        ttsCommit;\n    }\n\n### Example: A delete operation that uses the notexists join keyword\n\nYou can use the **notexists join** keyword pair in a **delete\\_from** statement. The **delete\\_from** statements in the following example are efficient. The **notexists join** clause enables the **delete\\_from** statement to delete a specific set of rows. In this example, the **delete\\_from** statement removes all parent-order header rows that there are no child-order line rows for. You can also use the **exists join** clause on the **delete\\_from** statement.\n\n    static void DeleteFromNotexists3bJob(Args _args)\n    {\n        GmTabOrderHeader tabOHeader;\n        GmTabOrderLine tabOLine;\n        AddressState tabAddressState;\n        str 127 sOH_Info;\n        str 127 sOL_Data;\n        int64 i64OHRecId;\n        delete_from tabOLine;\n        delete_from tabOHeader;\n        // Inserts into parent table.\n        sOH_Info = \"Albert needs tires.\";\n        insert_recordset tabOHeader\n            (OH_Info)\n            select firstOnly sOH_Info from tabAddressState;\n        sOH_Info = \"Benson wants plastic.\";\n        insert_recordset tabOHeader\n            (OH_Info)\n            select firstOnly sOH_Info from tabAddressState;\n        // Obtain a OrderHeader RecId,\n        // use it to insert one child row.\n        sOL_Data = \"4 re-treads.\";\n        while select firstOnly tabOHeader\n            order by OH_Info\n            where tabOHeader .OH_Info like \"A*\"\n        {\n            i64OHRecId = tabOHeader .RecId;\n            insert_recordset tabOLine\n                (OL_Data ,OrderHeaderRecId)\n                select firstOnly\n                    sOL_Data ,i64OHRecId\n                    from tabAddressState;\n            break;\n        }\n        // Before the delete notexists.\n        // Display all parent, and then all child rows.\n        while select tabOHeader\n            order by OH_Info\n        {\n            info(strFmt(\n                \"Before: OHeader:  OH_Info==%1 , RecId==%2\"\n                ,tabOHeader .OH_Info ,tabOHeader .RecId\n                ));\n        }\n        while select tabOLine\n            order by OL_Data\n        {\n            info(strFmt(\n                \"Before: OLine:  OL_Data==%1 , OrderHeaderRecId==%2\"\n                ,tabOLine .OL_Data ,tabOLine .OrderHeaderRecId\n                ));\n        }\n        // Delete_From NotExists Join, to remove from the\n        // parent table all order headers without children.\n        delete_from tabOHeader\n            notexists join tabOLine\n                where tabOHeader .RecId ==\n                    tabOLine .OrderHeaderRecId;\n        info(strFmt\n            (\"%1 is the number of childless OHeader records deleted.\"\n            ,tabOHeader.rowCount()));\n        // After the delete notexists.\n        // Display all parent, and then all child rows.\n        info(\"- - - - - - - - - - - - - - -\");\n        while select tabOHeader\n            order by OH_Info\n        {\n            info(strFmt(\n                \"After: OHeader:  OH_Info==%1 , RecId==%2\"\n                ,tabOHeader .OH_Info ,tabOHeader .RecId\n                ));\n        }\n        while select tabOLine\n            order by OL_Data\n        {\n            info(strFmt(\n                \"After: OLine:  OL_Data==%1 , OrderHeaderRecId==%2\"\n                ,tabOLine .OL_Data ,tabOLine .OrderHeaderRecId\n                ));\n        }\n\n    /**************  Actual Infolog output\n    Message (12:54:14 pm)\n    Before: OHeader:  OH_Info==Albert needs tires. , RecId==5637144608\n    Before: OHeader:  OH_Info==Benson wants plastic. , RecId==5637144609\n    Before: OLine:  OL_Data==4 re-treads. , OrderHeaderRecId==5637144608\n    1 is the number of childless OHeader records deleted.\n    - - - - - - - - - - - - - - -\n    After: OHeader:  OH_Info==Albert needs tires. , RecId==5637144608\n    After: OLine:  OL_Data==4 re-treads. , OrderHeaderRecId==5637144608\n    **************/\n    }\n\n## Maintain fast SQL operations\nThere are situations where record set–based operations can be converted to slower record-by-record operations. The following table identifies these situations.\n\n| Situation                                                                    | DELETE\\_FROM | UPDATE\\_RECORDSET | INSERT\\_RECORDSET | ARRAY\\_INSERT | Use this setting for overrides |\n|------------------------------------------------------------------------------|--------------|-------------------|-------------------|---------------|--------------------------------|\n| Non-SQL tables                                                               | Yes          | Yes               | Yes               | Yes           | Not applicable                 |\n| Delete actions                                                               | Yes          | No                | No                | No            | **skipDeleteActions**          |\n| The database log is enabled.                                                 | Yes          | Yes               | Yes               | No            | **skipDatabaseLog**            |\n| Overridden method                                                            | Yes          | Yes               | Yes               | Yes           | **skipDataMethods**            |\n| Alerts are set up for the table.                                             | Yes          | Yes               | Yes               | No            | **skipEvents**                 |\n| The **ValidTimeStateFieldType** property on a table isn't equal to **None**. | Yes          | Yes               | Yes               | Yes           | Not applicable                 |\n\nYou can use the settings that are shown in the last column to explicitly skip or ignore one or more factors that adversely affect performance. If, for some reason, one of the previously mentioned SQL operations is downgraded to a record-by-record operation, all the **skip\\*** settings are also ignored. For example, in the following code, the **insert** method on the myTable table is run, even though it's explicitly stated that this method should be skipped if a container or memo field is defined for myTable.\n\n    public void tutorialRecordInsertList()\n    {\n        MyTable myTable;\n        RecordInsertList insertList = new RecordInsertList(\n            myTable.TableId,\n            True);\n        int i;\n        for ( i = 1; i <=  100; i++ )\n        {\n            myTable.value = i;\n            insertList.add(myTable);\n        }\n        insertList.insertDatabase();\n    }\n\n\n\n","nodes":[{"pos":[4,658],"content":"# required metadata\n\ntitle: X++ data selection and manipulation\ndescription: This topic describes the support for data selection and manipulation in the X++ language.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 04/21/2017\nms.topic: article\nms.prod: \nms.service: Dynamics365Operations\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: annbe\nms.search.scope: AX 7.0.0, Operations\n# ms.tgt_pltfrm: \nms.custom: 150273\nms.assetid: 999a5ecf-559b-4d66-8b05-9a8e477e0518\nms.search.region: Global\n# ms.search.industry: \nms.author: robinr\nms.dyn365.ops.intro: AX 7.0.0\nms.search.validFrom: 2016-02-28\n","nodes":[{"content":"X++ data selection and manipulation","nodes":[{"pos":[0,35],"content":"X++ data selection and manipulation","nodes":[{"content":"X++ data selection and manipulation","pos":[0,35]}]}],"path":["title"]},{"content":"This topic describes the support for data selection and manipulation in the X++ language.","nodes":[{"pos":[0,89],"content":"This topic describes the support for data selection and manipulation in the X++ language.","nodes":[{"content":"This topic describes the support for data selection and manipulation in the X++ language.","pos":[0,89]}]}],"path":["description"]}],"header":"# required metadata\n","yml":true},{"pos":[666,701],"content":"X++ data selection and manipulation","linkify":"X++ data selection and manipulation","nodes":[{"content":"X++ data selection and manipulation","pos":[0,35]}]},{"content":"This topic describes the support for data selection and manipulation in the X++ language.","pos":[747,836]},{"content":"You can use SQL statements, either interactively or within source code, to access and retrieve data that is stored in the database.","pos":[838,969]},{"content":"You use the following statements for data manipulation:","pos":[970,1025]},{"pos":[1031,1070],"content":"<bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> – Select the data to modify.","source":"**select** – Select the data to modify."},{"pos":[1075,1127],"content":"<bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept> – Add one or more new records to a table.","source":"**insert** – Add one or more new records to a table."},{"pos":[1132,1183],"content":"<bpt id=\"p1\">**</bpt>update<ept id=\"p1\">**</ept> – Modify data in existing table records.","source":"**update** – Modify data in existing table records."},{"pos":[1188,1238],"content":"<bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> – Remove existing records from a table.","source":"**delete** – Remove existing records from a table."},{"content":"Before any data can be changed, you must use a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement to select the data to update.","pos":[1240,1337],"source":"Before any data can be changed, you must use a **select** statement to select the data to update."},{"content":"The <bpt id=\"p1\">**</bpt>select forUpdate<ept id=\"p1\">**</ept> command selects records for update only.","pos":[1338,1403],"source":" The **select forUpdate** command selects records for update only."},{"content":"The <bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>update<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>delete<ept id=\"p3\">**</ept> statements perform operations on one record at a time.","pos":[1404,1501],"source":" The **insert**, **update**, and **delete** statements perform operations on one record at a time."},{"content":"The <bpt id=\"p1\">**</bpt>array insert<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>RecordInsertList<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>update<ph id=\"ph2\">\\_</ph>recordset<ept id=\"p4\">**</ept> statements perform operations on multiple records at the same time.","pos":[1502,1662],"source":" The **array insert**, **insert\\_recordset**, **RecordInsertList**, and **update\\_recordset** statements perform operations on multiple records at the same time."},{"pos":[1667,1684],"content":"select statements","linkify":"select statements","nodes":[{"content":"select statements","pos":[0,17]}]},{"content":"The <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement fetches or manipulates data from the database.","pos":[1685,1756],"source":"The **select** statement fetches or manipulates data from the database."},{"content":"All <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statements use a table variable to fetch records.","pos":[1757,1821],"source":" All **select** statements use a table variable to fetch records."},{"content":"This variable must be declared before a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement can be run.","pos":[1822,1894],"source":" This variable must be declared before a **select** statement can be run."},{"content":"The <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement fetches only one record, or field.","pos":[1895,1954],"source":" The **select** statement fetches only one record, or field."},{"content":"To fetch additional records, you can use the <bpt id=\"p1\">**</bpt>next<ept id=\"p1\">**</ept> statement.","pos":[1955,2019],"source":" To fetch additional records, you can use the **next** statement."},{"content":"The <bpt id=\"p1\">**</bpt>next<ept id=\"p1\">**</ept> statement fetches the next record in the table.","pos":[2020,2080],"source":" The **next** statement fetches the next record in the table."},{"content":"If no <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement precedes the <bpt id=\"p2\">**</bpt>next<ept id=\"p2\">**</ept> statement, an error occurs.","pos":[2081,2157],"source":" If no **select** statement precedes the **next** statement, an error occurs."},{"content":"If you use a <bpt id=\"p1\">**</bpt>next<ept id=\"p1\">**</ept> statement, don't use the <bpt id=\"p2\">**</bpt>firstOnly<ept id=\"p2\">**</ept> find option.","pos":[2158,2231],"source":" If you use a **next** statement, don't use the **firstOnly** find option."},{"content":"If you must traverse several records, it's more appropriate to use a <bpt id=\"p1\">**</bpt>while<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement.","pos":[2232,2332],"source":" If you must traverse several records, it's more appropriate to use a **while** **select** statement."},{"content":"The results of a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement are returned in a table buffer variable.","pos":[2333,2411],"source":" The results of a **select** statement are returned in a table buffer variable."},{"content":"If you use a field list in the <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement, only those fields are available in the table variable.","pos":[2412,2519],"source":" If you use a field list in the **select** statement, only those fields are available in the table variable."},{"content":"If you use aggregate functions, such as <bpt id=\"p1\">**</bpt>sum<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>count<ept id=\"p2\">**</ept>, the results are returned in the fields that you perform the <bpt id=\"p3\">**</bpt>sum<ept id=\"p3\">**</ept> or <bpt id=\"p4\">**</bpt>count<ept id=\"p4\">**</ept> over.","pos":[2520,2668],"source":" If you use aggregate functions, such as **sum** or **count**, the results are returned in the fields that you perform the **sum** or **count** over."},{"content":"You can count, average, or sum only integer and real fields.","pos":[2669,2729]},{"pos":[2734,2761],"content":"Syntax of select statements","linkify":"Syntax of select statements","nodes":[{"content":"Syntax of select statements","pos":[0,27]}]},{"pos":[3406,3423],"content":"<bpt id=\"p1\">*</bpt>SelectStatement<ept id=\"p1\">*</ept>","source":"*SelectStatement*"},{"pos":[3432,3455],"content":"<bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>Parameters<ept id=\"p2\">*</ept>","source":"**select** *Parameters*"},{"pos":[3727,3739],"content":"<bpt id=\"p1\">*</bpt>Parameters<ept id=\"p1\">*</ept>","source":"*Parameters*"},{"pos":[3753,3946],"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\[</ph> <ph id=\"ph2\">\\[</ph><ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>FindOptions<ept id=\"p2\">*</ept> <bpt id=\"p3\">**</bpt><ph id=\"ph3\">\\]</ph><ept id=\"p3\">**</ept> <bpt id=\"p4\">**</bpt><ph id=\"ph4\">\\[</ph><ept id=\"p4\">**</ept> <bpt id=\"p5\">*</bpt>FieldList<ept id=\"p5\">*</ept> <bpt id=\"p6\">**</bpt>from <ph id=\"ph5\">\\]</ph> <ph id=\"ph6\">\\]</ph><ept id=\"p6\">**</ept> <bpt id=\"p7\">*</bpt>TableBufferVariable<ept id=\"p7\">*</ept> <bpt id=\"p8\">**</bpt><ph id=\"ph7\">\\[</ph><ept id=\"p8\">**</ept> <bpt id=\"p9\">*</bpt>IndexClause<ept id=\"p9\">*</ept> <bpt id=\"p10\">**</bpt><ph id=\"ph8\">\\]</ph><ept id=\"p10\">**</ept> <bpt id=\"p11\">**</bpt><ph id=\"ph9\">\\[</ph><ept id=\"p11\">**</ept> <bpt id=\"p12\">*</bpt>Options<ept id=\"p12\">*</ept> <bpt id=\"p13\">**</bpt><ph id=\"ph10\">\\]</ph><ept id=\"p13\">**</ept> <bpt id=\"p14\">**</bpt><ph id=\"ph11\">\\[</ph><ept id=\"p14\">**</ept> <bpt id=\"p15\">*</bpt>WhereClause<ept id=\"p15\">*</ept> <bpt id=\"p16\">**</bpt><ph id=\"ph12\">\\]</ph><ept id=\"p16\">**</ept> <bpt id=\"p17\">**</bpt><ph id=\"ph13\">\\[</ph><ept id=\"p17\">**</ept> <bpt id=\"p18\">*</bpt>JoinClause<ept id=\"p18\">*</ept> <bpt id=\"p19\">**</bpt><ph id=\"ph14\">\\]</ph><ept id=\"p19\">**</ept>","source":"**\\[ \\[** *FindOptions* **\\]** **\\[** *FieldList* **from \\] \\]** *TableBufferVariable* **\\[** *IndexClause* **\\]** **\\[** *Options* **\\]** **\\[** *WhereClause* **\\]** **\\[** *JoinClause* **\\]**"},{"pos":[4048,4061],"content":"<bpt id=\"p1\">*</bpt>FindOptions<ept id=\"p1\">*</ept>","source":"*FindOptions*"},{"pos":[4074,4090],"content":"<bpt id=\"p1\">**</bpt>crossCompany<ept id=\"p1\">**</ept>","source":"**crossCompany**"},{"pos":[4093,4104],"content":"<bpt id=\"p1\">**</bpt>reverse<ept id=\"p1\">**</ept>","source":"**reverse**"},{"pos":[4107,4120],"content":"<bpt id=\"p1\">**</bpt>firstFast<ept id=\"p1\">**</ept>","source":"**firstFast**"},{"pos":[4123,4139],"content":"<ph id=\"ph1\">\\[</ph> <bpt id=\"p1\">**</bpt>firstOnly<ept id=\"p1\">**</ept>","source":"\\[ **firstOnly**"},{"pos":[4142,4157],"content":"<bpt id=\"p1\">**</bpt>firstOnly10<ept id=\"p1\">**</ept>","source":"**firstOnly10**"},{"pos":[4160,4176],"content":"<bpt id=\"p1\">**</bpt>firstOnly100<ept id=\"p1\">**</ept>","source":"**firstOnly100**"},{"pos":[4179,4199],"content":"<bpt id=\"p1\">**</bpt>firstOnly1000<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\]</ph>","source":"**firstOnly1000** \\]"},{"pos":[4202,4215],"content":"<bpt id=\"p1\">**</bpt>forUpdate<ept id=\"p1\">**</ept>","source":"**forUpdate**"},{"pos":[4218,4229],"content":"<bpt id=\"p1\">**</bpt>noFetch<ept id=\"p1\">**</ept>","source":"**noFetch**"},{"pos":[4232,4255],"content":"<ph id=\"ph1\">\\[</ph><bpt id=\"p1\">**</bpt>forcePlaceholders<ept id=\"p1\">**</ept>","source":"\\[**forcePlaceholders**"},{"pos":[4258,4277],"content":"<bpt id=\"p1\">**</bpt>forceLiterals<ept id=\"p1\">**</ept><ph id=\"ph1\">\\]</ph>","source":"**forceLiterals**\\]"},{"pos":[4280,4300],"content":"<bpt id=\"p1\">**</bpt>forceselectorder<ept id=\"p1\">**</ept>","source":"**forceselectorder**"},{"pos":[4303,4322],"content":"<bpt id=\"p1\">**</bpt>forceNestedLoop<ept id=\"p1\">**</ept>","source":"**forceNestedLoop**"},{"pos":[4325,4343],"content":"<bpt id=\"p1\">**</bpt>repeatableRead<ept id=\"p1\">**</ept>","source":"**repeatableRead**"},{"pos":[4346,4364],"content":"<bpt id=\"p1\">**</bpt>validTimeState<ept id=\"p1\">**</ept>","source":"**validTimeState**"},{"pos":[4369,4380],"content":"<bpt id=\"p1\">*</bpt>FieldList<ept id=\"p1\">*</ept>","source":"*FieldList*"},{"pos":[4395,4424],"content":"<bpt id=\"p1\">*</bpt>Field<ept id=\"p1\">*</ept> <bpt id=\"p2\">**</bpt>{ ,<ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>Field<ept id=\"p3\">*</ept> <bpt id=\"p4\">**</bpt>}<ept id=\"p4\">**</ept>","source":"*Field* **{ ,** *Field* **}**"},{"pos":[4690,4697],"content":"<bpt id=\"p1\">*</bpt>Field<ept id=\"p1\">*</ept>","source":"*Field*"},{"pos":[4716,4755],"content":"<bpt id=\"p1\">*</bpt>Aggregate<ept id=\"p1\">*</ept> <bpt id=\"p2\">**</bpt>(<ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>FieldIdentifier<ept id=\"p3\">*</ept> **)","source":"*Aggregate* **(** *FieldIdentifier* **)"},{"pos":[4757,4777],"content":"<ph id=\"ph1\">** </ph><bpt id=\"p1\">*</bpt>FieldIdentifier<ept id=\"p1\">*</ept>","source":"** *FieldIdentifier*"},{"pos":[5011,5022],"content":"<bpt id=\"p1\">*</bpt>Aggregate<ept id=\"p1\">*</ept>","source":"*Aggregate*"},{"pos":[5037,5044],"content":"<bpt id=\"p1\">**</bpt>sum<ept id=\"p1\">**</ept>","source":"**sum**"},{"pos":[5047,5054],"content":"<bpt id=\"p1\">**</bpt>avg<ept id=\"p1\">**</ept>","source":"**avg**"},{"pos":[5057,5066],"content":"<bpt id=\"p1\">**</bpt>minof<ept id=\"p1\">**</ept>","source":"**minof**"},{"pos":[5069,5078],"content":"<bpt id=\"p1\">**</bpt>maxof<ept id=\"p1\">**</ept>","source":"**maxof**"},{"pos":[5081,5090],"content":"<bpt id=\"p1\">**</bpt>count<ept id=\"p1\">**</ept>","source":"**count**"},{"pos":[5332,5341],"content":"<bpt id=\"p1\">*</bpt>Options<ept id=\"p1\">*</ept>","source":"*Options*"},{"pos":[5358,5419],"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\[</ph> order by<ept id=\"p1\">**</ept> , <bpt id=\"p2\">**</bpt>group by ,<ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>FieldIdentifier<ept id=\"p3\">*</ept> <bpt id=\"p4\">**</bpt><ph id=\"ph2\">\\[</ph> asc<ept id=\"p4\">**</ept>","source":"**\\[ order by** , **group by ,** *FieldIdentifier* **\\[ asc**"},{"pos":[5422,5466],"content":"<bpt id=\"p1\">**</bpt>desc <ph id=\"ph1\">\\]</ph> { ,<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>FieldIdentifier<ept id=\"p2\">*</ept> <bpt id=\"p3\">**</bpt><ph id=\"ph2\">\\[</ph> asc<ept id=\"p3\">**</ept>","source":"**desc \\] { ,** *FieldIdentifier* **\\[ asc**"},{"pos":[5469,5484],"content":"<bpt id=\"p1\">**</bpt>desc <ph id=\"ph1\">\\]</ph> }<ph id=\"ph2\">\\]</ph><ept id=\"p1\">**</ept>","source":"**desc \\] }\\]**"},{"pos":[5487,5514],"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\[</ph><ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>IndexClause<ept id=\"p2\">*</ept> <bpt id=\"p3\">**</bpt><ph id=\"ph2\">\\]</ph><ept id=\"p3\">**</ept>","source":"**\\[** *IndexClause* **\\]**"},{"pos":[5653,5666],"content":"<bpt id=\"p1\">*</bpt>IndexClause<ept id=\"p1\">*</ept>","source":"*IndexClause*"},{"pos":[5679,5700],"content":"<bpt id=\"p1\">**</bpt>index<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>IndexName<ept id=\"p2\">*</ept>","source":"**index** *IndexName*"},{"pos":[5703,5729],"content":"<bpt id=\"p1\">**</bpt>index hint<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>IndexName<ept id=\"p2\">*</ept>","source":"**index hint** *IndexName*"},{"pos":[5974,5987],"content":"<bpt id=\"p1\">*</bpt>WhereClause<ept id=\"p1\">*</ept>","source":"*WhereClause*"},{"pos":[6000,6022],"content":"<bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>Expression<ept id=\"p2\">*</ept>","source":"**where** *Expression*"},{"pos":[6295,6307],"content":"<bpt id=\"p1\">*</bpt>JoinClause<ept id=\"p1\">*</ept>","source":"*JoinClause*"},{"pos":[6321,6333],"content":"<ph id=\"ph1\">\\[</ph><bpt id=\"p1\">**</bpt>exists<ept id=\"p1\">**</ept>","source":"\\[**exists**"},{"pos":[6336,6349],"content":"<bpt id=\"p1\">**</bpt>notexists<ept id=\"p1\">**</ept>","source":"**notexists**"},{"pos":[6352,6386],"content":"<bpt id=\"p1\">**</bpt>outer<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\]</ph> <bpt id=\"p2\">**</bpt>join<ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>Parameters<ept id=\"p3\">*</ept>","source":"**outer** \\] **join** *Parameters*"},{"pos":[6619,6662],"content":"Keywords that are used in select statements","linkify":"Keywords that are used in select statements","nodes":[{"content":"Keywords that are used in select statements","pos":[0,43]}]},{"content":"Keyword","pos":[6666,6673]},{"content":"Description","pos":[6686,6697]},{"content":"asc","pos":[8188,8191]},{"content":"This keyword is an option on the <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>group by<ept id=\"p2\">**</ept> clause.","pos":[8208,8277],"source":"This keyword is an option on the **order by** or **group by** clause."},{"content":"It specifies an ascending sort.","pos":[8278,8309]},{"content":"If neither <bpt id=\"p1\">**</bpt>asc<ept id=\"p1\">**</ept> nor <bpt id=\"p2\">**</bpt>desc<ept id=\"p2\">**</ept> is specified, the sort is ascending.","pos":[8310,8378],"source":" If neither **asc** nor **desc** is specified, the sort is ascending."},{"content":"avg","pos":[8949,8952]},{"content":"This keyword returns the average of the fields.","pos":[8969,9016]},{"content":"count","pos":[9710,9715]},{"content":"This keyword returns the number of records.","pos":[9730,9773]},{"content":"crossCompany","pos":[10471,10483]},{"content":"This keyword returns data for all companies that the user is authorized to read from.","pos":[10491,10576]},{"content":"You can add a container to reduce the number of companies that are involved.","pos":[10577,10653]},{"content":"desc","pos":[11232,11236]},{"content":"This keyword is an option on the <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>group by<ept id=\"p2\">**</ept> clause.","pos":[11252,11321],"source":"This keyword is an option on the **order by** or **group by** clause."},{"content":"It specifies a descending sort.","pos":[11322,11353]},{"content":"If neither <bpt id=\"p1\">**</bpt>asc<ept id=\"p1\">**</ept> nor <bpt id=\"p2\">**</bpt>desc<ept id=\"p2\">**</ept> is specified, the sort is ascending.","pos":[11354,11422],"source":" If neither **asc** nor **desc** is specified, the sort is ascending."},{"content":"exists","pos":[11993,11999]},{"pos":[12013,12089],"content":"This keyword is a method that returns a Boolean value and a <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> clause.","source":"This keyword is a method that returns a Boolean value and a **join** clause."},{"content":"firstFast","pos":[12754,12763]},{"content":"This keyword is a priority hint.","pos":[12774,12806]},{"content":"Although the first row appears more quickly, but the total return time for this option might be slower.","pos":[12807,12910]},{"content":"The <bpt id=\"p1\">**</bpt>firstFast<ept id=\"p1\">**</ept> hint is automatically issued from all pages.","pos":[12911,12973],"source":" The **firstFast** hint is automatically issued from all pages."},{"content":"firstOnly","pos":[13515,13524]},{"content":"This keyword helps speed up the fetch by returning only the first row.","pos":[13535,13605]},{"content":"firstOnly10","pos":[14276,14287]},{"pos":[14296,14377],"content":"This keyword is the same as <bpt id=\"p1\">**</bpt>firstOnly<ept id=\"p1\">**</ept>, but it returns 10 rows instead of one.","source":"This keyword is the same as **firstOnly**, but it returns 10 rows instead of one."},{"content":"firstOnly100","pos":[15037,15049]},{"pos":[15057,15139],"content":"This keyword is the same as <bpt id=\"p1\">**</bpt>firstOnly<ept id=\"p1\">**</ept>, but it returns 100 rows instead of one.","source":"This keyword is the same as **firstOnly**, but it returns 100 rows instead of one."},{"content":"firstOnly1000","pos":[15798,15811]},{"pos":[15818,15902],"content":"This keyword is the same as <bpt id=\"p1\">**</bpt>firstOnly<ept id=\"p1\">**</ept>, but it returns 1,000 rows instead of one.","source":"This keyword is the same as **firstOnly**, but it returns 1,000 rows instead of one."},{"content":"forceLiterals","pos":[16559,16572]},{"content":"This keyword instructs the kernel to reveal the actual values that are used in <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clauses to the Microsoft SQL Server database at the time of optimization.","pos":[16579,16741],"source":"This keyword instructs the kernel to reveal the actual values that are used in **where** clauses to the Microsoft SQL Server database at the time of optimization."},{"content":"The <bpt id=\"p1\">**</bpt>forceLiterals<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>forcePlaceholders<ept id=\"p2\">**</ept> keywords are mutually exclusive.","pos":[16742,16822],"source":" The **forceLiterals** and **forcePlaceholders** keywords are mutually exclusive."},{"content":"You should not to use the <bpt id=\"p1\">**</bpt>forceLiterals<ept id=\"p1\">**</ept> keyword in <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statements, because it could expose code to an SQL injection security threat.","pos":[16823,16966],"source":" You should not to use the **forceLiterals** keyword in **select** statements, because it could expose code to an SQL injection security threat."},{"content":"forceNestedLoop","pos":[17320,17335]},{"content":"This keyword forces the SQL Server database to use a nested-loop algorithm to process a particular SQL statement that contains a join algorithm.","pos":[17340,17484]},{"content":"Therefore, a record from the first table is fetched before any records from the second table are fetched.","pos":[17485,17590]},{"content":"Typically, other join algorithms, such as hash joins and merge joins, are considered.","pos":[17591,17676]},{"content":"This keyword is often combined with the <bpt id=\"p1\">**</bpt>forceSelectOrder<ept id=\"p1\">**</ept> keyword.","pos":[17677,17746],"source":" This keyword is often combined with the **forceSelectOrder** keyword."},{"content":"forcePlaceholders","pos":[18081,18098]},{"content":"This keyword instructs the kernel <bpt id=\"p1\">*</bpt>not<ept id=\"p1\">*</ept> to reveal the actual values that are used in <bpt id=\"p2\">**</bpt>where<ept id=\"p2\">**</ept> clauses to the SQL Server database at the time of optimization.","pos":[18101,18259],"source":"This keyword instructs the kernel *not* to reveal the actual values that are used in **where** clauses to the SQL Server database at the time of optimization."},{"content":"By default, this behavior is used in all statements that aren't <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> statements.","pos":[18260,18344],"source":" By default, this behavior is used in all statements that aren't **join** statements."},{"content":"The advantage of using this keyword is that the kernel can reuse the access plan for similar statements that have other search values.","pos":[18345,18479]},{"content":"The disadvantage is that the access plan is computed, but the fact that data distribution might be uneven isn't considered.","pos":[18480,18603]},{"content":"The access plan is an on-average access plan.","pos":[18604,18649]},{"content":"The <bpt id=\"p1\">**</bpt>forcePlaceholders<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>forceLiterals<ept id=\"p2\">**</ept> keywords are mutually exclusive.","pos":[18650,18730],"source":" The **forcePlaceholders** and **forceLiterals** keywords are mutually exclusive."},{"content":"forceSelectOrder","pos":[18842,18858]},{"content":"This keyword forces the SQL Server database to access the tables in a join in the specified order.","pos":[18862,18960]},{"content":"If two tables are joined, the first table in the statement is always accessed first.","pos":[18961,19045]},{"content":"This keyword is often combined with the <bpt id=\"p1\">**</bpt>forceNestedLoop<ept id=\"p1\">**</ept> keyword.","pos":[19046,19114],"source":" This keyword is often combined with the **forceNestedLoop** keyword."},{"content":"forUpdate","pos":[19603,19612]},{"content":"This keyword selects records for update only.","pos":[19623,19668]},{"content":"Depending on the underlying database, the records might be locked for other users.","pos":[19669,19751]},{"content":"group by","pos":[20364,20372]},{"content":"This keyword instructs the database to group selected records by fields.","pos":[20384,20456]},{"content":"index","pos":[21125,21130]},{"content":"This keyword instructs the database to sort the selected records in the manner that is defined by the index.","pos":[21145,21253]},{"content":"index hint","pos":[21886,21896]},{"content":"This keyword gives the database a hint to use this index to sort the selected records in the manner that is defined by the index.","pos":[21906,22035]},{"content":"The database can ignore the hint.","pos":[22036,22069]},{"content":"An incorrect index hint can greatly affect performance.","pos":[22070,22125]},{"content":"Index hints should be applied only to SQL statements that don't have dynamic <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clauses or <bpt id=\"p2\">**</bpt>order by<ept id=\"p2\">**</ept> clauses, and where the effect of the hint can be verified.","pos":[22126,22295],"source":" Index hints should be applied only to SQL statements that don't have dynamic **where** clauses or **order by** clauses, and where the effect of the hint can be verified."},{"content":"join","pos":[22647,22651]},{"content":"This keyword is used to join tables on a column that is shared by both tables.","pos":[22667,22745]},{"content":"The join criteria are specified in a <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause, because there is no <bpt id=\"p2\">**</bpt>on<ept id=\"p2\">**</ept>.","pos":[22746,22828],"source":" The join criteria are specified in a **where** clause, because there is no **on**."},{"content":"This keyword reduces the number of SQL statements that are required if you want to loop through a table and update transactions in a related table.","pos":[22829,22976]},{"content":"For example, you process 500 records in a table and want to update related records in another table.","pos":[22977,23077]},{"content":"If you use a nested <bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept>, there will be 501 trips to the database.","pos":[23078,23156],"source":" If you use a nested **while select**, there will be 501 trips to the database."},{"content":"However, if you use a <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept>, there will be just one trip to the database.","pos":[23157,23233],"source":" However, if you use a **join**, there will be just one trip to the database."},{"content":"maxof","pos":[23408,23413]},{"content":"This keyword returns the maximum of the fields.","pos":[23428,23475]},{"content":"minof","pos":[24169,24174]},{"content":"This keyword returns the minimum of the fields.","pos":[24189,24236]},{"content":"noFetch","pos":[24930,24937]},{"content":"This keyword indicates that no records should be fetched now.","pos":[24950,25011]},{"content":"Typically, this keyword is used when the result of the <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement is passed on to another application object, such as a query that performs the actual fetch.","pos":[25012,25179],"source":" Typically, this keyword is used when the result of the **select** statement is passed on to another application object, such as a query that performs the actual fetch."},{"content":"notExists","pos":[25691,25700]},{"content":"This keyword is selected only if there are no posts.","pos":[25711,25763]},{"content":"optimisticLock","pos":[26452,26466]},{"content":"This keyword forces a statement to run by using optimistic concurrency control, even if a different value is set on the table.","pos":[26472,26598]},{"content":"order by","pos":[27213,27221]},{"pos":[27233,27337],"content":"This keyword instructs the database to sort the selected records by the fields in the <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> list.","source":"This keyword instructs the database to sort the selected records by the fields in the **order by** list."},{"content":"outer","pos":[27974,27979]},{"content":"This keyword returns all rows from the table that is named first, even if rows have no match in the table that is named second.","pos":[27994,28121]},{"content":"This join is a left outer join, even though there is no <bpt id=\"p1\">**</bpt>left<ept id=\"p1\">**</ept>.","pos":[28122,28187],"source":" This join is a left outer join, even though there is no **left**."},{"content":"There is no right outer join.","pos":[28188,28217]},{"content":"pessimisticLock","pos":[28735,28750]},{"content":"This keyword forces a statement to run by using pessimistic concurrency control, even if a different value is set on the table.","pos":[28755,28882]},{"content":"repeatableRead","pos":[29496,29510]},{"content":"This keyword specifies that the current transaction must be completed before other transactions can modify data that has been read by logic inside the current transaction.","pos":[29516,29687]},{"content":"An explicit transaction is completed at either <bpt id=\"p1\">**</bpt>ttsAbort<ept id=\"p1\">**</ept> or the outermost <bpt id=\"p2\">**</bpt>ttsCommit<ept id=\"p2\">**</ept>.","pos":[29688,29779],"source":" An explicit transaction is completed at either **ttsAbort** or the outermost **ttsCommit**."},{"content":"For a stand-alone <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement, the transaction duration is the duration of the <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> command.","pos":[29780,29887],"source":" For a stand-alone **select** statement, the transaction duration is the duration of the **select** command."},{"content":"However, the database sometimes enforces the equivalent of <bpt id=\"p1\">**</bpt>repeatableRead<ept id=\"p1\">**</ept> in individual <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statements, even if this keyword doesn't appear in your code.","pos":[29888,30052],"source":" However, the database sometimes enforces the equivalent of **repeatableRead** in individual **select** statements, even if this keyword doesn't appear in your code."},{"content":"(The behavior depends on the method that the database uses to determine whether it should scan the tables.) For more information, see the documentation for the underlying relational database product.","pos":[30053,30252]},{"content":"reverse","pos":[30257,30264]},{"content":"Records are returned in reverse order.","pos":[30277,30315]},{"content":"sum","pos":[31018,31021]},{"content":"This keyword returns the sum of the fields.","pos":[31038,31081]},{"content":"It can be used to sum all accounts, order lines, and so on.","pos":[31082,31141]},{"content":"validTimeState","pos":[31779,31793]},{"pos":[31799,31923],"content":"This keyword filters rows from a table where the <bpt id=\"p1\">**</bpt>ValidTimeStateFieldType<ept id=\"p1\">**</ept> property is set to a value other than <bpt id=\"p2\">**</bpt>None<ept id=\"p2\">**</ept>.","source":"This keyword filters rows from a table where the **ValidTimeStateFieldType** property is set to a value other than **None**."},{"pos":[32544,32560],"content":"Keyword examples","linkify":"Keyword examples","nodes":[{"content":"Keyword examples","pos":[0,16]}]},{"pos":[38326,38351],"content":"select statement examples","linkify":"select statement examples","nodes":[{"content":"select statement examples","pos":[0,25]}]},{"pos":[38352,38418],"content":"The following examples show how you can use <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statements.","source":"The following examples show how you can use **select** statements."},{"pos":[40616,40628],"content":"join example","linkify":"join example","nodes":[{"content":"join example","pos":[0,12]}]},{"content":"The following example shows how an inner join can be performed as part of an SQL <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement.","pos":[40630,40732],"source":"The following example shows how an inner join can be performed as part of an SQL **select** statement."},{"content":"The example also shows an <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> clause, where each field is qualified by a table name.","pos":[40733,40826],"source":" The example also shows an **order by** clause, where each field is qualified by a table name."},{"content":"Therefore, you can use just one <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> clause to control how the retrieved records are sorted.","pos":[40827,40927],"source":" Therefore, you can use just one **order by** clause to control how the retrieved records are sorted."},{"pos":[42368,42397],"content":"group by and order by example","linkify":"group by and order by example","nodes":[{"content":"group by and order by example","pos":[0,29]}]},{"content":"The following example shows that the fields in the <bpt id=\"p1\">**</bpt>group by<ept id=\"p1\">**</ept> clause can be qualified by a table name.","pos":[42399,42503],"source":"The following example shows that the fields in the **group by** clause can be qualified by a table name."},{"content":"There can be multiple <bpt id=\"p1\">**</bpt>group by<ept id=\"p1\">**</ept> clauses.","pos":[42504,42547],"source":" There can be multiple **group by** clauses."},{"content":"However, the fields can be qualified by a table name in only one <bpt id=\"p1\">**</bpt>group by<ept id=\"p1\">**</ept> clause.","pos":[42548,42633],"source":" However, the fields can be qualified by a table name in only one **group by** clause."},{"content":"We recommend that you use table name qualifiers.","pos":[42634,42682]},{"content":"The <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> clause follows the same syntax patterns as <bpt id=\"p2\">**</bpt>group by<ept id=\"p2\">**</ept>.","pos":[42683,42756],"source":" The **order by** clause follows the same syntax patterns as **group by**."},{"content":"Both clauses, if they are provided, must appear after the <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> (or <bpt id=\"p2\">**</bpt>from<ept id=\"p2\">**</ept>) clause, and both must appear before any <bpt id=\"p3\">**</bpt>where<ept id=\"p3\">**</ept> clause that exists on the same <bpt id=\"p4\">**</bpt>join<ept id=\"p4\">**</ept> clause.","pos":[42757,42935],"source":" Both clauses, if they are provided, must appear after the **join** (or **from**) clause, and both must appear before any **where** clause that exists on the same **join** clause."},{"content":"We recommend that all <bpt id=\"p1\">**</bpt>group by<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>order by<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>where<ept id=\"p3\">**</ept> clauses appear immediately after the last <bpt id=\"p4\">**</bpt>join<ept id=\"p4\">**</ept> clause.","pos":[42936,43058],"source":" We recommend that all **group by**, **order by**, and **where** clauses appear immediately after the last **join** clause."},{"pos":[44260,44299],"content":"select statement that has an outer join","linkify":"select statement that has an outer join","nodes":[{"content":"select statement that has an outer join","pos":[0,39]}]},{"content":"The <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement supports filtering an outer join in the <bpt id=\"p2\">**</bpt>where<ept id=\"p2\">**</ept> clause.","pos":[44301,44383],"source":"The **select** statement supports filtering an outer join in the **where** clause."},{"content":"In the <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> clause of standard SQL, there is an <bpt id=\"p2\">**</bpt>on<ept id=\"p2\">**</ept> keyword for filter criteria.","pos":[44384,44471],"source":" In the **join** clause of standard SQL, there is an **on** keyword for filter criteria."},{"content":"However, this keyword isn't supported in X++.","pos":[44472,44517]},{"content":"An inner join rejects all table rows that don't match a row in the other joined table.","pos":[44518,44604]},{"content":"However, an outer join includes rows from the first table, even if there is no matching row in the other joined table.","pos":[44605,44723]},{"content":"Default values are substituted for the data that couldn't be obtained from a matching row in the other joined table.","pos":[44724,44840]},{"content":"You can filter an outer join at the equivalent of an <bpt id=\"p1\">**</bpt>on<ept id=\"p1\">**</ept> clause that is part of the <bpt id=\"p2\">**</bpt>join<ept id=\"p2\">**</ept> clause.","pos":[44841,44944],"source":" You can filter an outer join at the equivalent of an **on** clause that is part of the **join** clause."},{"content":"For an inner join, the behavior if you filter on an <bpt id=\"p1\">**</bpt>on<ept id=\"p1\">**</ept> clause is the same as the behavior if you filter on the <bpt id=\"p2\">**</bpt>where<ept id=\"p2\">**</ept> clause.","pos":[44945,45077],"source":" For an inner join, the behavior if you filter on an **on** clause is the same as the behavior if you filter on the **where** clause."},{"pos":[45084,45108],"content":"select statement example","linkify":"select statement example","nodes":[{"content":"select statement example","pos":[0,24]}]},{"content":"The following example is based on two tables.","pos":[45110,45155]},{"content":"The field types and example data are included.","pos":[45156,45202]},{"content":"There is a one-to-many relationship between the SalesOrder parent table and the SalesOrderLine child table.","pos":[45203,45310]},{"content":"For each row in the SalesOrder table, there are 0 (zero) or more rows in the SalesOrderLine table.","pos":[45311,45409]},{"content":"There are two rows in the SalesOrder table.","pos":[45410,45453]},{"content":"SalesOrderID (integer, primary key)","pos":[45457,45492]},{"content":"DateAdded (date)","pos":[45495,45511]},{"content":"1","pos":[45575,45576]},{"content":"2010-01-01","pos":[45613,45623]},{"content":"2","pos":[45634,45635]},{"content":"2010-02-02","pos":[45672,45682]},{"content":"The SalesOrderLine table contains a foreign key field that is named <bpt id=\"p1\">**</bpt>SalesOrderID<ept id=\"p1\">**</ept>.","pos":[45692,45777],"source":"The SalesOrderLine table contains a foreign key field that is named **SalesOrderID**."},{"content":"This field references the primary key column of the SalesOrder table.","pos":[45778,45847]},{"content":"A <bpt id=\"p1\">**</bpt>SalesOrderID<ept id=\"p1\">**</ept> value of <bpt id=\"p2\">**</bpt>2<ept id=\"p2\">**</ept> doesn't occur in the data for the SalesOrderLine table.","pos":[45848,45937],"source":" A **SalesOrderID** value of **2** doesn't occur in the data for the SalesOrderLine table."},{"content":"SalesOrderLineID (string, primary key)","pos":[45941,45979]},{"content":"Quantity (integer)","pos":[45982,46000]},{"content":"SalesOrderID (integer, foreign key)","pos":[46003,46038]},{"content":"AA","pos":[46145,46147]},{"content":"32","pos":[46186,46188]},{"content":"1","pos":[46207,46208]},{"content":"BB","pos":[46247,46249]},{"content":"67","pos":[46288,46290]},{"content":"1","pos":[46309,46310]},{"content":"CC","pos":[46349,46351]},{"content":"66","pos":[46390,46392]},{"content":"1","pos":[46411,46412]},{"content":"The following code has a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement that reads the two tables.","pos":[46450,46522],"source":"The following code has a **select** statement that reads the two tables."},{"content":"The <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement includes a left <bpt id=\"p2\">**</bpt>outer join<ept id=\"p2\">**</ept> clause.","pos":[46523,46586],"source":" The **select** statement includes a left **outer join** clause."},{"content":"Both the join criteria and the data filter are on the <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause.","pos":[46587,46658],"source":" Both the join criteria and the data filter are on the **where** clause."},{"content":"The output from the code is also shown.","pos":[46659,46698]},{"content":"The second record in the output has a <bpt id=\"p1\">**</bpt>SalesOrderID<ept id=\"p1\">**</ept> value of <bpt id=\"p2\">**</bpt>2<ept id=\"p2\">**</ept>.","pos":[46699,46769],"source":" The second record in the output has a **SalesOrderID** value of **2**."},{"content":"However, that value isn't present in the SalesOrderLine table.","pos":[46770,46832]},{"content":"Therefore, some of the fields in the second record have default values: <bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept> for an integer and a zero-length string for a string.","pos":[46833,46964],"source":" Therefore, some of the fields in the second record have default values: **0** for an integer and a zero-length string for a string."},{"pos":[48215,48238],"content":"while select statements","linkify":"while select statements","nodes":[{"content":"while select statements","pos":[0,23]}]},{"content":"A <bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> statement is used to handle data.","pos":[48239,48291],"source":"A **while select** statement is used to handle data."},{"content":"It's the most widely used form of the <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement.","pos":[48292,48351],"source":" It's the most widely used form of the **select** statement."},{"content":"The <bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> statement loops over many records that meet specific criteria, and can run a statement on each record.","pos":[48352,48475],"source":" The **while select** statement loops over many records that meet specific criteria, and can run a statement on each record."},{"content":"Typically, when you use the <bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> statement for data manipulation, you do it in a transaction to ensure data integrity.","pos":[48476,48606],"source":" Typically, when you use the **while select** statement for data manipulation, you do it in a transaction to ensure data integrity."},{"content":"The results of a <bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> statement are returned in a table buffer variable.","pos":[48607,48691],"source":" The results of a **while select** statement are returned in a table buffer variable."},{"content":"If you use a field list in the <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement, only those fields are available in the table variable.","pos":[48692,48799],"source":" If you use a field list in the **select** statement, only those fields are available in the table variable."},{"content":"If you use aggregate functions, such as <bpt id=\"p1\">**</bpt>sum<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>count<ept id=\"p2\">**</ept>, the results are returned in the fields that you perform the <bpt id=\"p3\">**</bpt>sum<ept id=\"p3\">**</ept> or <bpt id=\"p4\">**</bpt>count<ept id=\"p4\">**</ept> over.","pos":[48800,48948],"source":" If you use aggregate functions, such as **sum** or **count**, the results are returned in the fields that you perform the **sum** or **count** over."},{"content":"You can count, average, or sum only integer and real fields.","pos":[48949,49009]},{"content":"The syntax of a <bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> statement resembles the syntax of a <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement, but the statement is preceded by <bpt id=\"p3\">**</bpt>while select<ept id=\"p3\">**</ept> instead of <bpt id=\"p4\">**</bpt>select<ept id=\"p4\">**</ept>.","pos":[49010,49173],"source":" The syntax of a **while select** statement resembles the syntax of a **select** statement, but the statement is preceded by **while select** instead of **select**."},{"content":"The <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement itself is run only one time, immediately before the first iteration of the statements in the loop.","pos":[49174,49297],"source":" The **select** statement itself is run only one time, immediately before the first iteration of the statements in the loop."},{"content":"Any Boolean expressions (such as <bpt id=\"p1\">**</bpt>iCounter <ph id=\"ph1\">&amp;lt;</ph> 1<ept id=\"p1\">**</ept>) that are added to the <bpt id=\"p2\">**</bpt>while select<ept id=\"p2\">**</ept> are tested only one time.","pos":[49298,49416],"source":" Any Boolean expressions (such as **iCounter &lt; 1**) that are added to the **while select** are tested only one time."},{"content":"This behavior differs from the behavior of the <bpt id=\"p1\">**</bpt>while<ept id=\"p1\">**</ept> statement in languages such as C++ and C<ph id=\"ph1\">\\#</ph>.","pos":[49417,49517],"source":" This behavior differs from the behavior of the **while** statement in languages such as C++ and C\\#."},{"content":"For example, the following loop can have more than one iteration.","pos":[49518,49583]},{"pos":[50008,50028],"content":"while select example","linkify":"while select example","nodes":[{"content":"while select example","pos":[0,20]}]},{"content":"The following example prints the name reference and telephone number of every customer in the CustTable table whose account number is within a specified range.","pos":[50030,50189]},{"pos":[50819,50839],"content":"while select example","linkify":"while select example","nodes":[{"content":"while select example","pos":[0,20]}]},{"pos":[50841,50894],"content":"The following example uses the <bpt id=\"p1\">**</bpt>forUpdate<ept id=\"p1\">**</ept> keyword.","source":"The following example uses the **forUpdate** keyword."},{"pos":[51775,51800],"content":"Deleting a set of records","linkify":"Deleting a set of records","nodes":[{"content":"Deleting a set of records","pos":[0,25]}]},{"content":"You can use a <bpt id=\"p1\">**</bpt>while select<ept id=\"p1\">**</ept> statement to loop over a set of records that meet some criteria, and perform an action on each record.","pos":[51802,51935],"source":"You can use a **while select** statement to loop over a set of records that meet some criteria, and perform an action on each record."},{"content":"In the following example, the statement is used to delete a set of records.","pos":[51936,52011]},{"pos":[52169,52239],"content":"You can achieve the same effect by using the <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> keyword.","source":"You can achieve the same effect by using the **delete\\_from** keyword."},{"pos":[52364,52391],"content":"select statements on fields","linkify":"select statements on fields","nodes":[{"content":"select statements on fields","pos":[0,27]}]},{"content":"You can use a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement in a lookup on a field.","pos":[52393,52451],"source":"You can use a **select** statement in a lookup on a field."},{"content":"After a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement that fetches a record in a table, you can enter <bpt id=\"p2\">**</bpt>.fieldName<ept id=\"p2\">**</ept> to reference a field in the table.","pos":[52452,52578],"source":" After a **select** statement that fetches a record in a table, you can enter **.fieldName** to reference a field in the table."},{"content":"These <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statements must be used in expressions.","pos":[52579,52635],"source":" These **select** statements must be used in expressions."},{"content":"A <bpt id=\"p1\">*</bpt>normal <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement<ept id=\"p1\">*</ept> differs from a <bpt id=\"p3\">*</bpt>field <bpt id=\"p4\">**</bpt>select<ept id=\"p4\">**</ept> statement<ept id=\"p3\">*</ept>:","pos":[52636,52712],"source":" A *normal **select** statement* differs from a *field **select** statement*:"},{"pos":[52718,52778],"content":"The field <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement operates directly on a table.","source":"The field **select** statement operates directly on a table."},{"pos":[52783,52851],"content":"The normal <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement operates on a table buffer variable.","source":"The normal **select** statement operates on a table buffer variable."},{"pos":[52857,52877],"content":"select field example","linkify":"select field example","nodes":[{"content":"select field example","pos":[0,20]}]},{"pos":[53304,53356],"content":"Aggregate functions: Differences between X++ and SQL","linkify":"Aggregate functions: Differences between X++ and SQL","nodes":[{"content":"Aggregate functions: Differences between X++ and SQL","pos":[0,52]}]},{"content":"In industry-standard SQL, a database query can contain <bpt id=\"p1\">*</bpt>aggregate functions<ept id=\"p1\">*</ept>.","pos":[53358,53435],"source":"In industry-standard SQL, a database query can contain *aggregate functions*."},{"content":"Examples include <bpt id=\"p1\">**</bpt>count(RecID)<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>sum(columnA)<ept id=\"p2\">**</ept>.","pos":[53436,53491],"source":" Examples include **count(RecID)** and **sum(columnA)**."},{"content":"When an aggregate function is used, but no rows match the <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause, a row must be returned to hold the result of the aggregates.","pos":[53492,53628],"source":" When an aggregate function is used, but no rows match the **where** clause, a row must be returned to hold the result of the aggregates."},{"content":"The row that is returned shows the value <bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept> (zero) for the <bpt id=\"p2\">**</bpt>count<ept id=\"p2\">**</ept> function and <bpt id=\"p3\">**</bpt>null<ept id=\"p3\">**</ept> for the <bpt id=\"p4\">**</bpt>sum<ept id=\"p4\">**</ept> function.","pos":[53629,53748],"source":" The row that is returned shows the value **0** (zero) for the **count** function and **null** for the **sum** function."},{"content":"X++ doesn't support the concept of <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept> values for the database.","pos":[53749,53817],"source":" X++ doesn't support the concept of **null** values for the database."},{"content":"Therefore, in cases where the <bpt id=\"p1\">**</bpt>sum<ept id=\"p1\">**</ept> function will return <bpt id=\"p2\">**</bpt>null<ept id=\"p2\">**</ept>, no row is returned to the user.","pos":[53818,53918],"source":" Therefore, in cases where the **sum** function will return **null**, no row is returned to the user."},{"content":"Additionally, every data type has a specific value that is treated as a <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept> value in some circumstances.","pos":[53919,54028],"source":" Additionally, every data type has a specific value that is treated as a **null** value in some circumstances."},{"pos":[54034,54082],"content":"index and order by keywords in select statements","linkify":"index and order by keywords in select statements","nodes":[{"content":"index and order by keywords in select statements","pos":[0,48]}]},{"content":"You use the <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> keyword in <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statements to order the data that is returned.","pos":[54084,54177],"source":"You use the **order by** keyword in **select** statements to order the data that is returned."},{"content":"Use the <bpt id=\"p1\">**</bpt>index hint<ept id=\"p1\">**</ept> keyword to specify the index that should be used in the query and to sort the selected records in the manner that is defined by the index.","pos":[54178,54339],"source":" Use the **index hint** keyword to specify the index that should be used in the query and to sort the selected records in the manner that is defined by the index."},{"content":"Indexes optimize the selection of records.","pos":[54340,54382]},{"content":"To select records in a specific order, combine the <bpt id=\"p1\">**</bpt>index hint<ept id=\"p1\">**</ept> keyword with an <bpt id=\"p2\">**</bpt>order by<ept id=\"p2\">**</ept> expression.","pos":[54383,54489],"source":" To select records in a specific order, combine the **index hint** keyword with an **order by** expression."},{"content":"If you want the output to be sorted in reverse order, use the <bpt id=\"p1\">**</bpt>reverse<ept id=\"p1\">**</ept> keyword.","pos":[54490,54572],"source":" If you want the output to be sorted in reverse order, use the **reverse** keyword."},{"content":"If a table index has been disabled (that is, if the index's <bpt id=\"p1\">**</bpt>Enabled<ept id=\"p1\">**</ept> property is set to <bpt id=\"p2\">**</bpt>No<ept id=\"p2\">**</ept>), the <bpt id=\"p3\">**</bpt>select<ept id=\"p3\">**</ept> statement that references the index is still valid.","pos":[54573,54739],"source":" If a table index has been disabled (that is, if the index's **Enabled** property is set to **No**), the **select** statement that references the index is still valid."},{"content":"However, the database can't use the index as a hint to sort the data, because the index doesn't exist in the database.","pos":[54740,54858]},{"content":"The following table shows how to use the <bpt id=\"p1\">**</bpt>index hint<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>order by<ept id=\"p2\">**</ept> keywords in <bpt id=\"p3\">**</bpt>select<ept id=\"p3\">**</ept> statements.","pos":[54859,54966],"source":" The following table shows how to use the **index hint** and **order by** keywords in **select** statements."},{"content":"Task","pos":[54970,54974]},{"content":"Use","pos":[55057,55060]},{"content":"Select records when the order isn't significant.","pos":[55248,55296]},{"content":"select ..","pos":[55335,55344]},{"content":"where ...","pos":[55345,55354]},{"content":"Select records when the order is significant.","pos":[55387,55432]},{"content":"select ..","pos":[55474,55483]},{"content":"order by ... where ...","pos":[55484,55506]},{"content":"Select records, and force a specific index to be used.","pos":[55526,55580]},{"content":"select ..","pos":[55613,55622]},{"content":"index hint ... where ...","pos":[55623,55647]},{"content":"Select records when the order is significant, and force a specific index to be used.","pos":[55665,55749]},{"content":"select ..","pos":[55752,55761]},{"content":"index hint ... order by ... where ...","pos":[55762,55799]},{"pos":[55807,55833],"content":"index and order by example","linkify":"index and order by example","nodes":[{"content":"index and order by example","pos":[0,26]}]},{"content":"The following example shows how to select transactions from the SalesTable table, based on a range of customers and due dates.","pos":[55835,55961]},{"pos":[56279,56289],"content":"index hint","linkify":"index hint","nodes":[{"content":"index hint","pos":[0,10]}]},{"pos":[56291,56391],"content":"Before you can use <bpt id=\"p1\">**</bpt>index hint<ept id=\"p1\">**</ept> in queries, you must specify that hints can be used on the server.","source":"Before you can use **index hint** in queries, you must specify that hints can be used on the server."},{"pos":[56397,56495],"content":"Go to <bpt id=\"p1\">**</bpt>Start<ept id=\"p1\">**</ept> <ph id=\"ph1\">&amp;gt;</ph> <bpt id=\"p2\">**</bpt>Administrative Tools<ept id=\"p2\">**</ept> <ph id=\"ph2\">&amp;gt;</ph> <bpt id=\"p3\">**</bpt>Microsoft Dynamics AX Server Configuration<ept id=\"p3\">**</ept>.","source":"Go to **Start** &gt; **Administrative Tools** &gt; **Microsoft Dynamics AX Server Configuration**."},{"pos":[56500,56595],"content":"On the <bpt id=\"p1\">**</bpt>Database Tuning<ept id=\"p1\">**</ept> tab, select <bpt id=\"p2\">**</bpt>Allow INDEX hints in queries<ept id=\"p2\">**</ept>, and then click <bpt id=\"p3\">**</bpt>OK<ept id=\"p3\">**</ept>.","source":"On the **Database Tuning** tab, select **Allow INDEX hints in queries**, and then click **OK**."},{"content":"When a message box prompts you to restart the Application Object Server (AOS) service, click <bpt id=\"p1\">**</bpt>Yes<ept id=\"p1\">**</ept>.","pos":[56600,56701],"source":"When a message box prompts you to restart the Application Object Server (AOS) service, click **Yes**."},{"content":"Index hints won't be enabled until the service is restarted.","pos":[56702,56762]},{"content":"When an <bpt id=\"p1\">**</bpt>index hint<ept id=\"p1\">**</ept> in a <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement refers to a non-clustered index, and the <bpt id=\"p3\">**</bpt>where<ept id=\"p3\">**</ept> clause contains only the fields that are found in a clustered index on the same table, the clustered index is used instead of the index that is specified in the hint.","pos":[56764,57030],"source":"When an **index hint** in a **select** statement refers to a non-clustered index, and the **where** clause contains only the fields that are found in a clustered index on the same table, the clustered index is used instead of the index that is specified in the hint."},{"content":"For example, you run <bpt id=\"p1\">**</bpt>sp<ph id=\"ph1\">\\_</ph>helpindex InventTable<ept id=\"p1\">**</ept> in SQL Server Management Studio and you see that the InventTable table has a clustered index on the <bpt id=\"p2\">**</bpt>DataAreaId<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>ItemId<ept id=\"p3\">**</ept> columns, and a non-clustered index on the <bpt id=\"p4\">**</bpt>DataAreaId<ept id=\"p4\">**</ept>, <bpt id=\"p5\">**</bpt>ItemProductId<ept id=\"p5\">**</ept>, and <bpt id=\"p6\">**</bpt>ItemType<ept id=\"p6\">**</ept> columns.","pos":[57031,57314],"source":" For example, you run **sp\\_helpindex InventTable** in SQL Server Management Studio and you see that the InventTable table has a clustered index on the **DataAreaId** and **ItemId** columns, and a non-clustered index on the **DataAreaId**, **ItemProductId**, and **ItemType** columns."},{"content":"Index name","pos":[57318,57328]},{"content":"Description","pos":[57337,57348]},{"content":"Key columns","pos":[57390,57401]},{"content":"I<ph id=\"ph1\">\\_</ph>175ITEMIDX","pos":[57542,57555],"source":"I\\_175ITEMIDX"},{"content":"Clustered, unique, primary key, located on PRIMARY","pos":[57561,57611]},{"content":"DATAAREAID, ITEMID","pos":[57614,57632]},{"content":"I<ph id=\"ph1\">\\_</ph>175PRODUCTIDX","pos":[57654,57670],"source":"I\\_175PRODUCTIDX"},{"content":"Non-clustered, located on PRIMARY","pos":[57673,57706]},{"content":"DATAAREAID, ITEMPRODUCTID, ITEMTYPE","pos":[57726,57761]},{"pos":[57765,57887],"content":"In the following code, the clustered index is used instead of the non-clustered index that is specified by <bpt id=\"p1\">**</bpt>index hint<ept id=\"p1\">**</ept>.","source":"In the following code, the clustered index is used instead of the non-clustered index that is specified by **index hint**."},{"pos":[58060,58103],"content":"Writing a select statement as an expression","linkify":"Writing a select statement as an expression","nodes":[{"content":"Writing a select statement as an expression","pos":[0,43]}]},{"content":"You can use a <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement as an expression.","pos":[58105,58157],"source":"You can use a **select** statement as an expression."},{"content":"This type of <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement is known as an <bpt id=\"p2\">*</bpt>expression <bpt id=\"p3\">**</bpt>select<ept id=\"p3\">**</ept> statement<ept id=\"p2\">*</ept>.","pos":[58158,58241],"source":" This type of **select** statement is known as an *expression **select** statement*."},{"content":"A table buffer variable can't be used in an expression <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement.","pos":[58242,58318],"source":" A table buffer variable can't be used in an expression **select** statement."},{"content":"The name of the table must be used in the <bpt id=\"p1\">**</bpt>from<ept id=\"p1\">**</ept> clause.","pos":[58319,58377],"source":" The name of the table must be used in the **from** clause."},{"content":"One limitation of expression <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statements is that the <bpt id=\"p2\">**</bpt>join<ept id=\"p2\">**</ept> keyword isn't supported in an expression join.","pos":[58378,58496],"source":" One limitation of expression **select** statements is that the **join** keyword isn't supported in an expression join."},{"pos":[58502,58528],"content":"expression select examples","linkify":"expression select examples","nodes":[{"content":"expression select examples","pos":[0,26]}]},{"content":"In the following example, the <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement inside the parentheses returns one row.","pos":[58530,58620],"source":"In the following example, the **select** statement inside the parentheses returns one row."},{"content":"The only column that can be populated with data is the column that is named before the <bpt id=\"p1\">**</bpt>from<ept id=\"p1\">**</ept> clause in the <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> clause.","pos":[58621,58749],"source":" The only column that can be populated with data is the column that is named before the **from** clause in the **select** clause."},{"content":"After the closing parenthesis, the name of that column is used to reference the data value: <bpt id=\"p1\">**</bpt>).AccountNum;<ept id=\"p1\">**</ept>.","pos":[58750,58860],"source":" After the closing parenthesis, the name of that column is used to reference the data value: **).AccountNum;**."},{"content":"This example returns a maximum of one row, because it uses the <bpt id=\"p1\">**</bpt>firstonly<ept id=\"p1\">**</ept> keyword.","pos":[58861,58946],"source":" This example returns a maximum of one row, because it uses the **firstonly** keyword."},{"content":"However, the value that is assigned to <bpt id=\"p1\">**</bpt>sAccountNum<ept id=\"p1\">**</ept> is the same, even if the <bpt id=\"p2\">**</bpt>firstonly<ept id=\"p2\">**</ept> keyword is omitted.","pos":[58947,59060],"source":" However, the value that is assigned to **sAccountNum** is the same, even if the **firstonly** keyword is omitted."},{"content":"The <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause in this example serves no purpose except to show that the <bpt id=\"p2\">**</bpt>where<ept id=\"p2\">**</ept> clause must occur after the <bpt id=\"p3\">**</bpt>order by<ept id=\"p3\">**</ept> clause.","pos":[59061,59198],"source":" The **where** clause in this example serves no purpose except to show that the **where** clause must occur after the **order by** clause."},{"content":"The table name can't be used to qualify a field name in the <bpt id=\"p1\">**</bpt>order by<ept id=\"p1\">**</ept> clause.","pos":[59199,59279],"source":" The table name can't be used to qualify a field name in the **order by** clause."},{"content":"Here is a simpler way to achieve the same result as the previous example.","pos":[59562,59635]},{"content":"The following example includes a <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause.","pos":[59899,59949],"source":"The following example includes a **where** clause."},{"content":"In a <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause, the table name must be used as a qualifier of the field.","pos":[59950,60029],"source":" In a **where** clause, the table name must be used as a qualifier of the field."},{"content":"Here, the <bpt id=\"p1\">**</bpt>maxof<ept id=\"p1\">**</ept> aggregate function is used, and the <bpt id=\"p2\">**</bpt>RecId<ept id=\"p2\">**</ept> field is mentioned in the function.","pos":[60030,60131],"source":" Here, the **maxof** aggregate function is used, and the **RecId** field is mentioned in the function."},{"content":"The field that is mentioned in the aggregate function must be the same as the field name that is used to reference the data value after the closing parenthesis.","pos":[60132,60292]},{"content":"Otherwise, empty data is returned.","pos":[60293,60327]},{"content":"In the following example, a field name (in this case, <bpt id=\"p1\">**</bpt>RecId<ept id=\"p1\">**</ept>) is used to reference a data value that isn't a <bpt id=\"p2\">**</bpt>RecId<ept id=\"p2\">**</ept> value.","pos":[60627,60755],"source":"In the following example, a field name (in this case, **RecId**) is used to reference a data value that isn't a **RecId** value."},{"content":"The <bpt id=\"p1\">**</bpt>count<ept id=\"p1\">**</ept> aggregate function doesn't return a <bpt id=\"p2\">**</bpt>RecId<ept id=\"p2\">**</ept> value.","pos":[60756,60822],"source":" The **count** aggregate function doesn't return a **RecId** value."},{"content":"Typically, the <bpt id=\"p1\">**</bpt>RecId<ept id=\"p1\">**</ept> field is used with the <bpt id=\"p2\">**</bpt>count<ept id=\"p2\">**</ept> function.","pos":[60823,60890],"source":" Typically, the **RecId** field is used with the **count** function."},{"content":"The <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> keyword isn't supported in expression <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statements.","pos":[61182,61255],"source":"The **join** keyword isn't supported in expression **select** statements."},{"content":"The following example shows a subselect.","pos":[61256,61296]},{"content":"However, expression select <bpt id=\"p1\">**</bpt>statements<ept id=\"p1\">**</ept> don't support subselects that are equivalent to a standard inner join.","pos":[61297,61409],"source":" However, expression select **statements** don't support subselects that are equivalent to a standard inner join."},{"content":"Therefore, the following example doesn't compile, because it mentions two tables inside one expression <bpt id=\"p1\">**</bpt>select<ept id=\"p1\">**</ept> statement (that is, inside the subselect).","pos":[61410,61566],"source":" Therefore, the following example doesn't compile, because it mentions two tables inside one expression **select** statement (that is, inside the subselect)."},{"content":"As this example shows, subselects are supported, but only in a limited manner.","pos":[61567,61645]},{"pos":[62190,62203],"content":"update method","linkify":"update method","nodes":[{"content":"update method","pos":[0,13]}]},{"content":"The <bpt id=\"p1\">**</bpt>update<ept id=\"p1\">**</ept> table method updates the current record with the contents of the buffer.","pos":[62204,62291],"source":"The **update** table method updates the current record with the contents of the buffer."},{"content":"It also updates the appropriate system fields.","pos":[62292,62338]},{"content":"The <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause is optional.","pos":[62339,62372],"source":" The **where** clause is optional."},{"content":"When it's used, the <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause specifies a condition that <bpt id=\"p2\">**</bpt>update<ept id=\"p2\">**</ept> tests as it processes each row of the table.","pos":[62373,62492],"source":" When it's used, the **where** clause specifies a condition that **update** tests as it processes each row of the table."},{"content":"Only those rows that test <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> against the condition are updated with the new values.","pos":[62493,62582],"source":" Only those rows that test **true** against the condition are updated with the new values."},{"content":"The <bpt id=\"p1\">**</bpt>update<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> operator is a record set–based operator that updates multiple records at the same time.","pos":[62583,62696],"source":" The **update\\_recordset** operator is a record set–based operator that updates multiple records at the same time."},{"content":"To override the behavior of <bpt id=\"p1\">**</bpt>update<ept id=\"p1\">**</ept>, use the <bpt id=\"p2\">**</bpt>doUpdate<ept id=\"p2\">**</ept> method.","pos":[62697,62765],"source":" To override the behavior of **update**, use the **doUpdate** method."},{"content":"The following example selects the custTable table for update.","pos":[62766,62827]},{"content":"Any records where the value of the <bpt id=\"p1\">**</bpt>AccountNum<ept id=\"p1\">**</ept> field is equal to <bpt id=\"p2\">**</bpt>4000<ept id=\"p2\">**</ept> are updated.","pos":[62828,62917],"source":" Any records where the value of the **AccountNum** field is equal to **4000** are updated."},{"content":"(In this case, only one record is updated.) The value of the <bpt id=\"p1\">**</bpt>CreditMax<ept id=\"p1\">**</ept> field is changed to <bpt id=\"p2\">**</bpt>5000<ept id=\"p2\">**</ept>.","pos":[62918,63022],"source":" (In this case, only one record is updated.) The value of the **CreditMax** field is changed to **5000**."},{"pos":[63227,63242],"content":"doUpdate method","linkify":"doUpdate method","nodes":[{"content":"doUpdate method","pos":[0,15]}]},{"content":"The <bpt id=\"p1\">**</bpt>doUpdate<ept id=\"p1\">**</ept> method updates the current record with the contents of the buffer.","pos":[63243,63326],"source":"The **doUpdate** method updates the current record with the contents of the buffer."},{"content":"This method also updates the appropriate system fields.","pos":[63327,63382]},{"content":"You should use the <bpt id=\"p1\">**</bpt>doUpdate<ept id=\"p1\">**</ept> method when the <bpt id=\"p2\">**</bpt>update<ept id=\"p2\">**</ept> method on the table must be bypassed.","pos":[63383,63479],"source":" You should use the **doUpdate** method when the **update** method on the table must be bypassed."},{"content":"The syntax for a <bpt id=\"p1\">**</bpt>doUpdate<ept id=\"p1\">**</ept> table method is <bpt id=\"p2\">**</bpt>void doUpdate()<ept id=\"p2\">**</ept>.","pos":[63480,63546],"source":" The syntax for a **doUpdate** table method is **void doUpdate()**."},{"content":"In the following example, the value of the <bpt id=\"p1\">**</bpt>CreditMax<ept id=\"p1\">**</ept> field is increased by 1,000.","pos":[63547,63632],"source":" In the following example, the value of the **CreditMax** field is increased by 1,000."},{"pos":[63945,63958],"content":"delete method","linkify":"delete method","nodes":[{"content":"delete method","pos":[0,13]}]},{"content":"The <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> table method deletes the current record from the database.","pos":[63959,64032],"source":"The **delete** table method deletes the current record from the database."},{"content":"To use this method, use a <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause to specify the rows to delete.","pos":[64033,64106],"source":" To use this method, use a **where** clause to specify the rows to delete."},{"content":"One record at a time is then removed from the specified table.","pos":[64107,64169]},{"content":"The <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> operator is a record set–based operator that removes multiple records at the same time.","pos":[64170,64278],"source":" The **delete\\_from** operator is a record set–based operator that removes multiple records at the same time."},{"content":"The <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> method can be overridden.","pos":[64279,64319],"source":" The **delete** method can be overridden."},{"content":"For example, you might want to add extra validation before records are deleted.","pos":[64320,64399]},{"content":"If you override the <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> method, you can run the original (base) version of the <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> method by calling the <bpt id=\"p3\">**</bpt>doDelete<ept id=\"p3\">**</ept> method.","pos":[64400,64539],"source":" If you override the **delete** method, you can run the original (base) version of the **delete** method by calling the **doDelete** method."},{"content":"Therefore, a call to the <bpt id=\"p1\">**</bpt>doDelete<ept id=\"p1\">**</ept> method is equivalent to a call to <bpt id=\"p2\">**</bpt>super()<ept id=\"p2\">**</ept> in the <bpt id=\"p3\">**</bpt>delete<ept id=\"p3\">**</ept> method.","pos":[64540,64649],"source":" Therefore, a call to the **doDelete** method is equivalent to a call to **super()** in the **delete** method."},{"content":"In the following example, all records in the MyTable table that satisfy the criterion in the <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause (that is, all records where the value of the <bpt id=\"p2\">**</bpt>AccountNum<ept id=\"p2\">**</ept> field is equal to <bpt id=\"p3\">**</bpt>1000<ept id=\"p3\">**</ept>) are deleted from the database.","pos":[64650,64878],"source":" In the following example, all records in the MyTable table that satisfy the criterion in the **where** clause (that is, all records where the value of the **AccountNum** field is equal to **1000**) are deleted from the database."},{"content":"One record is deleted at a time.","pos":[64879,64911]},{"pos":[65062,65077],"content":"doDelete method","linkify":"doDelete method","nodes":[{"content":"doDelete method","pos":[0,15]}]},{"content":"Like the <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> table method, the <bpt id=\"p2\">**</bpt>doDelete<ept id=\"p2\">**</ept> table method deletes the current record from the database.","pos":[65078,65187],"source":"Like the **delete** table method, the **doDelete** table method deletes the current record from the database."},{"content":"Use the <bpt id=\"p1\">**</bpt>doDelete<ept id=\"p1\">**</ept> method if the <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> table method has been overridden, and you want to run the original (base) version of the <bpt id=\"p3\">**</bpt>delete<ept id=\"p3\">**</ept> method instead of the overridden version.","pos":[65188,65375],"source":" Use the **doDelete** method if the **delete** table method has been overridden, and you want to run the original (base) version of the **delete** method instead of the overridden version."},{"content":"Therefore, a call to the <bpt id=\"p1\">**</bpt>doDelete<ept id=\"p1\">**</ept> method is equivalent to a call to <bpt id=\"p2\">**</bpt>super()<ept id=\"p2\">**</ept> in the <bpt id=\"p3\">**</bpt>delete<ept id=\"p3\">**</ept> method.","pos":[65376,65485],"source":" Therefore, a call to the **doDelete** method is equivalent to a call to **super()** in the **delete** method."},{"content":"The following example deletes all records in the myTable table that have an account number that is more than or equal to <bpt id=\"p1\">**</bpt>200<ept id=\"p1\">**</ept>.","pos":[65486,65615],"source":" The following example deletes all records in the myTable table that have an account number that is more than or equal to **200**."},{"pos":[65767,65780],"content":"insert method","linkify":"insert method","nodes":[{"content":"insert method","pos":[0,13]}]},{"content":"The <bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept> method updates one record at a time.","pos":[65781,65832],"source":"The **insert** method updates one record at a time."},{"content":"To insert multiple records at a time, use array inserts, <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept>, or <bpt id=\"p2\">**</bpt>RecordSortedList.insertDatabase<ept id=\"p2\">**</ept>.","pos":[65833,65952],"source":" To insert multiple records at a time, use array inserts, **insert\\_recordset**, or **RecordSortedList.insertDatabase**."},{"content":"To override the behavior of the <bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept> method, use the <bpt id=\"p2\">**</bpt>doInsert<ept id=\"p2\">**</ept> method.","pos":[65953,66032],"source":" To override the behavior of the **insert** method, use the **doInsert** method."},{"content":"The <bpt id=\"p1\">**</bpt>xRecord .insert<ept id=\"p1\">**</ept> method generates values for the <bpt id=\"p2\">**</bpt>RecId<ept id=\"p2\">**</ept> field and system fields, and then inserts the contents of the buffer into the database.","pos":[66033,66186],"source":" The **xRecord .insert** method generates values for the **RecId** field and system fields, and then inserts the contents of the buffer into the database."},{"content":"Here is how the <bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept> method works:","pos":[66187,66227],"source":" Here is how the **insert** method works:"},{"content":"Only the specified columns of the rows that have been selected by the query are inserted into the named table.","pos":[66233,66343]},{"content":"The columns of the table that is copied from and the columns of the table that is copied to must be type-compatible.","pos":[66348,66464]},{"pos":[66469,66578],"content":"If the columns of both tables match in type and order, column list can be omitted from the <bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept> clause.","source":"If the columns of both tables match in type and order, column list can be omitted from the **insert** clause."},{"pos":[66584,66622],"content":"insert example: Inserting a new record","linkify":"insert example: Inserting a new record","nodes":[{"content":"insert example: Inserting a new record","pos":[0,38]}]},{"content":"The following example inserts a new record into the CustTable table.","pos":[66624,66692]},{"content":"The <bpt id=\"p1\">**</bpt>AccountNum<ept id=\"p1\">**</ept> field of the new record is set to <bpt id=\"p2\">**</bpt>5000<ept id=\"p2\">**</ept>, and the <bpt id=\"p3\">**</bpt>Name<ept id=\"p3\">**</ept> field is set to <bpt id=\"p4\">**</bpt>MyCompany<ept id=\"p4\">**</ept>.","pos":[66693,66803],"source":" The **AccountNum** field of the new record is set to **5000**, and the **Name** field is set to **MyCompany**."},{"content":"(Other fields in the record will be blank.)","pos":[66804,66847]},{"pos":[66999,67044],"content":"insert example: Transaction and duplicate key","linkify":"insert example: Transaction and duplicate key","nodes":[{"content":"insert example: Transaction and duplicate key","pos":[0,45]}]},{"content":"The following example shows how you can catch a <bpt id=\"p1\">**</bpt>DuplicateKeyException<ept id=\"p1\">**</ept> exception in the context of an explicit transaction.","pos":[67046,67172],"source":"The following example shows how you can catch a **DuplicateKeyException** exception in the context of an explicit transaction."},{"content":"The exception is thrown when a call to <bpt id=\"p1\">**</bpt>xRecord .insert<ept id=\"p1\">**</ept> fails because an existing unique value is duplicated.","pos":[67173,67285],"source":" The exception is thrown when a call to **xRecord .insert** fails because an existing unique value is duplicated."},{"content":"In the <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> block, your code can either take corrective action or log the error for later analysis.","pos":[67286,67390],"source":" In the **catch** block, your code can either take corrective action or log the error for later analysis."},{"content":"Your code can then continue without losing all the pending work of the transaction.","pos":[67391,67474]},{"content":"You can't catch a duplicate key exception that is caused by a set-based operation such as <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept>.","pos":[67475,67587],"source":" You can't catch a duplicate key exception that is caused by a set-based operation such as **insert\\_recordset**."},{"content":"This example depends on two tables: TableNumberA and TableNumberB.","pos":[67588,67654]},{"content":"Both tables have one mandatory integer field.","pos":[67655,67700]},{"content":"These fields are named <bpt id=\"p1\">**</bpt>NumberAKey<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>NumberBKey<ept id=\"p2\">**</ept>, respectively.","pos":[67701,67772],"source":" These fields are named **NumberAKey** and **NumberBKey**, respectively."},{"content":"A unique index is defined on each key field.","pos":[67773,67817]},{"content":"The TableNumberA table must have at least one record in it.","pos":[67818,67877]},{"pos":[70120,70135],"content":"doInsert method","linkify":"doInsert method","nodes":[{"content":"doInsert method","pos":[0,15]}]},{"content":"The <bpt id=\"p1\">**</bpt>doInsert<ept id=\"p1\">**</ept> method generates values for the <bpt id=\"p2\">**</bpt>RecId<ept id=\"p2\">**</ept> field and other system fields, and then inserts the contents of the buffer into the database.","pos":[70136,70288],"source":"The **doInsert** method generates values for the **RecId** field and other system fields, and then inserts the contents of the buffer into the database."},{"content":"Use this method when the <bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept> method on the table must be bypassed.","pos":[70289,70362],"source":" Use this method when the **insert** method on the table must be bypassed."},{"content":"In the following example, a new record is inserted.","pos":[70363,70414]},{"content":"The <bpt id=\"p1\">**</bpt>name<ept id=\"p1\">**</ept> field of the record is set to <bpt id=\"p2\">**</bpt>Warren Langer<ept id=\"p2\">**</ept>, and the <bpt id=\"p3\">**</bpt>value<ept id=\"p3\">**</ept> field is set to <bpt id=\"p4\">**</bpt>100<ept id=\"p4\">**</ept>.","pos":[70415,70519],"source":" The **name** field of the record is set to **Warren Langer**, and the **value** field is set to **100**."},{"pos":[70639,70662],"content":"Transactional integrity","linkify":"Transactional integrity","nodes":[{"content":"Transactional integrity","pos":[0,23]}]},{"content":"If steps aren't taken to help guarantee the integrity of transactions, data corruption could occur.","pos":[70663,70762]},{"content":"At the very least, you might experience poor scalability with respect to concurrent users on the system.","pos":[70763,70867]},{"content":"Two internal checking features help guarantee the integrity of transactions: the <bpt id=\"p1\">**</bpt>forUpdate<ept id=\"p1\">**</ept> check and the <bpt id=\"p2\">**</bpt>tssLevel<ept id=\"p2\">**</ept> check.","pos":[70868,70996],"source":" Two internal checking features help guarantee the integrity of transactions: the **forUpdate** check and the **tssLevel** check."},{"content":"A <bpt id=\"p1\">**</bpt>forUpdate<ept id=\"p1\">**</ept> check helps guarantee that a record can be updated or deleted only if it has first been selected for update.","pos":[70997,71121],"source":" A **forUpdate** check helps guarantee that a record can be updated or deleted only if it has first been selected for update."},{"content":"You can select a record for update by using either the <bpt id=\"p1\">**</bpt>forUpdate<ept id=\"p1\">**</ept> keyword in the <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement or the <bpt id=\"p3\">**</bpt>selectForUpdate<ept id=\"p3\">**</ept> method on tables.","pos":[71122,71271],"source":" You can select a record for update by using either the **forUpdate** keyword in the **select** statement or the **selectForUpdate** method on tables."},{"content":"A <bpt id=\"p1\">**</bpt>ttsLevel<ept id=\"p1\">**</ept> check helps guarantee that a record can be updated or deleted only within the same transaction scope where it was selected for update.","pos":[71272,71421],"source":" A **ttsLevel** check helps guarantee that a record can be updated or deleted only within the same transaction scope where it was selected for update."},{"content":"The following statements are used to help guarantee integrity:","pos":[71422,71484]},{"content":"<bpt id=\"p1\">**</bpt>ttsBegin<ept id=\"p1\">**</ept> – This statement marks the beginning of a transaction.","pos":[71490,71557],"source":"**ttsBegin** – This statement marks the beginning of a transaction."},{"content":"It helps guarantee data integrity, and also helps guarantees that all updates that are done until the transaction ends (through <bpt id=\"p1\">**</bpt>ttsCommit<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>ttsAbort<ept id=\"p2\">**</ept>) are consistent (all or none).","pos":[71558,71746],"source":" It helps guarantee data integrity, and also helps guarantees that all updates that are done until the transaction ends (through **ttsCommit** or **ttsAbort**) are consistent (all or none)."},{"content":"<bpt id=\"p1\">**</bpt>ttsCommit<ept id=\"p1\">**</ept> – This statement marks the successful end of a transaction.","pos":[71751,71824],"source":"**ttsCommit** – This statement marks the successful end of a transaction."},{"content":"It ends and commits a transaction.","pos":[71825,71859]},{"content":"Microsoft Dynamics 365 for Operations helps guarantee that a transaction that has been committed will be performed according to intentions.","pos":[71860,71999]},{"content":"<bpt id=\"p1\">**</bpt>ttsAbort<ept id=\"p1\">**</ept> – This statement lets you explicitly discard all changes in the current transaction.","pos":[72004,72101],"source":"**ttsAbort** – This statement lets you explicitly discard all changes in the current transaction."},{"content":"In this case, the database is rolled back to the original state where nothing has been changed.","pos":[72102,72197]},{"content":"Typically, you use this statement if you've detected that the user wants to break the current job.","pos":[72198,72296]},{"content":"The <bpt id=\"p1\">**</bpt>ttsAbort<ept id=\"p1\">**</ept> statement helps guarantee that the database is consistent.","pos":[72297,72372],"source":" The **ttsAbort** statement helps guarantee that the database is consistent."},{"content":"Usually, it's a better idea to use exception handling instead of <bpt id=\"p1\">**</bpt>ttsAbort<ept id=\"p1\">**</ept>.","pos":[72374,72452],"source":"Usually, it's a better idea to use exception handling instead of **ttsAbort**."},{"content":"The <bpt id=\"p1\">**</bpt>throw<ept id=\"p1\">**</ept> statement automatically aborts the current transaction.","pos":[72453,72522],"source":" The **throw** statement automatically aborts the current transaction."},{"content":"As the following example shows, statements between <bpt id=\"p1\">**</bpt>ttsBegin<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>ttsCommit<ept id=\"p2\">**</ept> can include one or more transaction blocks.","pos":[72523,72648],"source":" As the following example shows, statements between **ttsBegin** and **ttsCommit** can include one or more transaction blocks."},{"content":"In these cases, nothing is actually committed until the successful exit from the final <bpt id=\"p1\">**</bpt>ttsCommit<ept id=\"p1\">**</ept> statement.","pos":[72649,72760],"source":" In these cases, nothing is actually committed until the successful exit from the final **ttsCommit** statement."},{"pos":[72877,72960],"content":"The following example selects a set of records and updates the <bpt id=\"p1\">**</bpt>NameAlias<ept id=\"p1\">**</ept> field.","source":"The following example selects a set of records and updates the **NameAlias** field."},{"pos":[73156,73228],"content":"Example of code that is rejected by the two transaction integrity checks","linkify":"Example of code that is rejected by the two transaction integrity checks","nodes":[{"content":"Example of code that is rejected by the two transaction integrity checks","pos":[0,72]}]},{"content":"In this example, the first failure occurs because the <bpt id=\"p1\">**</bpt>forupdate<ept id=\"p1\">**</ept> keyword is missing.","pos":[73230,73317],"source":"In this example, the first failure occurs because the **forupdate** keyword is missing."},{"content":"The second failure occurs because the transaction scope of the update differs from the transaction scope where the record was selected for update in <bpt id=\"p1\">**</bpt>ttsCommit<ept id=\"p1\">**</ept>.","pos":[73318,73481],"source":" The second failure occurs because the transaction scope of the update differs from the transaction scope where the record was selected for update in **ttsCommit**."},{"pos":[73812,73838],"content":"Speeding up SQL operations","linkify":"Speeding up SQL operations","nodes":[{"content":"Speeding up SQL operations","pos":[0,26]}]},{"content":"The following constructs let you insert, update, or delete multiple records.","pos":[73839,73915]},{"content":"By using these constructs, you reduce communication between the application and the database, and therefore help increase performance.","pos":[73916,74050]},{"content":"In some situations, record set–based operations can fall back to record-by-record operations.","pos":[74051,74144]},{"content":"Construct","pos":[74148,74157]},{"content":"Description","pos":[74168,74179]},{"content":"RecordSortedList","pos":[74614,74630]},{"content":"Insert multiple records in one database trip.","pos":[74634,74679]},{"content":"Use this construct when you want a subset of data from a specific table, and you want that data to be sorted in an order that doesn't currently exist as an index.","pos":[74680,74842]},{"content":"RecordInsertList","pos":[74847,74863]},{"content":"Insert multiple records in one database trip.","pos":[74867,74912]},{"content":"Use this construct when you don't have to sort the data.","pos":[74913,74969]},{"content":"insert<ph id=\"ph1\">\\_</ph>recordset","pos":[75080,75097],"source":"insert\\_recordset"},{"content":"Copy multiple records directly from one or more tables into another table in one database trip.","pos":[75100,75195]},{"content":"update<ph id=\"ph1\">\\_</ph>recordset","pos":[75313,75330],"source":"update\\_recordset"},{"content":"Update multiple rows in a table in one database trip.","pos":[75333,75386]},{"content":"delete<ph id=\"ph1\">\\_</ph>from","pos":[75546,75558],"source":"delete\\_from"},{"content":"Delete multiple records from the database in one database trip.","pos":[75566,75629]},{"pos":[75781,75798],"content":"insert\\_recordset","linkify":"insert\\_recordset","nodes":[{"content":"insert<ph id=\"ph1\">\\_</ph>recordset","pos":[0,17],"source":"insert\\_recordset"}]},{"content":"The <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement copies data directly from one or more source tables into one destination table in one server trip.","pos":[75799,75933],"source":"The **insert\\_recordset** statement copies data directly from one or more source tables into one destination table in one server trip."},{"content":"It's faster to use <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> than an array insert.","pos":[75934,75996],"source":" It's faster to use **insert\\_recordset** than an array insert."},{"content":"However, array inserts are more flexible if you want to handle the data before you insert it.","pos":[75997,76090]},{"content":"<bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> is a record set–based operator that performs operations on multiple records at a time.","pos":[76091,76199],"source":"**insert\\_recordset** is a record set–based operator that performs operations on multiple records at a time."},{"content":"However, it can fall back to record-by-record operations in many situations.","pos":[76200,76276]},{"pos":[76282,76306],"content":"insert\\_recordset syntax","linkify":"insert\\_recordset syntax","nodes":[{"content":"insert<ph id=\"ph1\">\\_</ph>recordset syntax","pos":[0,24],"source":"insert\\_recordset syntax"}]},{"content":"<bpt id=\"p1\">*</bpt>ListOfFields<ept id=\"p1\">*</ept> in the destination table must match the list of fields in the source tables.","pos":[76308,76399],"source":"*ListOfFields* in the destination table must match the list of fields in the source tables."},{"content":"Data is transferred in the order in which it appears in the list of fields.","pos":[76400,76475]},{"content":"Fields in the destination table that aren't present in the list of fields are assigned <bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept> (zero) values, as in other areas.","pos":[76476,76602],"source":" Fields in the destination table that aren't present in the list of fields are assigned **0** (zero) values, as in other areas."},{"content":"System fields, such as <bpt id=\"p1\">**</bpt>RecId<ept id=\"p1\">**</ept>, are assigned transparently by the kernel in the destination table.","pos":[76603,76703],"source":" System fields, such as **RecId**, are assigned transparently by the kernel in the destination table."},{"content":"<bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>DestinationTable<ept id=\"p2\">*</ept> <bpt id=\"p3\">**</bpt>(<ept id=\"p3\">**</ept> <bpt id=\"p4\">*</bpt>ListOfFields<ept id=\"p4\">*</ept> <bpt id=\"p5\">**</bpt>)<ept id=\"p5\">**</ept> <bpt id=\"p6\">**</bpt>select<ept id=\"p6\">**</ept> <bpt id=\"p7\">*</bpt>ListOfFields1<ept id=\"p7\">*</ept> <bpt id=\"p8\">**</bpt>from<ept id=\"p8\">**</ept> <bpt id=\"p9\">*</bpt>SourceTable<ept id=\"p9\">*</ept> <bpt id=\"p10\">**</bpt><ph id=\"ph2\">\\[</ph> where<ept id=\"p10\">**</ept> <bpt id=\"p11\">*</bpt>WhereClause<ept id=\"p11\">*</ept> <bpt id=\"p12\">**</bpt><ph id=\"ph3\">\\]</ph><ept id=\"p12\">**</ept> <bpt id=\"p13\">**</bpt><ph id=\"ph4\">\\[</ph> join<ept id=\"p13\">**</ept> <bpt id=\"p14\">*</bpt>ListOfFields2<ept id=\"p14\">*</ept> <bpt id=\"p15\">**</bpt>from<ept id=\"p15\">**</ept> <bpt id=\"p16\">*</bpt>JoinedSourceTable<ept id=\"p16\">*</ept> <bpt id=\"p17\">**</bpt><ph id=\"ph5\">\\[</ph> where<ept id=\"p17\">**</ept> <bpt id=\"p18\">*</bpt>JoinedWhereClause<ept id=\"p18\">*</ept> <bpt id=\"p19\">**</bpt><ph id=\"ph6\">\\]</ph><ph id=\"ph7\">\\]</ph><ept id=\"p19\">**</ept>","pos":[76704,76954],"source":"**insert\\_recordset** *DestinationTable* **(** *ListOfFields* **)** **select** *ListOfFields1* **from** *SourceTable* **\\[ where** *WhereClause* **\\]** **\\[ join** *ListOfFields2* **from** *JoinedSourceTable* **\\[ where** *JoinedWhereClause* **\\]\\]**"},{"pos":[76960,77002],"content":"Example: Inserting data from another table","linkify":"Example: Inserting data from another table","nodes":[{"content":"Example: Inserting data from another table","pos":[0,42]}]},{"content":"In this example, the <bpt id=\"p1\">**</bpt>myNum<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>mySum<ept id=\"p2\">**</ept> records are retrieved from the anotherTable table and inserted into the myTable table.","pos":[77004,77135],"source":"In this example, the **myNum** and **mySum** records are retrieved from the anotherTable table and inserted into the myTable table."},{"content":"The records are grouped according to <bpt id=\"p1\">**</bpt>myNum<ept id=\"p1\">**</ept>, and only <bpt id=\"p2\">**</bpt>myNum<ept id=\"p2\">**</ept> records that have a value that is less than or equal to <bpt id=\"p3\">**</bpt>100<ept id=\"p3\">**</ept> are included in the insertion.","pos":[77136,77297],"source":" The records are grouped according to **myNum**, and only **myNum** records that have a value that is less than or equal to **100** are included in the insertion."},{"pos":[77472,77510],"content":"Example: Inserting data from variables","linkify":"Example: Inserting data from variables","nodes":[{"content":"Example: Inserting data from variables","pos":[0,38]}]},{"content":"The following example shows that the <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement can insert data that is provided in variables.","pos":[77512,77627],"source":"The following example shows that the **insert\\_recordset** statement can insert data that is provided in variables."},{"content":"In this example, the <bpt id=\"p1\">**</bpt>firstonly<ept id=\"p1\">**</ept> keyword is used so that only one row is inserted.","pos":[77628,77712],"source":" In this example, the **firstonly** keyword is used so that only one row is inserted."},{"content":"Literals, such as <bpt id=\"p1\">**</bpt>128<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>\"this literal string\"<ept id=\"p2\">**</ept>, can't be used as a source of data that is inserted.","pos":[77713,77820],"source":" Literals, such as **128** or **\"this literal string\"**, can't be used as a source of data that is inserted."},{"pos":[78418,78457],"content":"Example: Inserting data by using a join","linkify":"Example: Inserting data by using a join","nodes":[{"content":"Example: Inserting data by using a join","pos":[0,39]}]},{"content":"The following example shows a join of three tables on an <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement that has a subselect.","pos":[78459,78569],"source":"The following example shows a join of three tables on an **insert\\_recordset** statement that has a subselect."},{"content":"It also shows a <bpt id=\"p1\">**</bpt>while<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>select<ept id=\"p2\">**</ept> statement that has a similar join.","pos":[78570,78641],"source":" It also shows a **while** **select** statement that has a similar join."},{"content":"A variable is used to supply the inserted value for one column.","pos":[78642,78705]},{"content":"The <bpt id=\"p1\">**</bpt>str<ept id=\"p1\">**</ept> variable must be declared, and must have a length that is less than or equal to the maximum length of the corresponding database field.","pos":[78706,78853],"source":" The **str** variable must be declared, and must have a length that is less than or equal to the maximum length of the corresponding database field."},{"content":"In this example, there is an <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement for the tabEmplProj5 table.","pos":[78854,78942],"source":" In this example, there is an **insert\\_recordset** statement for the tabEmplProj5 table."},{"content":"One of the target fields is named <bpt id=\"p1\">**</bpt>Description<ept id=\"p1\">**</ept>, and the field's data comes from the local variable <bpt id=\"p2\">**</bpt>sDescriptionVariable<ept id=\"p2\">**</ept>.","pos":[78943,79070],"source":" One of the target fields is named **Description**, and the field's data comes from the local variable **sDescriptionVariable**."},{"content":"The <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement succeeds even when the configuration key for the <bpt id=\"p2\">**</bpt>Description<ept id=\"p2\">**</ept> field is turned off.","pos":[79071,79192],"source":" The **insert\\_recordset** statement succeeds even when the configuration key for the **Description** field is turned off."},{"content":"The system ignores both the <bpt id=\"p1\">**</bpt>Description<ept id=\"p1\">**</ept> field and the <bpt id=\"p2\">**</bpt>sDescriptionVariable<ept id=\"p2\">**</ept> variable.","pos":[79193,79285],"source":" The system ignores both the **Description** field and the **sDescriptionVariable** variable."},{"content":"Therefore, this code provides an example of <bpt id=\"p1\">*</bpt>configuration key automation<ept id=\"p1\">*</ept>.","pos":[79286,79361],"source":" Therefore, this code provides an example of *configuration key automation*."},{"content":"Configuration key automation occurs when the system can automatically adjust the behavior of an <bpt id=\"p1\">**</bpt>insert<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement that inserts data into fields that the configuration key is turned off for.","pos":[79362,79565],"source":" Configuration key automation occurs when the system can automatically adjust the behavior of an **insert\\_recordset** statement that inserts data into fields that the configuration key is turned off for."},{"pos":[81294,81311],"content":"update\\_recordset","linkify":"update\\_recordset","nodes":[{"content":"update<ph id=\"ph1\">\\_</ph>recordset","pos":[0,17],"source":"update\\_recordset"}]},{"content":"The <bpt id=\"p1\">**</bpt>update<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement lets you update multiple rows in one trip to the server.","pos":[81312,81404],"source":"The **update\\_recordset** statement lets you update multiple rows in one trip to the server."},{"content":"Therefore, the power of SQL Server can help improve the performance of some tasks.","pos":[81405,81487]},{"content":"The ****update<ph id=\"ph1\">\\_</ph>recordset**** statement resembles <bpt id=\"p1\">**</bpt>delete<ph id=\"ph2\">\\_</ph>from<ept id=\"p1\">**</ept> in X++ and <bpt id=\"p2\">**</bpt>update set<ept id=\"p2\">**</ept> in SQL.","pos":[81488,81588],"source":" The ****update\\_recordset**** statement resembles **delete\\_from** in X++ and **update set** in SQL."},{"content":"It doesn't retrieve each record separately by fetching, changing, and updating, Instead, it works on an SQL-style record set on the database server side.","pos":[81589,81742]},{"content":"If the <bpt id=\"p1\">**</bpt>update<ept id=\"p1\">**</ept> method is overridden, the implementation falls back to a classic looping construction, where one record at a time is updated.","pos":[81743,81886],"source":" If the **update** method is overridden, the implementation falls back to a classic looping construction, where one record at a time is updated."},{"content":"(This behavior resembles the behavior of <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> for deletions.) Therefore, the construction works on temporary tables and whole table–cached tables by using the looping construction.","pos":[81887,82079],"source":" (This behavior resembles the behavior of **delete\\_from** for deletions.) Therefore, the construction works on temporary tables and whole table–cached tables by using the looping construction."},{"pos":[82085,82136],"content":"Example: Update that is based on a calculated value","linkify":"Example: Update that is based on a calculated value","nodes":[{"content":"Example: Update that is based on a calculated value","pos":[0,51]}]},{"pos":[82138,82284],"content":"The following example updates the myTableBuffer table and increments the value of the <bpt id=\"p1\">**</bpt>field1<ept id=\"p1\">**</ept> field by ten percent in all records in the table.","source":"The following example updates the myTableBuffer table and increments the value of the **field1** field by ten percent in all records in the table."},{"pos":[82389,82429],"content":"Example: Update that uses a where clause","linkify":"Example: Update that uses a where clause","nodes":[{"content":"Example: Update that uses a where clause","pos":[0,40]}]},{"content":"The following example updates all records in the myTable table where the <bpt id=\"p1\">**</bpt>field1<ept id=\"p1\">**</ept> field has the value <bpt id=\"p2\">**</bpt>0<ept id=\"p2\">**</ept>.","pos":[82431,82541],"source":"The following example updates all records in the myTable table where the **field1** field has the value **0**."},{"content":"The <bpt id=\"p1\">**</bpt>field1<ept id=\"p1\">**</ept> field is assigned a new value of <bpt id=\"p2\">**</bpt>1<ept id=\"p2\">**</ept>.","pos":[82542,82596],"source":" The **field1** field is assigned a new value of **1**."},{"content":"The <bpt id=\"p1\">**</bpt>field2<ept id=\"p1\">**</ept> field is assigned a value that is the sum of <bpt id=\"p2\">**</bpt>fieldX<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>fieldY<ept id=\"p3\">**</ept>.","pos":[82597,82683],"source":" The **field2** field is assigned a value that is the sum of **fieldX** and **fieldY**."},{"content":"This example updates multiple fields at the same time, and it updates only those rows that satisfy the <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clause.","pos":[82684,82804],"source":" This example updates multiple fields at the same time, and it updates only those rows that satisfy the **where** clause."},{"pos":[82961,82992],"content":"Example: Updating joined tables","linkify":"Example: Updating joined tables","nodes":[{"content":"Example: Updating joined tables","pos":[0,31]}]},{"content":"The following example shows that the <bpt id=\"p1\">**</bpt>update<ph id=\"ph1\">\\_</ph>recordset<ept id=\"p1\">**</ept> statement supports joins of several tables.","pos":[82994,83096],"source":"The following example shows that the **update\\_recordset** statement supports joins of several tables."},{"content":"Data from the joined tables can be used to assign values to fields in the table that is being updated.","pos":[83097,83199]},{"pos":[83739,83751],"content":"delete\\_from","linkify":"delete\\_from","nodes":[{"content":"delete<ph id=\"ph1\">\\_</ph>from","pos":[0,12],"source":"delete\\_from"}]},{"content":"You can delete multiple records from a database table by using a <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> statement.","pos":[83752,83844],"source":"You can delete multiple records from a database table by using a **delete\\_from** statement."},{"content":"This approach can be more efficient and faster than an approach that uses the <bpt id=\"p1\">**</bpt>xRecord .delete<ept id=\"p1\">**</ept> method in a loop to delete one record at a time.","pos":[83845,83991],"source":" This approach can be more efficient and faster than an approach that uses the **xRecord .delete** method in a loop to delete one record at a time."},{"content":"If you've overridden the <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> method, the system interprets the <bpt id=\"p2\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p2\">**</ept> statement into code that calls the <bpt id=\"p3\">**</bpt>delete<ept id=\"p3\">**</ept> method one time for each row that is deleted.","pos":[83992,84170],"source":" If you've overridden the **delete** method, the system interprets the **delete\\_from** statement into code that calls the **delete** method one time for each row that is deleted."},{"pos":[84176,84235],"content":"Example: Efficiently deleting records by using delete\\_from","linkify":"Example: Efficiently deleting records by using delete\\_from","nodes":[{"content":"Example: Efficiently deleting records by using delete<ph id=\"ph1\">\\_</ph>from","pos":[0,59],"source":"Example: Efficiently deleting records by using delete\\_from"}]},{"content":"The following example shows an efficient way to delete multiple records.","pos":[84237,84309]},{"pos":[84486,84544],"content":"Example: Inefficiently deleting records by using forUpdate","linkify":"Example: Inefficiently deleting records by using forUpdate","nodes":[{"content":"Example: Inefficiently deleting records by using forUpdate","pos":[0,58]}]},{"content":"The following example is inefficient.","pos":[84546,84583]},{"content":"It issues a separate SQL <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> call to the database server for every record.","pos":[84584,84665],"source":" It issues a separate SQL **delete** call to the database server for every record."},{"content":"The <bpt id=\"p1\">**</bpt>xRecord<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>.delete<ept id=\"p2\">**</ept> method never deletes more than one record per call.","pos":[84666,84745],"source":" The **xRecord** **.delete** method never deletes more than one record per call."},{"pos":[85066,85116],"content":"Example: A delete operation that has an inner join","linkify":"Example: A delete operation that has an inner join","nodes":[{"content":"Example: A delete operation that has an inner join","pos":[0,50]}]},{"content":"Inner joins aren't supported on the <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> statement.","pos":[85118,85181],"source":"Inner joins aren't supported on the **delete\\_from** statement."},{"content":"Therefore, you can't use the unmodified <bpt id=\"p1\">**</bpt>join<ept id=\"p1\">**</ept> keyword on the <bpt id=\"p2\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p2\">**</ept> statement.","pos":[85182,85273],"source":" Therefore, you can't use the unmodified **join** keyword on the **delete\\_from** statement."},{"content":"However, you can logically accomplish an inner join by using other techniques.","pos":[85274,85352]},{"content":"The following example shows the new and old techniques for achieving inner join logic through a sequence of statements.","pos":[85353,85472]},{"pos":[86858,86922],"content":"Example: A delete operation that uses the notexists join keyword","linkify":"Example: A delete operation that uses the notexists join keyword","nodes":[{"content":"Example: A delete operation that uses the notexists join keyword","pos":[0,64]}]},{"content":"You can use the <bpt id=\"p1\">**</bpt>notexists join<ept id=\"p1\">**</ept> keyword pair in a <bpt id=\"p2\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p2\">**</ept> statement.","pos":[86924,87004],"source":"You can use the **notexists join** keyword pair in a **delete\\_from** statement."},{"content":"The <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> statements in the following example are efficient.","pos":[87005,87076],"source":" The **delete\\_from** statements in the following example are efficient."},{"content":"The <bpt id=\"p1\">**</bpt>notexists join<ept id=\"p1\">**</ept> clause enables the <bpt id=\"p2\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p2\">**</ept> statement to delete a specific set of rows.","pos":[87077,87179],"source":" The **notexists join** clause enables the **delete\\_from** statement to delete a specific set of rows."},{"content":"In this example, the <bpt id=\"p1\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p1\">**</ept> statement removes all parent-order header rows that there are no child-order line rows for.","pos":[87180,87309],"source":" In this example, the **delete\\_from** statement removes all parent-order header rows that there are no child-order line rows for."},{"content":"You can also use the <bpt id=\"p1\">**</bpt>exists join<ept id=\"p1\">**</ept> clause on the <bpt id=\"p2\">**</bpt>delete<ph id=\"ph1\">\\_</ph>from<ept id=\"p2\">**</ept> statement.","pos":[87310,87388],"source":" You can also use the **exists join** clause on the **delete\\_from** statement."},{"pos":[90761,90789],"content":"Maintain fast SQL operations","linkify":"Maintain fast SQL operations","nodes":[{"content":"Maintain fast SQL operations","pos":[0,28]}]},{"content":"There are situations where record set–based operations can be converted to slower record-by-record operations.","pos":[90790,90900]},{"content":"The following table identifies these situations.","pos":[90901,90949]},{"content":"Situation","pos":[90953,90962]},{"content":"DELETE<ph id=\"ph1\">\\_</ph>FROM","pos":[91032,91044],"source":"DELETE\\_FROM"},{"content":"UPDATE<ph id=\"ph1\">\\_</ph>RECORDSET","pos":[91047,91064],"source":"UPDATE\\_RECORDSET"},{"content":"INSERT<ph id=\"ph1\">\\_</ph>RECORDSET","pos":[91067,91084],"source":"INSERT\\_RECORDSET"},{"content":"ARRAY<ph id=\"ph1\">\\_</ph>INSERT","pos":[91087,91100],"source":"ARRAY\\_INSERT"},{"content":"Use this setting for overrides","pos":[91103,91133]},{"content":"Non-SQL tables","pos":[91323,91337]},{"content":"Yes","pos":[91402,91405]},{"content":"Yes","pos":[91417,91420]},{"content":"Yes","pos":[91437,91440]},{"content":"Yes","pos":[91457,91460]},{"content":"Not applicable","pos":[91473,91487]},{"content":"Delete actions","pos":[91508,91522]},{"content":"Yes","pos":[91587,91590]},{"content":"No","pos":[91602,91604]},{"content":"No","pos":[91622,91624]},{"content":"No","pos":[91642,91644]},{"pos":[91658,91679],"content":"<bpt id=\"p1\">**</bpt>skipDeleteActions<ept id=\"p1\">**</ept>","source":"**skipDeleteActions**"},{"content":"The database log is enabled.","pos":[91693,91721]},{"content":"Yes","pos":[91772,91775]},{"content":"Yes","pos":[91787,91790]},{"content":"Yes","pos":[91807,91810]},{"content":"No","pos":[91827,91829]},{"pos":[91843,91862],"content":"<bpt id=\"p1\">**</bpt>skipDatabaseLog<ept id=\"p1\">**</ept>","source":"**skipDatabaseLog**"},{"content":"Overridden method","pos":[91878,91895]},{"content":"Yes","pos":[91957,91960]},{"content":"Yes","pos":[91972,91975]},{"content":"Yes","pos":[91992,91995]},{"content":"Yes","pos":[92012,92015]},{"pos":[92028,92047],"content":"<bpt id=\"p1\">**</bpt>skipDataMethods<ept id=\"p1\">**</ept>","source":"**skipDataMethods**"},{"content":"Alerts are set up for the table.","pos":[92063,92095]},{"content":"Yes","pos":[92142,92145]},{"content":"Yes","pos":[92157,92160]},{"content":"Yes","pos":[92177,92180]},{"content":"No","pos":[92197,92199]},{"pos":[92213,92227],"content":"<bpt id=\"p1\">**</bpt>skipEvents<ept id=\"p1\">**</ept>","source":"**skipEvents**"},{"pos":[92248,92324],"content":"The <bpt id=\"p1\">**</bpt>ValidTimeStateFieldType<ept id=\"p1\">**</ept> property on a table isn't equal to <bpt id=\"p2\">**</bpt>None<ept id=\"p2\">**</ept>.","source":"The **ValidTimeStateFieldType** property on a table isn't equal to **None**."},{"content":"Yes","pos":[92327,92330]},{"content":"Yes","pos":[92342,92345]},{"content":"Yes","pos":[92362,92365]},{"content":"Yes","pos":[92382,92385]},{"content":"Not applicable","pos":[92398,92412]},{"content":"You can use the settings that are shown in the last column to explicitly skip or ignore one or more factors that adversely affect performance.","pos":[92432,92574]},{"content":"If, for some reason, one of the previously mentioned SQL operations is downgraded to a record-by-record operation, all the <bpt id=\"p1\">**</bpt>skip<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> settings are also ignored.","pos":[92575,92735],"source":" If, for some reason, one of the previously mentioned SQL operations is downgraded to a record-by-record operation, all the **skip\\*** settings are also ignored."},{"content":"For example, in the following code, the <bpt id=\"p1\">**</bpt>insert<ept id=\"p1\">**</ept> method on the myTable table is run, even though it's explicitly stated that this method should be skipped if a container or memo field is defined for myTable.","pos":[92736,92945],"source":" For example, in the following code, the **insert** method on the myTable table is run, even though it's explicitly stated that this method should be skipped if a container or memo field is defined for myTable."}]}