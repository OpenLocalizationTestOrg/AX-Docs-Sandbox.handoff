{"content":"---\n# required metadata\n\ntitle: Compute columns and virtual fields in a data entity\ndescription: This article provides information about computed and virtual fields, which are the two types of unmapped fields that a data entity can have. The article includes information about the properties of unmapped fields, and examples that show how to create, use, and test them.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \n# ms.reviewer: 61\nms.search.scope: AX 7.0.0, Operations, UnifiedOperations\n# ms.tgt_pltfrm: \nms.custom: 17891\nms.assetid: 88d230af-7d3d-49b3-bf19-69ecf81ed751\nms.search.region: Global\n# ms.search.industry: \nms.author: kuntalme\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# Compute columns and virtual fields in a data entity\n\n[!include[banner](../includes/banner.md)]\n\n\nThis article provides information about computed and virtual fields, which are the two types of unmapped fields that a data entity can have. The article includes information about the properties of unmapped fields, and examples that show how to create, use, and test them.\n\nOverview\n--------\n\nA data entity can have additional *unmapped* fields beyond those that are directly mapped to fields of the data sources. There are mechanisms for generating values for unmapped fields:\n\n-   Custom X++ code\n-   SQL executed by Microsoft SQL Server\n\nThe two types of unmapped fields are computed and virtual. Unmapped fields always support read actions, but the feature specification might not require any development effort to support write actions.\n\n### Computed field\n\n-   Value is generated by an SQL view computed column.\n-   During read, data is computed by SQL and is fetched directly from the view.\n-   For writes, custom X++ code must parse the input value and then write the parsed values to the regular fields of the data entity. The values are stored in the regular fields of the data sources of the entity.\n-   Computed fields are used mostly for reads.\n-   If possible, it's a good idea to use computed columns instead of virtual fields, because they are computed at the SQL Server level, whereas, virtual fields are computed row by row in X++.\n\n### Virtual field\n\n-   Is a non-persisted field.\n-   Is controlled by custom X++ code.\n-   Read and write happens through custom X++ code.\n-   Virtual fields are typically used for intake values that are calculated by using X++ code and can't be replaced by computed columns.\n\n### Properties of unmapped fields\n\n<table>\n<colgroup>\n<col width=\"20%\" />\n<col width=\"20%\" />\n<col width=\"20%\" />\n<col width=\"20%\" />\n<col width=\"20%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Category</th>\n<th>Name</th>\n<th>Type</th>\n<th>Default value</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Data</td>\n<td>IsComputedField</td>\n<td>NoYes</td>\n<td>Yes</td>\n<td><ul>\n<li><strong>Yes</strong> – The field is synchronized as a SQL view computed column. Requires an X++ method to compute the SQL definition string for the column. The virtual column definition is static and is used when the entity is synchronized. After that, the X++ method is not called at run time.</li>\n<li><strong>No</strong> – The field is a true virtual field, where inbound and outbound values are fully controlled through custom code.</li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td>Data</td>\n<td>ComputedFieldMethod</td>\n<td>String</td>\n<td></td>\n<td>A static <strong>DataEntity</strong> method in X++ to build the SQL expression that will generate the field definition. This property is disabled and irrelevant if the property <strong>IsComputedField</strong> is set to <strong>No</strong>. The method is required if the property <strong>IsComputedField</strong> is set to <strong>Yes</strong>.</td>\n</tr>\n<tr class=\"odd\">\n<td>Data</td>\n<td>ExtendedDataType</td>\n<td>String</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n\n## Example: Create a computed field\nIn this example, you add a computed field to the **FMCustomerEntity** entity. For reads, the field combines the name and address of the customer into a nice format. For writes, your X++ code parses the combined value into its separate name and address values, and then the code updates the regular name and address fields.\n\n1.  In Microsoft Visual Studio, right-click your project, and add the existing **FMCustomerEntity**.\n2.  In Solution Explorer, right-click the **FMCustomerEntity** node, and then click **Open**.\n3.  In the designer for **FMCustomerEntity**, right-click the **FMCustomerEntity** node, and then click **New** &gt; **String Unmapped Field**. [![Creating a new string unmapped field](./media/computedcolumnsandvirtualfields11.png)](./media/computedcolumnsandvirtualfields11.png)\n4.  Rename the new field **NameAndAddress**.\n5.  Update properties of the **NameAndAddress** unmapped field, as shown in the following screenshot. [![Updating the properties of the NameAndAddress unmapped field](./media/computedcolumnsandvirtualfields21.png)](./media/computedcolumnsandvirtualfields21.png)\n6.  Go to **FMCustomerEntity** &gt; **Methods**. Right-click the **Methods** node, and then click **New**. Ensure that the method name matches the **DataEntityView Method** property value of the unmapped computed field.\n7.  Paste the following X++ code into the method. The method returns the combined and formatted **NameAndAddress** value. **Note:** The **server** keyword is necessary.\n\n        private static server str formatNameAndAddress()   // X++\n        {\n            DataEntityName      dataEntityName= tablestr(FMCustomerEntity);\n            List                fieldList = new List(types::String);\n            ////Format name and address to look like following\n            ////John Smith, 123 Main St, Redmond, WA 98052\n            fieldList.addEnd(SysComputedColumn::returnField(DataEntityName, identifierstr(FMCustomer), fieldstr(FMCustomer, FirstName)));\n            fieldList.addEnd(SysComputedColumn::returnLiteral(\" \"));\n            fieldList.addEnd(SysComputedColumn::returnField(DataEntityName, identifierstr(FMCustomer), fieldstr(FMCustomer, LastName)));\n            fieldList.addEnd(SysComputedColumn::returnLiteral(\"; \"));\n            fieldList.addEnd(SysComputedColumn::returnField(DataEntityName, identifierstr(BillingAddress), fieldstr(FMAddressTable, AddressLine1)));\n            fieldList.addEnd(SysComputedColumn::returnLiteral(\", \"));\n            fieldList.addEnd(SysComputedColumn::returnField(DataEntityName, identifierstr(BillingAddress), fieldstr(FMAddressTable, City)));\n            fieldList.addEnd(SysComputedColumn::returnLiteral(\", \"));\n            fieldList.addEnd(SysComputedColumn::returnField(DataEntityName, identifierstr(BillingAddress), fieldstr(FMAddressTable, State)));\n            fieldList.addEnd(SysComputedColumn::returnLiteral(\", \"));\n            fieldList.addEnd(SysComputedColumn::cast(\n                SysComputedColumn::returnField(DataEntityName, identifierstr(BillingAddress), fieldstr(FMAddressTable, ZipCode)), \"NVARCHAR\"));\n            return SysComputedColumn::addList(fieldList);\n        }\n\n    T-SQL for the computed column.\n\n        ( Cast (( ( T1.firstname ) + ( N' ' ) + ( T1.lastname ) + ( N'; ' ) +\n                    ( T5.addressline1 )\n                + ( N', ' ) + ( T5.city ) + ( N', ' ) + ( T5.state ) + (\n                N', '\n                ) +\n                    ( Cast(T5.zipcode AS NVARCHAR) ) ) AS NVARCHAR(100))\n        )\n            AS\n        NAMEANDADDRESS\n\n    **Tip:** If you receive error in data entity synchronization because of computed columns, it's easier to come up with the SQL definition in Microsoft SQL Server Management Studio (SSMS) before using it in X++.\n\n8.  Rebuild the project.\n9.  Synchronize the database. Don't forget this step. You can do this by going to **Dynamics 365 **&gt; **Synchronize database** &gt; **Synchronize**.\n\n## Example: Create a virtual field\nIn this example, you add a virtual field to the **FMCustomerEntity** entity. This field displays the full name as a combination of the last name and first name. X++ code generates the combined value.\n\n1.  In the designer for the **FMCustomerEntity** entity, right-click the **Fields** node, and then click **New** &gt; **String Unmapped Field**.\n2.  In the properties pane for the unmapped field, set the **Name** property to **FullName**.\n3.  Set the **Is Computed Field** property to **No**. Notice that you leave the **DataEntityView Method** empty. [![Setting the properties for the unmapped field](./media/computedcolumnsandvirtualfields31.png)](./media/computedcolumnsandvirtualfields31.png)\n4.  In the **FMCustomerEntity** designer, right-click the **Methods** node, and then click **Override** &gt; **postLoad**. Your X++ code in this method will generate the values for the virtual field.\n5.  Paste the following X++ code in for the **postLoad** override. Notice that the **postLoad** method returns **void**.\n\n        public void postLoad()\n        {\n            super();\n            //Populate virtual field once entity has been loaded from database\n            //Format full name - \"Doe, John\"\n            this.FullName = this.LastName + \", \" + this.FirstName;\n        }\n\n6.  Compile your project.\n\n## Example: Use a virtual field to receive and parse an inbound field\nImagine that an external system sends the name of a person as a compound value that combines the last and first names in one field that comes into our system. However, our system stores the last and first names separately. For this scenario, you can use the **FullName** virtual field that you created. In this example, the major addition is an override of the **mapEntityToDataSource** method.\n\n1.  In the designer for the **FMCustomerEntity**, right-click the **Methods** node, and then click **Override** &gt; **mapEntityToDataSource**.\n2.  Paste the following X++ code in for the **mapEntityToDataSource** method.\n\n        public void mapEntityToDataSource(DataEntityRuntimeContext entityCtx, DataEntityDataSourceRuntimeContext dataSourceCtx)\n        {\n            super(entityCtx, dataSourceCtx);\n            //Check if desired data source context is available\n            if (dataSourceCtx.name() == \"FMCustomer\")\n            {\n                FMCustomer dsCustomer = dataSourceCtx.getBuffer();\n                //Find position of \",\" to parse full name format \"Doe, John\"\n                int commaPosition = strfind(this.FullName, \",\",0,strlen(this.FullName));\n                //Update FirstName and LastName in the data source buffer to update\n                dsCustomer.LastName = substr(this.FullName,0,commaPosition-1);\n                dsCustomer.FirstName = substr(this.FullName, commaPosition+1, strlen(this.FullName));\n            }\n        }\n\n    **Note:** When **update** is called, **mapEntityToDataSource** methods are invoked for each data source.\n\n## Test the computed and virtual fields\nThe following **main** method tests your computed and virtual fields. Both fields are tested in a read action, and the virtual field is tested in an update action.\n\n1.  For this example, ensure that you have the data set named **Fleet Management (migrated)**. The data set is available from the dashboard in the browser. Click the menu icon in the upper-right corner, click the **APP LINKS** menu, and then scroll to find the data set named **Fleet Management (migrated)**.\n2.  Paste the following X++ code into the startup object of your project. Run your project.\n\n        public static void main(Args _args)   // X++\n        {\n            FMCustomerEntity customer;\n            //Using transactions to avoid committing updates to database\n            ttsbegin;\n            //SELECT single customer entity record from the database\n            select customer\n                where customer.Email == \"phil.spencer@adatum.com\";\n            //Read full name (Virtual Field)\n            info(customer.FullName);\n            //Read formatted NameAndAddress(computed Field)\n            info(customer.NameAndAddress);\n            //UPDATE full name (virtual field)\n            customer.FullName = \"Doe, John\";\n            customer.update();\n            //Reselect data from database to get updated information\n            select customer\n                where customer.Email == \"phil.spencer@adatum.com\";\n            //Read full name (virtual field)\n            info(customer.FullName);\n            ttsabort;\n        }\n\n\n\n\n\n","nodes":[{"pos":[4,877],"content":"# required metadata\n\ntitle: Compute columns and virtual fields in a data entity\ndescription: This article provides information about computed and virtual fields, which are the two types of unmapped fields that a data entity can have. The article includes information about the properties of unmapped fields, and examples that show how to create, use, and test them.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \n# ms.reviewer: 61\nms.search.scope: AX 7.0.0, Operations, UnifiedOperations\n# ms.tgt_pltfrm: \nms.custom: 17891\nms.assetid: 88d230af-7d3d-49b3-bf19-69ecf81ed751\nms.search.region: Global\n# ms.search.industry: \nms.author: kuntalme\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n","nodes":[{"content":"Compute columns and virtual fields in a data entity","nodes":[{"pos":[0,51],"content":"Compute columns and virtual fields in a data entity","nodes":[{"content":"Compute columns and virtual fields in a data entity","pos":[0,51]}]}],"path":["title"]},{"content":"This article provides information about computed and virtual fields, which are the two types of unmapped fields that a data entity can have. The article includes information about the properties of unmapped fields, and examples that show how to create, use, and test them.","nodes":[{"pos":[0,272],"content":"This article provides information about computed and virtual fields, which are the two types of unmapped fields that a data entity can have. The article includes information about the properties of unmapped fields, and examples that show how to create, use, and test them.","nodes":[{"content":"This article provides information about computed and virtual fields, which are the two types of unmapped fields that a data entity can have. The article includes information about the properties of unmapped fields, and examples that show how to create, use, and test them.","pos":[0,272],"nodes":[{"content":"This article provides information about computed and virtual fields, which are the two types of unmapped fields that a data entity can have.","pos":[0,140]},{"content":"The article includes information about the properties of unmapped fields, and examples that show how to create, use, and test them.","pos":[141,272]}]}]}],"path":["description"]}],"header":"# required metadata\n","yml":true},{"pos":[885,936],"content":"Compute columns and virtual fields in a data entity","linkify":"Compute columns and virtual fields in a data entity","nodes":[{"content":"Compute columns and virtual fields in a data entity","pos":[0,51]}]},{"content":"This article provides information about computed and virtual fields, which are the two types of unmapped fields that a data entity can have.","pos":[982,1122]},{"content":"The article includes information about the properties of unmapped fields, and examples that show how to create, use, and test them.","pos":[1123,1254]},{"pos":[1256,1264],"content":"Overview","linkify":"Overview","nodes":[{"content":"Overview","pos":[0,8]}]},{"content":"A data entity can have additional <bpt id=\"p1\">*</bpt>unmapped<ept id=\"p1\">*</ept> fields beyond those that are directly mapped to fields of the data sources.","pos":[1275,1395],"source":"A data entity can have additional *unmapped* fields beyond those that are directly mapped to fields of the data sources."},{"content":"There are mechanisms for generating values for unmapped fields:","pos":[1396,1459]},{"content":"Custom X++ code","pos":[1465,1480]},{"content":"SQL executed by Microsoft SQL Server","pos":[1485,1521]},{"content":"The two types of unmapped fields are computed and virtual.","pos":[1523,1581]},{"content":"Unmapped fields always support read actions, but the feature specification might not require any development effort to support write actions.","pos":[1582,1723]},{"pos":[1729,1743],"content":"Computed field","linkify":"Computed field","nodes":[{"content":"Computed field","pos":[0,14]}]},{"content":"Value is generated by an SQL view computed column.","pos":[1749,1799]},{"content":"During read, data is computed by SQL and is fetched directly from the view.","pos":[1804,1879]},{"content":"For writes, custom X++ code must parse the input value and then write the parsed values to the regular fields of the data entity.","pos":[1884,2013]},{"content":"The values are stored in the regular fields of the data sources of the entity.","pos":[2014,2092]},{"content":"Computed fields are used mostly for reads.","pos":[2097,2139]},{"content":"If possible, it's a good idea to use computed columns instead of virtual fields, because they are computed at the SQL Server level, whereas, virtual fields are computed row by row in X++.","pos":[2144,2331]},{"pos":[2337,2350],"content":"Virtual field","linkify":"Virtual field","nodes":[{"content":"Virtual field","pos":[0,13]}]},{"content":"Is a non-persisted field.","pos":[2356,2381]},{"content":"Is controlled by custom X++ code.","pos":[2386,2419]},{"content":"Read and write happens through custom X++ code.","pos":[2424,2471]},{"content":"Virtual fields are typically used for intake values that are calculated by using X++ code and can't be replaced by computed columns.","pos":[2476,2608]},{"pos":[2614,2643],"content":"Properties of unmapped fields","linkify":"Properties of unmapped fields","nodes":[{"content":"Properties of unmapped fields","pos":[0,29]}]},{"content":"Category","pos":[2808,2816]},{"content":"Name","pos":[2826,2830]},{"content":"Type","pos":[2840,2844]},{"content":"Default value","pos":[2854,2867]},{"content":"Behavior","pos":[2877,2885]},{"content":"Data","pos":[2935,2939]},{"content":"IsComputedField","pos":[2949,2964]},{"content":"NoYes","pos":[2974,2979]},{"content":"Yes","pos":[2989,2992]},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>Yes<ept id=\"p1\">&lt;/strong&gt;</ept> – The field is synchronized as a SQL view computed column.","pos":[3011,3090],"source":"<strong>Yes</strong> – The field is synchronized as a SQL view computed column."},{"content":"Requires an X++ method to compute the SQL definition string for the column.","pos":[3091,3166]},{"content":"The virtual column definition is static and is used when the entity is synchronized.","pos":[3167,3251]},{"content":"After that, the X++ method is not called at run time.","pos":[3252,3305]},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>No<ept id=\"p1\">&lt;/strong&gt;</ept> – The field is a true virtual field, where inbound and outbound values are fully controlled through custom code.","pos":[3315,3447],"source":"<strong>No</strong> – The field is a true virtual field, where inbound and outbound values are fully controlled through custom code."},{"content":"Data","pos":[3492,3496]},{"content":"ComputedFieldMethod","pos":[3506,3525]},{"content":"String","pos":[3535,3541]},{"content":"A static <bpt id=\"p1\">&lt;strong&gt;</bpt>DataEntity<ept id=\"p1\">&lt;/strong&gt;</ept> method in X++ to build the SQL expression that will generate the field definition.","pos":[3561,3680],"source":"A static <strong>DataEntity</strong> method in X++ to build the SQL expression that will generate the field definition."},{"content":"This property is disabled and irrelevant if the property <bpt id=\"p1\">&lt;strong&gt;</bpt>IsComputedField<ept id=\"p1\">&lt;/strong&gt;</ept> is set to <bpt id=\"p2\">&lt;strong&gt;</bpt>No<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[3681,3801],"source":" This property is disabled and irrelevant if the property <strong>IsComputedField</strong> is set to <strong>No</strong>."},{"content":"The method is required if the property <bpt id=\"p1\">&lt;strong&gt;</bpt>IsComputedField<ept id=\"p1\">&lt;/strong&gt;</ept> is set to <bpt id=\"p2\">&lt;strong&gt;</bpt>Yes<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[3802,3905],"source":" The method is required if the property <strong>IsComputedField</strong> is set to <strong>Yes</strong>."},{"content":"Data","pos":[3938,3942]},{"content":"ExtendedDataType","pos":[3952,3968]},{"content":"String","pos":[3978,3984]},{"pos":[4038,4070],"content":"Example: Create a computed field","linkify":"Example: Create a computed field","nodes":[{"content":"Example: Create a computed field","pos":[0,32]}]},{"content":"In this example, you add a computed field to the <bpt id=\"p1\">**</bpt>FMCustomerEntity<ept id=\"p1\">**</ept> entity.","pos":[4071,4148],"source":"In this example, you add a computed field to the **FMCustomerEntity** entity."},{"content":"For reads, the field combines the name and address of the customer into a nice format.","pos":[4149,4235]},{"content":"For writes, your X++ code parses the combined value into its separate name and address values, and then the code updates the regular name and address fields.","pos":[4236,4393]},{"pos":[4399,4495],"content":"In Microsoft Visual Studio, right-click your project, and add the existing <bpt id=\"p1\">**</bpt>FMCustomerEntity<ept id=\"p1\">**</ept>.","source":"In Microsoft Visual Studio, right-click your project, and add the existing **FMCustomerEntity**."},{"pos":[4500,4589],"content":"In Solution Explorer, right-click the <bpt id=\"p1\">**</bpt>FMCustomerEntity<ept id=\"p1\">**</ept> node, and then click <bpt id=\"p2\">**</bpt>Open<ept id=\"p2\">**</ept>.","source":"In Solution Explorer, right-click the **FMCustomerEntity** node, and then click **Open**."},{"content":"In the designer for <bpt id=\"p1\">**</bpt>FMCustomerEntity<ept id=\"p1\">**</ept>, right-click the <bpt id=\"p2\">**</bpt>FMCustomerEntity<ept id=\"p2\">**</ept> node, and then click <bpt id=\"p3\">**</bpt>New<ept id=\"p3\">**</ept> <ph id=\"ph1\">&amp;gt;</ph> <bpt id=\"p4\">**</bpt>String Unmapped Field<ept id=\"p4\">**</ept>.","pos":[4594,4733],"source":"In the designer for **FMCustomerEntity**, right-click the **FMCustomerEntity** node, and then click **New** &gt; **String Unmapped Field**."},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Creating a new string unmapped field<ept id=\"p1\">](./media/computedcolumnsandvirtualfields11.png)](./media/computedcolumnsandvirtualfields11.png)</ept>","pos":[4734,4869],"source":"[![Creating a new string unmapped field](./media/computedcolumnsandvirtualfields11.png)](./media/computedcolumnsandvirtualfields11.png)"},{"pos":[4874,4914],"content":"Rename the new field <bpt id=\"p1\">**</bpt>NameAndAddress<ept id=\"p1\">**</ept>.","source":"Rename the new field **NameAndAddress**."},{"content":"Update properties of the <bpt id=\"p1\">**</bpt>NameAndAddress<ept id=\"p1\">**</ept> unmapped field, as shown in the following screenshot.","pos":[4919,5016],"source":"Update properties of the **NameAndAddress** unmapped field, as shown in the following screenshot."},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Updating the properties of the NameAndAddress unmapped field<ept id=\"p1\">](./media/computedcolumnsandvirtualfields21.png)](./media/computedcolumnsandvirtualfields21.png)</ept>","pos":[5017,5176],"source":"[![Updating the properties of the NameAndAddress unmapped field](./media/computedcolumnsandvirtualfields21.png)](./media/computedcolumnsandvirtualfields21.png)"},{"content":"Go to <bpt id=\"p1\">**</bpt>FMCustomerEntity<ept id=\"p1\">**</ept> <ph id=\"ph1\">&amp;gt;</ph> <bpt id=\"p2\">**</bpt>Methods<ept id=\"p2\">**</ept>.","pos":[5181,5225],"source":"Go to **FMCustomerEntity** &gt; **Methods**."},{"content":"Right-click the <bpt id=\"p1\">**</bpt>Methods<ept id=\"p1\">**</ept> node, and then click <bpt id=\"p2\">**</bpt>New<ept id=\"p2\">**</ept>.","pos":[5226,5283],"source":" Right-click the **Methods** node, and then click **New**."},{"content":"Ensure that the method name matches the <bpt id=\"p1\">**</bpt>DataEntityView Method<ept id=\"p1\">**</ept> property value of the unmapped computed field.","pos":[5284,5396],"source":" Ensure that the method name matches the **DataEntityView Method** property value of the unmapped computed field."},{"content":"Paste the following X++ code into the method.","pos":[5401,5446]},{"content":"The method returns the combined and formatted <bpt id=\"p1\">**</bpt>NameAndAddress<ept id=\"p1\">**</ept> value.","pos":[5447,5518],"source":" The method returns the combined and formatted **NameAndAddress** value."},{"content":"<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> The <bpt id=\"p2\">**</bpt>server<ept id=\"p2\">**</ept> keyword is necessary.","pos":[5519,5565],"source":"**Note:** The **server** keyword is necessary."},{"content":"T-SQL for the computed column.","pos":[7237,7267]},{"pos":[7628,7837],"content":"<bpt id=\"p1\">**</bpt>Tip:<ept id=\"p1\">**</ept> If you receive error in data entity synchronization because of computed columns, it's easier to come up with the SQL definition in Microsoft SQL Server Management Studio (SSMS) before using it in X++.","source":"**Tip:** If you receive error in data entity synchronization because of computed columns, it's easier to come up with the SQL definition in Microsoft SQL Server Management Studio (SSMS) before using it in X++."},{"content":"Rebuild the project.","pos":[7843,7863]},{"content":"Synchronize the database.","pos":[7868,7893]},{"content":"Don't forget this step.","pos":[7894,7917]},{"content":"You can do this by going to **Dynamics 365 **<ph id=\"ph1\">&amp;gt;</ph> <bpt id=\"p1\">**</bpt>Synchronize database<ept id=\"p1\">**</ept> <ph id=\"ph2\">&amp;gt;</ph> <bpt id=\"p2\">**</bpt>Synchronize<ept id=\"p2\">**</ept>.","pos":[7918,8014],"source":" You can do this by going to **Dynamics 365 **&gt; **Synchronize database** &gt; **Synchronize**."},{"pos":[8019,8050],"content":"Example: Create a virtual field","linkify":"Example: Create a virtual field","nodes":[{"content":"Example: Create a virtual field","pos":[0,31]}]},{"content":"In this example, you add a virtual field to the <bpt id=\"p1\">**</bpt>FMCustomerEntity<ept id=\"p1\">**</ept> entity.","pos":[8051,8127],"source":"In this example, you add a virtual field to the **FMCustomerEntity** entity."},{"content":"This field displays the full name as a combination of the last name and first name.","pos":[8128,8211]},{"content":"X++ code generates the combined value.","pos":[8212,8250]},{"pos":[8256,8396],"content":"In the designer for the <bpt id=\"p1\">**</bpt>FMCustomerEntity<ept id=\"p1\">**</ept> entity, right-click the <bpt id=\"p2\">**</bpt>Fields<ept id=\"p2\">**</ept> node, and then click <bpt id=\"p3\">**</bpt>New<ept id=\"p3\">**</ept> <ph id=\"ph1\">&amp;gt;</ph> <bpt id=\"p4\">**</bpt>String Unmapped Field<ept id=\"p4\">**</ept>.","source":"In the designer for the **FMCustomerEntity** entity, right-click the **Fields** node, and then click **New** &gt; **String Unmapped Field**."},{"pos":[8401,8490],"content":"In the properties pane for the unmapped field, set the <bpt id=\"p1\">**</bpt>Name<ept id=\"p1\">**</ept> property to <bpt id=\"p2\">**</bpt>FullName<ept id=\"p2\">**</ept>.","source":"In the properties pane for the unmapped field, set the **Name** property to **FullName**."},{"content":"Set the <bpt id=\"p1\">**</bpt>Is Computed Field<ept id=\"p1\">**</ept> property to <bpt id=\"p2\">**</bpt>No<ept id=\"p2\">**</ept>.","pos":[8495,8544],"source":"Set the **Is Computed Field** property to **No**."},{"content":"Notice that you leave the <bpt id=\"p1\">**</bpt>DataEntityView Method<ept id=\"p1\">**</ept> empty.","pos":[8545,8603],"source":" Notice that you leave the **DataEntityView Method** empty."},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Setting the properties for the unmapped field<ept id=\"p1\">](./media/computedcolumnsandvirtualfields31.png)](./media/computedcolumnsandvirtualfields31.png)</ept>","pos":[8604,8748],"source":"[![Setting the properties for the unmapped field](./media/computedcolumnsandvirtualfields31.png)](./media/computedcolumnsandvirtualfields31.png)"},{"content":"In the <bpt id=\"p1\">**</bpt>FMCustomerEntity<ept id=\"p1\">**</ept> designer, right-click the <bpt id=\"p2\">**</bpt>Methods<ept id=\"p2\">**</ept> node, and then click <bpt id=\"p3\">**</bpt>Override<ept id=\"p3\">**</ept> <ph id=\"ph1\">&amp;gt;</ph> <bpt id=\"p4\">**</bpt>postLoad<ept id=\"p4\">**</ept>.","pos":[8753,8871],"source":"In the **FMCustomerEntity** designer, right-click the **Methods** node, and then click **Override** &gt; **postLoad**."},{"content":"Your X++ code in this method will generate the values for the virtual field.","pos":[8872,8948]},{"content":"Paste the following X++ code in for the <bpt id=\"p1\">**</bpt>postLoad<ept id=\"p1\">**</ept> override.","pos":[8953,9015],"source":"Paste the following X++ code in for the **postLoad** override."},{"content":"Notice that the <bpt id=\"p1\">**</bpt>postLoad<ept id=\"p1\">**</ept> method returns <bpt id=\"p2\">**</bpt>void<ept id=\"p2\">**</ept>.","pos":[9016,9069],"source":" Notice that the **postLoad** method returns **void**."},{"content":"Compile your project.","pos":[9339,9360]},{"pos":[9365,9431],"content":"Example: Use a virtual field to receive and parse an inbound field","linkify":"Example: Use a virtual field to receive and parse an inbound field","nodes":[{"content":"Example: Use a virtual field to receive and parse an inbound field","pos":[0,66]}]},{"content":"Imagine that an external system sends the name of a person as a compound value that combines the last and first names in one field that comes into our system.","pos":[9432,9590]},{"content":"However, our system stores the last and first names separately.","pos":[9591,9654]},{"content":"For this scenario, you can use the <bpt id=\"p1\">**</bpt>FullName<ept id=\"p1\">**</ept> virtual field that you created.","pos":[9655,9734],"source":" For this scenario, you can use the **FullName** virtual field that you created."},{"content":"In this example, the major addition is an override of the <bpt id=\"p1\">**</bpt>mapEntityToDataSource<ept id=\"p1\">**</ept> method.","pos":[9735,9826],"source":" In this example, the major addition is an override of the **mapEntityToDataSource** method."},{"pos":[9832,9971],"content":"In the designer for the <bpt id=\"p1\">**</bpt>FMCustomerEntity<ept id=\"p1\">**</ept>, right-click the <bpt id=\"p2\">**</bpt>Methods<ept id=\"p2\">**</ept> node, and then click <bpt id=\"p3\">**</bpt>Override<ept id=\"p3\">**</ept> <ph id=\"ph1\">&amp;gt;</ph> <bpt id=\"p4\">**</bpt>mapEntityToDataSource<ept id=\"p4\">**</ept>.","source":"In the designer for the **FMCustomerEntity**, right-click the **Methods** node, and then click **Override** &gt; **mapEntityToDataSource**."},{"pos":[9976,10049],"content":"Paste the following X++ code in for the <bpt id=\"p1\">**</bpt>mapEntityToDataSource<ept id=\"p1\">**</ept> method.","source":"Paste the following X++ code in for the **mapEntityToDataSource** method."},{"pos":[10893,10997],"content":"<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> When <bpt id=\"p2\">**</bpt>update<ept id=\"p2\">**</ept> is called, <bpt id=\"p3\">**</bpt>mapEntityToDataSource<ept id=\"p3\">**</ept> methods are invoked for each data source.","source":"**Note:** When **update** is called, **mapEntityToDataSource** methods are invoked for each data source."},{"pos":[11002,11038],"content":"Test the computed and virtual fields","linkify":"Test the computed and virtual fields","nodes":[{"content":"Test the computed and virtual fields","pos":[0,36]}]},{"content":"The following <bpt id=\"p1\">**</bpt>main<ept id=\"p1\">**</ept> method tests your computed and virtual fields.","pos":[11039,11108],"source":"The following **main** method tests your computed and virtual fields."},{"content":"Both fields are tested in a read action, and the virtual field is tested in an update action.","pos":[11109,11202]},{"content":"For this example, ensure that you have the data set named <bpt id=\"p1\">**</bpt>Fleet Management (migrated)<ept id=\"p1\">**</ept>.","pos":[11208,11298],"source":"For this example, ensure that you have the data set named **Fleet Management (migrated)**."},{"content":"The data set is available from the dashboard in the browser.","pos":[11299,11359]},{"content":"Click the menu icon in the upper-right corner, click the <bpt id=\"p1\">**</bpt>APP LINKS<ept id=\"p1\">**</ept> menu, and then scroll to find the data set named <bpt id=\"p2\">**</bpt>Fleet Management (migrated)<ept id=\"p2\">**</ept>.","pos":[11360,11512],"source":" Click the menu icon in the upper-right corner, click the **APP LINKS** menu, and then scroll to find the data set named **Fleet Management (migrated)**."},{"content":"Paste the following X++ code into the startup object of your project.","pos":[11517,11586]},{"content":"Run your project.","pos":[11587,11604]}]}