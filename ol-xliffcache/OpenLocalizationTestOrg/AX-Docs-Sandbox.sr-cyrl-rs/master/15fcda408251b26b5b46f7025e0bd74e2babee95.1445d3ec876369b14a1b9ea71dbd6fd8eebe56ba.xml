{"content":"---\n# required metadata\n\ntitle: Extensible control programming reference\ndescription: This topic provides reference content for extensible control programming.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer, IT Pro\n# ms.devlang: \n# ms.reviewer: 61\nms.search.scope: AX 7.0.0, Operations, UnifiedOperations\n# ms.tgt_pltfrm: \nms.custom: 50211\nms.assetid: 0a774c73-9e5d-4faa-8716-61476c1a9b6e\nms.search.region: Global\n# ms.search.industry: \nms.author: shshabazz\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# Extensible control programming reference\n\n[!include[banner](../includes/banner.md)]\n\n\nThis topic provides reference content for extensible control programming.\n\nThis document describes the API, HTML, and JavaScript support for creating extensible controls.\n\n## Examples\nThis document contains small code snippets that show how to use each API that is documented. More complete examples of finished controls that leverage many of these APIs can be found on Github. [Extensible Control Examples on Github](http://github.com/Microsoft/Dynamics-AX-Extensible-Control-Samples)\n\n## Control block diagram\nThis high-level diagram illustrates the key components of an extensible control and how they interact with each other. Your extensible control solution will contain two X++ classes that implement your control. The runtime class implements the runtime data, presentation, and behavior of your control. The build class defines how your control is displayed in Form Designer, Property Window, and Application Explorer. [![ExtensibilityArchitecture](./media/extensibilityarchitecture.png)](./media/extensibilityarchitecture.png)\n\nX++\n---\n\nThe X++ API of your control is the Form-developer-facing API. Be sure to consider the APIs and behaviors you want to provide to the Form developer when designing the X++ APIs for your control.\n\n## Runtime: The X++ runtime class\nThe runtime class defines the public, developer-facing API for your control. It also contains the runtime logic for your control. The job of the runtime class is to maintain the state of the control via the control’s properties.\n\n## Runtime: Class declaration\nDeclare an X++ class that extends **FormTemplateControl** or a type derived from **FormTemplateControl***. ***FormTemplateControl** contains basic properties that are necessary for every control, such as the Template ID and the Resource Bundle. The following example extends the base control class, **FormTemplateControl**.\n\n    class MyControl extends FormTemplateControl\n\n## Runtime: FormControlAttribute\nYou must apply the **FormControlAttribute** attribute to the X++ class declaration.\n\n    [FormControlAttribute(<Template ID>, <Resource Bundle Path>, <Build class name>))]\n\nYou must supply the following arguments:\n\n-   **Template ID**: A string that specifies the ID of the template. The Template ID is the JavaScript class name & the HTML element ID of the control. By convention, the TemplateID matches the class name of the control's runtime class.\n-   **Resource Bundle Path**: A string that specifies the path to the resource bundle. The Resource Bundle Path is the web path where the main HTM files are located. At runtime, the Client framework will load the HTM file specified by the Resource Bundle Path. At runtime, the Client framework will search the Resource Bundle for the HTML element with an ID matching the specified Template ID. At runtime, the Client framework will instantiate the JavaScript class specified by the Template ID. This path is relative to the root of the web directory.\n-   **Build class name**: A string that specifies the name of the build class. The build class name is the X++ class that determines the design-time behavior. At design time, the Visual Studio framework reflects over this attribute and loads the specified X++ class as the designer class. At runtime, the X++ framework will instantiate the specified X++ class as the build class in the super of applyBuild().\n\nThe following example shows a typical class and attribute declaration for a control named \"MyControl\".\n\n    [FormControlAttribute('MyControl', '/resources/html/MyControl', classstr(MyControlBuild))]\n    class MyControl extends FormTemplateControl\n\n## Runtime: FormCommandAttribute\nThe **FormCommandAttribute** is applied to a method in your control class, which allows the method to be called from a control’s JavaScript class. A method with this attribute applied is called a **command.** Use the **FormCommandAttribute** on only the X++ methods that need to be accessed directly from the control’s JavaScript class. An X++ method serving as a command can only accept string arguments. The method must perform the necessary operations to serialize or deserialize the string arguments into other types. The **FormCommandAttribute** has no effect on the behavior of the X++ method when the method is used from within X++. The **FormCommandAttribute** exposes the X++ method as an external endpoint that is accessible from JavaScript. As such, every command should be threat modeled and tested for exploits, and should perform validation on all of its arguments. The underlying X++ method should be declared private so that it is not accessible from X++. If X++ code needs to access this method’s behavior, then a separate X++ method should be declared as public without the **FormCommandAttribute.** This public method should contain any shared code that is needed by both X++ and JavaScript. The private X++ method with the **FormCommandAttribute** can then call this public method to access the shared code. This practice allows the command to perform logic that is specific to calls coming from JavaScript (such as argument type deserialization, argument validation, security validation, etc.) before executing the core shared X++ logic. You supply the following arguments to the **FormCommandAttribute** constructor:\n\n-   **Name**: A required string that specifies the name of the command. A few best practices for naming Properties:\n    -   Capitalize the first letter, and use PascalCase.\n    -   Use a verb in the name.\n    -   Include the Property name if the Command is used to read/write a FormProperty (ex: Set\\_&lt;PropertyName&gt;)\n    -   Do not use any of the names of inherited JavaScript properties.\n-   **Execute immediate**: An optional boolean that specifies whether calls to this command are deferred or require immediate execution. By default, commands have **Execute immediate** set to **true,** so calls are not deferred. Most commands likely require immediate execution because their X++ logic must run before allowing the user to complete their next action. However, commands that have no side-effects on the user’s ability to take their next action can likely be safely deferred to gain a performance benefit. For commands that can be deferred, set Execute immediate to **false** to reduce network chattiness.\n\nThe following example declares a command with the name of \"SetText\".\n\n    [FormCommandAttribute(\"SetText\")]\n    private void setText(str value)\n    {\n        // Add implementation code here.\n    }\n\n## Runtime: FormPropertyAttribute\nThe **FormPropertyAttribute** is applied to a method in your control class, which allows an X++ method to be called as a **FormProperty** getter/setter from the control's JavaScript class. A method with this attribute applied is called a **property.** Only use the **FormPropertyAttribute** on those X++ methods which need to be accessed directly from the control’s JavaScript class. The **FormPropertyAttribute** has no effect on the behavior of the X++ method when the method is used from within X++. Every property exposes an endpoint to the browser. As such, every property should be threat modeled and tested for exploits. The underlying X++ method should be declared private so that it is not accessible from other X++ code. If other X++ code needs to access the property, then declare a separate public X++ method without the **FormPropertyAttibute,** and move the shared property logic to this method. Then call this method from the private X++ method with the **FormPropertyAttribute. This practice allows the property to perform logic that is specific to calls coming from JavaScript (such as argument type deserialization, argument validation, security validation, etc.) before executing the core shared X++ logic.** The underlying X++ method must accept and return the desired type of the property. If the desired type if an EDT, the property must accept and return the base type of the EDT. The supported property types are:\n\n-   [X++ primitive types](https://msdn.microsoft.com/en-us/library/aa602290.aspx)\n-   [X++ data contracts](https://msdn.microsoft.com/en-us/library/system.runtime.serialization.datacontractattribute(v=vs.110).aspx) (whose members are also supported types)\n-   [X++ List](https://msdn.microsoft.com/en-us/library/list.aspx) (whose items are also supported types)\n\nYou supply the following arguments to the **FormPropertyAttribute** constructor:\n\n-   **FormPropertyKind:** A required **FormProperyKind** value that specifies the type of the property. Use **FormPropertyKind::Value** for Properties not bound to a data source field, and use **FormPropertyKind::BindableValue** for properties that may be bound to a data source field.\n-   **Name:** A required string that specifies the name of the property. A few best practices for naming properties:\n    -   Capitalize the first letter, and use PascalCase.\n    -   Do not use any of the names of inherited JavaScript properties\n-   **Read only**: An optional boolean that specifies whether this property is writable from the control’s JavaScript class. By default, properties have **Read only** set to **false,** so they are writeable. This argument does not affect the ability to write to this property from X++. To make the X++ method read only, remove all method arguments from the method declaration. A majority of properties should not be writable from the control’s JavaScript class. Because most property values require validation, a command should be used as a setter for the property so that validation logic is can be run before the backing property is set.\n-   **Execute immediate**: An optional Boolean that specifies whether writes to this property are deferred or require immediate execution. By default, properties have **Execute immediate** set to **false,** so writes are deferred. Because the majority of properties should not be writeable form the control’s JavaScript class, the **Execute immediate** flag defaults to **false** and provides performance benefits. Even in the case of properties that are writable from the control’s JavaScript class, the performance side effects of immediate execution should be carefully considered before enabling the behavior.\n\nThe following example shows a typical property declaration. Most properties share the same boilerplate code for getting/setting, as shown below. The textProperty variable is the backing FormProperty field for this property.\n\n```\n[FormPropertyAttribute(FormPropertyKind::Value, \"Text\", true)\nprivate void parmText(str value = textProperty.parmValue())\n{\n        if(!prmisDefault(value))\n        {\n                textProperty.setValueOrBinding(value);\n        }\n        return textProperty.parmValue();\n}\n```\n\n## Runtime: FormProperty\n##### Behavior\n\n**FormProperty** is an X++ [derived type](https://msdn.microsoft.com/en-us/library/esd9wew8(v=vs.100).aspx) used by the control framework for the synchronization of property values between X++ and JavaScript. **FormProperty** objects are considered the backing fields used internally by properties. Each **FormProperty** is typically used in 4 places throughout a control’s X++ runtime class:\n\n1.  The **FormProperty** is declared, usually right below the class declaration\n2.  The **FormProperty** is instantiated in the **new** method of the class\n3.  The **FormProperty** is initialized in the **applyBuild** method of the class\n4.  The **FormProperty** is read and written in the X++ method for the property\n\nThe following example shows a **FormProperty** being used in a typical controls’ X++ runtime class.\n\n```\n[FormControlAttribute(\"MyControl\", \"/resources/html/MyControl\", classstr(BuildMyControl))]\nclass MyControl extends FormTemplateControl\n{             \n        FormProperty textProperty;          \n     \n        public void new(FormBuildControl _build, FormRun _formRun)\n        {\n                super(_build, _formRun);\n                this.setTemplateId(\"MyControl\");\n                this.setResourceBundleName(\"/resources/html/MyControl\");\n                textProperty = this.addProperty(\n                methodStr(MyControl, parmText), Types::String);\n        }\n\n        public void applyBuild()\n        {\n                BuildMyControl build;\n                super();\n                build = this.build();\n                if(build)\n                {\n                        this.parmText(build.Text());\n                }\n        }\n\n        [FormPropertyAttribute(FormPropertyKind::Value, \"Text\", true)\n        private void parmText(str value = textProperty.parmValue())\n        {\n                if(!prmisDefault(value))\n                {\n                        textProperty.setValueOrBinding(value);\n                }\n                return textProperty.parmValue();\n        }\n}\n```\n\n## Runtime: new method\nThe **new** method on a control’s X++ runtime class is called as a part of instantiating the control on a form. For the details on when the **new** method is called in the form lifecycle, please see the Control Lifecycle Diagrams. This method is used for instantiation of a control’s FormProperties and setting the control’s Template ID and Resource Bundle Path. See typical use of the **new** method in the example for FormProperty.\n\n## Runtime: applyBuild method\nThe **applyBuild** method on a control’s X++ runtime class is called as a part of instantiating the control on a form. For the details on when the **applyBuild** method is called in the form lifecycle, please see the Control Lifecycle Diagrams. This method is used for initialization of a control’s FormProperties to their default values, or to the values specified by the form developer who placed the control on the form. See typical use of the **applyBuild **method in the example for FormProperty.\n\n## Runtime: FormBindingUtil::initbinding method\nThe **FormBindingUtil** is an API provided by the control framework. It is used to bind FormProperties to data fields and data methods on a data source. The following example binds the data field with name \"Value\" on the data source with name \"DataSource1\" to the textProperty FormProperty of the runtime class.\n\n    [FormControlAttribute(\"MyControl\", \"/resources/html/MyControl\", classstr(BuildMyControl))]\n    class MyControl extends FormTemplateControl\n    {\n            FormProperty textProperty;\n            public void new(FormBuildControl _build, FormRun _formRun)\n            {\n                    super(_build, _formRun);\n                    this.setTemplateId(\"MyControl\");\n                    this.setResourceBundleName(\"/resources/html/MyControl\");\n                    textProperty = this.addProperty(\n                    methodStr(MyControl, parmText), Types::String);\n            }\n\n            public void applyBuild()\n            {\n                    BuildMyControl build;\n                    super();\n                    build = this.build();\n                    if(build)\n                    {\n                            this.parmText(FormBindingUtil::initBinding(\n                            \"DataSource1\", \"Value\", this.formRun()));\n                    }\n            }\n\n            [FormPropertyAttribute(FormPropertyKind::Value, \"Text\", true)\n            private void parmText(str value = textProperty.parmValue())\n            {\n                    if(!prmisDefault(value))\n                    {\n                            textProperty.setValueOrBinding(value);\n                    }\n                    return textProperty.parmValue();\n            }\n    }\n\n## Design time: The X++ build class\nThe build class defines the design time behavior of your control. This class determines which properties appear in the property sheet, and how the control behaves when it is modeled in the Form designer. The job of the design time class is to capture design time information for the runtime class to access later on.\n\n## Design time: Class declaration & FormDesignControlAttribute\nThe FormDesignControlAttribute is necessary for the control to appear in the Visual Studio Form designer when right-clicking on the design node of the form. If the FromDesignControlAttribute is missing, then the control can only be added to a form via imperative X++ code (i.e. via the addControlEx method on the form).\n\n    [FormDesignControlAttribute(\"MyControl\")]\n    class MyControlBuild extends FormBuildControl\n    {\n            \n    }\n\n## Design time: FormDesignPropertyAttribute\nPlacing this attribute on a method in the design time class will result in a new property with the name specified by the first argument (and in the section specified by the second argument) appearing the property sheet for this control, with the corresponding X++ method operating as the getter/setter for the property.\n\n    [FormDesignControlAttribute(\"MyControl\")]\n    class MyControlBuild extends FormBuildControl\n    {\n            str text; \n         \n            [FormDesignPropertyAttribute(\"Text\", \"Data\")]\n            public str Text(str value = text)\n            {\n                    if(!prmisDefault(value))\n                    {\n                            text = value;\n                    }\n                    return text;\n            }\n    }\n\n## Design time: FormDesignProperty** **Attribute\nThere are a number of FormDesignProperty attributes which may be applied alongside the standard FormDesignPropertyAttribute for specialized behavior in the property sheet. The specialized behavior includes enabling the property as a combobox which allows selecting from a list of a values. The different types of lists that used are enumerated below. Whenever the user selects an item from the combobox, the string name of that item is passed into the X++ method getter/setter with the attribute.\n\n-   \\[FormDesignPropertyDataSourceAttribute\\] - Shows a list of the data sources on the form.\n-   \\[FormDesignPropertyDataFieldAttribute(&lt;data source name&gt;)\\] - Shows a list of the data fields on the specified data source.\n-   \\[FormDesignPropertyDataMethodAttribute(&lt;data source name&gt;)\\] - Shows a list of the data methods on the specified data source.\n-   \\[FormDesignPropertyFieldGroupAttribute(&lt;data source name&gt;)\\] - Shows a list of the field groups on the specified data source.\n-   \\[FormDesignPropertyExtendsClassAttribute(&lt;class name&gt;)\\] - Shows a list of the classes which extend the specified class.\n-   \\[FormDesignPropertyImplementsAttribute(&lt;interface name&gt;)\\] - Shows a list of the classes which implement the specified interface.\n-   \\[FormDesignPropertyReferenceAttribute(&lt;FormDesignPropertyReferenceType::&lt;type&gt;)\\] - Shows a list of the specified AOT artifacts with the given type. The supported types are:\n    -   Table\n    -   View\n    -   Map\n    -   EDT\n    -   BaseEnum\n    -   Query\n    -   Class\n    -   Form\n    -   MenuItemDisplay\n    -   MenuItemOuput\n    -   MenuItemAction\n    -   Tile\n    -   KPI\n\nThe following example shows standard properties used to allow a Form developer to specify the Data Source and Data Field for the design time class.\n\n    [FormDesignControlAttribute(\"MyControl\")]\n    class MyControlBuild extends FormBuildControl\n    {\n            str dataSource; \n            str dataField;\n            str dataMethod;\n     \n            [FormDesignPropertyAttribute(\"Data source\", \"Data\"),\n            FormDesignPropertyDataSourceAttribute]\n            public str DataSource(str value = dataSource)\n            {\n                    if(!prmisDefault(value))\n                    {\n                            dataSource = value;\n                    }\n                    return dataSource;\n            }\n\n            [FormDesignPropertyAttribute(\"Data Field\", \"Data\"),\n            FormDesignPropertyDataFieldAttribute(methodStr(MyControlBuild, DataSource))]\n            public str DataField(str value = dataField)\n            {\n                    if(!prmisDefault(dataField))\n                    {\n                            dataField = value;\n                    }\n                    return dataField;\n            }\n\n            [FormDesignPropertyAttribute(\"Data Method\", \"Data\"),\n            FormDesignPropertyDataMethodAttribute(methodStr(MyControlBuild, DataSource))]\n            public str DataMethod(str value = dataMethod)\n            {\n                    if(!prmisDefault(dataMethod))\n                    {\n                            dataMethod = value;\n                    }\n                    return dataMethod;\n            }\n    }\n\nA control with a design time class like the one above can then bind to the specified data source and data field inside of the applyBuild method, as show below.\n\n    public void applyBuild()\n    {\n            BuildMyControl build;\n            super();\n            build = this.build();\n            if(build)\n            {\n                    this.parmText(FormBindingUtil::initBinding(\n                    build.DataSource(), build.DataField(), this.formRun(), build.DataMethod()));\n            }\n    }\n\nIf you supply both a data field and data method to FormBindingUtil::initBinding, the data field binding will override the data method binding.\n\n## HTML\nHTML: Framework attributes\n--------------------------\n\nThe following section documents the HTML attributes that are used in the control framework for control development.\n\n### data-dyn-bind\n\n**data-dyn-bind**, the data binding attribute, standardizes many common DOM manipulations - such as modifying an element’s attributes, properties and CSS, or handling DOM events - through a declarative HTML-based API. The data binding attribute allows for these behaviors without requiring complex JavaScript. Using the data binding attribute rather than writing complex JavaScript can save the control developer valuable time by making things such as designing, debugging and maintaining the control much easier. However, complex JavaScript is still available when scenarios require its use. The data binding attribute binds HTML element behaviors to values supplied by the control developer. The values supplied can be simple JavaScript [variables](http://www.w3schools.com/js/js_variables.asp), JavaScript [comparison](http://www.w3schools.com/js/js_comparisons.asp) or [arithmetic](http://www.w3schools.com/js/js_arithmetic.asp) expressions, JavaScript [functions](http://www.w3schools.com/js/js_functions.asp) and JSON [objects](https://www.w3schools.com/js/js_json_objects.asp). The values supplied can also be observable variables, created using the APIs described in this document. The way in which the supplied value is bound to the HTML element is determined by the binding handler that is used with the data binding attribute. A list of all supported binding handlers is provided in this document. The data binding attribute requires the following syntax when used with any binding handler. The syntax for **data-dyn-bind** is:\n\n    data-dyn-bind=\"[first binding handler]: [value to bind to]\"\n\nThe data binding attribute accepts a comma-separated list of binding handler-value pairs, so you can supply more than one binding handler to the binding attribute at a time. The following example binds the **visible** property of the div element to true, and binds the **textContent** property of the div element to \"Hi\".\n\n    data-dyn-bind=\"text: 'Hi', visible: true\"\n\nThe data binding attribute is a custom HTML attribute understood by the control framework. The data binding attribute can be applied to any HTML element. Some HTML elements may not have the behavior which the binding handler modifies. For example, using the text binding handler on an **&lt;svg&gt;** element will not show the text since the **&lt;svg&gt;** element does not have a textContent property. The control framework reads and executes the data bindings specified in the control’s template at runtime. The lifecycle for the control in the browser can be summarized as follows:\n\n1.  The control’s HTM file is loaded by the browser.\n2.  Any script or resource files referenced in the HTM file are also loaded by the browser. Steps 1 and 2 are executed only once during a user’s session, even if there are multiple instances of the control.\n3.  The JavaScript class's constructor for the control is call and passed with the X++ properties for the control instance.\n4.  The control’s template is copied from the HTM file and into the browser’s memory.\n5.  HTML elements in the control’s template are processed for data binding in hierarchical order (depth first), and data bindings on each element are executed in order from left-to-right\n6.  The final HTML, including the original data binding attributes as well as any other markup added by the binding handlers or by the framework, is added to the browser’s DOM and rendered for the user to see.\n7.  Later, when the value of an observable changes, any binding handlers subscribed to the observable are re-executed and the live DOM is updated in real-time.\n\n## HTML: Binding handlers\n### attr\n\nThe **attr** binding handler applies the supplied HTML attribute and value to the element. For a list of HTML attributes see [W3 Schools – HTML Attributes](http://www.w3schools.com/html/html_attributes.asp). The arguments are passed in as an object array. Each argument is dual-valued. The first value is the name of the attribute, and the second value is the value of the attribute.\n\n-   **Name**: a string that specifies the desired name of the attribute to create.\n-   **Value or Expression:** a string that specifies the value to set on the attribute. If an expression is supplied, the value returned by evaluating the expression will be used.\n\nThe following example creates the title and name attributes and sets their value.\n\n```\n<!-- the markup in the HTML template -->\n<div data-dyn-bind=\"attr: {title: 'Hello', name: 'Greeting'}\"></div>\n\n<!-- the markup in the browser after the binding handler is applied -->\n<div title=\"Hello\" data-dyn-bind=\"attr: {title: 'Hello', name: 'Greeting'}\" name=\"Greeting\"></div>\n```\n\nThe following example uses expressions and functions. However, using JavaScript functions as in-line HTML like the example below is not recommended.\n\n```\n<!-- the markup in the HTML template -->\n<div data-dyn-bind=\"attr: {title: false? 'Hello':'World', name: function(){return 'Greetings';}()}\"></div>\n\n<!-- the markup in the browser after the binding handler is applied -->\n<div title=\"World\" data-dyn-bind=\"attr: {title: false? 'Hello':'World', name: function(){return 'Greetings';}()}\" name=\"Greetings\"></div>\n```\n\n#### click\n\n##### Behavior\n\nSubscribes the supplied function to the click event on the element. For more information on subscribing to the click event see [jQuery – click()](http://api.jquery.com/click/).\n\n##### Arguments\n\n###### EventHandler (function)\n\nThe function to call when the event is raised.\n\n##### Example 1\n\nThe following example shows an alert message “Hello” when the element is clicked.\n\n```\n// In your control’s code-behind JS file\n<script>\n... // boilerplate code\nself.ElementClicked = function (event) {\n/* handle the click event */\nalert('Hello');\n};\n...\n</script>\n\n<!-- In your control’s template HTM file -->\n<div data-dyn-bind=\"click: $control.ElementClicked\"></div>\n```\n\nThe following example prevents the click event on child elements from bubbling up to parent elements. The example below will show only one alert with message “Hello” when the child element is clicked.\n\n```\n// In your control’s code-behind JS file\n<script>\n... // boilerplate code\nself.ParentElementClicked = function (event) {\n        /* handle the click event */\n        alert('Hi');\n};\n\nself.ElementClicked = function (event) {\n        /* prevents the event form bubbling up to parent elements*/\n        event.stopPropagation();\n\n        /* handle the click event */\n        alert('Hello');\n};\n\n...\n</script>\n\n<!-- In your control’s template HTM file -->\n<div data-dyn-bind=\"click: $control.ParentElementClicked\">\n<div data-dyn-bind=\"click: $control.ElementClicked\"></div>\n</div>\n```\n\nThe following example prevents the browser default behavior from executing. For anchor tags, the default hyperlink behavior is prevented, so the browser will not navigate to the link when the element is clicked.\n\n```\n// In your control’s code-behind JS file\n<script>\n... // boilerplate code\nself.LinkClicked = function (event) {\n        /* handle the click event */\n        alert($dyn.format('Navigation to ' + {0} + ' was prevented', $(event.target).attr(\"href\")));\n\n        /* prevents the default event behavior */\n        event.preventDefault();\n};\n</script>\n\n<!-- In your control’s template HTM file -->\n<a href=\"http://www.microsoft.com\" data-dyn-bind=\"click: $control.LinkClicked\">Click here</a>\n```\n\n#### css\n\n##### Behavior\n\nAdds or removes the specified CSS class name(s) to the element, based on the specified condition(s). Note that expressions supplied to the binding handler are only executed once.\n\n##### Arguments\n\nThe arguments are passed in as an object array. Each argument is dual-valued. The first value is the Class name, and the second value is the Condition.\n\n###### Class name (string)\n\nThe CSS class name to add to the element.\n\n###### Condition (expression)\n\nThe condition on which to add the CSS class name. If the condition evaluates to true, the CSS class name is added. If the condition evaluates to false, the CSS class name is removed. If a supplied condition takes a dependency on an observable (via $dyn.value), then the condition will be re-evaluated whenever the observable value changes, and the associated CSS class name will be added/removed based on the new condition. The following example adds the CSS class names \"red\", \"green\", and \"yellow\".\n\n```\n// In your control’s code-behind JS file\n<script>\n... // boilerplate code\nself.red = function () { return true; };\nself.yellow = $dyn.observable(true);\n...\n</script>\n\n<!-- the markup in the HTML template -->\n<div data-dyn-bind=\"css: {green: true, red: $control.red, yellow: $dyn.value($control.yellow)}\"></div>\n\n<!-- the markup in the browser after the binding handler is applied -->\n<div class=\"green red yellow\" data-dyn-bind=\"css: {green: true, red: $data.red, yellow: $dyn.value($control.yellow) }\"></div>\n```\n\n#### event\n\n##### Behavior\n\nSubscribes the supplied event handler to the specified DOM event. For a list of supported DOM events, see [jQuery - Event](http://api.jquery.com/Types/#Event).\n\n##### Arguments\n\nFor details on the arguments to the event binding handler, see [jQuery - .bind()](http://api.jquery.com/bind/). The following example subscribes to the mouseover event and shows an alert when the element is hovered.\n\n```\n// In your control’s code-behind JS file\n<script>\n... // boilerplate code\nself.elementHovered = function (event) { alert($dyn.format('{0}',$(event.target).text()))};\n...\n</script>\n\n<!-- the markup in the HTML template -->\n<div data-dyn-bind=\"event: {mouseover: $data.elementHovered}\">Greetings!</div>\n```\n\n#### foreach\n\n##### Behavior\n\nRepeats the content of the child element, updating the binding context of each child based on the supplied data. Supply ***only one*** child element inside of the element with the **foreach** binding. This one element is the element that will be cloned and repeated. Any other additional elements or content will be removed when the binding is applied. Binding handlers are executed in the order in which they appear on the element. Since the **foreach** binding changes the binding context, it is a best practice to always place the **foreach** binding after all other bindings on the element. This will ensure that preceding bindings are not affected by the binding context created by the **foreach** binding. To avoid performance issues, be careful to not create unintentional dependencies on observables inside of your **foreach.** Do not access an observable in the array using **$dyn.value** from within the child elements of the **foreach,** as the **foreach** binding has already subscribed to the observables in the array. Instead, use **$dyn.peek** to access an observable’s value once without creating a subscription.\n\n##### Arguments\n\n###### Data (array list or JSON object)\n\nThe list of items to bind the child element to. If an array list is supplied, the binding context is an item in the array. If a JSON object array is supplied, the binding context is one of the object’s properties.\n\n##### Scope variables\n\nWhen inside the scope of the **foreach,** the following scope variables are useful and can be used on the repeatable child element: $data, index, control, your own scope variables. The following example uses **foreach** to render a span element for each color in the array.\n\n```\n// In your control’s code-behind JS file\n<script>\n... // boilerplate code\nself.colors = ['Red','Blue','Green'];\n...\n</script>\n\n<!-- the markup in the HTML template -->\n<div data-dyn-bind=\"foreach: $control.Colors\">\n<span data-dyn-bind=\"text: $data\"></span>\n</div>\n\n<!-- the markup in the browser after the binding handler is applied -->\n<div data-dyn-bind=\"foreach: $control.colors\">\n<span data-dyn-bind=\"text: $data\">Red</span>\n<span data-dyn-bind=\"text: $data\">Blue</span>\n<span data-dyn-bind=\"text: $data\">Green</span>\n</div>\n```\n\nThe following examples shows a nested **foreach** binding. This example showcases how to use the index framework scope variable and custom scope variables to access the binding context from the parent element.\n\n```\n    // In your control’s code-behind JS file\n<script>\n... // boilerplate code\nself.colors = [\n{\n        Name: 'Red',\n        Variants: ['Maroon','Burgundy','Sunrise']\n},\n{\n        Name: 'Green',\n        Variants: ['Sage','Forest','Lime']\n},\n{\n        Name: 'Blue',\n        Variants: ['Navy','Sky','Ice']\n}\n];\n...\n</script>\n<!-- the markup in the HTML template -->\n<div data-dyn-bind=\"foreach: $control.colors\">\n<div data-dyn-bind=\"vars: {$BaseIndex: $index, $BaseColor: $data.Name}\">\n<div data-dyn-bind=\"foreach: $data.Variants\">\n<div data-dyn-bind=\"text: $BaseIndex+'.'+$index+' '+$data+' '+$BaseColor\"></div>\n</div>\n</div>\n</div>\n<!-- the markup in the browser after the binding handler is applied -->\n<div data-dyn-bind=\"foreach...\">\n<div data-dyn-bind=\"vars...\">\n<div data-dyn-bind=\"foreach...\">\n<div data-dyn-bind=\"vars...foreach...\">\n<div data-dyn-bind=\"text...\">1.1 (0.2552) X++ Language</div>\n<div data-dyn-bind=\"text...\">1.2 (0.7) Applications</div>\n</div>\n</div>\n<div data-dyn-bind=\"vars...\">\n<div data-dyn-bind=\"text...\">2. (600) Technology</div>\n<div data-dyn-bind=\"vars... foreach...\">\n<div data-dyn-bind=\"text...\">2.1 (600.343) Microsoft Coporation</div>\n<div data-dyn-bind=\"text...\">2.2 (600.117) Enterprise Resource Planning</div>\n</div>\n</div>\n</div>\n```\n\n#### if\n\n##### Behavior\n\nConditionally renders and binds the child elements of the element with this binding. This binding handler only operates on the child elements. It will not show/hide the element with the binding, nor will this binding show/hide the text content of the element with the binding. Bindings on the child elements will only be executed if the condition evaluates to true. Once the bindings on child elements have been evaluated once they will remain data bound even if the condition changes to false. This means that any calculations caused by bindings on child elements will continue to operate even after the child elements are hidden. Consider this when evaluating the performance of your control.\n\n##### Arguments\n\n###### Condition (expression)\n\nDetermines whether to render the children elements. The following example conditionally binds the **show** and **text** elements.\n\n```\n    // In your control’s code-behind JS file\n<script>\n... // boilerplate code\nself.show = $dyn.observable(false);\nself.text = \"Hello\";\n...\n</script>\n<!-- the markup in the HTML template -->\n<div data-dyn-bind=\"if: $control.show\">\n<div data-dyn-bind=\"text: $control.text\"></div>\n</div>\n<!-- the markup in the browser after the binding handler is applied -->\n<div data-dyn-bind=\"if: $control.show\">\n</div>\n// Later on, the value of the “show” observable changes to true\n<script>\n...\nself.show(true);\n...\n</script>\n<!-- the markup in the browser after the binding handler is re-applied due to the observable value changing -->\n<div data-dyn-bind=\"if: $control.show\">\n<div data-dyn-bind=\"text: $control.text\">Hello</div>\n</div>\n```\n\n#### sizing\n\n##### Behavior\n\nSpecifies the height and width of the control. The sizing binding handler should always be applied to the root element of the template (the element that has the id attribute), and supplied the height and width values from the X++ instance of the control by using the $dyn.layout.sizing helper function. See Example 1.\n\n##### Arguments\n\nThe arguments are passed an object containing height and width properties.\n\n###### Height (int)\n\nDetermines the height in pixels of the element on which the binding handler is applied.\n\n###### Width (int)\n\nDetermines the width in pixels of the element on which the binding handler is applied. The following example specifies the size of **MyControl.**\n\n```\n<!-- the markup in the HTML template -->\n<!-- this boilerplate binding ensures that the control’s container is sized based on the height and width properties -->\n<div id=\"MyControl\" data-dyn-bind=\"sizing: $dyn.layout.sizing($control)\"></div>\n<!-- the markup in browser after the binding handler is applied will vary based on the height and width properties defined in $control -->\n```\n\nThe following example makes the control large or small depending on the value of the **bigbox** variable.\n\n```\n// Later on, the value of the “show” observable changes to true\n<script>\n...\nself.bigBox = true;\n...\n</script>\n<!-- the markup in the HTML template -->\n<div data-dyn-bind=\"sizing: {height: $control.bigBox?50:10, width: $control.bigBox?50:10}\"></div>\n<!-- the markup in the browser after the binding handler is applied -->\n<div style=\"width: 50px; height: 50px;\" data-dyn-bind=\"sizing: {height: $control.bigBox?50:10, width: $control.bigBox?50:10}\"></div>\n```\n\n#### text\n\n##### Behavior\n\nBinds to the textContent property of the element. The text binding handler is meant to be used with UI text. It is not meant to bind non-string values (such as numbers, dates or Booleans) to the element. Convert all values into strings before supplying them to the binding handler, by using the dyn.format function. The text binding handler will replace all of the content inside of the element with the binding, whether or not the existing content is HTML or simple text.\n\n##### Arguments\n\n###### Text (string)\n\nThe text to bind to. The following example binds the textContext property of the div element to the text property on the control.\n\n```\n// In your control’s code-behind JS file\n<script>\n... // boilerplate code\nself.text = \"Hello\";\n...\n</script>\n<!-- the markup in the HTML template -->\n<div data-dyn-bind=\"text: $dyn.format('{0}',$control.text)\"></div>\n<!-- the markup in browser after the binding handler is applied -->\n<div data-dyn-bind=\"text: $dyn.format('{0}',$control.text)\">Hello</div>\n```\n\n#### vars\n\n##### Behavior\n\nCreates an HTML scope variable with the supplied name and value. The created scope variable is accessible only from bindings in the template. In addition, the scope variable is inherited by child elements. Binding handlers are executed in the order in which they appear on the element. Since the vars binding adds variables to the binding context, it is a best practice to always place the vars binding before all other bindings on the element. This will ensure that the subsequent bindings can access scope variables added by the vars binding. Do not create scope variables with any of the following names, as these names are reserved for framework scope variables: $control, $data, $index, and $value.\n\n##### Arguments\n\n###### Scope variables (object array)\n\nThe object array whose keys are the scope variable names and whose values are the initial values for the scope variables. The following example creates scope variables named \"Hello\" and \"World\" and displays their values.\n\n```\n<!-- the markup in the HTML template -->\n<div data-dyn-bind=\"vars: {$myVar: 'Hello', $myObs: $dyn.observable('World')}\">\n<span data-dyn-bind=\"text: $dyn.format('{0} {1}!', $myVar, $myObs)\">\n</span>\n</div>\n<!-- the markup in browser after the binding handler is applied -->\n<div data-dyn-bind=\"vars: {$myVar: 'Hello', $myObs: $dyn.observable('World')}\">\n<span data-dyn-bind=\"text: $dyn.format('{0} {1}!', $myVar, $myObs)\">\nHello World!\n</span>\n</div>\n```\n\n##### Example 2\n\nFor an example, see the foreach binding handler examples.\n\n#### visible\n\n##### Behavior\n\nSets the visibility of the element. Always supply the visible binding handler on the root element of the template, and bind to the *Visible* property from the X++ control. This will ensure that the control respects the *Visible* property when it is set by a form developer or when it is set by the framework. If a control is initialized with its *Visible* X++ property set to false, then the control will not appear on the form, and it the control’s template will not be loaded in the browser. If the control’s *Visible* X++ property is set to true at a later time, then the control’s template will be loaded and instantiated in the browser at that time. A control’s *Visible* X++ property can be inherited from its parent controls on the form. An element’s visibility may be controlled by its parent elements, controls and containers, regardless of whether the visible binding handler is applied. The cascading nature of visibility is a standard HTML behavior and is not specific to the control framework.\n\n##### Arguments\n\n###### Visible (boolean)\n\nDetermines whether the element is visible or not. The following example sets the visibility of the control's outermost div element.\n\n```\n// In your control’s code-behind JS file\n<script>\n... // boilerplate code\nself.Visible(false); // set the X++ observable property to false\n...\n</script>\n<!-- the markup on the root element of the HTML template -->\n<div id=\"MyControl\" data-dyn-bind=\"visible: $control.Visible\">Hello World!</div>\n<!-- the markup in browser after the binding handler is applied -->\n<div id=\"MyControl\" style=\"display: none;\" data-dyn-bind=\"visible: $control.Visible\">Hello World!</div>\n```\n\n## HTML: Scope variables\nScope variables can be used when binding values to binding handlers. Scope variables are only accessible from within the control’s HTML template, and can only be used with the data binding attribute. Scope variables are neither accessible from other HTML attributes nor from the control’s JavaScript class, but scope variables can be used in inline JavaScript expressions, functions and JSON objects that are passed to binding handlers.\n\n#### $control\n\nThe *$control* scope variable provides the bindings in the HTML template with access to the properties and functions on the control’s JavaScript instance. The following example binds visibility of the div element to the of Visible property of the control.\n\n```\n<div id=\"MyControl\" data-dyn-bind=\"visible: $control.Visible\"></div>\n```\n\n#### $data\n\nThe *$data* scope variable provides elements with access to their current binding context. Only variables defined in $data (the binding context) or scope variables, can be used inside of HTML bindings. Variables that do not exist in the current binding context and do not exist as current scope variable cannot be accessed from an HTML binding. In most cases the binding context will be the control’s JavaScript instance, so *$data* and *$control* will be equivalent. However, in some cases the binding context can change. For example, for elements inside of a **foreach** binding, *$data* provides the elements with access to the current array item. In cases involving multiple nested **foreach** bindings, elements in a nested binding may need access to the array item in a parent **foreach** binding. To access items in the parent **foreach** binding, you may create a scope variable which will be accessible to elements in the nested **foreach** biding. For an example, see the foreach binding handler examples.\n\n#### $index\n\nThe $index scope variable provides a 0-based index of the array item when in a **foreach** binding. For an example, see the foreach binding handler examples.\n\n## JavaScript: Inherited properties\n#### Visible\n\nThe **Visible** property is inherited from the base JavaScript class (via **$dyn.ui.Controls.apply**). There is also a **Visible** property in X++ that the runtime class in inherits from the base **FormControl** X++ class. Simply bind this property to the visible binding handler and place it on the root element of the HTML template for your control. The framework takes care of the rest. The following example shows how to use the Visible property.\n\n```\n<!-- the markup in the HTML template -->\n<div id=\"MyControl\" data-dyn-bind=\"visible: $control.Visible\"></div>\n```\n\n## Observable framework\n#### $dyn.observe\n\n##### Usage\n\nSubscribes a function to changes of an observable. We recommend that you use dispose.\n\n```\n$dyn.observe(observable, observer, [context], [disposableObserver])\n```\n\n##### Arguments\n\n###### Observable (observable)\n\nInstance of an observable. Or a function, which will become a $dyn.computed.\n\n###### Observer (function)\n\nFunction is invoked upon registration and also later when the observable is updated. Function is invoked with one argument, the value of the observable. If Observer returns false, then we un-subscribed automatically.\n\n###### Context (options, optional)\n\nContext to pass to the Observer. The Context becomes the ***this*** variable inside of the observer.\n\n###### DisposableObserver (options, optional)\n\nUnsubscribes the supplied DisposableObserver\n\n##### Returns\n\n###### Subscription (object)\n\nObservable, ID, Dispose function (public) used to unsubscribe The following example subscribes to the myObs observable, and executes the supplied function whenever the myObs observable value changes.\n\n```\n$dyn.observe(myObs, function (value) { console.log(value);});\n```\n\nThe following example shows how a function can automatically subscribe to observables simply by accessing the observable using $dyn.value. The first function is treated like an observable whose value is dependent upon the value of two other observables (FirstName and LastName). Every time one of the observables  (FirstName or LastName) changes its value, then the first function has also changed its value. When this happens, the second function (the callback function) will log the concatenation of the observable values to the console.\n\n```\nself.FirstName = $dyn.observable(\"Joanne\");\nself.LastName = $dyn.observable(\"Gordon\");\n$dyn.observe(\nfunction ()\n{\n        // Joann + \" \" + Gordon\n            return $dyn.value(self.FirstName) + \" \" + $dyn.value(self.LastName);\n},\nfunction (value)\n{\n            // \"Joanne Gordon\"\n            console.log(value);\n}\n);\n```\n\nThe following example performs similarly to the previous example. However, this example uses a computed observable, named myComp, to handle the concatenation.\n\n```\nself.FirstName = $dyn.observable(\"Joanne\");\nself.LastName = $dyn.observable(\"Gordon\");\nself.myComp = $dyn.computed(function ()\n{\n        // Joanne + \" \" + Gordon\n        return $dyn.value(self.FirstName) + \" \" + $dyn.value(self.LastName);\n});\n$dyn.observe(\nself.myComp,\nfunction (value)\n{\n        // \"Joanne Gordon\"\n        console.log(value)\n);\n},\n{FirstNameLabel: label1, LastNameLabel: label2}\n);\n```\n\n#### $dyn.observable\n\n##### Usage\n\nCreates an observable variable.\n\n```\n$dyn.observable([initial value])\n```\n\n##### Arguments\n\n###### Initial value (optional)\n\nThe value to initialize the observable to.\n\n##### Returns\n\n###### Observable (function)\n\nThe newly created observable The following example creates and observable variable named \"Hello\".\n\n    var greeting = $dyn.observable(\"Hello\");\n\n#### $dyn.value\n\n##### Usage\n\nAccesses the value of an observable variable. When **$dyn.value** is called from inside of an observer function (such as an observer passed to **$dyn.observe** or **$dyn.computed**, as well as the binding expression passed to a binding handler) a dependency on the observable is created. This will cause the binding handler or callback to re-execute whenever the value of the observable changes. Because this dependency is created automatically when using **$dyn.value**, it is important to only use **$dyn.value** when you intentionally wish to create such a dependency. If you wish to access the value of an observable without creating a dependency, you should use $dyn.peek.\n\n```\n$dyn.value(observable)\n```\n\n##### Arguments\n\n###### Observable\n\nThe observable property whose value to access.\n\n##### Returns\n\n###### Value\n\nThe current value in the observable property The following example returns the value of variable named observable and prints it to the console.\n\n```\nconsole.log($dyn.value(observable));\n```\n\n#### $dyn.peek\n\n##### Usage\n\nAccesses the value of an observable variable, without creating a dependency. For more information about dependency, see the $dyn.value function.\n\n```\n$dyn.peek(observable)\n```\n\n##### Arguments\n\n###### Observable\n\nThe observable whose value to access.\n\n##### Returns\n\n###### Value\n\nThe current value in the observable The following example returns the value of variable named observable and prints it to the console.\n\n```\nconsole.log($dyn.peek(observable));\n```\n\n#### $dyn.computed\n\n##### Usage\n\nWraps a function with an observability scope. If observables are accessed from inside of the function by using the **$dyn.value** function, then the function will re-execute whenever the values of those observables change. Observables that are accessed by using **$dyn.peek** will not cause the function to re-execute when their values change.\n\n```\n$dyn.computed(observer, [context], [disposableObserver])\n```\n\n##### Arguments\n\n###### Observer (function)\n\nFunction is invoked upon registration and can also be invoked later due to an observable value change. The Observer automatically observes any observables that are accessed using $dyn.value from within the scope of the function.\n\n###### Context (options, optional)\n\nContext to pass to the Observer. The Context becomes the *this* variable inside of the observer.\n\n###### DisposableObserver (options, optional)\n\nUnsubscribes the supplied DisposableObserver\n\n##### Returns\n\n###### Anything (optional)\n\nIf the Observer returns a value, then that value will also be returned by the call to **$dyn.computed** on the first time **$dyn.computed** is called (upon registration) as well every time the observer is invoked.\n\n## Framework functions\n#### $dyn.callFunction\n\n##### Usage\n\nCalls the apply method on specified function. Is cannot be used during an interaction.\n\n##### Arguments\n\n###### Function (function or observable)\n\nThe function to call. If an observable is supplied, the current value of the observable will be retrieved and used as the function.\n\n###### This (object, optional)\n\nThe object to assign to *this* within the scope of the function.\n\n###### Arguments (array, optional)\n\nThe arguments to pass to the supplied function.\n\n###### Callback (function, optional)\n\nThe callback function to call when the supplied Function has returned. The callback will be passed any values that are returned by the function that is called. The following example calls the **apply** function on the **printName** function.\n\n```\nself.Name = \"Joanne M Gordon\";\nvar printName = function () {\n        console.log(this.Name);\n};\n$dyn.callFunction(printName, self);\n```\n\nThe following example calls the **getWholeName** function.\n\n```\nvar getWholeName = function (first, middle, last) {\n        var wholeName = first + \" \" + middle + \" \" + last;\n        return wholeName;\n};\nvar printName = function (wholeName) {\nconsole.log(\"Your name is: \" + wholeName);\n};\nvar firstName = \"Joanne\";\nvar middleName = \"M\";\nvar lastName = \"Gordon\";\n$dyn.callFunction(getWholeName, null, [firstName , middleName, lastName], printName);\n```\n\n#### $dyn.format\n\n##### Usage\n\nBuilds a string using the supplied values according to the supplied format.\n\n##### Arguments\n\n###### Format (string)\n\nThe format in which to build the string. Use bracket notation for placeholders.\n\n###### Values (optional)\n\nThe comma separated values to use in the format\n\n##### Returns\n\n###### FormattedString (string)\n\nThe string after formatting has been applied The following example builds a string with the first, middle initial, and the last name.\n\n##### Example 1\n\n```\nvar first = \"Joanne\";\nvar middle = \"M\";\nvar last = \"Gordon\";\nvar $dyn.format(\"Your name is : {0} {1} {2}\", first, middle, last);\n```\n\n#### $dyn.label\n\n##### Usage\n\nProvides access to any labels stored via the Globalization API.\n\n##### Arguments\n\n###### Identifier (string)\n\nThe label ID, as specified to the Globalization API.\n\n##### Returns\n\n###### Value (string)\n\nThe label string in the current culture, if the Identifier is found. Otherwise, returns the supplied Identifier as a string. The following example returns and prints the label named \"greeting\".\n\n```\nGlobalize.addCultureInfo(\"en\", {\nmessages: {\n    \"greeting\": \"Hello!\"\n    },\n});\nconsole.log($dyn.label(\"greeting\"));\n```\n\nCSS\n---\n\nAdd namespaces to all CSS class names by prepending the class name with the control’s template ID. This will prevent your control and its styles from conflicting with other controls in the client.\n\n## Flexbox\nFor advanced layout scenarios we encourage using Flexbox. Flexbox is compatible with the Extensible Control framework. [Using CSS flexible boxes (Mozilla Developer Network)](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes) Please see the [public Flexbox documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes) for explanations and examples of the following topics:\n\n-   Responsive layouts\n-   Building columns and rows\n-   Arranging elements horizontally or vertically\n-   Arranging nesting elements\n-   Auto-sizing elements to stretch and shrink\n-   Locking/Freezing elements\n-   Building scrollable elements\n\nControl Lifecycle Diagrams\n==========================\n\n## Control Instantiation\n[![ExtensibilityProcess](./media/extensibilityprocess-951x1024.png)](./media/extensibilityprocess.png)\n\n\n\n\n\n","nodes":[{"pos":[4,676],"content":"# required metadata\n\ntitle: Extensible control programming reference\ndescription: This topic provides reference content for extensible control programming.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer, IT Pro\n# ms.devlang: \n# ms.reviewer: 61\nms.search.scope: AX 7.0.0, Operations, UnifiedOperations\n# ms.tgt_pltfrm: \nms.custom: 50211\nms.assetid: 0a774c73-9e5d-4faa-8716-61476c1a9b6e\nms.search.region: Global\n# ms.search.industry: \nms.author: shshabazz\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n","nodes":[{"content":"Extensible control programming reference","nodes":[{"pos":[0,40],"content":"Extensible control programming reference","nodes":[{"content":"Extensible control programming reference","pos":[0,40]}]}],"path":["title"]},{"content":"This topic provides reference content for extensible control programming.","nodes":[{"pos":[0,73],"content":"This topic provides reference content for extensible control programming.","nodes":[{"content":"This topic provides reference content for extensible control programming.","pos":[0,73]}]}],"path":["description"]}],"header":"# required metadata\n","yml":true},{"pos":[684,724],"content":"Extensible control programming reference","linkify":"Extensible control programming reference","nodes":[{"content":"Extensible control programming reference","pos":[0,40]}]},{"content":"This topic provides reference content for extensible control programming.","pos":[770,843]},{"content":"This document describes the API, HTML, and JavaScript support for creating extensible controls.","pos":[845,940]},{"pos":[945,953],"content":"Examples","linkify":"Examples","nodes":[{"content":"Examples","pos":[0,8]}]},{"content":"This document contains small code snippets that show how to use each API that is documented.","pos":[954,1046]},{"content":"More complete examples of finished controls that leverage many of these APIs can be found on Github.","pos":[1047,1147]},{"content":"<bpt id=\"p1\">[</bpt>Extensible Control Examples on Github<ept id=\"p1\">](http://github.com/Microsoft/Dynamics-AX-Extensible-Control-Samples)</ept>","pos":[1148,1255],"source":"[Extensible Control Examples on Github](http://github.com/Microsoft/Dynamics-AX-Extensible-Control-Samples)"},{"pos":[1260,1281],"content":"Control block diagram","linkify":"Control block diagram","nodes":[{"content":"Control block diagram","pos":[0,21]}]},{"content":"This high-level diagram illustrates the key components of an extensible control and how they interact with each other.","pos":[1282,1400]},{"content":"Your extensible control solution will contain two X++ classes that implement your control.","pos":[1401,1491]},{"content":"The runtime class implements the runtime data, presentation, and behavior of your control.","pos":[1492,1582]},{"content":"The build class defines how your control is displayed in Form Designer, Property Window, and Application Explorer.","pos":[1583,1697]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>ExtensibilityArchitecture<ept id=\"p1\">](./media/extensibilityarchitecture.png)](./media/extensibilityarchitecture.png)</ept>","pos":[1698,1806],"source":"[![ExtensibilityArchitecture](./media/extensibilityarchitecture.png)](./media/extensibilityarchitecture.png)"},{"pos":[1808,1811],"content":"X++","linkify":"X++","nodes":[{"content":"X++","pos":[0,3]}]},{"content":"The X++ API of your control is the Form-developer-facing API.","pos":[1817,1878]},{"content":"Be sure to consider the APIs and behaviors you want to provide to the Form developer when designing the X++ APIs for your control.","pos":[1879,2009]},{"pos":[2014,2044],"content":"Runtime: The X++ runtime class","linkify":"Runtime: The X++ runtime class","nodes":[{"content":"Runtime: The X++ runtime class","pos":[0,30]}]},{"content":"The runtime class defines the public, developer-facing API for your control.","pos":[2045,2121]},{"content":"It also contains the runtime logic for your control.","pos":[2122,2174]},{"content":"The job of the runtime class is to maintain the state of the control via the control’s properties.","pos":[2175,2273]},{"pos":[2278,2304],"content":"Runtime: Class declaration","linkify":"Runtime: Class declaration","nodes":[{"content":"Runtime: Class declaration","pos":[0,26]}]},{"content":"Declare an X++ class that extends <bpt id=\"p1\">**</bpt>FormTemplateControl<ept id=\"p1\">**</ept> or a type derived from <bpt id=\"p2\">**</bpt>FormTemplateControl<ept id=\"p2\">**</ept>*.","pos":[2305,2411],"source":"Declare an X++ class that extends **FormTemplateControl** or a type derived from **FormTemplateControl***."},{"content":"<ph id=\"ph1\"> *</ph><bpt id=\"p1\">**</bpt>FormTemplateControl<ept id=\"p1\">**</ept> contains basic properties that are necessary for every control, such as the Template ID and the Resource Bundle.","pos":[2411,2549],"source":" ***FormTemplateControl** contains basic properties that are necessary for every control, such as the Template ID and the Resource Bundle."},{"content":"The following example extends the base control class, <bpt id=\"p1\">**</bpt>FormTemplateControl<ept id=\"p1\">**</ept>.","pos":[2550,2628],"source":" The following example extends the base control class, **FormTemplateControl**."},{"pos":[2682,2711],"content":"Runtime: FormControlAttribute","linkify":"Runtime: FormControlAttribute","nodes":[{"content":"Runtime: FormControlAttribute","pos":[0,29]}]},{"pos":[2712,2795],"content":"You must apply the <bpt id=\"p1\">**</bpt>FormControlAttribute<ept id=\"p1\">**</ept> attribute to the X++ class declaration.","source":"You must apply the **FormControlAttribute** attribute to the X++ class declaration."},{"content":"You must supply the following arguments:","pos":[2885,2925]},{"content":"<bpt id=\"p1\">**</bpt>Template ID<ept id=\"p1\">**</ept>: A string that specifies the ID of the template.","pos":[2931,2995],"source":"**Template ID**: A string that specifies the ID of the template."},{"content":"The Template ID is the JavaScript class name &amp; the HTML element ID of the control.","pos":[2996,3078],"source":" The Template ID is the JavaScript class name & the HTML element ID of the control."},{"content":"By convention, the TemplateID matches the class name of the control's runtime class.","pos":[3079,3163]},{"content":"<bpt id=\"p1\">**</bpt>Resource Bundle Path<ept id=\"p1\">**</ept>: A string that specifies the path to the resource bundle.","pos":[3168,3250],"source":"**Resource Bundle Path**: A string that specifies the path to the resource bundle."},{"content":"The Resource Bundle Path is the web path where the main HTM files are located.","pos":[3251,3329]},{"content":"At runtime, the Client framework will load the HTM file specified by the Resource Bundle Path.","pos":[3330,3424]},{"content":"At runtime, the Client framework will search the Resource Bundle for the HTML element with an ID matching the specified Template ID.","pos":[3425,3557]},{"content":"At runtime, the Client framework will instantiate the JavaScript class specified by the Template ID.","pos":[3558,3658]},{"content":"This path is relative to the root of the web directory.","pos":[3659,3714]},{"content":"<bpt id=\"p1\">**</bpt>Build class name<ept id=\"p1\">**</ept>: A string that specifies the name of the build class.","pos":[3719,3793],"source":"**Build class name**: A string that specifies the name of the build class."},{"content":"The build class name is the X++ class that determines the design-time behavior.","pos":[3794,3873]},{"content":"At design time, the Visual Studio framework reflects over this attribute and loads the specified X++ class as the designer class.","pos":[3874,4003]},{"content":"At runtime, the X++ framework will instantiate the specified X++ class as the build class in the super of applyBuild().","pos":[4004,4123]},{"content":"The following example shows a typical class and attribute declaration for a control named \"MyControl\".","pos":[4125,4227]},{"pos":[4376,4405],"content":"Runtime: FormCommandAttribute","linkify":"Runtime: FormCommandAttribute","nodes":[{"content":"Runtime: FormCommandAttribute","pos":[0,29]}]},{"content":"The <bpt id=\"p1\">**</bpt>FormCommandAttribute<ept id=\"p1\">**</ept> is applied to a method in your control class, which allows the method to be called from a control’s JavaScript class.","pos":[4406,4552],"source":"The **FormCommandAttribute** is applied to a method in your control class, which allows the method to be called from a control’s JavaScript class."},{"content":"A method with this attribute applied is called a <bpt id=\"p1\">**</bpt>command.<ept id=\"p1\">**</ept>","pos":[4553,4614],"source":" A method with this attribute applied is called a **command.**"},{"content":"Use the <bpt id=\"p1\">**</bpt>FormCommandAttribute<ept id=\"p1\">**</ept> on only the X++ methods that need to be accessed directly from the control’s JavaScript class.","pos":[4615,4742],"source":" Use the **FormCommandAttribute** on only the X++ methods that need to be accessed directly from the control’s JavaScript class."},{"content":"An X++ method serving as a command can only accept string arguments.","pos":[4743,4811]},{"content":"The method must perform the necessary operations to serialize or deserialize the string arguments into other types.","pos":[4812,4927]},{"content":"The <bpt id=\"p1\">**</bpt>FormCommandAttribute<ept id=\"p1\">**</ept> has no effect on the behavior of the X++ method when the method is used from within X++.","pos":[4928,5045],"source":" The **FormCommandAttribute** has no effect on the behavior of the X++ method when the method is used from within X++."},{"content":"The <bpt id=\"p1\">**</bpt>FormCommandAttribute<ept id=\"p1\">**</ept> exposes the X++ method as an external endpoint that is accessible from JavaScript.","pos":[5046,5157],"source":" The **FormCommandAttribute** exposes the X++ method as an external endpoint that is accessible from JavaScript."},{"content":"As such, every command should be threat modeled and tested for exploits, and should perform validation on all of its arguments.","pos":[5158,5285]},{"content":"The underlying X++ method should be declared private so that it is not accessible from X++.","pos":[5286,5377]},{"content":"If X++ code needs to access this method’s behavior, then a separate X++ method should be declared as public without the <bpt id=\"p1\">**</bpt>FormCommandAttribute.<ept id=\"p1\">**</ept>","pos":[5378,5523],"source":" If X++ code needs to access this method’s behavior, then a separate X++ method should be declared as public without the **FormCommandAttribute.**"},{"content":"This public method should contain any shared code that is needed by both X++ and JavaScript.","pos":[5524,5616]},{"content":"The private X++ method with the <bpt id=\"p1\">**</bpt>FormCommandAttribute<ept id=\"p1\">**</ept> can then call this public method to access the shared code.","pos":[5617,5733],"source":" The private X++ method with the **FormCommandAttribute** can then call this public method to access the shared code."},{"content":"This practice allows the command to perform logic that is specific to calls coming from JavaScript (such as argument type deserialization, argument validation, security validation, etc.) before executing the core shared X++ logic.","pos":[5734,5964]},{"content":"You supply the following arguments to the <bpt id=\"p1\">**</bpt>FormCommandAttribute<ept id=\"p1\">**</ept> constructor:","pos":[5965,6044],"source":" You supply the following arguments to the **FormCommandAttribute** constructor:"},{"content":"<bpt id=\"p1\">**</bpt>Name<ept id=\"p1\">**</ept>: A required string that specifies the name of the command.","pos":[6050,6117],"source":"**Name**: A required string that specifies the name of the command."},{"content":"A few best practices for naming Properties:","pos":[6118,6161]},{"content":"Capitalize the first letter, and use PascalCase.","pos":[6170,6218]},{"content":"Use a verb in the name.","pos":[6227,6250]},{"content":"Include the Property name if the Command is used to read/write a FormProperty (ex: Set<ph id=\"ph1\">\\_</ph><ph id=\"ph2\">&amp;lt;</ph>PropertyName<ph id=\"ph3\">&amp;gt;</ph>)","pos":[6259,6368],"source":"Include the Property name if the Command is used to read/write a FormProperty (ex: Set\\_&lt;PropertyName&gt;)"},{"content":"Do not use any of the names of inherited JavaScript properties.","pos":[6377,6440]},{"content":"<bpt id=\"p1\">**</bpt>Execute immediate<ept id=\"p1\">**</ept>: An optional boolean that specifies whether calls to this command are deferred or require immediate execution.","pos":[6445,6577],"source":"**Execute immediate**: An optional boolean that specifies whether calls to this command are deferred or require immediate execution."},{"content":"By default, commands have <bpt id=\"p1\">**</bpt>Execute immediate<ept id=\"p1\">**</ept> set to <bpt id=\"p2\">**</bpt>true,<ept id=\"p2\">**</ept> so calls are not deferred.","pos":[6578,6669],"source":" By default, commands have **Execute immediate** set to **true,** so calls are not deferred."},{"content":"Most commands likely require immediate execution because their X++ logic must run before allowing the user to complete their next action.","pos":[6670,6807]},{"content":"However, commands that have no side-effects on the user’s ability to take their next action can likely be safely deferred to gain a performance benefit.","pos":[6808,6960]},{"content":"For commands that can be deferred, set Execute immediate to <bpt id=\"p1\">**</bpt>false<ept id=\"p1\">**</ept> to reduce network chattiness.","pos":[6961,7060],"source":" For commands that can be deferred, set Execute immediate to **false** to reduce network chattiness."},{"content":"The following example declares a command with the name of \"SetText\".","pos":[7062,7130]},{"pos":[7263,7293],"content":"Runtime: FormPropertyAttribute","linkify":"Runtime: FormPropertyAttribute","nodes":[{"content":"Runtime: FormPropertyAttribute","pos":[0,30]}]},{"content":"The <bpt id=\"p1\">**</bpt>FormPropertyAttribute<ept id=\"p1\">**</ept> is applied to a method in your control class, which allows an X++ method to be called as a <bpt id=\"p2\">**</bpt>FormProperty<ept id=\"p2\">**</ept> getter/setter from the control's JavaScript class.","pos":[7294,7482],"source":"The **FormPropertyAttribute** is applied to a method in your control class, which allows an X++ method to be called as a **FormProperty** getter/setter from the control's JavaScript class."},{"content":"A method with this attribute applied is called a <bpt id=\"p1\">**</bpt>property.<ept id=\"p1\">**</ept>","pos":[7483,7545],"source":" A method with this attribute applied is called a **property.**"},{"content":"Only use the <bpt id=\"p1\">**</bpt>FormPropertyAttribute<ept id=\"p1\">**</ept> on those X++ methods which need to be accessed directly from the control’s JavaScript class.","pos":[7546,7677],"source":" Only use the **FormPropertyAttribute** on those X++ methods which need to be accessed directly from the control’s JavaScript class."},{"content":"The <bpt id=\"p1\">**</bpt>FormPropertyAttribute<ept id=\"p1\">**</ept> has no effect on the behavior of the X++ method when the method is used from within X++.","pos":[7678,7796],"source":" The **FormPropertyAttribute** has no effect on the behavior of the X++ method when the method is used from within X++."},{"content":"Every property exposes an endpoint to the browser.","pos":[7797,7847]},{"content":"As such, every property should be threat modeled and tested for exploits.","pos":[7848,7921]},{"content":"The underlying X++ method should be declared private so that it is not accessible from other X++ code.","pos":[7922,8024]},{"content":"If other X++ code needs to access the property, then declare a separate public X++ method without the <bpt id=\"p1\">**</bpt>FormPropertyAttibute,<ept id=\"p1\">**</ept> and move the shared property logic to this method.","pos":[8025,8203],"source":" If other X++ code needs to access the property, then declare a separate public X++ method without the **FormPropertyAttibute,** and move the shared property logic to this method."},{"content":"Then call this method from the private X++ method with the <bpt id=\"p1\">**</bpt>FormPropertyAttribute. This practice allows the property to perform logic that is specific to calls coming from JavaScript (such as argument type deserialization, argument validation, security validation, etc.) before executing the core shared X++ logic.<ept id=\"p1\">**</ept>","pos":[8204,8521],"source":" Then call this method from the private X++ method with the **FormPropertyAttribute. This practice allows the property to perform logic that is specific to calls coming from JavaScript (such as argument type deserialization, argument validation, security validation, etc.) before executing the core shared X++ logic.**"},{"content":"The underlying X++ method must accept and return the desired type of the property.","pos":[8522,8604]},{"content":"If the desired type if an EDT, the property must accept and return the base type of the EDT.","pos":[8605,8697]},{"content":"The supported property types are:","pos":[8698,8731]},{"pos":[8737,8814],"content":"<bpt id=\"p1\">[</bpt>X++ primitive types<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/aa602290.aspx)</ept>","source":"[X++ primitive types](https://msdn.microsoft.com/en-us/library/aa602290.aspx)"},{"pos":[8819,8988],"content":"<bpt id=\"p1\">[</bpt>X++ data contracts<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/system.runtime.serialization.datacontractattribute(v=vs.110).aspx)</ept> (whose members are also supported types)","source":"[X++ data contracts](https://msdn.microsoft.com/en-us/library/system.runtime.serialization.datacontractattribute(v=vs.110).aspx) (whose members are also supported types)"},{"pos":[8993,9094],"content":"<bpt id=\"p1\">[</bpt>X++ List<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/list.aspx)</ept> (whose items are also supported types)","source":"[X++ List](https://msdn.microsoft.com/en-us/library/list.aspx) (whose items are also supported types)"},{"pos":[9096,9176],"content":"You supply the following arguments to the <bpt id=\"p1\">**</bpt>FormPropertyAttribute<ept id=\"p1\">**</ept> constructor:","source":"You supply the following arguments to the **FormPropertyAttribute** constructor:"},{"content":"<bpt id=\"p1\">**</bpt>FormPropertyKind:<ept id=\"p1\">**</ept> A required <bpt id=\"p2\">**</bpt>FormProperyKind<ept id=\"p2\">**</ept> value that specifies the type of the property.","pos":[9182,9281],"source":"**FormPropertyKind:** A required **FormProperyKind** value that specifies the type of the property."},{"content":"Use <bpt id=\"p1\">**</bpt>FormPropertyKind::Value<ept id=\"p1\">**</ept> for Properties not bound to a data source field, and use <bpt id=\"p2\">**</bpt>FormPropertyKind::BindableValue<ept id=\"p2\">**</ept> for properties that may be bound to a data source field.","pos":[9282,9463],"source":" Use **FormPropertyKind::Value** for Properties not bound to a data source field, and use **FormPropertyKind::BindableValue** for properties that may be bound to a data source field."},{"content":"<bpt id=\"p1\">**</bpt>Name:<ept id=\"p1\">**</ept> A required string that specifies the name of the property.","pos":[9468,9536],"source":"**Name:** A required string that specifies the name of the property."},{"content":"A few best practices for naming properties:","pos":[9537,9580]},{"content":"Capitalize the first letter, and use PascalCase.","pos":[9589,9637]},{"content":"Do not use any of the names of inherited JavaScript properties","pos":[9646,9708]},{"content":"<bpt id=\"p1\">**</bpt>Read only<ept id=\"p1\">**</ept>: An optional boolean that specifies whether this property is writable from the control’s JavaScript class.","pos":[9713,9833],"source":"**Read only**: An optional boolean that specifies whether this property is writable from the control’s JavaScript class."},{"content":"By default, properties have <bpt id=\"p1\">**</bpt>Read only<ept id=\"p1\">**</ept> set to <bpt id=\"p2\">**</bpt>false,<ept id=\"p2\">**</ept> so they are writeable.","pos":[9834,9916],"source":" By default, properties have **Read only** set to **false,** so they are writeable."},{"content":"This argument does not affect the ability to write to this property from X++.","pos":[9917,9994]},{"content":"To make the X++ method read only, remove all method arguments from the method declaration.","pos":[9995,10085]},{"content":"A majority of properties should not be writable from the control’s JavaScript class.","pos":[10086,10170]},{"content":"Because most property values require validation, a command should be used as a setter for the property so that validation logic is can be run before the backing property is set.","pos":[10171,10348]},{"content":"<bpt id=\"p1\">**</bpt>Execute immediate<ept id=\"p1\">**</ept>: An optional Boolean that specifies whether writes to this property are deferred or require immediate execution.","pos":[10353,10487],"source":"**Execute immediate**: An optional Boolean that specifies whether writes to this property are deferred or require immediate execution."},{"content":"By default, properties have <bpt id=\"p1\">**</bpt>Execute immediate<ept id=\"p1\">**</ept> set to <bpt id=\"p2\">**</bpt>false,<ept id=\"p2\">**</ept> so writes are deferred.","pos":[10488,10579],"source":" By default, properties have **Execute immediate** set to **false,** so writes are deferred."},{"content":"Because the majority of properties should not be writeable form the control’s JavaScript class, the <bpt id=\"p1\">**</bpt>Execute immediate<ept id=\"p1\">**</ept> flag defaults to <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> and provides performance benefits.","pos":[10580,10763],"source":" Because the majority of properties should not be writeable form the control’s JavaScript class, the **Execute immediate** flag defaults to **false** and provides performance benefits."},{"content":"Even in the case of properties that are writable from the control’s JavaScript class, the performance side effects of immediate execution should be carefully considered before enabling the behavior.","pos":[10764,10962]},{"content":"The following example shows a typical property declaration.","pos":[10964,11023]},{"content":"Most properties share the same boilerplate code for getting/setting, as shown below.","pos":[11024,11108]},{"content":"The textProperty variable is the backing FormProperty field for this property.","pos":[11109,11187]},{"pos":[11476,11497],"content":"Runtime: FormProperty","linkify":"Runtime: FormProperty","nodes":[{"content":"Runtime: FormProperty","pos":[0,21]}]},{"pos":[11504,11512],"content":"Behavior","linkify":"Behavior","nodes":[{"content":"Behavior","pos":[0,8]}]},{"content":"<bpt id=\"p1\">**</bpt>FormProperty<ept id=\"p1\">**</ept> is an X++ <bpt id=\"p2\">[</bpt>derived type<ept id=\"p2\">](https://msdn.microsoft.com/en-us/library/esd9wew8(v=vs.100).aspx)</ept> used by the control framework for the synchronization of property values between X++ and JavaScript.","pos":[11514,11722],"source":"**FormProperty** is an X++ [derived type](https://msdn.microsoft.com/en-us/library/esd9wew8(v=vs.100).aspx) used by the control framework for the synchronization of property values between X++ and JavaScript."},{"content":"<bpt id=\"p1\">**</bpt>FormProperty<ept id=\"p1\">**</ept> objects are considered the backing fields used internally by properties.","pos":[11723,11812],"source":"**FormProperty** objects are considered the backing fields used internally by properties."},{"content":"Each <bpt id=\"p1\">**</bpt>FormProperty<ept id=\"p1\">**</ept> is typically used in 4 places throughout a control’s X++ runtime class:","pos":[11813,11906],"source":" Each **FormProperty** is typically used in 4 places throughout a control’s X++ runtime class:"},{"pos":[11912,11987],"content":"The <bpt id=\"p1\">**</bpt>FormProperty<ept id=\"p1\">**</ept> is declared, usually right below the class declaration","source":"The **FormProperty** is declared, usually right below the class declaration"},{"pos":[11992,12063],"content":"The <bpt id=\"p1\">**</bpt>FormProperty<ept id=\"p1\">**</ept> is instantiated in the <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> method of the class","source":"The **FormProperty** is instantiated in the **new** method of the class"},{"pos":[12068,12145],"content":"The <bpt id=\"p1\">**</bpt>FormProperty<ept id=\"p1\">**</ept> is initialized in the <bpt id=\"p2\">**</bpt>applyBuild<ept id=\"p2\">**</ept> method of the class","source":"The **FormProperty** is initialized in the **applyBuild** method of the class"},{"pos":[12150,12225],"content":"The <bpt id=\"p1\">**</bpt>FormProperty<ept id=\"p1\">**</ept> is read and written in the X++ method for the property","source":"The **FormProperty** is read and written in the X++ method for the property"},{"pos":[12227,12326],"content":"The following example shows a <bpt id=\"p1\">**</bpt>FormProperty<ept id=\"p1\">**</ept> being used in a typical controls’ X++ runtime class.","source":"The following example shows a **FormProperty** being used in a typical controls’ X++ runtime class."},{"pos":[13524,13543],"content":"Runtime: new method","linkify":"Runtime: new method","nodes":[{"content":"Runtime: new method","pos":[0,19]}]},{"content":"The <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method on a control’s X++ runtime class is called as a part of instantiating the control on a form.","pos":[13544,13655],"source":"The **new** method on a control’s X++ runtime class is called as a part of instantiating the control on a form."},{"content":"For the details on when the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method is called in the form lifecycle, please see the Control Lifecycle Diagrams.","pos":[13656,13774],"source":" For the details on when the **new** method is called in the form lifecycle, please see the Control Lifecycle Diagrams."},{"content":"This method is used for instantiation of a control’s FormProperties and setting the control’s Template ID and Resource Bundle Path.","pos":[13775,13906]},{"content":"See typical use of the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method in the example for FormProperty.","pos":[13907,13977],"source":" See typical use of the **new** method in the example for FormProperty."},{"pos":[13982,14008],"content":"Runtime: applyBuild method","linkify":"Runtime: applyBuild method","nodes":[{"content":"Runtime: applyBuild method","pos":[0,26]}]},{"content":"The <bpt id=\"p1\">**</bpt>applyBuild<ept id=\"p1\">**</ept> method on a control’s X++ runtime class is called as a part of instantiating the control on a form.","pos":[14009,14127],"source":"The **applyBuild** method on a control’s X++ runtime class is called as a part of instantiating the control on a form."},{"content":"For the details on when the <bpt id=\"p1\">**</bpt>applyBuild<ept id=\"p1\">**</ept> method is called in the form lifecycle, please see the Control Lifecycle Diagrams.","pos":[14128,14253],"source":" For the details on when the **applyBuild** method is called in the form lifecycle, please see the Control Lifecycle Diagrams."},{"content":"This method is used for initialization of a control’s FormProperties to their default values, or to the values specified by the form developer who placed the control on the form.","pos":[14254,14432]},{"content":"See typical use of the **applyBuild **method in the example for FormProperty.","pos":[14433,14510]},{"pos":[14515,14559],"content":"Runtime: FormBindingUtil::initbinding method","linkify":"Runtime: FormBindingUtil::initbinding method","nodes":[{"content":"Runtime: FormBindingUtil::initbinding method","pos":[0,44]}]},{"content":"The <bpt id=\"p1\">**</bpt>FormBindingUtil<ept id=\"p1\">**</ept> is an API provided by the control framework.","pos":[14560,14628],"source":"The **FormBindingUtil** is an API provided by the control framework."},{"content":"It is used to bind FormProperties to data fields and data methods on a data source.","pos":[14629,14712]},{"content":"The following example binds the data field with name \"Value\" on the data source with name \"DataSource1\" to the textProperty FormProperty of the runtime class.","pos":[14713,14871]},{"pos":[16245,16277],"content":"Design time: The X++ build class","linkify":"Design time: The X++ build class","nodes":[{"content":"Design time: The X++ build class","pos":[0,32]}]},{"content":"The build class defines the design time behavior of your control.","pos":[16278,16343]},{"content":"This class determines which properties appear in the property sheet, and how the control behaves when it is modeled in the Form designer.","pos":[16344,16481]},{"content":"The job of the design time class is to capture design time information for the runtime class to access later on.","pos":[16482,16594]},{"pos":[16599,16658],"content":"Design time: Class declaration & FormDesignControlAttribute","linkify":"Design time: Class declaration & FormDesignControlAttribute","nodes":[{"content":"Design time: Class declaration &amp; FormDesignControlAttribute","pos":[0,59],"source":"Design time: Class declaration & FormDesignControlAttribute"}]},{"content":"The FormDesignControlAttribute is necessary for the control to appear in the Visual Studio Form designer when right-clicking on the design node of the form.","pos":[16659,16815]},{"content":"If the FromDesignControlAttribute is missing, then the control can only be added to a form via imperative X++ code (i.e. via the addControlEx method on the form).","pos":[16816,16978]},{"pos":[17105,17145],"content":"Design time: FormDesignPropertyAttribute","linkify":"Design time: FormDesignPropertyAttribute","nodes":[{"content":"Design time: FormDesignPropertyAttribute","pos":[0,40]}]},{"content":"Placing this attribute on a method in the design time class will result in a new property with the name specified by the first argument (and in the section specified by the second argument) appearing the property sheet for this control, with the corresponding X++ method operating as the getter/setter for the property.","pos":[17146,17465]},{"pos":[17908,17953],"content":"Design time: FormDesignProperty** **Attribute","linkify":"Design time: FormDesignProperty** **Attribute","nodes":[{"content":"Design time: FormDesignProperty** **Attribute","pos":[0,45]}]},{"content":"There are a number of FormDesignProperty attributes which may be applied alongside the standard FormDesignPropertyAttribute for specialized behavior in the property sheet.","pos":[17954,18125]},{"content":"The specialized behavior includes enabling the property as a combobox which allows selecting from a list of a values.","pos":[18126,18243]},{"content":"The different types of lists that used are enumerated below.","pos":[18244,18304]},{"content":"Whenever the user selects an item from the combobox, the string name of that item is passed into the X++ method getter/setter with the attribute.","pos":[18305,18450]},{"content":"<ph id=\"ph1\">\\[</ph>FormDesignPropertyDataSourceAttribute<ph id=\"ph2\">\\]</ph> - Shows a list of the data sources on the form.","pos":[18456,18545],"source":"\\[FormDesignPropertyDataSourceAttribute\\] - Shows a list of the data sources on the form."},{"content":"<ph id=\"ph1\">\\[</ph>FormDesignPropertyDataFieldAttribute(<ph id=\"ph2\">&amp;lt;</ph>data source name<ph id=\"ph3\">&amp;gt;</ph>)<ph id=\"ph4\">\\]</ph> - Shows a list of the data fields on the specified data source.","pos":[18550,18680],"source":"\\[FormDesignPropertyDataFieldAttribute(&lt;data source name&gt;)\\] - Shows a list of the data fields on the specified data source."},{"content":"<ph id=\"ph1\">\\[</ph>FormDesignPropertyDataMethodAttribute(<ph id=\"ph2\">&amp;lt;</ph>data source name<ph id=\"ph3\">&amp;gt;</ph>)<ph id=\"ph4\">\\]</ph> - Shows a list of the data methods on the specified data source.","pos":[18685,18817],"source":"\\[FormDesignPropertyDataMethodAttribute(&lt;data source name&gt;)\\] - Shows a list of the data methods on the specified data source."},{"content":"<ph id=\"ph1\">\\[</ph>FormDesignPropertyFieldGroupAttribute(<ph id=\"ph2\">&amp;lt;</ph>data source name<ph id=\"ph3\">&amp;gt;</ph>)<ph id=\"ph4\">\\]</ph> - Shows a list of the field groups on the specified data source.","pos":[18822,18954],"source":"\\[FormDesignPropertyFieldGroupAttribute(&lt;data source name&gt;)\\] - Shows a list of the field groups on the specified data source."},{"content":"<ph id=\"ph1\">\\[</ph>FormDesignPropertyExtendsClassAttribute(<ph id=\"ph2\">&amp;lt;</ph>class name<ph id=\"ph3\">&amp;gt;</ph>)<ph id=\"ph4\">\\]</ph> - Shows a list of the classes which extend the specified class.","pos":[18959,19086],"source":"\\[FormDesignPropertyExtendsClassAttribute(&lt;class name&gt;)\\] - Shows a list of the classes which extend the specified class."},{"content":"<ph id=\"ph1\">\\[</ph>FormDesignPropertyImplementsAttribute(<ph id=\"ph2\">&amp;lt;</ph>interface name<ph id=\"ph3\">&amp;gt;</ph>)<ph id=\"ph4\">\\]</ph> - Shows a list of the classes which implement the specified interface.","pos":[19091,19227],"source":"\\[FormDesignPropertyImplementsAttribute(&lt;interface name&gt;)\\] - Shows a list of the classes which implement the specified interface."},{"content":"<ph id=\"ph1\">\\[</ph>FormDesignPropertyReferenceAttribute(<ph id=\"ph2\">&amp;lt;</ph>FormDesignPropertyReferenceType::<ph id=\"ph3\">&amp;lt;</ph>type<ph id=\"ph4\">&amp;gt;</ph>)<ph id=\"ph5\">\\]</ph> - Shows a list of the specified AOT artifacts with the given type.","pos":[19232,19390],"source":"\\[FormDesignPropertyReferenceAttribute(&lt;FormDesignPropertyReferenceType::&lt;type&gt;)\\] - Shows a list of the specified AOT artifacts with the given type."},{"content":"The supported types are:","pos":[19391,19415]},{"content":"Table","pos":[19424,19429]},{"content":"View","pos":[19438,19442]},{"content":"Map","pos":[19451,19454]},{"content":"EDT","pos":[19463,19466]},{"content":"BaseEnum","pos":[19475,19483]},{"content":"Query","pos":[19492,19497]},{"content":"Class","pos":[19506,19511]},{"content":"Form","pos":[19520,19524]},{"content":"MenuItemDisplay","pos":[19533,19548]},{"content":"MenuItemOuput","pos":[19557,19570]},{"content":"MenuItemAction","pos":[19579,19593]},{"content":"Tile","pos":[19602,19606]},{"content":"KPI","pos":[19615,19618]},{"content":"The following example shows standard properties used to allow a Form developer to specify the Data Source and Data Field for the design time class.","pos":[19620,19767]},{"content":"A control with a design time class like the one above can then bind to the specified data source and data field inside of the applyBuild method, as show below.","pos":[21185,21344]},{"content":"If you supply both a data field and data method to FormBindingUtil::initBinding, the data field binding will override the data method binding.","pos":[21688,21830]},{"pos":[21835,21839],"content":"HTML","linkify":"HTML","nodes":[{"content":"HTML","pos":[0,4]}]},{"pos":[21840,21866],"content":"HTML: Framework attributes","linkify":"HTML: Framework attributes","nodes":[{"content":"HTML: Framework attributes","pos":[0,26]}]},{"content":"The following section documents the HTML attributes that are used in the control framework for control development.","pos":[21895,22010]},{"pos":[22016,22029],"content":"data-dyn-bind","linkify":"data-dyn-bind","nodes":[{"content":"data-dyn-bind","pos":[0,13]}]},{"content":"<bpt id=\"p1\">**</bpt>data-dyn-bind<ept id=\"p1\">**</ept>, the data binding attribute, standardizes many common DOM manipulations - such as modifying an element’s attributes, properties and CSS, or handling DOM events - through a declarative HTML-based API.","pos":[22031,22248],"source":"**data-dyn-bind**, the data binding attribute, standardizes many common DOM manipulations - such as modifying an element’s attributes, properties and CSS, or handling DOM events - through a declarative HTML-based API."},{"content":"The data binding attribute allows for these behaviors without requiring complex JavaScript.","pos":[22249,22340]},{"content":"Using the data binding attribute rather than writing complex JavaScript can save the control developer valuable time by making things such as designing, debugging and maintaining the control much easier.","pos":[22341,22544]},{"content":"However, complex JavaScript is still available when scenarios require its use.","pos":[22545,22623]},{"content":"The data binding attribute binds HTML element behaviors to values supplied by the control developer.","pos":[22624,22724]},{"content":"The values supplied can be simple JavaScript <bpt id=\"p1\">[</bpt>variables<ept id=\"p1\">](http://www.w3schools.com/js/js_variables.asp)</ept>, JavaScript <bpt id=\"p2\">[</bpt>comparison<ept id=\"p2\">](http://www.w3schools.com/js/js_comparisons.asp)</ept> or <bpt id=\"p3\">[</bpt>arithmetic<ept id=\"p3\">](http://www.w3schools.com/js/js_arithmetic.asp)</ept> expressions, JavaScript <bpt id=\"p4\">[</bpt>functions<ept id=\"p4\">](http://www.w3schools.com/js/js_functions.asp)</ept> and JSON <bpt id=\"p5\">[</bpt>objects<ept id=\"p5\">](https://www.w3schools.com/js/js_json_objects.asp)</ept>.","pos":[22725,23115],"source":" The values supplied can be simple JavaScript [variables](http://www.w3schools.com/js/js_variables.asp), JavaScript [comparison](http://www.w3schools.com/js/js_comparisons.asp) or [arithmetic](http://www.w3schools.com/js/js_arithmetic.asp) expressions, JavaScript [functions](http://www.w3schools.com/js/js_functions.asp) and JSON [objects](https://www.w3schools.com/js/js_json_objects.asp)."},{"content":"The values supplied can also be observable variables, created using the APIs described in this document.","pos":[23116,23220]},{"content":"The way in which the supplied value is bound to the HTML element is determined by the binding handler that is used with the data binding attribute.","pos":[23221,23368]},{"content":"A list of all supported binding handlers is provided in this document.","pos":[23369,23439]},{"content":"The data binding attribute requires the following syntax when used with any binding handler.","pos":[23440,23532]},{"content":"The syntax for <bpt id=\"p1\">**</bpt>data-dyn-bind<ept id=\"p1\">**</ept> is:","pos":[23533,23569],"source":" The syntax for **data-dyn-bind** is:"},{"content":"The data binding attribute accepts a comma-separated list of binding handler-value pairs, so you can supply more than one binding handler to the binding attribute at a time.","pos":[23636,23809]},{"content":"The following example binds the <bpt id=\"p1\">**</bpt>visible<ept id=\"p1\">**</ept> property of the div element to true, and binds the <bpt id=\"p2\">**</bpt>textContent<ept id=\"p2\">**</ept> property of the div element to \"Hi\".","pos":[23810,23957],"source":" The following example binds the **visible** property of the div element to true, and binds the **textContent** property of the div element to \"Hi\"."},{"content":"The data binding attribute is a custom HTML attribute understood by the control framework.","pos":[24006,24096]},{"content":"The data binding attribute can be applied to any HTML element.","pos":[24097,24159]},{"content":"Some HTML elements may not have the behavior which the binding handler modifies.","pos":[24160,24240]},{"content":"For example, using the text binding handler on an <bpt id=\"p1\">**</bpt><ph id=\"ph1\">&amp;lt;</ph>svg<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">**</ept> element will not show the text since the <bpt id=\"p2\">**</bpt><ph id=\"ph3\">&amp;lt;</ph>svg<ph id=\"ph4\">&amp;gt;</ph><ept id=\"p2\">**</ept> element does not have a textContent property.","pos":[24241,24409],"source":" For example, using the text binding handler on an **&lt;svg&gt;** element will not show the text since the **&lt;svg&gt;** element does not have a textContent property."},{"content":"The control framework reads and executes the data bindings specified in the control’s template at runtime.","pos":[24410,24516]},{"content":"The lifecycle for the control in the browser can be summarized as follows:","pos":[24517,24591]},{"content":"The control’s HTM file is loaded by the browser.","pos":[24597,24645]},{"content":"Any script or resource files referenced in the HTM file are also loaded by the browser.","pos":[24650,24737]},{"content":"Steps 1 and 2 are executed only once during a user’s session, even if there are multiple instances of the control.","pos":[24738,24852]},{"content":"The JavaScript class's constructor for the control is call and passed with the X++ properties for the control instance.","pos":[24857,24976]},{"content":"The control’s template is copied from the HTM file and into the browser’s memory.","pos":[24981,25062]},{"content":"HTML elements in the control’s template are processed for data binding in hierarchical order (depth first), and data bindings on each element are executed in order from left-to-right","pos":[25067,25249]},{"content":"The final HTML, including the original data binding attributes as well as any other markup added by the binding handlers or by the framework, is added to the browser’s DOM and rendered for the user to see.","pos":[25254,25459]},{"content":"Later, when the value of an observable changes, any binding handlers subscribed to the observable are re-executed and the live DOM is updated in real-time.","pos":[25464,25619]},{"pos":[25624,25646],"content":"HTML: Binding handlers","linkify":"HTML: Binding handlers","nodes":[{"content":"HTML: Binding handlers","pos":[0,22]}]},{"pos":[25651,25655],"content":"attr","linkify":"attr","nodes":[{"content":"attr","pos":[0,4]}]},{"content":"The <bpt id=\"p1\">**</bpt>attr<ept id=\"p1\">**</ept> binding handler applies the supplied HTML attribute and value to the element.","pos":[25657,25747],"source":"The **attr** binding handler applies the supplied HTML attribute and value to the element."},{"content":"For a list of HTML attributes see <bpt id=\"p1\">[</bpt>W3 Schools – HTML Attributes<ept id=\"p1\">](http://www.w3schools.com/html/html_attributes.asp)</ept>.","pos":[25748,25864],"source":" For a list of HTML attributes see [W3 Schools – HTML Attributes](http://www.w3schools.com/html/html_attributes.asp)."},{"content":"The arguments are passed in as an object array.","pos":[25865,25912]},{"content":"Each argument is dual-valued.","pos":[25913,25942]},{"content":"The first value is the name of the attribute, and the second value is the value of the attribute.","pos":[25943,26040]},{"pos":[26046,26124],"content":"<bpt id=\"p1\">**</bpt>Name<ept id=\"p1\">**</ept>: a string that specifies the desired name of the attribute to create.","source":"**Name**: a string that specifies the desired name of the attribute to create."},{"content":"<bpt id=\"p1\">**</bpt>Value or Expression:<ept id=\"p1\">**</ept> a string that specifies the value to set on the attribute.","pos":[26129,26212],"source":"**Value or Expression:** a string that specifies the value to set on the attribute."},{"content":"If an expression is supplied, the value returned by evaluating the expression will be used.","pos":[26213,26304]},{"content":"The following example creates the title and name attributes and sets their value.","pos":[26306,26387]},{"content":"The following example uses expressions and functions.","pos":[26680,26733]},{"content":"However, using JavaScript functions as in-line HTML like the example below is not recommended.","pos":[26734,26828]},{"pos":[27203,27208],"content":"click","linkify":"click","nodes":[{"content":"click","pos":[0,5]}]},{"pos":[27216,27224],"content":"Behavior","linkify":"Behavior","nodes":[{"content":"Behavior","pos":[0,8]}]},{"content":"Subscribes the supplied function to the click event on the element.","pos":[27226,27293]},{"content":"For more information on subscribing to the click event see <bpt id=\"p1\">[</bpt>jQuery – click()<ept id=\"p1\">](http://api.jquery.com/click/)</ept>.","pos":[27294,27402],"source":" For more information on subscribing to the click event see [jQuery – click()](http://api.jquery.com/click/)."},{"pos":[27410,27419],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[27428,27451],"content":"EventHandler (function)","linkify":"EventHandler (function)","nodes":[{"content":"EventHandler (function)","pos":[0,23]}]},{"content":"The function to call when the event is raised.","pos":[27453,27499]},{"pos":[27507,27516],"content":"Example 1","linkify":"Example 1","nodes":[{"content":"Example 1","pos":[0,9]}]},{"content":"The following example shows an alert message “Hello” when the element is clicked.","pos":[27518,27599]},{"content":"The following example prevents the click event on child elements from bubbling up to parent elements.","pos":[27892,27993]},{"content":"The example below will show only one alert with message “Hello” when the child element is clicked.","pos":[27994,28092]},{"content":"The following example prevents the browser default behavior from executing.","pos":[28679,28754]},{"content":"For anchor tags, the default hyperlink behavior is prevented, so the browser will not navigate to the link when the element is clicked.","pos":[28755,28890]},{"pos":[29392,29395],"content":"css","linkify":"css","nodes":[{"content":"css","pos":[0,3]}]},{"pos":[29403,29411],"content":"Behavior","linkify":"Behavior","nodes":[{"content":"Behavior","pos":[0,8]}]},{"content":"Adds or removes the specified CSS class name(s) to the element, based on the specified condition(s).","pos":[29413,29513]},{"content":"Note that expressions supplied to the binding handler are only executed once.","pos":[29514,29591]},{"pos":[29599,29608],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"content":"The arguments are passed in as an object array.","pos":[29610,29657]},{"content":"Each argument is dual-valued.","pos":[29658,29687]},{"content":"The first value is the Class name, and the second value is the Condition.","pos":[29688,29761]},{"pos":[29770,29789],"content":"Class name (string)","linkify":"Class name (string)","nodes":[{"content":"Class name (string)","pos":[0,19]}]},{"content":"The CSS class name to add to the element.","pos":[29791,29832]},{"pos":[29841,29863],"content":"Condition (expression)","linkify":"Condition (expression)","nodes":[{"content":"Condition (expression)","pos":[0,22]}]},{"content":"The condition on which to add the CSS class name.","pos":[29865,29914]},{"content":"If the condition evaluates to true, the CSS class name is added.","pos":[29915,29979]},{"content":"If the condition evaluates to false, the CSS class name is removed.","pos":[29980,30047]},{"content":"If a supplied condition takes a dependency on an observable (via $dyn.value), then the condition will be re-evaluated whenever the observable value changes, and the associated CSS class name will be added/removed based on the new condition.","pos":[30048,30288]},{"content":"The following example adds the CSS class names \"red\", \"green\", and \"yellow\".","pos":[30289,30365]},{"pos":[30891,30896],"content":"event","linkify":"event","nodes":[{"content":"event","pos":[0,5]}]},{"pos":[30904,30912],"content":"Behavior","linkify":"Behavior","nodes":[{"content":"Behavior","pos":[0,8]}]},{"content":"Subscribes the supplied event handler to the specified DOM event.","pos":[30914,30979]},{"content":"For a list of supported DOM events, see <bpt id=\"p1\">[</bpt>jQuery - Event<ept id=\"p1\">](http://api.jquery.com/Types/#Event)</ept>.","pos":[30980,31073],"source":" For a list of supported DOM events, see [jQuery - Event](http://api.jquery.com/Types/#Event)."},{"pos":[31081,31090],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"content":"For details on the arguments to the event binding handler, see <bpt id=\"p1\">[</bpt>jQuery - .bind()<ept id=\"p1\">](http://api.jquery.com/bind/)</ept>.","pos":[31092,31203],"source":"For details on the arguments to the event binding handler, see [jQuery - .bind()](http://api.jquery.com/bind/)."},{"content":"The following example subscribes to the mouseover event and shows an alert when the element is hovered.","pos":[31204,31307]},{"pos":[31624,31631],"content":"foreach","linkify":"foreach","nodes":[{"content":"foreach","pos":[0,7]}]},{"pos":[31639,31647],"content":"Behavior","linkify":"Behavior","nodes":[{"content":"Behavior","pos":[0,8]}]},{"content":"Repeats the content of the child element, updating the binding context of each child based on the supplied data.","pos":[31649,31761]},{"content":"Supply <bpt id=\"p1\">***</bpt>only one<ept id=\"p1\">***</ept> child element inside of the element with the <bpt id=\"p2\">**</bpt>foreach<ept id=\"p2\">**</ept> binding.","pos":[31762,31849],"source":" Supply ***only one*** child element inside of the element with the **foreach** binding."},{"content":"This one element is the element that will be cloned and repeated.","pos":[31850,31915]},{"content":"Any other additional elements or content will be removed when the binding is applied.","pos":[31916,32001]},{"content":"Binding handlers are executed in the order in which they appear on the element.","pos":[32002,32081]},{"content":"Since the <bpt id=\"p1\">**</bpt>foreach<ept id=\"p1\">**</ept> binding changes the binding context, it is a best practice to always place the <bpt id=\"p2\">**</bpt>foreach<ept id=\"p2\">**</ept> binding after all other bindings on the element.","pos":[32082,32243],"source":" Since the **foreach** binding changes the binding context, it is a best practice to always place the **foreach** binding after all other bindings on the element."},{"content":"This will ensure that preceding bindings are not affected by the binding context created by the <bpt id=\"p1\">**</bpt>foreach<ept id=\"p1\">**</ept> binding.","pos":[32244,32360],"source":" This will ensure that preceding bindings are not affected by the binding context created by the **foreach** binding."},{"content":"To avoid performance issues, be careful to not create unintentional dependencies on observables inside of your <bpt id=\"p1\">**</bpt>foreach.<ept id=\"p1\">**</ept>","pos":[32361,32484],"source":" To avoid performance issues, be careful to not create unintentional dependencies on observables inside of your **foreach.**"},{"content":"Do not access an observable in the array using <bpt id=\"p1\">**</bpt>$dyn.value<ept id=\"p1\">**</ept> from within the child elements of the <bpt id=\"p2\">**</bpt>foreach,<ept id=\"p2\">**</ept> as the <bpt id=\"p3\">**</bpt>foreach<ept id=\"p3\">**</ept> binding has already subscribed to the observables in the array.","pos":[32485,32680],"source":" Do not access an observable in the array using **$dyn.value** from within the child elements of the **foreach,** as the **foreach** binding has already subscribed to the observables in the array."},{"content":"Instead, use <bpt id=\"p1\">**</bpt>$dyn.peek<ept id=\"p1\">**</ept> to access an observable’s value once without creating a subscription.","pos":[32681,32777],"source":" Instead, use **$dyn.peek** to access an observable’s value once without creating a subscription."},{"pos":[32785,32794],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[32803,32835],"content":"Data (array list or JSON object)","linkify":"Data (array list or JSON object)","nodes":[{"content":"Data (array list or JSON object)","pos":[0,32]}]},{"content":"The list of items to bind the child element to.","pos":[32837,32884]},{"content":"If an array list is supplied, the binding context is an item in the array.","pos":[32885,32959]},{"content":"If a JSON object array is supplied, the binding context is one of the object’s properties.","pos":[32960,33050]},{"pos":[33058,33073],"content":"Scope variables","linkify":"Scope variables","nodes":[{"content":"Scope variables","pos":[0,15]}]},{"content":"When inside the scope of the <bpt id=\"p1\">**</bpt>foreach,<ept id=\"p1\">**</ept> the following scope variables are useful and can be used on the repeatable child element: $data, index, control, your own scope variables.","pos":[33075,33255],"source":"When inside the scope of the **foreach,** the following scope variables are useful and can be used on the repeatable child element: $data, index, control, your own scope variables."},{"content":"The following example uses <bpt id=\"p1\">**</bpt>foreach<ept id=\"p1\">**</ept> to render a span element for each color in the array.","pos":[33256,33348],"source":" The following example uses **foreach** to render a span element for each color in the array."},{"content":"The following examples shows a nested <bpt id=\"p1\">**</bpt>foreach<ept id=\"p1\">**</ept> binding.","pos":[33888,33946],"source":"The following examples shows a nested **foreach** binding."},{"content":"This example showcases how to use the index framework scope variable and custom scope variables to access the binding context from the parent element.","pos":[33947,34097]},{"pos":[35381,35383],"content":"if","linkify":"if","nodes":[{"content":"if","pos":[0,2]}]},{"pos":[35391,35399],"content":"Behavior","linkify":"Behavior","nodes":[{"content":"Behavior","pos":[0,8]}]},{"content":"Conditionally renders and binds the child elements of the element with this binding.","pos":[35401,35485]},{"content":"This binding handler only operates on the child elements.","pos":[35486,35543]},{"content":"It will not show/hide the element with the binding, nor will this binding show/hide the text content of the element with the binding.","pos":[35544,35677]},{"content":"Bindings on the child elements will only be executed if the condition evaluates to true.","pos":[35678,35766]},{"content":"Once the bindings on child elements have been evaluated once they will remain data bound even if the condition changes to false.","pos":[35767,35895]},{"content":"This means that any calculations caused by bindings on child elements will continue to operate even after the child elements are hidden.","pos":[35896,36032]},{"content":"Consider this when evaluating the performance of your control.","pos":[36033,36095]},{"pos":[36103,36112],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[36121,36143],"content":"Condition (expression)","linkify":"Condition (expression)","nodes":[{"content":"Condition (expression)","pos":[0,22]}]},{"content":"Determines whether to render the children elements.","pos":[36145,36196]},{"content":"The following example conditionally binds the <bpt id=\"p1\">**</bpt>show<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>text<ept id=\"p2\">**</ept> elements.","pos":[36197,36274],"source":" The following example conditionally binds the **show** and **text** elements."},{"pos":[37014,37020],"content":"sizing","linkify":"sizing","nodes":[{"content":"sizing","pos":[0,6]}]},{"pos":[37028,37036],"content":"Behavior","linkify":"Behavior","nodes":[{"content":"Behavior","pos":[0,8]}]},{"content":"Specifies the height and width of the control.","pos":[37038,37084]},{"content":"The sizing binding handler should always be applied to the root element of the template (the element that has the id attribute), and supplied the height and width values from the X++ instance of the control by using the $dyn.layout.sizing helper function.","pos":[37085,37340]},{"content":"See Example 1.","pos":[37341,37355]},{"pos":[37363,37372],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"content":"The arguments are passed an object containing height and width properties.","pos":[37374,37448]},{"pos":[37457,37469],"content":"Height (int)","linkify":"Height (int)","nodes":[{"content":"Height (int)","pos":[0,12]}]},{"content":"Determines the height in pixels of the element on which the binding handler is applied.","pos":[37471,37558]},{"pos":[37567,37578],"content":"Width (int)","linkify":"Width (int)","nodes":[{"content":"Width (int)","pos":[0,11]}]},{"content":"Determines the width in pixels of the element on which the binding handler is applied.","pos":[37580,37666]},{"content":"The following example specifies the size of <bpt id=\"p1\">**</bpt>MyControl.<ept id=\"p1\">**</ept>","pos":[37667,37725],"source":" The following example specifies the size of **MyControl.**"},{"pos":[38117,38222],"content":"The following example makes the control large or small depending on the value of the <bpt id=\"p1\">**</bpt>bigbox<ept id=\"p1\">**</ept> variable.","source":"The following example makes the control large or small depending on the value of the **bigbox** variable."},{"pos":[38693,38697],"content":"text","linkify":"text","nodes":[{"content":"text","pos":[0,4]}]},{"pos":[38705,38713],"content":"Behavior","linkify":"Behavior","nodes":[{"content":"Behavior","pos":[0,8]}]},{"content":"Binds to the textContent property of the element.","pos":[38715,38764]},{"content":"The text binding handler is meant to be used with UI text.","pos":[38765,38823]},{"content":"It is not meant to bind non-string values (such as numbers, dates or Booleans) to the element.","pos":[38824,38918]},{"content":"Convert all values into strings before supplying them to the binding handler, by using the dyn.format function.","pos":[38919,39030]},{"content":"The text binding handler will replace all of the content inside of the element with the binding, whether or not the existing content is HTML or simple text.","pos":[39031,39187]},{"pos":[39195,39204],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[39213,39226],"content":"Text (string)","linkify":"Text (string)","nodes":[{"content":"Text (string)","pos":[0,13]}]},{"content":"The text to bind to.","pos":[39228,39248]},{"content":"The following example binds the textContext property of the div element to the text property on the control.","pos":[39249,39357]},{"pos":[39730,39734],"content":"vars","linkify":"vars","nodes":[{"content":"vars","pos":[0,4]}]},{"pos":[39742,39750],"content":"Behavior","linkify":"Behavior","nodes":[{"content":"Behavior","pos":[0,8]}]},{"content":"Creates an HTML scope variable with the supplied name and value.","pos":[39752,39816]},{"content":"The created scope variable is accessible only from bindings in the template.","pos":[39817,39893]},{"content":"In addition, the scope variable is inherited by child elements.","pos":[39894,39957]},{"content":"Binding handlers are executed in the order in which they appear on the element.","pos":[39958,40037]},{"content":"Since the vars binding adds variables to the binding context, it is a best practice to always place the vars binding before all other bindings on the element.","pos":[40038,40196]},{"content":"This will ensure that the subsequent bindings can access scope variables added by the vars binding.","pos":[40197,40296]},{"content":"Do not create scope variables with any of the following names, as these names are reserved for framework scope variables: $control, $data, $index, and $value.","pos":[40297,40455]},{"pos":[40463,40472],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[40481,40511],"content":"Scope variables (object array)","linkify":"Scope variables (object array)","nodes":[{"content":"Scope variables (object array)","pos":[0,30]}]},{"content":"The object array whose keys are the scope variable names and whose values are the initial values for the scope variables.","pos":[40513,40634]},{"content":"The following example creates scope variables named \"Hello\" and \"World\" and displays their values.","pos":[40635,40733]},{"pos":[41200,41209],"content":"Example 2","linkify":"Example 2","nodes":[{"content":"Example 2","pos":[0,9]}]},{"content":"For an example, see the foreach binding handler examples.","pos":[41211,41268]},{"pos":[41275,41282],"content":"visible","linkify":"visible","nodes":[{"content":"visible","pos":[0,7]}]},{"pos":[41290,41298],"content":"Behavior","linkify":"Behavior","nodes":[{"content":"Behavior","pos":[0,8]}]},{"content":"Sets the visibility of the element.","pos":[41300,41335]},{"content":"Always supply the visible binding handler on the root element of the template, and bind to the <bpt id=\"p1\">*</bpt>Visible<ept id=\"p1\">*</ept> property from the X++ control.","pos":[41336,41471],"source":" Always supply the visible binding handler on the root element of the template, and bind to the *Visible* property from the X++ control."},{"content":"This will ensure that the control respects the <bpt id=\"p1\">*</bpt>Visible<ept id=\"p1\">*</ept> property when it is set by a form developer or when it is set by the framework.","pos":[41472,41608],"source":" This will ensure that the control respects the *Visible* property when it is set by a form developer or when it is set by the framework."},{"content":"If a control is initialized with its <bpt id=\"p1\">*</bpt>Visible<ept id=\"p1\">*</ept> X++ property set to false, then the control will not appear on the form, and it the control’s template will not be loaded in the browser.","pos":[41609,41793],"source":" If a control is initialized with its *Visible* X++ property set to false, then the control will not appear on the form, and it the control’s template will not be loaded in the browser."},{"content":"If the control’s <bpt id=\"p1\">*</bpt>Visible<ept id=\"p1\">*</ept> X++ property is set to true at a later time, then the control’s template will be loaded and instantiated in the browser at that time.","pos":[41794,41954],"source":" If the control’s *Visible* X++ property is set to true at a later time, then the control’s template will be loaded and instantiated in the browser at that time."},{"content":"A control’s <bpt id=\"p1\">*</bpt>Visible<ept id=\"p1\">*</ept> X++ property can be inherited from its parent controls on the form.","pos":[41955,42044],"source":" A control’s *Visible* X++ property can be inherited from its parent controls on the form."},{"content":"An element’s visibility may be controlled by its parent elements, controls and containers, regardless of whether the visible binding handler is applied.","pos":[42045,42197]},{"content":"The cascading nature of visibility is a standard HTML behavior and is not specific to the control framework.","pos":[42198,42306]},{"pos":[42314,42323],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[42332,42349],"content":"Visible (boolean)","linkify":"Visible (boolean)","nodes":[{"content":"Visible (boolean)","pos":[0,17]}]},{"content":"Determines whether the element is visible or not.","pos":[42351,42400]},{"content":"The following example sets the visibility of the control's outermost div element.","pos":[42401,42482]},{"pos":[42963,42984],"content":"HTML: Scope variables","linkify":"HTML: Scope variables","nodes":[{"content":"HTML: Scope variables","pos":[0,21]}]},{"content":"Scope variables can be used when binding values to binding handlers.","pos":[42985,43053]},{"content":"Scope variables are only accessible from within the control’s HTML template, and can only be used with the data binding attribute.","pos":[43054,43184]},{"content":"Scope variables are neither accessible from other HTML attributes nor from the control’s JavaScript class, but scope variables can be used in inline JavaScript expressions, functions and JSON objects that are passed to binding handlers.","pos":[43185,43421]},{"pos":[43428,43436],"content":"$control","linkify":"$control","nodes":[{"content":"$control","pos":[0,8]}]},{"content":"The <bpt id=\"p1\">*</bpt>$control<ept id=\"p1\">*</ept> scope variable provides the bindings in the HTML template with access to the properties and functions on the control’s JavaScript instance.","pos":[43438,43592],"source":"The *$control* scope variable provides the bindings in the HTML template with access to the properties and functions on the control’s JavaScript instance."},{"content":"The following example binds visibility of the div element to the of Visible property of the control.","pos":[43593,43693]},{"pos":[43778,43783],"content":"$data","linkify":"$data","nodes":[{"content":"$data","pos":[0,5]}]},{"content":"The <bpt id=\"p1\">*</bpt>$data<ept id=\"p1\">*</ept> scope variable provides elements with access to their current binding context.","pos":[43785,43875],"source":"The *$data* scope variable provides elements with access to their current binding context."},{"content":"Only variables defined in $data (the binding context) or scope variables, can be used inside of HTML bindings.","pos":[43876,43986]},{"content":"Variables that do not exist in the current binding context and do not exist as current scope variable cannot be accessed from an HTML binding.","pos":[43987,44129]},{"content":"In most cases the binding context will be the control’s JavaScript instance, so <bpt id=\"p1\">*</bpt>$data<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>$control<ept id=\"p2\">*</ept> will be equivalent.","pos":[44130,44252],"source":" In most cases the binding context will be the control’s JavaScript instance, so *$data* and *$control* will be equivalent."},{"content":"However, in some cases the binding context can change.","pos":[44253,44307]},{"content":"For example, for elements inside of a <bpt id=\"p1\">**</bpt>foreach<ept id=\"p1\">**</ept> binding, <bpt id=\"p2\">*</bpt>$data<ept id=\"p2\">*</ept> provides the elements with access to the current array item.","pos":[44308,44435],"source":" For example, for elements inside of a **foreach** binding, *$data* provides the elements with access to the current array item."},{"content":"In cases involving multiple nested <bpt id=\"p1\">**</bpt>foreach<ept id=\"p1\">**</ept> bindings, elements in a nested binding may need access to the array item in a parent <bpt id=\"p2\">**</bpt>foreach<ept id=\"p2\">**</ept> binding.","pos":[44436,44588],"source":" In cases involving multiple nested **foreach** bindings, elements in a nested binding may need access to the array item in a parent **foreach** binding."},{"content":"To access items in the parent <bpt id=\"p1\">**</bpt>foreach<ept id=\"p1\">**</ept> binding, you may create a scope variable which will be accessible to elements in the nested <bpt id=\"p2\">**</bpt>foreach<ept id=\"p2\">**</ept> biding.","pos":[44589,44742],"source":" To access items in the parent **foreach** binding, you may create a scope variable which will be accessible to elements in the nested **foreach** biding."},{"content":"For an example, see the foreach binding handler examples.","pos":[44743,44800]},{"pos":[44807,44813],"content":"$index","linkify":"$index","nodes":[{"content":"$index","pos":[0,6]}]},{"content":"The $index scope variable provides a 0-based index of the array item when in a <bpt id=\"p1\">**</bpt>foreach<ept id=\"p1\">**</ept> binding.","pos":[44815,44914],"source":"The $index scope variable provides a 0-based index of the array item when in a **foreach** binding."},{"content":"For an example, see the foreach binding handler examples.","pos":[44915,44972]},{"pos":[44977,45009],"content":"JavaScript: Inherited properties","linkify":"JavaScript: Inherited properties","nodes":[{"content":"JavaScript: Inherited properties","pos":[0,32]}]},{"pos":[45015,45022],"content":"Visible","linkify":"Visible","nodes":[{"content":"Visible","pos":[0,7]}]},{"content":"The <bpt id=\"p1\">**</bpt>Visible<ept id=\"p1\">**</ept> property is inherited from the base JavaScript class (via <bpt id=\"p2\">**</bpt>$dyn.ui.Controls.apply<ept id=\"p2\">**</ept>).","pos":[45024,45126],"source":"The **Visible** property is inherited from the base JavaScript class (via **$dyn.ui.Controls.apply**)."},{"content":"There is also a <bpt id=\"p1\">**</bpt>Visible<ept id=\"p1\">**</ept> property in X++ that the runtime class in inherits from the base <bpt id=\"p2\">**</bpt>FormControl<ept id=\"p2\">**</ept> X++ class.","pos":[45127,45246],"source":" There is also a **Visible** property in X++ that the runtime class in inherits from the base **FormControl** X++ class."},{"content":"Simply bind this property to the visible binding handler and place it on the root element of the HTML template for your control.","pos":[45247,45375]},{"content":"The framework takes care of the rest.","pos":[45376,45413]},{"content":"The following example shows how to use the Visible property.","pos":[45414,45474]},{"pos":[45598,45618],"content":"Observable framework","linkify":"Observable framework","nodes":[{"content":"Observable framework","pos":[0,20]}]},{"pos":[45624,45636],"content":"$dyn.observe","linkify":"$dyn.observe","nodes":[{"content":"$dyn.observe","pos":[0,12]}]},{"pos":[45644,45649],"content":"Usage","linkify":"Usage","nodes":[{"content":"Usage","pos":[0,5]}]},{"content":"Subscribes a function to changes of an observable.","pos":[45651,45701]},{"content":"We recommend that you use dispose.","pos":[45702,45736]},{"pos":[45821,45830],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[45839,45862],"content":"Observable (observable)","linkify":"Observable (observable)","nodes":[{"content":"Observable (observable)","pos":[0,23]}]},{"content":"Instance of an observable.","pos":[45864,45890]},{"content":"Or a function, which will become a $dyn.computed.","pos":[45891,45940]},{"pos":[45949,45968],"content":"Observer (function)","linkify":"Observer (function)","nodes":[{"content":"Observer (function)","pos":[0,19]}]},{"content":"Function is invoked upon registration and also later when the observable is updated.","pos":[45970,46054]},{"content":"Function is invoked with one argument, the value of the observable.","pos":[46055,46122]},{"content":"If Observer returns false, then we un-subscribed automatically.","pos":[46123,46186]},{"pos":[46195,46222],"content":"Context (options, optional)","linkify":"Context (options, optional)","nodes":[{"content":"Context (options, optional)","pos":[0,27]}]},{"content":"Context to pass to the Observer.","pos":[46224,46256]},{"content":"The Context becomes the <bpt id=\"p1\">***</bpt>this<ept id=\"p1\">***</ept> variable inside of the observer.","pos":[46257,46324],"source":" The Context becomes the ***this*** variable inside of the observer."},{"pos":[46333,46371],"content":"DisposableObserver (options, optional)","linkify":"DisposableObserver (options, optional)","nodes":[{"content":"DisposableObserver (options, optional)","pos":[0,38]}]},{"content":"Unsubscribes the supplied DisposableObserver","pos":[46373,46417]},{"pos":[46425,46432],"content":"Returns","linkify":"Returns","nodes":[{"content":"Returns","pos":[0,7]}]},{"pos":[46441,46462],"content":"Subscription (object)","linkify":"Subscription (object)","nodes":[{"content":"Subscription (object)","pos":[0,21]}]},{"content":"Observable, ID, Dispose function (public) used to unsubscribe The following example subscribes to the myObs observable, and executes the supplied function whenever the myObs observable value changes.","pos":[46464,46663]},{"content":"The following example shows how a function can automatically subscribe to observables simply by accessing the observable using $dyn.value.","pos":[46736,46874]},{"content":"The first function is treated like an observable whose value is dependent upon the value of two other observables (FirstName and LastName).","pos":[46875,47014]},{"content":"Every time one of the observables  (FirstName or LastName) changes its value, then the first function has also changed its value.","pos":[47015,47144]},{"content":"When this happens, the second function (the callback function) will log the concatenation of the observable values to the console.","pos":[47145,47275]},{"content":"The following example performs similarly to the previous example.","pos":[47604,47669]},{"content":"However, this example uses a computed observable, named myComp, to handle the concatenation.","pos":[47670,47762]},{"pos":[48178,48193],"content":"$dyn.observable","linkify":"$dyn.observable","nodes":[{"content":"$dyn.observable","pos":[0,15]}]},{"pos":[48201,48206],"content":"Usage","linkify":"Usage","nodes":[{"content":"Usage","pos":[0,5]}]},{"content":"Creates an observable variable.","pos":[48208,48239]},{"pos":[48289,48298],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[48307,48331],"content":"Initial value (optional)","linkify":"Initial value (optional)","nodes":[{"content":"Initial value (optional)","pos":[0,24]}]},{"content":"The value to initialize the observable to.","pos":[48333,48375]},{"pos":[48383,48390],"content":"Returns","linkify":"Returns","nodes":[{"content":"Returns","pos":[0,7]}]},{"pos":[48399,48420],"content":"Observable (function)","linkify":"Observable (function)","nodes":[{"content":"Observable (function)","pos":[0,21]}]},{"content":"The newly created observable The following example creates and observable variable named \"Hello\".","pos":[48422,48519]},{"pos":[48572,48582],"content":"$dyn.value","linkify":"$dyn.value","nodes":[{"content":"$dyn.value","pos":[0,10]}]},{"pos":[48590,48595],"content":"Usage","linkify":"Usage","nodes":[{"content":"Usage","pos":[0,5]}]},{"content":"Accesses the value of an observable variable.","pos":[48597,48642]},{"content":"When <bpt id=\"p1\">**</bpt>$dyn.value<ept id=\"p1\">**</ept> is called from inside of an observer function (such as an observer passed to <bpt id=\"p2\">**</bpt>$dyn.observe<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>$dyn.computed<ept id=\"p3\">**</ept>, as well as the binding expression passed to a binding handler) a dependency on the observable is created.","pos":[48643,48884],"source":" When **$dyn.value** is called from inside of an observer function (such as an observer passed to **$dyn.observe** or **$dyn.computed**, as well as the binding expression passed to a binding handler) a dependency on the observable is created."},{"content":"This will cause the binding handler or callback to re-execute whenever the value of the observable changes.","pos":[48885,48992]},{"content":"Because this dependency is created automatically when using <bpt id=\"p1\">**</bpt>$dyn.value<ept id=\"p1\">**</ept>, it is important to only use <bpt id=\"p2\">**</bpt>$dyn.value<ept id=\"p2\">**</ept> when you intentionally wish to create such a dependency.","pos":[48993,49168],"source":" Because this dependency is created automatically when using **$dyn.value**, it is important to only use **$dyn.value** when you intentionally wish to create such a dependency."},{"content":"If you wish to access the value of an observable without creating a dependency, you should use $dyn.peek.","pos":[49169,49274]},{"pos":[49314,49323],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[49332,49342],"content":"Observable","linkify":"Observable","nodes":[{"content":"Observable","pos":[0,10]}]},{"content":"The observable property whose value to access.","pos":[49344,49390]},{"pos":[49398,49405],"content":"Returns","linkify":"Returns","nodes":[{"content":"Returns","pos":[0,7]}]},{"pos":[49414,49419],"content":"Value","linkify":"Value","nodes":[{"content":"Value","pos":[0,5]}]},{"content":"The current value in the observable property The following example returns the value of variable named observable and prints it to the console.","pos":[49421,49564]},{"pos":[49617,49626],"content":"$dyn.peek","linkify":"$dyn.peek","nodes":[{"content":"$dyn.peek","pos":[0,9]}]},{"pos":[49634,49639],"content":"Usage","linkify":"Usage","nodes":[{"content":"Usage","pos":[0,5]}]},{"content":"Accesses the value of an observable variable, without creating a dependency.","pos":[49641,49717]},{"content":"For more information about dependency, see the $dyn.value function.","pos":[49718,49785]},{"pos":[49824,49833],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[49842,49852],"content":"Observable","linkify":"Observable","nodes":[{"content":"Observable","pos":[0,10]}]},{"content":"The observable whose value to access.","pos":[49854,49891]},{"pos":[49899,49906],"content":"Returns","linkify":"Returns","nodes":[{"content":"Returns","pos":[0,7]}]},{"pos":[49915,49920],"content":"Value","linkify":"Value","nodes":[{"content":"Value","pos":[0,5]}]},{"content":"The current value in the observable The following example returns the value of variable named observable and prints it to the console.","pos":[49922,50056]},{"pos":[50108,50121],"content":"$dyn.computed","linkify":"$dyn.computed","nodes":[{"content":"$dyn.computed","pos":[0,13]}]},{"pos":[50129,50134],"content":"Usage","linkify":"Usage","nodes":[{"content":"Usage","pos":[0,5]}]},{"content":"Wraps a function with an observability scope.","pos":[50136,50181]},{"content":"If observables are accessed from inside of the function by using the <bpt id=\"p1\">**</bpt>$dyn.value<ept id=\"p1\">**</ept> function, then the function will re-execute whenever the values of those observables change.","pos":[50182,50358],"source":" If observables are accessed from inside of the function by using the **$dyn.value** function, then the function will re-execute whenever the values of those observables change."},{"content":"Observables that are accessed by using <bpt id=\"p1\">**</bpt>$dyn.peek<ept id=\"p1\">**</ept> will not cause the function to re-execute when their values change.","pos":[50359,50479],"source":" Observables that are accessed by using **$dyn.peek** will not cause the function to re-execute when their values change."},{"pos":[50553,50562],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[50571,50590],"content":"Observer (function)","linkify":"Observer (function)","nodes":[{"content":"Observer (function)","pos":[0,19]}]},{"content":"Function is invoked upon registration and can also be invoked later due to an observable value change.","pos":[50592,50694]},{"content":"The Observer automatically observes any observables that are accessed using $dyn.value from within the scope of the function.","pos":[50695,50820]},{"pos":[50829,50856],"content":"Context (options, optional)","linkify":"Context (options, optional)","nodes":[{"content":"Context (options, optional)","pos":[0,27]}]},{"content":"Context to pass to the Observer.","pos":[50858,50890]},{"content":"The Context becomes the <bpt id=\"p1\">*</bpt>this<ept id=\"p1\">*</ept> variable inside of the observer.","pos":[50891,50954],"source":" The Context becomes the *this* variable inside of the observer."},{"pos":[50963,51001],"content":"DisposableObserver (options, optional)","linkify":"DisposableObserver (options, optional)","nodes":[{"content":"DisposableObserver (options, optional)","pos":[0,38]}]},{"content":"Unsubscribes the supplied DisposableObserver","pos":[51003,51047]},{"pos":[51055,51062],"content":"Returns","linkify":"Returns","nodes":[{"content":"Returns","pos":[0,7]}]},{"pos":[51071,51090],"content":"Anything (optional)","linkify":"Anything (optional)","nodes":[{"content":"Anything (optional)","pos":[0,19]}]},{"pos":[51092,51305],"content":"If the Observer returns a value, then that value will also be returned by the call to <bpt id=\"p1\">**</bpt>$dyn.computed<ept id=\"p1\">**</ept> on the first time <bpt id=\"p2\">**</bpt>$dyn.computed<ept id=\"p2\">**</ept> is called (upon registration) as well every time the observer is invoked.","source":"If the Observer returns a value, then that value will also be returned by the call to **$dyn.computed** on the first time **$dyn.computed** is called (upon registration) as well every time the observer is invoked."},{"pos":[51310,51329],"content":"Framework functions","linkify":"Framework functions","nodes":[{"content":"Framework functions","pos":[0,19]}]},{"pos":[51335,51352],"content":"$dyn.callFunction","linkify":"$dyn.callFunction","nodes":[{"content":"$dyn.callFunction","pos":[0,17]}]},{"pos":[51360,51365],"content":"Usage","linkify":"Usage","nodes":[{"content":"Usage","pos":[0,5]}]},{"content":"Calls the apply method on specified function.","pos":[51367,51412]},{"content":"Is cannot be used during an interaction.","pos":[51413,51453]},{"pos":[51461,51470],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[51479,51512],"content":"Function (function or observable)","linkify":"Function (function or observable)","nodes":[{"content":"Function (function or observable)","pos":[0,33]}]},{"content":"The function to call.","pos":[51514,51535]},{"content":"If an observable is supplied, the current value of the observable will be retrieved and used as the function.","pos":[51536,51645]},{"pos":[51654,51677],"content":"This (object, optional)","linkify":"This (object, optional)","nodes":[{"content":"This (object, optional)","pos":[0,23]}]},{"pos":[51679,51743],"content":"The object to assign to <bpt id=\"p1\">*</bpt>this<ept id=\"p1\">*</ept> within the scope of the function.","source":"The object to assign to *this* within the scope of the function."},{"pos":[51752,51779],"content":"Arguments (array, optional)","linkify":"Arguments (array, optional)","nodes":[{"content":"Arguments (array, optional)","pos":[0,27]}]},{"content":"The arguments to pass to the supplied function.","pos":[51781,51828]},{"pos":[51837,51866],"content":"Callback (function, optional)","linkify":"Callback (function, optional)","nodes":[{"content":"Callback (function, optional)","pos":[0,29]}]},{"content":"The callback function to call when the supplied Function has returned.","pos":[51868,51938]},{"content":"The callback will be passed any values that are returned by the function that is called.","pos":[51939,52027]},{"content":"The following example calls the <bpt id=\"p1\">**</bpt>apply<ept id=\"p1\">**</ept> function on the <bpt id=\"p2\">**</bpt>printName<ept id=\"p2\">**</ept> function.","pos":[52028,52109],"source":" The following example calls the **apply** function on the **printName** function."},{"pos":[52252,52310],"content":"The following example calls the <bpt id=\"p1\">**</bpt>getWholeName<ept id=\"p1\">**</ept> function.","source":"The following example calls the **getWholeName** function."},{"pos":[52710,52721],"content":"$dyn.format","linkify":"$dyn.format","nodes":[{"content":"$dyn.format","pos":[0,11]}]},{"pos":[52729,52734],"content":"Usage","linkify":"Usage","nodes":[{"content":"Usage","pos":[0,5]}]},{"content":"Builds a string using the supplied values according to the supplied format.","pos":[52736,52811]},{"pos":[52819,52828],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[52837,52852],"content":"Format (string)","linkify":"Format (string)","nodes":[{"content":"Format (string)","pos":[0,15]}]},{"content":"The format in which to build the string.","pos":[52854,52894]},{"content":"Use bracket notation for placeholders.","pos":[52895,52933]},{"pos":[52942,52959],"content":"Values (optional)","linkify":"Values (optional)","nodes":[{"content":"Values (optional)","pos":[0,17]}]},{"content":"The comma separated values to use in the format","pos":[52961,53008]},{"pos":[53016,53023],"content":"Returns","linkify":"Returns","nodes":[{"content":"Returns","pos":[0,7]}]},{"pos":[53032,53056],"content":"FormattedString (string)","linkify":"FormattedString (string)","nodes":[{"content":"FormattedString (string)","pos":[0,24]}]},{"content":"The string after formatting has been applied The following example builds a string with the first, middle initial, and the last name.","pos":[53058,53191]},{"pos":[53199,53208],"content":"Example 1","linkify":"Example 1","nodes":[{"content":"Example 1","pos":[0,9]}]},{"pos":[53353,53363],"content":"$dyn.label","linkify":"$dyn.label","nodes":[{"content":"$dyn.label","pos":[0,10]}]},{"pos":[53371,53376],"content":"Usage","linkify":"Usage","nodes":[{"content":"Usage","pos":[0,5]}]},{"content":"Provides access to any labels stored via the Globalization API.","pos":[53378,53441]},{"pos":[53449,53458],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"pos":[53467,53486],"content":"Identifier (string)","linkify":"Identifier (string)","nodes":[{"content":"Identifier (string)","pos":[0,19]}]},{"content":"The label ID, as specified to the Globalization API.","pos":[53488,53540]},{"pos":[53548,53555],"content":"Returns","linkify":"Returns","nodes":[{"content":"Returns","pos":[0,7]}]},{"pos":[53564,53578],"content":"Value (string)","linkify":"Value (string)","nodes":[{"content":"Value (string)","pos":[0,14]}]},{"content":"The label string in the current culture, if the Identifier is found.","pos":[53580,53648]},{"content":"Otherwise, returns the supplied Identifier as a string.","pos":[53649,53704]},{"content":"The following example returns and prints the label named \"greeting\".","pos":[53705,53773]},{"pos":[53902,53905],"content":"CSS","linkify":"CSS","nodes":[{"content":"CSS","pos":[0,3]}]},{"content":"Add namespaces to all CSS class names by prepending the class name with the control’s template ID.","pos":[53911,54009]},{"content":"This will prevent your control and its styles from conflicting with other controls in the client.","pos":[54010,54107]},{"pos":[54112,54119],"content":"Flexbox","linkify":"Flexbox","nodes":[{"content":"Flexbox","pos":[0,7]}]},{"content":"For advanced layout scenarios we encourage using Flexbox.","pos":[54120,54177]},{"content":"Flexbox is compatible with the Extensible Control framework.","pos":[54178,54238]},{"content":"<bpt id=\"p1\">[</bpt>Using CSS flexible boxes (Mozilla Developer Network)<ept id=\"p1\">](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes)</ept> Please see the <bpt id=\"p2\">[</bpt>public Flexbox documentation<ept id=\"p2\">](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes)</ept> for explanations and examples of the following topics:","pos":[54239,54592],"source":"[Using CSS flexible boxes (Mozilla Developer Network)](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes) Please see the [public Flexbox documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes) for explanations and examples of the following topics:"},{"content":"Responsive layouts","pos":[54598,54616]},{"content":"Building columns and rows","pos":[54621,54646]},{"content":"Arranging elements horizontally or vertically","pos":[54651,54696]},{"content":"Arranging nesting elements","pos":[54701,54727]},{"content":"Auto-sizing elements to stretch and shrink","pos":[54732,54774]},{"content":"Locking/Freezing elements","pos":[54779,54804]},{"content":"Building scrollable elements","pos":[54809,54837]},{"pos":[54839,54865],"content":"Control Lifecycle Diagrams","linkify":"Control Lifecycle Diagrams","nodes":[{"content":"Control Lifecycle Diagrams","pos":[0,26]}]},{"pos":[54897,54918],"content":"Control Instantiation","linkify":"Control Instantiation","nodes":[{"content":"Control Instantiation","pos":[0,21]}]},{"pos":[54919,55021],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>ExtensibilityProcess<ept id=\"p1\">](./media/extensibilityprocess-951x1024.png)](./media/extensibilityprocess.png)</ept>","source":"[![ExtensibilityProcess](./media/extensibilityprocess-951x1024.png)](./media/extensibilityprocess.png)"}]}