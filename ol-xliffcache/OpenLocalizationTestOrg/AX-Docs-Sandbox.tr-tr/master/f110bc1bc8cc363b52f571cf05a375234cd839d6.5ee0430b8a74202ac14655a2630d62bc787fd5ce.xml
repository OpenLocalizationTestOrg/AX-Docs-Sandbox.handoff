{"nodes":[{"pos":[32,72],"content":"X++ Classes and Methods | Microsoft Docs","needQuote":true,"needEscape":true,"nodes":[{"content":"X++ Classes and Methods | Microsoft Docs","pos":[0,40]}]},{"pos":[86,157],"content":"This topic describes how to create and use class and interfaces in X++.","needQuote":true,"needEscape":true,"nodes":[{"content":"This topic describes how to create and use class and interfaces in X++.","pos":[0,71]}]},{"pos":[541,564],"content":"X++ Classes and Methods","linkify":"X++ Classes and Methods","nodes":[{"content":"X++ Classes and Methods","pos":[0,23]}]},{"pos":[566,580],"content":"Classes in X++","linkify":"Classes in X++","nodes":[{"content":"Classes in X++","pos":[0,14]}]},{"content":"A <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept> is a software construct that defines the data and methods of the specific concrete objects that are subsequently constructed from that class.","pos":[597,750],"source":"A **class** is a software construct that defines the data and methods of the specific concrete objects that are subsequently constructed from that class."},{"content":"The data represents the state of the object.","pos":[751,795]},{"content":"The methods represent the behavior of the object.","pos":[796,845]},{"content":"<bpt id=\"p1\">**</bpt>Variables<ept id=\"p1\">**</ept> are the data for the class.","pos":[846,887],"source":"**Variables** are the data for the class."},{"content":"Variables in a class are specific to objects that are constructed from that class.","pos":[888,970]},{"content":"Every object constructed from the class declaration has its own copy of the variables.","pos":[971,1057]},{"content":"Such variables are known as instance variables.","pos":[1058,1105]},{"content":"<bpt id=\"p1\">**</bpt>Methods<ept id=\"p1\">**</ept> define the behavior of a class.","pos":[1106,1149],"source":"**Methods** define the behavior of a class."},{"content":"They are the sequences of statements that operate on the data.","pos":[1150,1212]},{"content":"Methods are typically declared to operate on the instance variables of the class, and are known as instance methods or object methods.","pos":[1213,1347]},{"content":"You can also declare static methods and static fields.","pos":[1348,1402]},{"pos":[1407,1429],"content":"Declaration of Classes","linkify":"Declaration of Classes","nodes":[{"content":"Declaration of Classes","pos":[0,22]}]},{"pos":[1434,1467],"content":"Creating a Class in Visual Studio","linkify":"Creating a Class in Visual Studio","nodes":[{"content":"Creating a Class in Visual Studio","pos":[0,33]}]},{"content":"You create a class by following these steps:","pos":[1469,1513]},{"pos":[1519,1590],"content":"In <bpt id=\"p1\">**</bpt>Server Explorer<ept id=\"p1\">**</ept>, right-click on the project, and select <bpt id=\"p2\">**</bpt>Add<ept id=\"p2\">**</ept>.","source":"In **Server Explorer**, right-click on the project, and select **Add**."},{"pos":[1595,1671],"content":"In the <bpt id=\"p1\">**</bpt>New Item<ept id=\"p1\">**</ept> dialog, select <bpt id=\"p2\">**</bpt>Class<ept id=\"p2\">**</ept> and enter a name for the class.","source":"In the **New Item** dialog, select **Class** and enter a name for the class."},{"pos":[1676,1690],"content":"Click <bpt id=\"p1\">**</bpt>Add<ept id=\"p1\">**</ept>.","source":"Click **Add**."},{"content":"All classes are <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept>.","pos":[1692,1719],"source":"All classes are **public**."},{"content":"If you remove the <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> modifier, the system still treats the class as <bpt id=\"p2\">**</bpt>public<ept id=\"p2\">**</ept>.","pos":[1720,1807],"source":" If you remove the **public** modifier, the system still treats the class as **public**."},{"content":"Other modifiers can be specified on the class declaration, including <bpt id=\"p1\">**</bpt>final<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>extends<ept id=\"p2\">**</ept>.","pos":[1808,1903],"source":" Other modifiers can be specified on the class declaration, including **final** and **extends**."},{"pos":[1909,1938],"content":"Creating Variables in a Class","linkify":"Creating Variables in a Class","nodes":[{"content":"Creating Variables in a Class","pos":[0,29]}]},{"content":"All classes are public, but all member variables are implicitly private.","pos":[1940,2012]},{"content":"Even though all member variables are private, you cannot decorate a member variable with the <bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept> keyword.","pos":[2013,2126],"source":" Even though all member variables are private, you cannot decorate a member variable with the **private** keyword."},{"content":"All member variables belong only to object instances of the class.","pos":[2127,2193]},{"content":"The following code shows you how you would use accessor methods to make the variable data public.","pos":[2194,2291]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Accessor Methods<ept id=\"p1\">](#Accessor%20Methods)</ept>.","pos":[2292,2358],"source":" For more information, see [Accessor Methods](#Accessor%20Methods)."},{"pos":[2621,2633],"content":"Constructors","linkify":"Constructors","nodes":[{"content":"Constructors","pos":[0,12]}]},{"content":"To create an instance of a class (an object), you have to instantiate it.","pos":[2634,2707]},{"content":"The default constructor is the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method:","pos":[2708,2754],"source":" The default constructor is the **new** method:"},{"content":"It is a best practice to make the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method protected, and instead, use a <bpt id=\"p2\">**</bpt>static construct<ept id=\"p2\">**</ept> method, or <bpt id=\"p3\">**</bpt>static new<ept id=\"p3\">**</ept> method as the public constructor for the class.","pos":[2913,3086],"source":"It is a best practice to make the **new** method protected, and instead, use a **static construct** method, or **static new** method as the public constructor for the class."},{"content":"If no initialization is required, use a <bpt id=\"p1\">**</bpt>static construct<ept id=\"p1\">**</ept> method, otherwise use a <bpt id=\"p2\">**</bpt>static new<ept id=\"p2\">**</ept> method.","pos":[3087,3194],"source":" If no initialization is required, use a **static construct** method, otherwise use a **static new** method."},{"content":"For more information, see Best Practices for Constructors.","pos":[3195,3253]},{"pos":[3259,3300],"content":"Creating Other Objects from a Constructor","linkify":"Creating Other Objects from a Constructor","nodes":[{"content":"Creating Other Objects from a Constructor","pos":[0,41]}]},{"content":"A class constructor can instantiate other objects, in addition to creating an instance of the class.","pos":[3302,3402]},{"content":"The following code illustrates one such situation by declaring a <bpt id=\"p1\">**</bpt>Rectangle<ept id=\"p1\">**</ept> class that uses two <bpt id=\"p2\">**</bpt>Point<ept id=\"p2\">**</ept> objects to define its bounds.","pos":[3403,3541],"source":" The following code illustrates one such situation by declaring a **Rectangle** class that uses two **Point** objects to define its bounds."},{"pos":[3865,3876],"content":"Destructors","linkify":"Destructors","nodes":[{"content":"Destructors","pos":[0,11]}]},{"content":"A <bpt id=\"p1\">**</bpt>destructor<ept id=\"p1\">**</ept> is used to explicitly destroy a class object.","pos":[3877,3939],"source":"A **destructor** is used to explicitly destroy a class object."},{"content":"Objects are destructed automatically when there are no more references to them.","pos":[3940,4019]},{"content":"You can destruct them explicitly in the following ways:","pos":[4020,4075]},{"pos":[4081,4109],"content":"Use the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method.","source":"Use the **finalize** method."},{"pos":[4114,4148],"content":"Set the object handle to <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept>.","source":"Set the object handle to **null**."},{"pos":[4154,4169],"content":"finalize method","linkify":"finalize method","nodes":[{"content":"finalize method","pos":[0,15]}]},{"content":"Use the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method to explicitly destruct an object.","pos":[4171,4232],"source":"Use the **finalize** method to explicitly destruct an object."},{"content":"There are no implicit calls to the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method.","pos":[4233,4288],"source":" There are no implicit calls to the **finalize** method."},{"content":"You must call it to execute the statements in it.","pos":[4289,4338]},{"content":"The <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method is also where to put any other clean-up code.","pos":[4472,4541],"source":"The **finalize** method is also where to put any other clean-up code."},{"content":"For example, if your class uses a DLL module, you can use the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method to release the DLL when you no longer need it.","pos":[4542,4670],"source":" For example, if your class uses a DLL module, you can use the **finalize** method to release the DLL when you no longer need it."},{"content":"Use <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> carefully.","pos":[4671,4698],"source":" Use **finalize** carefully."},{"content":"It will destruct an object even if there are references to it.","pos":[4699,4761]},{"pos":[4767,4795],"content":"Set an Object Handle to null","linkify":"Set an Object Handle to null","nodes":[{"content":"Set an Object Handle to null","pos":[0,28]}]},{"content":"Set the object handle to <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept> to terminate an object.","pos":[4797,4854],"source":"Set the object handle to **null** to terminate an object."},{"content":"This only destroys the object if there are no other object handles pointing to it.","pos":[4855,4937]},{"content":"Check that other programmers haven't already used the object handle.","pos":[4938,5006]},{"content":"For example:","pos":[5007,5019]},{"pos":[5238,5257],"content":"Creating a Subclass","linkify":"Creating a Subclass","nodes":[{"content":"Creating a Subclass","pos":[0,19]}]},{"content":"Subclasses are classes that extend or inherit from other classes.","pos":[5258,5323]},{"content":"A class can only extend one other class; multiple inheritance is not supported.","pos":[5324,5403]},{"content":"If you extend a class, it inherits all the methods and variables in the parent class (the superclass).","pos":[5404,5506]},{"content":"Subclasses enable you to reuse existing code for a more specific purpose, saving time on design, development, and testing.","pos":[5507,5629]},{"content":"To customize the behavior of the superclass, override the methods in your subclass.","pos":[5630,5713]},{"content":"A superclass is often called a <bpt id=\"p1\">**</bpt>base<ept id=\"p1\">**</ept> class, and a subclass is often called a <bpt id=\"p2\">**</bpt>derived<ept id=\"p2\">**</ept> class.","pos":[5714,5812],"source":" A superclass is often called a **base** class, and a subclass is often called a **derived** class."},{"pos":[5818,5834],"content":"Subclass Example","linkify":"Subclass Example","nodes":[{"content":"Subclass Example","pos":[0,16]}]},{"pos":[5836,5950],"content":"The following example creates a class called <bpt id=\"p1\">**</bpt>Point<ept id=\"p1\">**</ept> and extends it to create a new class called <bpt id=\"p2\">**</bpt>ThreePoint<ept id=\"p2\">**</ept>.","source":"The following example creates a class called **Point** and extends it to create a new class called **ThreePoint**."},{"pos":[6538,6566],"content":"Preventing Class Inheritance","linkify":"Preventing Class Inheritance","nodes":[{"content":"Preventing Class Inheritance","pos":[0,28]}]},{"pos":[6568,6718],"content":"You can prevent classes from being inherited by using the <bpt id=\"p1\">**</bpt>final<ept id=\"p1\">**</ept> modifier: <bpt id=\"p2\">**</bpt>public final class Attribute<ept id=\"p2\">**</ept>  <bpt id=\"p3\">**</bpt>{<ept id=\"p3\">**</ept>  <bpt id=\"p4\">**</bpt>    int objectField;<ept id=\"p4\">**</ept>  <bpt id=\"p5\">**</bpt>}<ept id=\"p5\">**</ept>","source":"You can prevent classes from being inherited by using the **final** modifier: **public final class Attribute**  **{**  **    int objectField;**  **}**"},{"pos":[6723,6730],"content":"Methods","linkify":"Methods","nodes":[{"content":"Methods","pos":[0,7]}]},{"content":"The following list describes the code block types that are standard for application classes:","pos":[6731,6823]},{"content":"****classDescription<bpt id=\"p1\">**</bpt> declaration block<ept id=\"p1\">**</ept>: Contains class modifiers such as <bpt id=\"p2\">**</bpt>public<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>private<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>extends<ept id=\"p4\">**</ept>.","pos":[6829,6947],"source":"****classDescription** declaration block**: Contains class modifiers such as **public**, **private**, and **extends**."},{"content":"Also contains the field members for objects that are constructed from this class.","pos":[6948,7029]},{"content":"IntelliSense can display a list of the members when you type the keyword <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept>.","pos":[7030,7112],"source":" IntelliSense can display a list of the members when you type the keyword **this**."},{"content":"****new<bpt id=\"p1\">**</bpt> method<ept id=\"p1\">**</ept>: Creates an instance of the class.","pos":[7117,7170],"source":"****new** method**: Creates an instance of the class."},{"content":"The constructor can be called only by using the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> keyword.","pos":[7171,7235],"source":" The constructor can be called only by using the **new** keyword."},{"content":"Derived classes can call the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method of their constructor by calling <bpt id=\"p2\">**</bpt>super<ept id=\"p2\">**</ept> method reference.","pos":[7236,7339],"source":" Derived classes can call the **new** method of their constructor by calling **super** method reference."},{"content":"****finalize<bpt id=\"p1\">**</bpt> method<ept id=\"p1\">**</ept>: Finalizes an instance of the class.","pos":[7344,7404],"source":"****finalize** method**: Finalizes an instance of the class."},{"content":"The destructor method.","pos":[7405,7427]},{"content":"However, this is a destructor only by convention.","pos":[7428,7477]},{"content":"The <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method is not called automatically by the system during garbage collection.","pos":[7478,7570],"source":" The **finalize** method is not called automatically by the system during garbage collection."},{"content":"Additional methods for a class fall into the following types:","pos":[7572,7633]},{"content":"Instance methods","pos":[7639,7655]},{"content":"Static methods","pos":[7660,7674]},{"content":"Main methods","pos":[7679,7691]},{"content":"Methods can be created on many kinds of items.","pos":[7693,7739]},{"content":"The list includes the following:","pos":[7740,7772]},{"content":"Classes","pos":[7778,7785]},{"content":"Maps","pos":[7790,7794]},{"content":"Views","pos":[7799,7804]},{"content":"Data Sets","pos":[7809,7818]},{"content":"Forms","pos":[7823,7828]},{"content":"Queries","pos":[7833,7840]},{"pos":[7846,7862],"content":"Instance Methods","linkify":"Instance Methods","nodes":[{"content":"Instance Methods","pos":[0,16]}]},{"content":"Instance methods, or object methods, are embedded in each object that is created from the class.","pos":[7864,7960]},{"content":"You must instantiate the object before you can use the method.","pos":[7961,8023]},{"content":"If you later convert an instance method to a static method, you must restart the client for the compiler to note the change.","pos":[8024,8148]},{"content":"Once you have converted the instance method to a static method, you can no longer call this method from the instance of the class, only from the class itself.","pos":[8149,8307]},{"content":"Static methods are discussed in the next section.","pos":[8308,8357]},{"content":"Instance methods are called by using the following syntax:","pos":[8358,8416]},{"pos":[8508,8522],"content":"Static Methods","linkify":"Static Methods","nodes":[{"content":"Static Methods","pos":[0,14]}]},{"content":"Static methods, also called class methods, belong to a class and are created by using the keyword <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept>.","pos":[8524,8633],"source":"Static methods, also called class methods, belong to a class and are created by using the keyword **static**."},{"content":"You do not need to instantiate an object before you use static methods.","pos":[8634,8705]},{"content":"Static methods are widely used in Microsoft Dynamics AX to work with data that is stored in tables.","pos":[8706,8805]},{"content":"It is not possible to use member variables in a static method.","pos":[8806,8868]},{"content":"Static methods are called by using the following syntax:","pos":[8869,8925]},{"pos":[8961,8973],"content":"Main Methods","linkify":"Main Methods","nodes":[{"content":"Main Methods","pos":[0,12]}]},{"content":"A <bpt id=\"p1\">**</bpt>main<ept id=\"p1\">**</ept> method is a class method that is executed directly from a menu option.","pos":[8975,9056],"source":"A **main** method is a class method that is executed directly from a menu option."},{"content":"The method should only create an instance of the object and then call the necessary member methods.","pos":[9057,9156]},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\_</ph>args<ept id=\"p1\">**</ept> parameter allows you to transfer data to the method.","pos":[9157,9224],"source":" The **\\_args** parameter allows you to transfer data to the method."},{"pos":[9304,9326],"content":"Declaration of Methods","linkify":"Declaration of Methods","nodes":[{"content":"Declaration of Methods","pos":[0,22]}]},{"content":"Method declarations consist of a header and a body.","pos":[9328,9379]},{"content":"The method header declares the name and return type (possibly <bpt id=\"p1\">**</bpt>void<ept id=\"p1\">**</ept>) of the method, the method modifiers, and parameters.","pos":[9380,9504],"source":" The method header declares the name and return type (possibly **void**) of the method, the method modifiers, and parameters."},{"content":"The method body consists of variable declarations, method declarations, and statements.","pos":[9505,9592]},{"pos":[9598,9609],"content":"Return Type","linkify":"Return Type","nodes":[{"content":"Return Type","pos":[0,11]}]},{"content":"If a method does not return anything, you must specify this with the <bpt id=\"p1\">**</bpt>void<ept id=\"p1\">**</ept> keyword.","pos":[9611,9697],"source":"If a method does not return anything, you must specify this with the **void** keyword."},{"content":"The following example shows two methods, one with return type and one without.","pos":[9698,9776]},{"pos":[10030,10036],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[10038,10807],"content":"Method declaration = <bpt id=\"p1\">*</bpt>Heading<ept id=\"p1\">*</ept>  <bpt id=\"p2\">*</bpt>Body<ept id=\"p2\">*</ept> Heading = <bpt id=\"p3\">**</bpt><ph id=\"ph1\">\\[</ph><ept id=\"p3\">**</ept> <bpt id=\"p4\">*</bpt>Modifiers<ept id=\"p4\">*</ept> <bpt id=\"p5\">**</bpt><ph id=\"ph2\">\\]</ph><ept id=\"p5\">**</ept>  <bpt id=\"p6\">*</bpt>ReturnType<ept id=\"p6\">*</ept>  <bpt id=\"p7\">*</bpt>MethodName<ept id=\"p7\">*</ept>  <bpt id=\"p8\">**</bpt>(<ept id=\"p8\">**</ept>  <bpt id=\"p9\">*</bpt>ParameterList<ept id=\"p9\">*</ept>  <bpt id=\"p10\">**</bpt>)<ept id=\"p10\">**</ept> Modifiers = <bpt id=\"p11\">**</bpt><ph id=\"ph3\">\\[</ph>client<ph id=\"ph4\">\\]</ph> <ph id=\"ph5\">\\[</ph>server<ph id=\"ph6\">\\]</ph> <ph id=\"ph7\">\\[</ph>edit | display | public | protected | private<ph id=\"ph8\">\\]</ph> <ph id=\"ph9\">\\[</ph>static | abstract | final <ph id=\"ph10\">\\]</ph><ept id=\"p11\">**</ept> ReturnType = <bpt id=\"p12\">*</bpt>Datatype<ept id=\"p12\">*</ept>  <bpt id=\"p13\">**</bpt>| void | anytype<ept id=\"p13\">**</ept> MethodName = <bpt id=\"p14\">*</bpt>Identifier<ept id=\"p14\">*</ept> ParameterList = <bpt id=\"p15\">**</bpt><ph id=\"ph11\">\\[</ph><ept id=\"p15\">**</ept> <bpt id=\"p16\">*</bpt>Parameter<ept id=\"p16\">*</ept>  <bpt id=\"p17\">**</bpt>{ ,<ept id=\"p17\">**</ept>  <bpt id=\"p18\">*</bpt>Parameter<ept id=\"p18\">*</ept>  <bpt id=\"p19\">**</bpt>}<ph id=\"ph12\">\\]</ph><ept id=\"p19\">**</ept> Parameter = <bpt id=\"p20\">*</bpt>Datatype<ept id=\"p20\">*</ept>  <bpt id=\"p21\">*</bpt>Variableidentifier<ept id=\"p21\">*</ept>  <bpt id=\"p22\">**</bpt><ph id=\"ph13\">\\[</ph><ph id=\"ph14\"> =</ph><ept id=\"p22\">**</ept>  <bpt id=\"p23\">*</bpt>Expression<ept id=\"p23\">*</ept>  <bpt id=\"p24\">**</bpt><ph id=\"ph15\">\\]</ph><ept id=\"p24\">**</ept> Body = <bpt id=\"p25\">**</bpt>{ <ph id=\"ph16\">\\[</ph><ept id=\"p25\">**</ept>  <bpt id=\"p26\">*</bpt>VariableDeclarations<ept id=\"p26\">*</ept>  <bpt id=\"p27\">**</bpt><ph id=\"ph17\">\\]</ph> <ph id=\"ph18\">\\[</ph><ept id=\"p27\">**</ept>  <bpt id=\"p28\">*</bpt>EmbeddedFunctionDeclarations<ept id=\"p28\">*</ept>  <bpt id=\"p29\">**</bpt><ph id=\"ph19\">\\]</ph> <ph id=\"ph20\">\\[</ph><ept id=\"p29\">**</ept>  <bpt id=\"p30\">*</bpt>Statements<ept id=\"p30\">*</ept>  <bpt id=\"p31\">**</bpt><ph id=\"ph21\">\\]</ph> }<ept id=\"p31\">**</ept> EmbeddedFunctionDeclaration = <bpt id=\"p32\">*</bpt>Heading<ept id=\"p32\">*</ept>  <bpt id=\"p33\">**</bpt>{<ph id=\"ph22\">\\[</ph><ept id=\"p33\">**</ept>  <bpt id=\"p34\">*</bpt>VariableDeclarations<ept id=\"p34\">*</ept>  <bpt id=\"p35\">**</bpt><ph id=\"ph23\">\\]</ph> <ph id=\"ph24\">\\[</ph><ept id=\"p35\">**</ept>  <bpt id=\"p36\">*</bpt>Statements<ept id=\"p36\">*</ept>  <bpt id=\"p37\">**</bpt><ph id=\"ph25\">\\]</ph>}<ept id=\"p37\">**</ept> If you use the <bpt id=\"p38\">**</bpt>anytype<ept id=\"p38\">**</ept> return type, the method can return any data type.","source":"Method declaration = *Heading*  *Body* Heading = **\\[** *Modifiers* **\\]**  *ReturnType*  *MethodName*  **(**  *ParameterList*  **)** Modifiers = **\\[client\\] \\[server\\] \\[edit | display | public | protected | private\\] \\[static | abstract | final \\]** ReturnType = *Datatype*  **| void | anytype** MethodName = *Identifier* ParameterList = **\\[** *Parameter*  **{ ,**  *Parameter*  **}\\]** Parameter = *Datatype*  *Variableidentifier*  **\\[ =**  *Expression*  **\\]** Body = **{ \\[**  *VariableDeclarations*  **\\] \\[**  *EmbeddedFunctionDeclarations*  **\\] \\[**  *Statements*  **\\] }** EmbeddedFunctionDeclaration = *Heading*  **{\\[**  *VariableDeclarations*  **\\] \\[**  *Statements*  **\\]}** If you use the **anytype** return type, the method can return any data type."},{"pos":[10813,10855],"content":"Code Example: Method Without a Return Type","linkify":"Code Example: Method Without a Return Type","nodes":[{"content":"Code Example: Method Without a Return Type","pos":[0,42]}]},{"pos":[11443,11479],"content":"Code Example: Method with Parameters","linkify":"Code Example: Method with Parameters","nodes":[{"content":"Code Example: Method with Parameters","pos":[0,36]}]},{"pos":[11481,11615],"content":"In the following code example, the <bpt id=\"p1\">**</bpt>checkAccountBlocked<ept id=\"p1\">**</ept> method returns a <bpt id=\"p2\">**</bpt>Boolean<ept id=\"p2\">**</ept> value and acts on the parameter <bpt id=\"p3\">**</bpt>amountCur<ept id=\"p3\">**</ept>.","source":"In the following code example, the **checkAccountBlocked** method returns a **Boolean** value and acts on the parameter **amountCur**."},{"pos":[11914,11930],"content":"Method Modifiers","linkify":"Method Modifiers","nodes":[{"content":"Method Modifiers","pos":[0,16]}]},{"content":"There are several modifiers that can be applied to method declarations.","pos":[11931,12002]},{"content":"Some of the modifiers can be combined (for example, <bpt id=\"p1\">**</bpt>final static<ept id=\"p1\">**</ept>).","pos":[12003,12073],"source":" Some of the modifiers can be combined (for example, **final static**)."},{"content":"The following list describes method modifier keywords:","pos":[12074,12128]},{"content":"<bpt id=\"p1\">**</bpt>abstract<ept id=\"p1\">**</ept>: The method is declared but not implemented in a parent class.","pos":[12134,12209],"source":"**abstract**: The method is declared but not implemented in a parent class."},{"content":"The method must be overridden in subclasses.","pos":[12210,12254]},{"content":"If you try to create an object from a subclass where one or more of the abstract methods belonging to the parent class have not been overridden, you will get a compiler error.","pos":[12255,12430]},{"content":"Classes can also be abstract.","pos":[12431,12460]},{"content":"Sometimes a class represents an abstract concept, but it should not be instantiated: Only subclasses should be instantiated.","pos":[12461,12585]},{"content":"Such base classes can be declared abstract.","pos":[12586,12629]},{"content":"Consider the case where the programmer wants to model the concept of an account.","pos":[12630,12710]},{"content":"Accounts are abstract, because only derived classes (ledger accounts and so on) exist in the real world.","pos":[12711,12815]},{"content":"This would be a clear case for declaring the <bpt id=\"p1\">**</bpt>Account<ept id=\"p1\">**</ept> class abstract.","pos":[12816,12888],"source":" This would be a clear case for declaring the **Account** class abstract."},{"content":"<bpt id=\"p1\">**</bpt>display<ept id=\"p1\">**</ept>: Indicates that the method's return value is to be displayed on a form or a report.","pos":[12893,12988],"source":"**display**: Indicates that the method's return value is to be displayed on a form or a report."},{"content":"The value cannot be altered in the form or report.The return value is typically a calculated value, for example, a sum.","pos":[12989,13108]},{"content":"<bpt id=\"p1\">**</bpt>edit<ept id=\"p1\">**</ept>: Indicates that the method's return type is to be used to provide information for a field that is used in a form.","pos":[13113,13235],"source":"**edit**: Indicates that the method's return type is to be used to provide information for a field that is used in a form."},{"content":"The value in the field can be edited.","pos":[13236,13273]},{"pos":[13278,13377],"content":"<bpt id=\"p1\">**</bpt>final<ept id=\"p1\">**</ept>: Indicates that the method cannot be overridden in any class that derives from its class.","source":"**final**: Indicates that the method cannot be overridden in any class that derives from its class."},{"content":"<bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept>: Methods that are declared as <bpt id=\"p2\">**</bpt>public<ept id=\"p2\">**</ept> are accessible anywhere the class is accessible and can be overridden by subclasses.","pos":[13382,13518],"source":"**public**: Methods that are declared as **public** are accessible anywhere the class is accessible and can be overridden by subclasses."},{"content":"Methods that have no access modifier are implicitly <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept>.","pos":[13519,13582],"source":" Methods that have no access modifier are implicitly **public**."},{"pos":[13587,13759],"content":"<bpt id=\"p1\">**</bpt>protected<ept id=\"p1\">**</ept>: Methods that are declared as <bpt id=\"p2\">**</bpt>protected<ept id=\"p2\">**</ept> can only be called from methods in the class and in subclasses that extend the class where the method is declared.","source":"**protected**: Methods that are declared as **protected** can only be called from methods in the class and in subclasses that extend the class where the method is declared."},{"pos":[13764,13900],"content":"<bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept>: Methods that are declared as <bpt id=\"p2\">**</bpt>private<ept id=\"p2\">**</ept> can be called only from methods in the class where the private method is declared.","source":"**private**: Methods that are declared as **private** can be called only from methods in the class where the private method is declared."},{"content":"<bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept>: Specifies that the method is a class method and does not operate on an instance.","pos":[13905,13997],"source":"**static**: Specifies that the method is a class method and does not operate on an instance."},{"content":"<bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> methods cannot refer to instance variables and are invoked by using the class name rather than on an instance of the class (<bpt id=\"p2\">**</bpt>MyClass::aStaticProcedure()<ept id=\"p2\">**</ept>).","pos":[13998,14166],"source":"**static** methods cannot refer to instance variables and are invoked by using the class name rather than on an instance of the class (**MyClass::aStaticProcedure()**)."},{"pos":[14172,14194],"content":"Methods with Modifiers","linkify":"Methods with Modifiers","nodes":[{"content":"Methods with Modifiers","pos":[0,22]}]},{"content":"Only the method headers are shown in the following examples.","pos":[14196,14256]},{"pos":[14458,14478],"content":"Static Class Members","linkify":"Static Class Members","nodes":[{"content":"Static Class Members","pos":[0,20]}]},{"content":"You declare static class members by using the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> keyword.","pos":[14479,14544],"source":"You declare static class members by using the **static** keyword."},{"content":"The <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> keyword instructs the system to create only one instance of the method regardless of how many times you call new.","pos":[14545,14673],"source":" The **static** keyword instructs the system to create only one instance of the method regardless of how many times you call new."},{"content":"This single instance is used throughout your session.","pos":[14674,14727]},{"content":"Static methods are generally intended for cases where the following criteria are met:","pos":[14728,14813]},{"content":"The method has no reason to access the member variables that are declared in the class.","pos":[14819,14906]},{"content":"The method has no reason to call any instance (non-static) methods of the class.","pos":[14911,14991]},{"pos":[14998,15012],"content":"Static methods","linkify":"Static methods","nodes":[{"content":"Static methods","pos":[0,14]}]},{"content":"Consider the example of a software key type that is used for piracy prevention.","pos":[15014,15093]},{"content":"Each instance of a software key can have its own unique value.","pos":[15094,15156]},{"content":"But all software keys must conform to the rules of software key design.","pos":[15157,15228]},{"content":"Therefore the logic to test for software key conformance is the same for all software keys.","pos":[15229,15320]},{"content":"The method that contains the conformance validation logic should be static.","pos":[15321,15396]},{"content":"Here is an example of a method that is declared with the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> keyword:","pos":[15397,15473],"source":" Here is an example of a method that is declared with the **static** keyword:"},{"content":"In the following example, there is no need to first construct an instance of the <bpt id=\"p1\">**</bpt>SoftwareKey<ept id=\"p1\">**</ept> class before you call a static method on the class.","pos":[15575,15723],"source":"In the following example, there is no need to first construct an instance of the **SoftwareKey** class before you call a static method on the class."},{"content":"To call the static method <bpt id=\"p1\">**</bpt>validateSoftwareKey<ept id=\"p1\">**</ept>, the syntax starts with the name of the class that contains the method.","pos":[15724,15845],"source":" To call the static method **validateSoftwareKey**, the syntax starts with the name of the class that contains the method."},{"content":"A pair of colon (<bpt id=\"p1\">**</bpt>::<ept id=\"p1\">**</ept>) characters is used to connect the class name to the static method name.","pos":[15846,15942],"source":" A pair of colon (**::**) characters is used to connect the class name to the static method name."},{"pos":[16030,16043],"content":"Static fields","linkify":"Static fields","nodes":[{"content":"Static fields","pos":[0,13]}]},{"content":"Static fields are supported in X++.","pos":[16045,16080]},{"pos":[16086,16105],"content":"Static constructors","linkify":"Static constructors","nodes":[{"content":"Static constructors","pos":[0,19]}]},{"content":"Static constructors are guaranteed to run before any static or instance calls are made to the class.","pos":[16107,16207]},{"content":"In C<ph id=\"ph1\">\\#</ph>, the concept of static relates to the whole executing application domain.","pos":[16208,16288],"source":" In C\\#, the concept of static relates to the whole executing application domain."},{"content":"The execution of the static constructor is relative to the user’s session.","pos":[16289,16363]},{"content":"The static constructor has the following syntax:","pos":[16364,16412]},{"content":"You never call the static constructor explicitly; the compiler will generate code to ensure that the constructor is called exactly once prior to any other method on the class.","pos":[16442,16617]},{"content":"A static constructor is used to initialize any static data, or to perform a particular action that needs to be performed only once.","pos":[16618,16749]},{"content":"No parameters can be provided for the static constructor, and it must be marked as static.","pos":[16750,16840]},{"content":"Static fields are fields that are declared using the static keyword.","pos":[16841,16909]},{"content":"Conceptually they apply to the class, not instances of the class.","pos":[16910,16975]},{"content":"The following example shows how to create a singleton instance by using a static constructor.","pos":[16976,17069]},{"content":"The singleton will guarantee that only one instance of the class will ever be called.","pos":[17369,17454]},{"content":"The following code example shows how to instantiate the singleton.","pos":[17455,17521]},{"pos":[17585,17606],"content":"Method Access Control","linkify":"Method Access Control","nodes":[{"content":"Method Access Control","pos":[0,21]}]},{"content":"You use the accessor keywords <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>protected<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>private<ept id=\"p3\">**</ept> to control whether the methods in other classes can call the methods on your class.","pos":[17607,17763],"source":"You use the accessor keywords **public**, **protected**, and **private** to control whether the methods in other classes can call the methods on your class."},{"content":"The accessor keywords on methods also interact with the rules for class inheritance.","pos":[17764,17848]},{"content":"The following list describes the accessor keywords you use with methods.","pos":[17849,17921]},{"content":"<bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept>: Methods that are declared as <bpt id=\"p2\">**</bpt>public<ept id=\"p2\">**</ept> can be called from anywhere the class is accessible.","pos":[17927,18031],"source":"**public**: Methods that are declared as **public** can be called from anywhere the class is accessible."},{"content":"In addition, a public method can be overridden by a subclass, unless the method is declared as <bpt id=\"p1\">**</bpt>final<ept id=\"p1\">**</ept>.","pos":[18032,18137],"source":" In addition, a public method can be overridden by a subclass, unless the method is declared as **final**."},{"pos":[18142,18238],"content":"<bpt id=\"p1\">**</bpt>protected<ept id=\"p1\">**</ept>: Methods that are declared as <bpt id=\"p2\">**</bpt>protected<ept id=\"p2\">**</ept> can be called only from the following:","source":"**protected**: Methods that are declared as **protected** can be called only from the following:"},{"content":"From methods in the class.","pos":[18247,18273]},{"content":"From methods in a subclass of the class that contains the protected method.","pos":[18282,18357]},{"content":"Methods that are <bpt id=\"p1\">**</bpt>protected<ept id=\"p1\">**</ept> can be overridden in subclasses.","pos":[18358,18421],"source":" Methods that are **protected** can be overridden in subclasses."},{"content":"<bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept>: Methods that are declared as <bpt id=\"p2\">**</bpt>private<ept id=\"p2\">**</ept> can be called only from methods in the class where the private method is declared.","pos":[18426,18562],"source":"**private**: Methods that are declared as **private** can be called only from methods in the class where the private method is declared."},{"content":"No private method can be overridden in a subclass.When you create a new method, the default accessor keyword that appears in the code editor is <bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept>.","pos":[18563,18719],"source":" No private method can be overridden in a subclass.When you create a new method, the default accessor keyword that appears in the code editor is **private**."},{"content":"This is the most conservative default for maximum security.","pos":[18720,18779]},{"pos":[18785,18812],"content":"Static and Instance Methods","linkify":"Static and Instance Methods","nodes":[{"content":"Static and Instance Methods","pos":[0,27]}]},{"content":"The accessor keywords on methods never restrict call between two methods that are in the same class.","pos":[18814,18914]},{"content":"This is true regardless of which of the two methods are <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> or non-static.","pos":[18915,18996],"source":" This is true regardless of which of the two methods are **static** or non-static."},{"content":"In a static method, calls to the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> constructor method are valid even if the <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> constructor method is decorated with the <bpt id=\"p3\">**</bpt>private<ept id=\"p3\">**</ept> modifier.","pos":[18997,19149],"source":" In a static method, calls to the **new** constructor method are valid even if the **new** constructor method is decorated with the **private** modifier."},{"content":"The syntax for these calls requires the use of the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> keyword.","pos":[19150,19217],"source":" The syntax for these calls requires the use of the **new** keyword."},{"content":"The code in a static method must construct an instance object of its own class before the code can call any instance methods on the class.","pos":[19218,19356]},{"pos":[19362,19393],"content":"Increase Access When Overriding","linkify":"Increase Access When Overriding","nodes":[{"content":"Increase Access When Overriding","pos":[0,31]}]},{"content":"When a method is overridden in a subclass, the overriding method must be at least as accessible as the overridden method.","pos":[19395,19516]},{"content":"For example, the following compiler rules apply to overriding a <bpt id=\"p1\">**</bpt>protected<ept id=\"p1\">**</ept> method in a subclass:","pos":[19517,19616],"source":" For example, the following compiler rules apply to overriding a **protected** method in a subclass:"},{"pos":[19622,19720],"content":"A <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> method in a superclass can be overridden only by a <bpt id=\"p2\">**</bpt>public<ept id=\"p2\">**</ept> method in the subclass.","source":"A **public** method in a superclass can be overridden only by a **public** method in the subclass."},{"pos":[19725,19840],"content":"In a subclass, a <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> method or a <bpt id=\"p2\">**</bpt>protected<ept id=\"p2\">**</ept> method can override a <bpt id=\"p3\">**</bpt>protected<ept id=\"p3\">**</ept> method of the superclass.","source":"In a subclass, a **public** method or a **protected** method can override a **protected** method of the superclass."},{"pos":[19845,19938],"content":"In a subclass, a <bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept> method cannot override a <bpt id=\"p2\">**</bpt>protected<ept id=\"p2\">**</ept> method of the superclass.","source":"In a subclass, a **private** method cannot override a **protected** method of the superclass."},{"pos":[19943,19968],"content":"Using Optional Parameters","linkify":"Using Optional Parameters","nodes":[{"content":"Using Optional Parameters","pos":[0,25]}]},{"content":"It is possible to initialize parameters in the method declaration.","pos":[19969,20035]},{"content":"This makes the parameter an optional parameter.","pos":[20036,20083]},{"content":"If no value is supplied in the method call, the default value is used.","pos":[20084,20154]},{"content":"All required parameters must be listed before the first optional parameter.","pos":[20155,20230]},{"content":"The following code examples show how to create and call a method with optional parameters.","pos":[20231,20321]},{"content":"The <bpt id=\"p1\">**</bpt>AddThreeInts<ept id=\"p1\">**</ept> method shows that you cannot skip over default parameters when calling the method.","pos":[20322,20425],"source":" The **AddThreeInts** method shows that you cannot skip over default parameters when calling the method."},{"pos":[20431,20464],"content":"Optional Parameters Code Examples","linkify":"Optional Parameters Code Examples","nodes":[{"content":"Optional Parameters Code Examples","pos":[0,33]}]},{"pos":[22919,22935],"content":"Accessor Methods","linkify":"Accessor Methods","nodes":[{"content":"Accessor Methods","pos":[0,16]}]},{"content":"Class variables are private.","pos":[22936,22964]},{"content":"By hiding details of the internal implementation of a class, X++ allows the programmer to change the implementation of the class in the future without breaking any code that uses that class.","pos":[22965,23155]},{"content":"To access the data from reference variables, you need to create accessor methods.","pos":[23156,23237]},{"content":"The following example defines a <bpt id=\"p1\">**</bpt>Point<ept id=\"p1\">**</ept> class that uses accessor methods to access the variables <bpt id=\"p2\">**</bpt>x<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>y<ept id=\"p3\">**</ept>.","pos":[23238,23353],"source":" The following example defines a **Point** class that uses accessor methods to access the variables **x** and **y**."},{"content":"These method declarations illustrate how the <bpt id=\"p1\">**</bpt>Point<ept id=\"p1\">**</ept> class provides access to its variables from the outside world.","pos":[23910,24027],"source":"These method declarations illustrate how the **Point** class provides access to its variables from the outside world."},{"content":"Other objects can manipulate the instance variables of <bpt id=\"p1\">**</bpt>Point<ept id=\"p1\">**</ept> objects by using the accessor methods:","pos":[24028,24131],"source":" Other objects can manipulate the instance variables of **Point** objects by using the accessor methods:"},{"content":"The X++ callstack depth is limited to 100.","pos":[24423,24465]},{"pos":[24470,24489],"content":"Overriding a Method","linkify":"Overriding a Method","nodes":[{"content":"Overriding a Method","pos":[0,19]}]},{"content":"The methods in a class are inherited by any class that extends it.","pos":[24490,24556]},{"content":"You can alter the functionality of an inherited method by creating a method in the subclass with the same name and parameters as in the superclass.","pos":[24557,24704]},{"content":"This is called overriding the method.","pos":[24705,24742]},{"content":"In the following code example, <bpt id=\"p1\">**</bpt>ColorAttribute<ept id=\"p1\">**</ept> is a subclass of <bpt id=\"p2\">**</bpt>Attribute<ept id=\"p2\">**</ept> and therefore inherits the method <bpt id=\"p3\">**</bpt>methodAttr<ept id=\"p3\">**</ept>.","pos":[24743,24873],"source":" In the following code example, **ColorAttribute** is a subclass of **Attribute** and therefore inherits the method **methodAttr**."},{"content":"However, because <bpt id=\"p1\">**</bpt>ColorAttribute<ept id=\"p1\">**</ept> defines a method with the same name and the same number of arguments, the method in the superclass is overridden.","pos":[24874,25023],"source":" However, because **ColorAttribute** defines a method with the same name and the same number of arguments, the method in the superclass is overridden."},{"pos":[25406,25434],"content":"Preventing Method Overriding","linkify":"Preventing Method Overriding","nodes":[{"content":"Preventing Method Overriding","pos":[0,28]}]},{"content":"Static methods cannot be overridden because they exist per class.","pos":[25436,25501]},{"content":"To protect other sensitive methods, or core methods, from being overridden, use the <bpt id=\"p1\">**</bpt>final<ept id=\"p1\">**</ept> modifier.","pos":[25502,25605],"source":" To protect other sensitive methods, or core methods, from being overridden, use the **final** modifier."},{"content":"In the example below, <bpt id=\"p1\">**</bpt>methodAtt<ept id=\"p1\">**</ept> is declared as <bpt id=\"p2\">**</bpt>final<ept id=\"p2\">**</ept>, and so it cannot be overridden in any class that extends <bpt id=\"p3\">**</bpt>Attribute<ept id=\"p3\">**</ept>.","pos":[25606,25739],"source":" In the example below, **methodAtt** is declared as **final**, and so it cannot be overridden in any class that extends **Attribute**."},{"content":"You should not specify <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>finalize<ept id=\"p2\">**</ept> methods as <bpt id=\"p3\">**</bpt>final<ept id=\"p3\">**</ept>.","pos":[25740,25808],"source":" You should not specify **new** or **finalize** methods as **final**."},{"content":"The following example shows how to use the <bpt id=\"p1\">**</bpt>final<ept id=\"p1\">**</ept> keyword.","pos":[25809,25870],"source":" The following example shows how to use the **final** keyword."},{"pos":[26026,26052],"content":"Overriding vs. Overloading","linkify":"Overriding vs. Overloading","nodes":[{"content":"Overriding vs. Overloading","pos":[0,26]}]},{"content":"Overloading is where there is more than one method with the same name, but the methods have different signatures (return type or parameter lists or both).","pos":[26054,26208]},{"content":"Overriding is where the superclass's implementation of a method is altered by the subclass's implementation of the method, but the signatures of both methods are the same.","pos":[26209,26380]},{"content":"X++ supports overriding, but it does not support overloading.","pos":[26381,26442]},{"pos":[26447,26457],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The scope rules in X++ state that all methods have their own scope.","pos":[26458,26525]},{"content":"A method can take one or more parameters.","pos":[26526,26567]},{"content":"Within the scope of the method, these parameters are treated like local variables and are initialized with the value from the parameter in the method-call.","pos":[26568,26723]},{"content":"The following table shows an example.","pos":[26724,26761]},{"content":"All parameters are passed by value.","pos":[26762,26797]},{"content":"You cannot change the value of the original variable, you can change only the local variable in the method, which is a copy of the original.","pos":[26798,26938]},{"content":".","pos":[26939,26940]},{"pos":[26945,26974],"content":"Scope of Variables in Methods","linkify":"Scope of Variables in Methods","nodes":[{"content":"Scope of Variables in Methods","pos":[0,29]}]},{"content":"A scope defines the area in which an item can be accessed.","pos":[26975,27033]},{"content":"Variables defined in a class are available to the methods within that class.","pos":[27034,27110]},{"content":"Variables in methods can be accessed only within the current block, as shown in the following figure.","pos":[27111,27212]},{"pos":[27217,27232],"content":"Local Functions","linkify":"Local Functions","nodes":[{"content":"Local Functions","pos":[0,15]}]},{"content":"You can declare local functions inside a method.","pos":[27233,27281]},{"content":"The best practice is to add private methods to the class rather than to add local functions inside the method.","pos":[27282,27392]},{"content":"The following code example shows valid declarations of two local functions named <bpt id=\"p1\">**</bpt>localFunc55b<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>localFunc66c<ept id=\"p2\">**</ept>.","pos":[27393,27512],"source":" The following code example shows valid declarations of two local functions named **localFunc55b** and **localFunc66c**."},{"content":"This calls to the local functions occur after the function declarations in the code example, as is required.","pos":[27513,27621]},{"pos":[28490,28520],"content":"Declaration of Local Functions","linkify":"Declaration of Local Functions","nodes":[{"content":"Declaration of Local Functions","pos":[0,30]}]},{"content":"The local functions must be declared physically above any non-declaration statements that exist in the method.","pos":[28526,28636]},{"content":"You can declare more than one local function in your method.","pos":[28641,28701]},{"content":"But all local functions must be declared in an uninterrupted series, with the set terminated by one semicolon.","pos":[28702,28812]},{"pos":[28818,28838],"content":"Scoping of Variables","linkify":"Scoping of Variables","nodes":[{"content":"Scoping of Variables","pos":[0,20]}]},{"content":"Code that is inside the local function can access variables that are declared in the method that contains the local function.","pos":[28844,28969]},{"content":"Code that is outside the local function cannot access variables that are declared in the local function.","pos":[28974,29078]},{"pos":[29084,29108],"content":"Calls to Local Functions","linkify":"Calls to Local Functions","nodes":[{"content":"Calls to Local Functions","pos":[0,24]}]},{"content":"A local function can be called only by code in the same method where the local function is declared.","pos":[29114,29214]},{"content":"A local function should never call itself.","pos":[29219,29261]},{"content":"Such recursion can prevent the successful compilation.","pos":[29262,29316]},{"pos":[29321,29336],"content":"The this Object","linkify":"The this Object","nodes":[{"content":"The this Object","pos":[0,15]}]},{"content":"The keyword <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> is a reference to the instance of the class or table in which the <bpt id=\"p2\">**</bpt>this<ept id=\"p2\">**</ept> keyword is used.","pos":[29337,29449],"source":"The keyword **this** is a reference to the instance of the class or table in which the **this** keyword is used."},{"content":"The <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> reference is never required, but it can clarify your code, and it enhances the behavior of IntelliSense in the code editor.","pos":[29450,29586],"source":" The **this** reference is never required, but it can clarify your code, and it enhances the behavior of IntelliSense in the code editor."},{"content":"All calls to instance methods must be qualified, either with the <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> reference or with a variable.","pos":[29587,29690],"source":" All calls to instance methods must be qualified, either with the **this** reference or with a variable."},{"content":"The <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> reference can be used in the following ways:","pos":[29691,29748],"source":" The **this** reference can be used in the following ways:"},{"content":"Can be used to qualify the names of other instance (non-<bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept>) methods in the same class where the <bpt id=\"p2\">**</bpt>this<ept id=\"p2\">**</ept> reference is used.","pos":[29754,29885],"source":"Can be used to qualify the names of other instance (non-**static**) methods in the same class where the **this** reference is used."},{"content":"For example: <bpt id=\"p1\">**</bpt>boolColorChanged = this.colorItOrange();<ept id=\"p1\">**</ept>","pos":[29886,29943],"source":" For example: **boolColorChanged = this.colorItOrange();**"},{"pos":[29948,30034],"content":"Can be used to quality the names of methods that are inherited by the <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> object.","source":"Can be used to quality the names of methods that are inherited by the **this** object."},{"pos":[30039,30157],"content":"Can be used to qualify the names of fields on the table that contains the method that the <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> keyword is used in.","source":"Can be used to qualify the names of fields on the table that contains the method that the **this** keyword is used in."},{"pos":[30159,30219],"content":"The <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> reference cannot be used in the following ways:","source":"The **this** reference cannot be used in the following ways:"},{"pos":[30225,30332],"content":"Cannot be used to qualify the names of member variables that are declared in the <bpt id=\"p1\">**</bpt>classDeclaration<ept id=\"p1\">**</ept> code.","source":"Cannot be used to qualify the names of member variables that are declared in the **classDeclaration** code."},{"pos":[30337,30375],"content":"Cannot be used in a <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> method.","source":"Cannot be used in a **static** method."},{"pos":[30380,30460],"content":"Cannot be used to qualify the names of <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> methods of the class or table.","source":"Cannot be used to qualify the names of **static** methods of the class or table."},{"pos":[30465,30475],"content":"Interfaces","linkify":"Interfaces","nodes":[{"content":"Interfaces","pos":[0,10]}]},{"content":"An interface is a specification for a set of public instance methods.","pos":[30476,30545]},{"content":"The purpose of interfaces is to define and enforce similarities between unrelated classes without having to artificially derive one class from the other.","pos":[30546,30699]},{"content":"All interfaces are public regardless of whether you explicitly write the keyword <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> in front of the keyword <bpt id=\"p2\">**</bpt>interface<ept id=\"p2\">**</ept> in the <bpt id=\"p3\">**</bpt>classDeclaration<ept id=\"p3\">**</ept>.","pos":[30700,30858],"source":" All interfaces are public regardless of whether you explicitly write the keyword **public** in front of the keyword **interface** in the **classDeclaration**."},{"content":"The methods on an interface are also public, and again the explicit inclusion of the keyword <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> is optional.","pos":[30859,30975],"source":" The methods on an interface are also public, and again the explicit inclusion of the keyword **public** is optional."},{"content":"To create an interface:","pos":[30976,30999]},{"pos":[31005,31075],"content":"In <bpt id=\"p1\">**</bpt>Server Explorer<ept id=\"p1\">**</ept>, right-clickon the project, and select <bpt id=\"p2\">**</bpt>Add<ept id=\"p2\">**</ept>.","source":"In **Server Explorer**, right-clickon the project, and select **Add**."},{"pos":[31080,31164],"content":"In the <bpt id=\"p1\">**</bpt>New Item<ept id=\"p1\">**</ept> dialog, select <bpt id=\"p2\">**</bpt>Interface<ept id=\"p2\">**</ept> and enter a name for the interface.","source":"In the **New Item** dialog, select **Interface** and enter a name for the interface."},{"pos":[31169,31183],"content":"Click <bpt id=\"p1\">**</bpt>Add<ept id=\"p1\">**</ept>.","source":"Click **Add**."},{"content":"You can add the <bpt id=\"p1\">**</bpt>implements<ept id=\"p1\">**</ept> keyword on a class declaration, and this requires the class to declare the methods that are specified by the interface.","pos":[31185,31335],"source":"You can add the **implements** keyword on a class declaration, and this requires the class to declare the methods that are specified by the interface."},{"content":"A class declaration can implement multiple interfaces by listing them after the single occurrence of the <bpt id=\"p1\">**</bpt>implements<ept id=\"p1\">**</ept> keyword, with commas separating the interface names.","pos":[31336,31508],"source":" A class declaration can implement multiple interfaces by listing them after the single occurrence of the **implements** keyword, with commas separating the interface names."},{"content":"All interface methods that a class implements must be declared with the explicit keyword <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> in the class.","pos":[31509,31622],"source":" All interface methods that a class implements must be declared with the explicit keyword **public** in the class."},{"content":"Also, a class that implements an interface must also be declared with <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept>.","pos":[31623,31704],"source":" Also, a class that implements an interface must also be declared with **public**."},{"content":"An interface can extend another interface by using the <bpt id=\"p1\">**</bpt>extends<ept id=\"p1\">**</ept> keyword.","pos":[31705,31780],"source":" An interface can extend another interface by using the **extends** keyword."},{"content":"An interface cannot extend more than one interface.","pos":[31781,31832]},{"pos":[31838,31860],"content":"Interface Code Example","linkify":"Interface Code Example","nodes":[{"content":"Interface Code Example","pos":[0,22]}]},{"content":"This section shows the code for an <bpt id=\"p1\">**</bpt>Automobile<ept id=\"p1\">**</ept> class that implements an <bpt id=\"p2\">**</bpt>IDrivable<ept id=\"p2\">**</ept> interface.","pos":[31862,31961],"source":"This section shows the code for an **Automobile** class that implements an **IDrivable** interface."},{"content":"The keyword <bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept> is supported for testing whether a class that implements an interface.","pos":[31963,32052],"source":"  The keyword **is** is supported for testing whether a class that implements an interface."},{"pos":[33118,33154],"content":"Microsoft Dynamics AX Class Overview","linkify":"Microsoft Dynamics AX Class Overview","nodes":[{"content":"Microsoft Dynamics AX Class Overview","pos":[0,36]}]},{"content":"There are two main kinds of classes in Microsoft Dynamics AX:","pos":[33155,33216]},{"content":"Application classes are implemented in X++.","pos":[33222,33265]},{"content":"They are available in the Classes node in the Application Explorer.","pos":[33266,33333]},{"content":"System classes, sometimes called kernel classes, are implemented in C++.","pos":[33338,33410]},{"content":"They are listed under the <bpt id=\"p1\">**</bpt>System Documentation <ph id=\"ph1\">&amp;gt;</ph> Classes<ept id=\"p1\">**</ept> node in the Application Explorer.","pos":[33411,33508],"source":" They are listed under the **System Documentation &gt; Classes** node in the Application Explorer."},{"content":"However, the source code for these classes is not available.","pos":[33509,33569]},{"pos":[33574,33623],"content":"Substitute Application Classes for System Classes","linkify":"Substitute Application Classes for System Classes","nodes":[{"content":"Substitute Application Classes for System Classes","pos":[0,49]}]},{"content":"You should call the substitute application classes instead of calling the system classes that they extend.","pos":[33624,33730]},{"content":"In the <bpt id=\"p1\">**</bpt>Application Explorer <ept id=\"p1\">**</ept>under <bpt id=\"p2\">**</bpt>System Documentation <ph id=\"ph1\">&amp;gt;</ph> Classes<ept id=\"p2\">**</ept> there are several kernel or system classes whose names begin with a lowercase x.","pos":[33731,33887],"source":" In the **Application Explorer **under **System Documentation &gt; Classes** there are several kernel or system classes whose names begin with a lowercase x."},{"content":"Examples of the x system classes include <bpt id=\"p1\">**</bpt>xApplication<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>xVersionControl.<ept id=\"p2\">**</ept>","pos":[33888,33970],"source":" Examples of the x system classes include **xApplication** and **xVersionControl.**"},{"content":"Some of the x system classes are extended by application classes.","pos":[33971,34036]},{"content":"For example, the Application class extends the xApplication system class.","pos":[34037,34110]},{"content":"The classes that derive from the x system classes are called <bpt id=\"p1\">**</bpt>substitute application classes<ept id=\"p1\">**</ept>.","pos":[34111,34207],"source":" The classes that derive from the x system classes are called **substitute application classes**."},{"content":"In the <bpt id=\"p1\">**</bpt>Application Explorer <ept id=\"p1\">**</ept>under the <bpt id=\"p2\">**</bpt>Classes<ept id=\"p2\">**</ept> node, the icon next to the substitute application classes differs from the standard icon.","pos":[34208,34351],"source":" In the **Application Explorer **under the **Classes** node, the icon next to the substitute application classes differs from the standard icon."},{"pos":[34357,34385],"content":"Special X++ Global Variables","linkify":"Special X++ Global Variables","nodes":[{"content":"Special X++ Global Variables","pos":[0,28]}]},{"content":"Some of the substitute application classes that extend an x system class are associated with a special global variable that represents an instance of the class.","pos":[34387,34547]},{"content":"For example, the <bpt id=\"p1\">**</bpt>appl<ept id=\"p1\">**</ept> variable references a pre-instantiated object from the Application class.","pos":[34548,34647],"source":" For example, the **appl** variable references a pre-instantiated object from the Application class."},{"content":"The advantage of the <bpt id=\"p1\">**</bpt>appl<ept id=\"p1\">**</ept> variable is that the system maintains the object throughout the scope of your session.","pos":[34648,34764],"source":" The advantage of the **appl** variable is that the system maintains the object throughout the scope of your session."},{"content":"It would be less efficient for your code to repeatedly use the <bpt id=\"p1\">**</bpt>new Application()<ept id=\"p1\">**</ept> syntax to obtain an instance of the <bpt id=\"p2\">**</bpt>Application<ept id=\"p2\">**</ept> class.","pos":[34765,34908],"source":" It would be less efficient for your code to repeatedly use the **new Application()** syntax to obtain an instance of the **Application** class."},{"content":"You should not use the <bpt id=\"p1\">**</bpt>xApplication<ept id=\"p1\">**</ept> system class.","pos":[34909,34962],"source":" You should not use the **xApplication** system class."},{"content":"Use the <bpt id=\"p1\">**</bpt>Application<ept id=\"p1\">**</ept> substitute application class instead.","pos":[34963,35024],"source":" Use the **Application** substitute application class instead."},{"content":"You can reference the static members of the <bpt id=\"p1\">**</bpt>Application<ept id=\"p1\">**</ept> class by using the standard syntax <bpt id=\"p2\">**</bpt>Application::checkForNewBatchJobs()<ept id=\"p2\">**</ept>.","pos":[35025,35160],"source":" You can reference the static members of the **Application** class by using the standard syntax **Application::checkForNewBatchJobs()**."},{"content":"But you should reference the instance members of the <bpt id=\"p1\">**</bpt>Application<ept id=\"p1\">**</ept> class by using its corresponding special system variable <bpt id=\"p2\">**</bpt>appl<ept id=\"p2\">**</ept>, if one exists.","pos":[35161,35311],"source":" But you should reference the instance members of the **Application** class by using its corresponding special system variable **appl**, if one exists."},{"content":"This pattern applies to most of the x system classes.","pos":[35312,35365]},{"content":"The <bpt id=\"p1\">**</bpt>Session<ept id=\"p1\">**</ept> substitute application class is one exception to this pattern, because there is no special system variable for <bpt id=\"p2\">**</bpt>Session<ept id=\"p2\">**</ept>.","pos":[35366,35505],"source":" The **Session** substitute application class is one exception to this pattern, because there is no special system variable for **Session**."},{"content":"The following table lists x system classes for which there is a corresponding substitute application class.","pos":[35506,35613]},{"content":"The special global variables are also shown for those classes that have one.","pos":[35614,35690]},{"content":"Application class","pos":[35694,35711]},{"content":"System class","pos":[35714,35726]},{"content":"Global variable","pos":[35736,35751]},{"content":"Args","pos":[35824,35828]},{"pos":[35844,35853],"content":"<bpt id=\"p1\">**</bpt>xArgs<ept id=\"p1\">**</ept>","source":"**xArgs**"},{"content":"(none)","pos":[35866,35872]},{"content":"Application","pos":[35889,35900]},{"pos":[35909,35925],"content":"<bpt id=\"p1\">**</bpt>xApplication<ept id=\"p1\">**</ept>","source":"**xApplication**"},{"pos":[35931,35939],"content":"<bpt id=\"p1\">**</bpt>appl<ept id=\"p1\">**</ept>","source":"**appl**"},{"content":"ClassFactory","pos":[35954,35966]},{"pos":[35974,35991],"content":"<bpt id=\"p1\">**</bpt>xClassFactory<ept id=\"p1\">**</ept>","source":"**xClassFactory**"},{"pos":[35996,36012],"content":"<bpt id=\"p1\">**</bpt>classFactory<ept id=\"p1\">**</ept>","source":"**classFactory**"},{"content":"Company","pos":[36019,36026]},{"pos":[36039,36051],"content":"<bpt id=\"p1\">**</bpt>xCompany<ept id=\"p1\">**</ept>","source":"**xCompany**"},{"pos":[36061,36077],"content":"<bpt id=\"p1\">**</bpt>appl.company<ept id=\"p1\">**</ept>","source":"**appl.company**"},{"content":"Global","pos":[36084,36090]},{"pos":[36104,36115],"content":"<bpt id=\"p1\">**</bpt>xGlobal<ept id=\"p1\">**</ept>","source":"**xGlobal**"},{"content":"(none)","pos":[36126,36132]},{"content":"Info","pos":[36149,36153]},{"pos":[36169,36178],"content":"<bpt id=\"p1\">**</bpt>xInfo<ept id=\"p1\">**</ept>","source":"**xInfo**"},{"pos":[36191,36202],"content":"<bpt id=\"p1\">**</bpt>Infolog<ept id=\"p1\">**</ept>","source":"**Infolog**"},{"content":"MenuFunction","pos":[36214,36226]},{"pos":[36234,36251],"content":"<bpt id=\"p1\">**</bpt>xMenuFunction<ept id=\"p1\">**</ept>","source":"**xMenuFunction**"},{"content":"(none)","pos":[36256,36262]},{"content":"Session","pos":[36279,36286]},{"pos":[36299,36311],"content":"<bpt id=\"p1\">**</bpt>xSession<ept id=\"p1\">**</ept>","source":"**xSession**"},{"content":"(none)","pos":[36321,36327]},{"content":"VersionControl","pos":[36344,36358]},{"pos":[36364,36383],"content":"<bpt id=\"p1\">**</bpt>xVersionControl<ept id=\"p1\">**</ept>","source":"**xVersionControl**"},{"pos":[36386,36404],"content":"<bpt id=\"p1\">**</bpt>versionControl<ept id=\"p1\">**</ept>","source":"**versionControl**"},{"pos":[36412,36454],"content":"Example Method That Uses Special Variables","linkify":"Example Method That Uses Special Variables","nodes":[{"content":"Example Method That Uses Special Variables","pos":[0,42]}]},{"content":"The following method demonstrates the syntax for using several special variables that reference instances of the substitute application classes.","pos":[36456,36600]},{"pos":[37331,37355],"content":"Execute Startup Commands","linkify":"Execute Startup Commands","nodes":[{"content":"Execute Startup Commands","pos":[0,24]}]},{"content":"Use the <bpt id=\"p1\">**</bpt>SysStartupCmd<ept id=\"p1\">**</ept> class framework to execute commands at startup.","pos":[37356,37429],"source":"Use the **SysStartupCmd** class framework to execute commands at startup."},{"content":"When Microsoft Dynamics AX starts, calls are made to the <ph id=\"ph1\">\\*</ph><bpt id=\"p1\">**</bpt>startup<ept id=\"p1\">**</ept> methods on the application-substituted kernel classes <bpt id=\"p2\">**</bpt>Application<ept id=\"p2\">**</ept> (<bpt id=\"p3\">**</bpt>Application.startup<ept id=\"p3\">**</ept>) and <bpt id=\"p4\">**</bpt>Info<ept id=\"p4\">**</ept> (<bpt id=\"p5\">**</bpt>Info.startup<ept id=\"p5\">**</ept>).","pos":[37430,37629],"source":" When Microsoft Dynamics AX starts, calls are made to the \\***startup** methods on the application-substituted kernel classes **Application** (**Application.startup**) and **Info** (**Info.startup**)."},{"content":"The <ph id=\"ph1\">\\*</ph><bpt id=\"p1\">**</bpt>startup<ept id=\"p1\">**</ept> methods are used for vital system and version-specific calls, and you must never directly modify these methods.","pos":[37630,37759],"source":" The \\***startup** methods are used for vital system and version-specific calls, and you must never directly modify these methods."},{"content":"Instead, use the <bpt id=\"p1\">**</bpt>SysStartupCmd<ept id=\"p1\">**</ept> framework.","pos":[37760,37805],"source":" Instead, use the **SysStartupCmd** framework."},{"content":"Serious consequences may follow if the SYS layer versions of the startup methods are not called.","pos":[37806,37902]},{"content":"When Microsoft Dynamics AX is started, calls are executed in the sequence shown in the following code.","pos":[37903,38005]},{"pos":[38237,38289],"content":"Commands Available when Microsoft Dynamics AX Starts","linkify":"Commands Available when Microsoft Dynamics AX Starts","nodes":[{"content":"Commands Available when Microsoft Dynamics AX Starts","pos":[0,52]}]},{"content":"The commands that are available when Microsoft Dynamics AX starts are listed in the <bpt id=\"p1\">**</bpt>SysStartupCmd.construct<ept id=\"p1\">**</ept> method.","pos":[38291,38410],"source":"The commands that are available when Microsoft Dynamics AX starts are listed in the **SysStartupCmd.construct** method."},{"content":"The commands include the following:","pos":[38411,38446]},{"content":"AutoRun","pos":[38452,38459]},{"content":"AOTImport","pos":[38464,38473]},{"content":"Synchronize","pos":[38478,38489]},{"content":"The following code example shows how to execute a new command when Dynamics AX starts.","pos":[38491,38577]},{"content":"A class that extends SysStartupCmd is created that performs your specific task.","pos":[38578,38657]},{"content":"Then modify the construct method on SysStartupCmd to call your class.","pos":[38658,38727]},{"content":"You can add parameters commands that are executed on startup to the Command to run at application startup field on the General tab in the Microsoft Dynamics AX Configuration Utility.","pos":[38728,38910]},{"content":"Instead of giving the command from the Dynamics AX Configuration Utility, you might choose to use the command-line parameter <bpt id=\"p1\">**</bpt>-startupcmd=<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>MyCommand<ept id=\"p2\">*</ept>.","pos":[38911,39065],"source":" Instead of giving the command from the Dynamics AX Configuration Utility, you might choose to use the command-line parameter **-startupcmd=** *MyCommand*."},{"pos":[39880,39904],"content":"Batch Processing Classes","linkify":"Batch Processing Classes","nodes":[{"content":"Batch Processing Classes","pos":[0,24]}]},{"content":"Implement classes by using the batch processing system, and by extending the <bpt id=\"p1\">**</bpt>RunBase<ept id=\"p1\">**</ept> and the <bpt id=\"p2\">**</bpt>RunBaseBatch<ept id=\"p2\">**</ept> classes.","pos":[39905,40027],"source":"Implement classes by using the batch processing system, and by extending the **RunBase** and the **RunBaseBatch** classes."},{"content":"Remove the <bpt id=\"p1\">**</bpt>Recurrence<ept id=\"p1\">**</ept> button from the <bpt id=\"p2\">**</bpt>Batch processing<ept id=\"p2\">**</ept> dialog by using the <bpt id=\"p3\">**</bpt>Args::parmEnum<ept id=\"p3\">**</ept> method.","pos":[40028,40137],"source":" Remove the **Recurrence** button from the **Batch processing** dialog by using the **Args::parmEnum** method."},{"content":"It is recommended that you designate a class to run as a server-bound batch method.","pos":[40138,40221]},{"content":"Server-bound batch methods are more secure than methods that are not server-bound batch for the following reasons:","pos":[40222,40336]},{"content":"The method executes by using the permissions of the user who submitted the method.","pos":[40342,40424]},{"content":"The method can interact with the Microsoft Dynamics AX client, which is processing the method, by using only certain Info and Global class methods.","pos":[40429,40576]},{"content":"This limits interaction with the client.","pos":[40577,40617]},{"pos":[40623,40675],"content":"Enable a Class to Run as a Server-Bound Batch Method","linkify":"Enable a Class to Run as a Server-Bound Batch Method","nodes":[{"content":"Enable a Class to Run as a Server-Bound Batch Method","pos":[0,52]}]},{"content":"Create a class that extends the RunBaseBatch class.","pos":[40681,40732]},{"pos":[40737,40852],"content":"Override the RunBaseBatch.runsImpersonated method to return a value of <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept>, as shown in the following example.","source":"Override the RunBaseBatch.runsImpersonated method to return a value of **true**, as shown in the following example."},{"pos":[40946,41032],"content":"Confirm that the class calls only the following <bpt id=\"p1\">**</bpt>Info<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Global<ept id=\"p2\">**</ept> class methods:","source":"Confirm that the class calls only the following **Info** and **Global** class methods:"},{"pos":[41041,41048],"content":"<bpt id=\"p1\">**</bpt>add<ept id=\"p1\">**</ept>","source":"**add**"},{"pos":[41057,41070],"content":"<bpt id=\"p1\">**</bpt>Info.copy<ept id=\"p1\">**</ept>","source":"**Info.copy**"},{"pos":[41079,41091],"content":"<bpt id=\"p1\">**</bpt>Info.cut<ept id=\"p1\">**</ept>","source":"**Info.cut**"},{"pos":[41100,41115],"content":"<bpt id=\"p1\">**</bpt>Info.import<ept id=\"p1\">**</ept>","source":"**Info.import**"},{"pos":[41124,41139],"content":"<bpt id=\"p1\">**</bpt>Info.export<ept id=\"p1\">**</ept>","source":"**Info.export**"},{"pos":[41148,41161],"content":"<bpt id=\"p1\">**</bpt>Info.line<ept id=\"p1\">**</ept>","source":"**Info.line**"},{"pos":[41170,41182],"content":"<bpt id=\"p1\">**</bpt>Info.num<ept id=\"p1\">**</ept>","source":"**Info.num**"},{"pos":[41191,41208],"content":"<bpt id=\"p1\">**</bpt>Global::error<ept id=\"p1\">**</ept>","source":"**Global::error**"},{"pos":[41217,41233],"content":"<bpt id=\"p1\">**</bpt>Global::info<ept id=\"p1\">**</ept>","source":"**Global::info**"},{"pos":[41242,41261],"content":"<bpt id=\"p1\">**</bpt>Global::warning<ept id=\"p1\">**</ept>","source":"**Global::warning**"},{"pos":[41267,41345],"content":"The <bpt id=\"p1\">**</bpt>Info.line<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Info.num<ept id=\"p2\">**</ept> methods are inherited from the xInfo class.","source":"The **Info.line** and **Info.num** methods are inherited from the xInfo class."},{"pos":[41351,41412],"content":"Remove the Recurrence Button from the Batch Processing Dialog","linkify":"Remove the Recurrence Button from the Batch Processing Dialog","nodes":[{"content":"Remove the Recurrence Button from the Batch Processing Dialog","pos":[0,61]}]},{"content":"When you implement a class by using the batch processing system, call the <bpt id=\"p1\">**</bpt>Args.parmEnum<ept id=\"p1\">**</ept> method, and pass the <bpt id=\"p2\">**</bpt>NoYes::Yes<ept id=\"p2\">**</ept> system enumeration value to remove the <bpt id=\"p3\">**</bpt>Recurrence<ept id=\"p3\">**</ept> button.","pos":[41414,41603],"source":"When you implement a class by using the batch processing system, call the **Args.parmEnum** method, and pass the **NoYes::Yes** system enumeration value to remove the **Recurrence** button."},{"content":"The <bpt id=\"p1\">**</bpt>NoYes<ept id=\"p1\">**</ept> system enumeration determines whether the recurrence button is removed from the batch processing dialog.","pos":[41604,41722],"source":" The **NoYes** system enumeration determines whether the recurrence button is removed from the batch processing dialog."},{"content":"The default value is <bpt id=\"p1\">**</bpt>NoYes::No<ept id=\"p1\">**</ept>.","pos":[41723,41758],"source":" The default value is **NoYes::No**."},{"content":"In the following code example, the <bpt id=\"p1\">**</bpt>InventTransferMultiShip<ept id=\"p1\">**</ept> class is implemented.","pos":[41759,41843],"source":" In the following code example, the **InventTransferMultiShip** class is implemented."},{"content":"The <bpt id=\"p1\">**</bpt>BatchDialog::main<ept id=\"p1\">**</ept> method creates the <bpt id=\"p2\">**</bpt>Batch processing<ept id=\"p2\">**</ept> dialog.","pos":[41844,41917],"source":" The **BatchDialog::main** method creates the **Batch processing** dialog."},{"pos":[42256,42282],"content":"Image Manipulation Classes","linkify":"Image Manipulation Classes","nodes":[{"content":"Image Manipulation Classes","pos":[0,26]}]},{"content":"There are two system classes that enable you to manipulate graphics and icons.","pos":[42283,42361]},{"content":"The <bpt id=\"p1\">**</bpt>Image<ept id=\"p1\">**</ept> class enables you to load, save, and manipulate individual images.","pos":[42362,42442],"source":" The **Image** class enables you to load, save, and manipulate individual images."},{"content":"For example, you can capture a screen and save it as an image, crop or rotate an image, or manipulate the color depth.","pos":[42443,42561]},{"content":"The <bpt id=\"p1\">**</bpt>Imagelist<ept id=\"p1\">**</ept> class enables you to work with a set of images that have some common properties, such as size and transparency color.","pos":[42562,42697],"source":" The **Imagelist** class enables you to work with a set of images that have some common properties, such as size and transparency color."},{"content":"The image lists that are used in the application can be viewed in the application classes called <bpt id=\"p1\">**</bpt>ImageListAppl<ph id=\"ph1\">\\_</ph><ph id=\"ph2\">\\*</ph><ept id=\"p1\">**</ept>.","pos":[42698,42817],"source":" The image lists that are used in the application can be viewed in the application classes called **ImageListAppl\\_\\***."},{"pos":[42822,42840],"content":"Query Object Model","linkify":"Query Object Model","nodes":[{"content":"Query Object Model","pos":[0,18]}]},{"content":"The query object model contains classes to define and run a query.","pos":[42841,42907]},{"content":"These objects are used to define the query data source, the fields returned, record ranges and relations to child data sources.","pos":[42908,43035]},{"content":"The following illustration shows the object model.","pos":[43036,43086]},{"content":"The query components shown in the previous figure are system classes.","pos":[43087,43156]},{"content":"The query classes are more visible when you create a dynamic query in code, but they are also used behind the scenes when you create a static query in the <bpt id=\"p1\">**</bpt>Application Explorer<ept id=\"p1\">**</ept>.","pos":[43157,43337],"source":" The query classes are more visible when you create a dynamic query in code, but they are also used behind the scenes when you create a static query in the **Application Explorer**."},{"content":"System class","pos":[43341,43353]},{"content":"Description","pos":[43368,43379]},{"pos":[44467,44479],"content":"<bpt id=\"p1\">**</bpt>QueryRun<ept id=\"p1\">**</ept>","source":"**QueryRun**"},{"content":"Executes the query and fetches the data.","pos":[44494,44534]},{"pos":[45030,45039],"content":"<bpt id=\"p1\">**</bpt>Query<ept id=\"p1\">**</ept>","source":"**Query**"},{"content":"Holds some properties itself and has one or more related data sources.","pos":[45057,45127]},{"content":"The top level of the query definition.","pos":[45128,45166]},{"pos":[45593,45617],"content":"<bpt id=\"p1\">**</bpt>QueryBuildDataSource<ept id=\"p1\">**</ept>","source":"**QueryBuildDataSource**"},{"content":"Defines access to a single data source in the query.","pos":[45620,45672]},{"content":"If more than one data source exists at the same level in a query, they result in separate SQL statements that are executed sequentially.","pos":[45673,45809]},{"content":"If one data source exists as a child of another data source, a join is created between the two data sources.","pos":[45810,45918]},{"pos":[46156,46179],"content":"<bpt id=\"p1\">**</bpt>QueryBuildFieldList<ept id=\"p1\">**</ept>","source":"**QueryBuildFieldList**"},{"content":"Defines which fields are returned from the database.","pos":[46183,46235]},{"content":"The default is that the field list is dynamic, which returns all fields from the data source table, map, or view.","pos":[46236,46349]},{"content":"Each data source has only one <bpt id=\"p1\">**</bpt>QueryBuildFieldList<ept id=\"p1\">**</ept> object, which contains information on all selected fields.","pos":[46350,46462],"source":" Each data source has only one **QueryBuildFieldList** object, which contains information on all selected fields."},{"content":"It's possible to specify aggregate functions like <bpt id=\"p1\">**</bpt>SUM<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>COUNT<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>AVG<ept id=\"p3\">**</ept> on the field list object.","pos":[46463,46570],"source":" It's possible to specify aggregate functions like **SUM**, **COUNT**, and **AVG** on the field list object."},{"pos":[46719,46738],"content":"<bpt id=\"p1\">**</bpt>QueryBuildRange<ept id=\"p1\">**</ept>","source":"**QueryBuildRange**"},{"content":"Defines a subset of records returned based on a single field.","pos":[46746,46807]},{"content":"A range is translated into a <bpt id=\"p1\">**</bpt>WHERE<ept id=\"p1\">**</ept> clause in the query SQL statement.","pos":[46808,46881],"source":" A range is translated into a **WHERE** clause in the query SQL statement."},{"content":"If more than one field is used to limit the query (<bpt id=\"p1\">**</bpt>WHERE<ept id=\"p1\">**</ept> clause), the data source will contain more than one range.","pos":[46882,47001],"source":" If more than one field is used to limit the query (**WHERE** clause), the data source will contain more than one range."},{"pos":[47282,47304],"content":"<bpt id=\"p1\">**</bpt>QueryBuildDynalink<ept id=\"p1\">**</ept>","source":"**QueryBuildDynalink**"},{"content":"Contains information regarding a relation (limitation) to an external record.","pos":[47309,47386]},{"content":"When the query is run, this information is converted to additional entries in the <bpt id=\"p1\">**</bpt>WHERE<ept id=\"p1\">**</ept> clause of the query SQL statement.","pos":[47387,47513],"source":" When the query is run, this information is converted to additional entries in the **WHERE** clause of the query SQL statement."},{"content":"Can only exist on the parent data source of a query.","pos":[47514,47566]},{"content":"The function is used by forms, when two data sources are synchronized.","pos":[47567,47637]},{"content":"Then the child data source will contain a dynalink or dynalinks to the parent data source.","pos":[47638,47728]},{"content":"The function is used even if the two data sources are placed in two different forms but are still synchronized.","pos":[47729,47840]},{"pos":[47845,47863],"content":"<bpt id=\"p1\">**</bpt>QueryBuildLink<ept id=\"p1\">**</ept>","source":"**QueryBuildLink**"},{"content":"Specifies the relation between the two data sources in the join.","pos":[47872,47936]},{"content":"Can only exist on a child data source.","pos":[47937,47975]},{"pos":[48410,48433],"content":"System Classes Overview","linkify":"System Classes Overview","nodes":[{"content":"System Classes Overview","pos":[0,23]}]},{"content":"System classes (or kernel classes) are implemented in C++.","pos":[48434,48492]},{"content":"The source for these classes is not available.","pos":[48493,48539]},{"content":"A system class can have:","pos":[48540,48564]},{"content":"Static methods (or class methods)","pos":[48570,48603]},{"content":"Dynamic methods","pos":[48608,48623]},{"content":"Properties: these are member functions to set properties.","pos":[48628,48685]},{"content":"For example, <bpt id=\"p1\">**</bpt>LeftMargin<ept id=\"p1\">**</ept>.","pos":[48686,48714],"source":" For example, **LeftMargin**."},{"content":"You cannot override system class methods.","pos":[48716,48757]},{"content":"It is not intended that you design your application objects from scratch by using the system classes.","pos":[48758,48859]},{"content":"Instead, use them to extend or alter the default functionality in the <bpt id=\"p1\">**</bpt>Application Explorer<ept id=\"p1\">**</ept>.","pos":[48860,48955],"source":" Instead, use them to extend or alter the default functionality in the **Application Explorer**."},{"content":"For example, you could dynamically add extra information to an existing report or change the available options on a form, depending on the user's choice in a previous form.","pos":[48956,49128]},{"pos":[49134,49152],"content":"Collection Classes","linkify":"Collection Classes","nodes":[{"content":"Collection Classes","pos":[0,18]}]},{"content":"The Collection Classes in Microsoft Dynamics AX enable you to create lists, sets, structs, maps, and arrays.","pos":[49154,49262]},{"pos":[49268,49295],"content":"Application Objects Classes","linkify":"Application Objects Classes","nodes":[{"content":"Application Objects Classes","pos":[0,27]}]},{"content":"These system classes hold functions that are activated whenever you use the <bpt id=\"p1\">**</bpt>Application Explorer <ept id=\"p1\">**</ept>to create your application.","pos":[49297,49425],"source":"These system classes hold functions that are activated whenever you use the **Application Explorer **to create your application."},{"content":"For example, the system uses the <bpt id=\"p1\">**</bpt>FormDesign<ept id=\"p1\">**</ept> class when you define the layout of your form in the <bpt id=\"p2\">**</bpt>Designs<ept id=\"p2\">**</ept> node in the <bpt id=\"p3\">**</bpt>Application Explorer.<ept id=\"p3\">**</ept>","pos":[49426,49576],"source":" For example, the system uses the **FormDesign** class when you define the layout of your form in the **Designs** node in the **Application Explorer.**"},{"content":"These classes also enable you to create and modify application objects.","pos":[49577,49648]},{"content":"For example, if you want to change a property on a form string field, see Forms System classes and Query System Classes.","pos":[49649,49769]},{"pos":[49775,49794],"content":"Integration Classes","linkify":"Integration Classes","nodes":[{"content":"Integration Classes","pos":[0,19]}]},{"content":"The integration to the environment of Microsoft Dynamics AX is typically implemented by classes.","pos":[49796,49892]},{"content":"Some examples of classes of this category are:","pos":[49893,49939]},{"pos":[49945,49984],"content":"<bpt id=\"p1\">**</bpt>COM<ept id=\"p1\">**</ept>: call of methods on COM objects","source":"**COM**: call of methods on COM objects"},{"pos":[49989,50037],"content":"<bpt id=\"p1\">**</bpt>DLL<ept id=\"p1\">**</ept>: call of Microsoft Windows DLL functions","source":"**DLL**: call of Microsoft Windows DLL functions"},{"pos":[50042,50079],"content":"<bpt id=\"p1\">**</bpt>IO<ept id=\"p1\">**</ept>: Read and write external files","source":"**IO**: Read and write external files"},{"pos":[50084,50143],"content":"<bpt id=\"p1\">**</bpt>ODBCConnection<ept id=\"p1\">**</ept>: an ODBC interface to a foreign database","source":"**ODBCConnection**: an ODBC interface to a foreign database"},{"pos":[50154,50184],"content":"Event Terminology and Keywords","linkify":"Event Terminology and Keywords","nodes":[{"content":"Event Terminology and Keywords","pos":[0,30]}]},{"content":"In Microsoft Dynamics AX, you can use the event design pattern to make your code more modular and reusable.","pos":[50185,50292]},{"content":"The term <bpt id=\"p1\">**</bpt>event<ept id=\"p1\">**</ept> is a metaphor that explains how <bpt id=\"p2\">**</bpt>delegates<ept id=\"p2\">**</ept> are used.","pos":[50293,50367],"source":" The term **event** is a metaphor that explains how **delegates** are used."},{"content":"When something important occurs during a program run, there might be other modules that need to process the occurrence.","pos":[50368,50487]},{"content":"These important occurrences are called <bpt id=\"p1\">**</bpt>events<ept id=\"p1\">**</ept>.","pos":[50488,50538],"source":" These important occurrences are called **events**."},{"content":"When an event occurs, the program tells its <bpt id=\"p1\">**</bpt>notifier<ept id=\"p1\">**</ept> for the event that the notifier must send notifications of the event.","pos":[50539,50665],"source":" When an event occurs, the program tells its **notifier** for the event that the notifier must send notifications of the event."},{"content":"A notification must be sent to all the <bpt id=\"p1\">**</bpt>event handlers<ept id=\"p1\">**</ept> that are <bpt id=\"p2\">**</bpt>subscribers<ept id=\"p2\">**</ept> of the notifier.","pos":[50666,50765],"source":" A notification must be sent to all the **event handlers** that are **subscribers** of the notifier."},{"content":"When the program tells its notifier to send the notifications, we call that <bpt id=\"p1\">**</bpt>raising<ept id=\"p1\">**</ept> an event.","pos":[50766,50863],"source":" When the program tells its notifier to send the notifications, we call that **raising** an event."},{"content":"The following table displays the terms that are used to describe the event metaphor.","pos":[50864,50948]},{"content":"Metaphorical term","pos":[50952,50969]},{"content":"Description","pos":[50972,50983]},{"content":"event","pos":[51244,51249]},{"content":"An important occurrence in a program module where additional modules must process the occurrence.","pos":[51264,51361]},{"content":"notifier","pos":[51390,51398]},{"content":"The program element that sends information about the event to all the event handlers that are subscribed to the notifier.","pos":[51410,51531]},{"content":"subscriber","pos":[51536,51546]},{"content":"The program functions or methods that are subscribed to an event notifier.","pos":[51556,51630]},{"content":"event handler","pos":[51682,51695]},{"content":"The methods that subscribe to an event notifier.","pos":[51702,51750]},{"content":"Only the appropriate kind of methods can be event handlers.","pos":[51751,51810]},{"pos":[51831,51879],"content":"Keywords used for X++ Programming with Delegates","linkify":"Keywords used for X++ Programming with Delegates","nodes":[{"content":"Keywords used for X++ Programming with Delegates","pos":[0,48]}]},{"content":"The following table shows the X++ keywords that describe the use of delegates.","pos":[51881,51959]},{"content":"X++ keyword or term","pos":[51963,51982]},{"content":"Code","pos":[52009,52013]},{"content":"Description","pos":[52088,52099]},{"pos":[52779,52791],"content":"<bpt id=\"p1\">**</bpt>delegate<ept id=\"p1\">**</ept>","source":"**delegate**"},{"pos":[52825,52870],"content":"<bpt id=\"p1\">**</bpt>delegate myDelegate(str <ph id=\"ph1\">\\_</ph>information) {}<ept id=\"p1\">**</ept>","source":"**delegate myDelegate(str \\_information) {}**"},{"content":"The code shows how the delegate looks in the method editor in the MorphX client.","pos":[52904,52984]},{"content":"The return type is always void, so it is not mentioned in the syntax.","pos":[52985,53054]},{"content":"No code is allowed inside the <bpt id=\"p1\">**</bpt>{}<ept id=\"p1\">**</ept> braces.","pos":[53055,53099],"source":" No code is allowed inside the **{}** braces."},{"pos":[53187,53203],"content":"<bpt id=\"p1\">**</bpt>eventHandler<ept id=\"p1\">**</ept>","source":"**eventHandler**"},{"pos":[53233,53309],"content":"<bpt id=\"p1\">**</bpt>myClassInstance.myDelegate += eventHandler(otherClass.myInstanceMethod);<ept id=\"p1\">**</ept>","source":"**myClassInstance.myDelegate += eventHandler(otherClass.myInstanceMethod);**"},{"content":"The syntax of the <bpt id=\"p1\">**</bpt>eventHandler<ept id=\"p1\">**</ept> keyword might give the impression that <bpt id=\"p2\">**</bpt>eventHandler<ept id=\"p2\">**</ept> is an X++ function, but it is not a function.","pos":[53312,53448],"source":"The syntax of the **eventHandler** keyword might give the impression that **eventHandler** is an X++ function, but it is not a function."},{"content":"The <bpt id=\"p1\">**</bpt>eventHandler<ept id=\"p1\">**</ept> keyword tells the compiler that a method is being subscribed to a delegate.","pos":[53449,53545],"source":" The **eventHandler** keyword tells the compiler that a method is being subscribed to a delegate."},{"pos":[53595,53638],"content":"Subscribe or add a method to a <bpt id=\"p1\">**</bpt>delegate<ept id=\"p1\">**</ept>","source":"Subscribe or add a method to a **delegate**"},{"pos":[53641,53715],"content":"<bpt id=\"p1\">**</bpt>myClassInstance.myDelegate += eventHandler(OtherClass::aStaticMethod);<ept id=\"p1\">**</ept>","source":"**myClassInstance.myDelegate += eventHandler(OtherClass::aStaticMethod);**"},{"pos":[53720,53803],"content":"The static method <bpt id=\"p1\">**</bpt>OtherClass::aStaticMethod<ept id=\"p1\">**</ept> becomes subscribed to the delegate.","source":"The static method **OtherClass::aStaticMethod** becomes subscribed to the delegate."},{"pos":[54003,54022],"content":"Call a <bpt id=\"p1\">**</bpt>delegate<ept id=\"p1\">**</ept>","source":"Call a **delegate**"},{"pos":[54049,54089],"content":"<bpt id=\"p1\">**</bpt>myClassInstance.myDelegate(\"Hello\");<ept id=\"p1\">**</ept>","source":"**myClassInstance.myDelegate(\"Hello\");**"},{"content":"This call to the delegate prompts the delegate to call each method that is subscribed to the delegate.","pos":[54128,54230]},{"content":"The subscribed methods are called in the same sequence in which they were added to the delegate.","pos":[54231,54327]},{"content":"One subscribed method must complete before the delegate calls the next method.","pos":[54328,54406]}],"content":"---\n# required metadata\n\ntitle: X++ Classes and Methods | Microsoft Docs\ndescription: This topic describes how to create and use class and interfaces in X++.\nauthor: annbe\nmanager: AnnBe\nms.date: 2016-08-27 00:36:06\nms.topic: \nms.prod: \nms.service: \nms.technology: \n\n# optional metadata\n\n# keywords: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: 61\nms.suite: Released- Dynamics AX 7.0.0\n# ms.tgt_pltfrm: \nms.custom: 150303\nms.assetid: 789139ca-bf25-4ffa-a3d1-1d9884b21da5\n# ms.region: \n# ms.industry: \nms.author: annbe\n\n---\n\n# X++ Classes and Methods\n\nClasses in X++\n--------------\n\nA **class** is a software construct that defines the data and methods of the specific concrete objects that are subsequently constructed from that class. The data represents the state of the object. The methods represent the behavior of the object. **Variables** are the data for the class. Variables in a class are specific to objects that are constructed from that class. Every object constructed from the class declaration has its own copy of the variables. Such variables are known as instance variables. **Methods** define the behavior of a class. They are the sequences of statements that operate on the data. Methods are typically declared to operate on the instance variables of the class, and are known as instance methods or object methods. You can also declare static methods and static fields.\n\n## Declaration of Classes\n### Creating a Class in Visual Studio\n\nYou create a class by following these steps:\n\n1.  In **Server Explorer**, right-click on the project, and select **Add**.\n2.  In the **New Item** dialog, select **Class** and enter a name for the class.\n3.  Click **Add**.\n\nAll classes are **public**. If you remove the **public** modifier, the system still treats the class as **public**. Other modifiers can be specified on the class declaration, including **final** and **extends**.\n\n### Creating Variables in a Class\n\nAll classes are public, but all member variables are implicitly private. Even though all member variables are private, you cannot decorate a member variable with the **private** keyword. All member variables belong only to object instances of the class. The following code shows you how you would use accessor methods to make the variable data public. For more information, see [Accessor Methods](#Accessor%20Methods).\n\n    public class HasAFirstName\n    {\n        str firstName;\n        public str getFirstName()\n        {\n            return firstName;\n        }\n        \n        public void setFirstName(str newName)\n        {\n           firstName = newName;\n        }\n    }\n\n## Constructors\nTo create an instance of a class (an object), you have to instantiate it. The default constructor is the **new** method:\n\n    // Declare a variable to refer to a Point object\n    Point myPoint; \n        \n    // Allocate an instance of a Point object\n    myPoint = new Point(); \n\nIt is a best practice to make the **new** method protected, and instead, use a **static construct** method, or **static new** method as the public constructor for the class. If no initialization is required, use a **static construct** method, otherwise use a **static new** method. For more information, see Best Practices for Constructors.\n\n### Creating Other Objects from a Constructor\n\nA class constructor can instantiate other objects, in addition to creating an instance of the class. The following code illustrates one such situation by declaring a **Rectangle** class that uses two **Point** objects to define its bounds.\n\n    class Rectangle1\n    {\n        Point lowerLeft;\n        Point upperRight;\n\n        void new(real _topLeftX, real _topLeftY, real _bottomRightX, real _bottomRightY)\n        {\n            lowerLeft  = new Point(_topLeftX, _topLeftY);\n            upperRight = new Point(_bottomRightX, _bottomRightY);\n        }\n    }\n\n## Destructors\nA **destructor** is used to explicitly destroy a class object. Objects are destructed automatically when there are no more references to them. You can destruct them explicitly in the following ways:\n\n-   Use the **finalize** method.\n-   Set the object handle to **null**.\n\n### finalize method\n\nUse the **finalize** method to explicitly destruct an object. There are no implicit calls to the **finalize** method. You must call it to execute the statements in it.\n\n    // From any method in a class.\n    if (Condition)\n    {\n        // Removes object from memory.\n        this.finalize(); \n    }\n\nThe **finalize** method is also where to put any other clean-up code. For example, if your class uses a DLL module, you can use the **finalize** method to release the DLL when you no longer need it. Use **finalize** carefully. It will destruct an object even if there are references to it.\n\n### Set an Object Handle to null\n\nSet the object handle to **null** to terminate an object. This only destroys the object if there are no other object handles pointing to it. Check that other programmers haven't already used the object handle. For example:\n\n    // Create an object handle of the type MyObject.\n    MyObject mo;\n    // Create an object of MyObject type andlink it to the object handle.\n    mo = new myObject();\n    // Terminate the object.\n    mo = null;\n\n## Creating a Subclass\nSubclasses are classes that extend or inherit from other classes. A class can only extend one other class; multiple inheritance is not supported. If you extend a class, it inherits all the methods and variables in the parent class (the superclass). Subclasses enable you to reuse existing code for a more specific purpose, saving time on design, development, and testing. To customize the behavior of the superclass, override the methods in your subclass. A superclass is often called a **base** class, and a subclass is often called a **derived** class.\n\n### Subclass Example\n\nThe following example creates a class called **Point** and extends it to create a new class called **ThreePoint**.\n\n    class Point\n    {\n        // Instance fields.\n        real x; \n        real y; \n\n        // Constructor to initialize fields x and y.\n        void new(real _x, real _y)\n        { \n            x = _x;\n            y = _y;\n        }\n    }\n\n    class ThreePoint extends Point\n    {\n        // Additional instance fields z. Fields x and y are inherited.\n        real z; \n\n        // Constructor is overridden to initialize z.\n        void new(real _x, real _y, real _z)\n        {\n            // Initialize the fields.\n            super(_x, _y); \n            z = _z;\n        }\n    }\n\n### Preventing Class Inheritance\n\nYou can prevent classes from being inherited by using the **final** modifier: **public final class Attribute**  **{**  **    int objectField;**  **}**\n\n## Methods\nThe following list describes the code block types that are standard for application classes:\n\n-   ****classDescription** declaration block**: Contains class modifiers such as **public**, **private**, and **extends**. Also contains the field members for objects that are constructed from this class. IntelliSense can display a list of the members when you type the keyword **this**.\n-   ****new** method**: Creates an instance of the class. The constructor can be called only by using the **new** keyword. Derived classes can call the **new** method of their constructor by calling **super** method reference.\n-   ****finalize** method**: Finalizes an instance of the class. The destructor method. However, this is a destructor only by convention. The **finalize** method is not called automatically by the system during garbage collection.\n\nAdditional methods for a class fall into the following types:\n\n-   Instance methods\n-   Static methods\n-   Main methods\n\nMethods can be created on many kinds of items. The list includes the following:\n\n-   Classes\n-   Maps\n-   Views\n-   Data Sets\n-   Forms\n-   Queries\n\n### Instance Methods\n\nInstance methods, or object methods, are embedded in each object that is created from the class. You must instantiate the object before you can use the method. If you later convert an instance method to a static method, you must restart the client for the compiler to note the change. Once you have converted the instance method to a static method, you can no longer call this method from the instance of the class, only from the class itself. Static methods are discussed in the next section. Instance methods are called by using the following syntax:\n\n    ClassName objectHandleName = new ClassName();\n    objectHandleName.methodName();\n\n### Static Methods\n\nStatic methods, also called class methods, belong to a class and are created by using the keyword **static**. You do not need to instantiate an object before you use static methods. Static methods are widely used in Microsoft Dynamics AX to work with data that is stored in tables. It is not possible to use member variables in a static method. Static methods are called by using the following syntax:\n\n    ClassName::methodName();\n\n### Main Methods\n\nA **main** method is a class method that is executed directly from a menu option. The method should only create an instance of the object and then call the necessary member methods. The **\\_args** parameter allows you to transfer data to the method.\n\n    static void main (Args _args)\n    {\n        // Your code here.\n    }\n\n### Declaration of Methods\n\nMethod declarations consist of a header and a body. The method header declares the name and return type (possibly **void**) of the method, the method modifiers, and parameters. The method body consists of variable declarations, method declarations, and statements.\n\n### Return Type\n\nIf a method does not return anything, you must specify this with the **void** keyword. The following example shows two methods, one with return type and one without.\n\n    void methodNameNoReturnValue()\n    {\n        // Your code here.\n    }\n\n    // If a method returns something, you must specify the return type and include a return statement.\n    int methodNameIntegerReturnValue()\n    {\n        return 1;\n    }\n\n### Syntax\n\nMethod declaration = *Heading*  *Body* Heading = **\\[** *Modifiers* **\\]**  *ReturnType*  *MethodName*  **(**  *ParameterList*  **)** Modifiers = **\\[client\\] \\[server\\] \\[edit | display | public | protected | private\\] \\[static | abstract | final \\]** ReturnType = *Datatype*  **| void | anytype** MethodName = *Identifier* ParameterList = **\\[** *Parameter*  **{ ,**  *Parameter*  **}\\]** Parameter = *Datatype*  *Variableidentifier*  **\\[ =**  *Expression*  **\\]** Body = **{ \\[**  *VariableDeclarations*  **\\] \\[**  *EmbeddedFunctionDeclarations*  **\\] \\[**  *Statements*  **\\] }** EmbeddedFunctionDeclaration = *Heading*  **{\\[**  *VariableDeclarations*  **\\] \\[**  *Statements*  **\\]}** If you use the **anytype** return type, the method can return any data type.\n\n### Code Example: Method Without a Return Type\n\n    void update ()\n    {   \n        // Variable declared and initialized\n        CustTable this_Orig = this.orig();\n\n        // First statement in body (begin transaction)\n        ttsBegin;\n        this.setNameAlias();\n        // Calls super's implementation of update\n        super();\n        this.setAccountOnVend(this_Orig);\n        if (this_Orig.custGroup != this.custGroup)\n            ForecastSales::setCustGroupId(\n                this.accountNum,\n                this_Orig.custGroup,\n                this.custGroup);\n        // Commits transaction\n        ttsCommit;\n    }\n\n### Code Example: Method with Parameters\n\nIn the following code example, the **checkAccountBlocked** method returns a **Boolean** value and acts on the parameter **amountCur**.\n\n    boolean checkAccountBlocked(AmountCur amountCur)\n    {\n        if (this.blocked == CustVendorBlocked::All \n            ||(this.blocked == CustVendorBlocked::Invoice \n            && amountCur > 0 ))\n        return checkFailed(strFmt(\"@SYS7987\",this.accountNum));\n        return true;\n    }\n\n## Method Modifiers\nThere are several modifiers that can be applied to method declarations. Some of the modifiers can be combined (for example, **final static**). The following list describes method modifier keywords:\n\n-   **abstract**: The method is declared but not implemented in a parent class. The method must be overridden in subclasses. If you try to create an object from a subclass where one or more of the abstract methods belonging to the parent class have not been overridden, you will get a compiler error. Classes can also be abstract. Sometimes a class represents an abstract concept, but it should not be instantiated: Only subclasses should be instantiated. Such base classes can be declared abstract. Consider the case where the programmer wants to model the concept of an account. Accounts are abstract, because only derived classes (ledger accounts and so on) exist in the real world. This would be a clear case for declaring the **Account** class abstract.\n-   **display**: Indicates that the method's return value is to be displayed on a form or a report. The value cannot be altered in the form or report.The return value is typically a calculated value, for example, a sum.\n-   **edit**: Indicates that the method's return type is to be used to provide information for a field that is used in a form. The value in the field can be edited.\n-   **final**: Indicates that the method cannot be overridden in any class that derives from its class.\n-   **public**: Methods that are declared as **public** are accessible anywhere the class is accessible and can be overridden by subclasses. Methods that have no access modifier are implicitly **public**.\n-   **protected**: Methods that are declared as **protected** can only be called from methods in the class and in subclasses that extend the class where the method is declared.\n-   **private**: Methods that are declared as **private** can be called only from methods in the class where the private method is declared.\n-   **static**: Specifies that the method is a class method and does not operate on an instance. **static** methods cannot refer to instance variables and are invoked by using the class name rather than on an instance of the class (**MyClass::aStaticProcedure()**).\n\n### Methods with Modifiers\n\nOnly the method headers are shown in the following examples.\n\n    // A method that cannot be overridden\n    final int dontAlterMe() \n\n    // A static method \n    static void noChange()\n\n    // A display method that returns an integer\n    display int value()\n\n## Static Class Members\nYou declare static class members by using the **static** keyword. The **static** keyword instructs the system to create only one instance of the method regardless of how many times you call new. This single instance is used throughout your session. Static methods are generally intended for cases where the following criteria are met:\n\n-   The method has no reason to access the member variables that are declared in the class.\n-   The method has no reason to call any instance (non-static) methods of the class.\n\n#### Static methods\n\nConsider the example of a software key type that is used for piracy prevention. Each instance of a software key can have its own unique value. But all software keys must conform to the rules of software key design. Therefore the logic to test for software key conformance is the same for all software keys. The method that contains the conformance validation logic should be static. Here is an example of a method that is declared with the **static** keyword:\n\n    static public boolean validateSoftwareKey(str _softwareKeyString)  {      // Your code here. }\n\nIn the following example, there is no need to first construct an instance of the **SoftwareKey** class before you call a static method on the class. To call the static method **validateSoftwareKey**, the syntax starts with the name of the class that contains the method. A pair of colon (**::**) characters is used to connect the class name to the static method name.\n\n    boolean yourBool = SoftwareKey::validateSoftwareKey(yourSoftwareKeyString);\n\n#### Static fields\n\nStatic fields are supported in X++.\n\n### Static constructors\n\nStatic constructors are guaranteed to run before any static or instance calls are made to the class. In C\\#, the concept of static relates to the whole executing application domain. The execution of the static constructor is relative to the user’s session. The static constructor has the following syntax:\n\n    static void TypeNew() \n\nYou never call the static constructor explicitly; the compiler will generate code to ensure that the constructor is called exactly once prior to any other method on the class. A static constructor is used to initialize any static data, or to perform a particular action that needs to be performed only once. No parameters can be provided for the static constructor, and it must be marked as static. Static fields are fields that are declared using the static keyword. Conceptually they apply to the class, not instances of the class. The following example shows how to create a singleton instance by using a static constructor.\n\n    public class Singleton\n    {\n      private static Singleton instance;\n\n      private void new()\n      {\n      }\n\n      static void TypeNew()\n      {\n        instance = new Singleton();\n      }\n\n      public static Singleton Instance()\n      {\n        return Singleton::instance;\n      }\n    }\n\nThe singleton will guarantee that only one instance of the class will ever be called. The following code example shows how to instantiate the singleton.\n\n    {\n\n        Singleton i = Singleton::Instance();\n    }\n\n## Method Access Control\nYou use the accessor keywords **public**, **protected**, and **private** to control whether the methods in other classes can call the methods on your class. The accessor keywords on methods also interact with the rules for class inheritance. The following list describes the accessor keywords you use with methods.\n\n-   **public**: Methods that are declared as **public** can be called from anywhere the class is accessible. In addition, a public method can be overridden by a subclass, unless the method is declared as **final**.\n-   **protected**: Methods that are declared as **protected** can be called only from the following:\n    -   From methods in the class.\n    -   From methods in a subclass of the class that contains the protected method. Methods that are **protected** can be overridden in subclasses.\n-   **private**: Methods that are declared as **private** can be called only from methods in the class where the private method is declared. No private method can be overridden in a subclass.When you create a new method, the default accessor keyword that appears in the code editor is **private**. This is the most conservative default for maximum security.\n\n### Static and Instance Methods\n\nThe accessor keywords on methods never restrict call between two methods that are in the same class. This is true regardless of which of the two methods are **static** or non-static. In a static method, calls to the **new** constructor method are valid even if the **new** constructor method is decorated with the **private** modifier. The syntax for these calls requires the use of the **new** keyword. The code in a static method must construct an instance object of its own class before the code can call any instance methods on the class.\n\n### Increase Access When Overriding\n\nWhen a method is overridden in a subclass, the overriding method must be at least as accessible as the overridden method. For example, the following compiler rules apply to overriding a **protected** method in a subclass:\n\n-   A **public** method in a superclass can be overridden only by a **public** method in the subclass.\n-   In a subclass, a **public** method or a **protected** method can override a **protected** method of the superclass.\n-   In a subclass, a **private** method cannot override a **protected** method of the superclass.\n\n## Using Optional Parameters\nIt is possible to initialize parameters in the method declaration. This makes the parameter an optional parameter. If no value is supplied in the method call, the default value is used. All required parameters must be listed before the first optional parameter. The following code examples show how to create and call a method with optional parameters. The **AddThreeInts** method shows that you cannot skip over default parameters when calling the method.\n\n### Optional Parameters Code Examples\n\n    // This is an example of a function being used as the default.\n    public class Person \n    {\n        date birthDate;\n\n        // The constructor that takes a date type as\n        // a parameter. That value is assigned to the field member birthDate. \n        void new(date _date)\n        {\n            birthDate = _date;\n        }\n\n        // The CalculateAgeAsOfDate method references\n        // the birthDate field, is called by the Main method, and has an \n        // optional parameter. In this example, the default value is the\n        // return value of a function. \n        public real CalculateAgeAsOfDate(date _calcToDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) )  \n        {\n            return (_calcToDate - birthDate) / 365;\n        }\n\n        // The Main method calls the CalculateAgeAsOfDate method twice. \n        static public void Main(Args _args)\n        {\n            Person mc = new Person(13\\5\\2010);   // birthDate is initialized.\n            // Optional parameter's default is used.\n            print( \"Age in years: \" + num2str(mc.CalculateAgeAsOfDate(),2,0,0,0));\n            // January 2, 2044  is the parameter value for _date.\n            print \"Age in years: \" + num2str(mc.CalculateAgeAsOfDate(2\\1\\2044),2,0,0,0);\n        }\n    }\n\n    // This is an example of how you cannot skip to a second optional parameter. \n    // The first method has two optional parameters. The second method is a caller \n    // of the first method. The caller wants to override only the _i3 default value, but the \n    // compiler requires that all prior optional parameters also \n    // be overriden in the call. \n    public class Additions {\n        static public int AddThreeInts(int _i1, int _i2 = 2,int _i3 = 3)\n        {\n            return _i1 + _i2 + _i3;\n        }\n    }\n\n    // The second method has a commented section showing the\n    // failed attempt to accept the default of the first optional \n    // parameter (_i2) while trying to override the final optional \n    // parameter (_i3).\n    static public void Main(Args _args)\n    { \n        // No way to skip the first optional parameter (so it can default)\n        // while also specifying the value of the second optional parameter.\n        // The next statement does not compile.\n        //print Additions::AddThreeInts(1, , 99);\n\n        // Settle for overriding both optional parameters.\n        print Additions::AddThreeInts(1, 2, 99);\n    }\n\n## Accessor Methods\nClass variables are private. By hiding details of the internal implementation of a class, X++ allows the programmer to change the implementation of the class in the future without breaking any code that uses that class. To access the data from reference variables, you need to create accessor methods. The following example defines a **Point** class that uses accessor methods to access the variables **x** and **y**.\n\n    class Point\n    {\n        // Instance variables\n        real x; \n        real y;\n\n        //Constructor to initialize to a specific or default value\n        void new(real _x=10, real _y=10) \n        {\n            x = _x;\n            y = _y;\n        }\n\n        //Accessor methods\n        void setX(real _x) \n        {\n            x = _x;\n        }\n\n        void setY(real _y) \n        {\n            y = _y;\n        }\n\n        real getX() \n        {\n            return x;\n        }\n\n        real getY() \n        {\n            return y;\n        }\n    }\n\nThese method declarations illustrate how the **Point** class provides access to its variables from the outside world. Other objects can manipulate the instance variables of **Point** objects by using the accessor methods:\n\n    // Declare a variable to refer to a Point object\n    Point myPoint; \n    // Create a Point object\n    myPoint = new Point(); \n    // Set the x variable using the accessor method\n    myPoint.setX(10.0); \n    // Set the y variable by means of the accessor method\n    myPoint.setY(25.7);\n\nThe X++ callstack depth is limited to 100.\n\n## Overriding a Method\nThe methods in a class are inherited by any class that extends it. You can alter the functionality of an inherited method by creating a method in the subclass with the same name and parameters as in the superclass. This is called overriding the method. In the following code example, **ColorAttribute** is a subclass of **Attribute** and therefore inherits the method **methodAttr**. However, because **ColorAttribute** defines a method with the same name and the same number of arguments, the method in the superclass is overridden.\n\n    // Superclass: Attribute\n    public class Attribute\n    {\n        int objectVariable;\n\n        void methodAtt()\n        {\n            //Some statements\n        }\n    }\n\n    // Subclass: ColorAttribute\n    public class ColorAttribute extends Attribute\n    {\n        int addedObjectVariable;\n\n        void methodAtt()\n        {\n            //Some statements\n        }\n    }\n\n### Preventing Method Overriding\n\nStatic methods cannot be overridden because they exist per class. To protect other sensitive methods, or core methods, from being overridden, use the **final** modifier. In the example below, **methodAtt** is declared as **final**, and so it cannot be overridden in any class that extends **Attribute**. You should not specify **new** or **finalize** methods as **final**. The following example shows how to use the **final** keyword.\n\n    public class Attribute\n    {\n        int objectVariable;\n\n        final void methodAtt()\n        {\n            //Some statements\n        }\n    }\n\n### Overriding vs. Overloading\n\nOverloading is where there is more than one method with the same name, but the methods have different signatures (return type or parameter lists or both). Overriding is where the superclass's implementation of a method is altered by the subclass's implementation of the method, but the signatures of both methods are the same. X++ supports overriding, but it does not support overloading.\n\n## Parameters\nThe scope rules in X++ state that all methods have their own scope. A method can take one or more parameters. Within the scope of the method, these parameters are treated like local variables and are initialized with the value from the parameter in the method-call. The following table shows an example. All parameters are passed by value. You cannot change the value of the original variable, you can change only the local variable in the method, which is a copy of the original. .\n\n## Scope of Variables in Methods\nA scope defines the area in which an item can be accessed. Variables defined in a class are available to the methods within that class. Variables in methods can be accessed only within the current block, as shown in the following figure.\n\n## Local Functions\nYou can declare local functions inside a method. The best practice is to add private methods to the class rather than to add local functions inside the method. The following code example shows valid declarations of two local functions named **localFunc55b** and **localFunc66c**. This calls to the local functions occur after the function declarations in the code example, as is required.\n\n    static void G_LocalFuncJob2(Args _args) \n    {\n        int nn = 654;\n        void localFunc55b(int _iNum)  // The local function.\n        {\n            str sInnerString;\n            sInnerString = \"String_in_localFunc55b\";\n            info(strFmt(\"localFunc55b: %1 , %2 , %3\", \n                _iNum, sInnerString, nn));\n        }\n\n        void localFunc66c()\n        {\n            info(\"Printing from inside localFunc66c.\");\n        }\n\n\n        localFunc55b(55);\n        localFunc66c();\n        // Next print statement would fail to compile,\n        // because sInnerString is restricted to the\n        // scope of the local function in which it is declared.\n        // print sInnerString; \n    }\n    /***  Infolog window display:\n    Message (07:38:54 pm)\n    localFunc55b: 55 , String_in_localFunc55b , 654\n    Printing from inside localFunc66c.\n    ***/\n\n### Declaration of Local Functions\n\n-   The local functions must be declared physically above any non-declaration statements that exist in the method.\n-   You can declare more than one local function in your method. But all local functions must be declared in an uninterrupted series, with the set terminated by one semicolon.\n\n### Scoping of Variables\n\n-   Code that is inside the local function can access variables that are declared in the method that contains the local function.\n-   Code that is outside the local function cannot access variables that are declared in the local function.\n\n### Calls to Local Functions\n\n-   A local function can be called only by code in the same method where the local function is declared.\n-   A local function should never call itself. Such recursion can prevent the successful compilation.\n\n## The this Object\nThe keyword **this** is a reference to the instance of the class or table in which the **this** keyword is used. The **this** reference is never required, but it can clarify your code, and it enhances the behavior of IntelliSense in the code editor. All calls to instance methods must be qualified, either with the **this** reference or with a variable. The **this** reference can be used in the following ways:\n\n-   Can be used to qualify the names of other instance (non-**static**) methods in the same class where the **this** reference is used. For example: **boolColorChanged = this.colorItOrange();**\n-   Can be used to quality the names of methods that are inherited by the **this** object.\n-   Can be used to qualify the names of fields on the table that contains the method that the **this** keyword is used in.\n\nThe **this** reference cannot be used in the following ways:\n\n-   Cannot be used to qualify the names of member variables that are declared in the **classDeclaration** code.\n-   Cannot be used in a **static** method.\n-   Cannot be used to qualify the names of **static** methods of the class or table.\n\n## Interfaces\nAn interface is a specification for a set of public instance methods. The purpose of interfaces is to define and enforce similarities between unrelated classes without having to artificially derive one class from the other. All interfaces are public regardless of whether you explicitly write the keyword **public** in front of the keyword **interface** in the **classDeclaration**. The methods on an interface are also public, and again the explicit inclusion of the keyword **public** is optional. To create an interface:\n\n1.  In **Server Explorer**, right-clickon the project, and select **Add**.\n2.  In the **New Item** dialog, select **Interface** and enter a name for the interface.\n3.  Click **Add**.\n\nYou can add the **implements** keyword on a class declaration, and this requires the class to declare the methods that are specified by the interface. A class declaration can implement multiple interfaces by listing them after the single occurrence of the **implements** keyword, with commas separating the interface names. All interface methods that a class implements must be declared with the explicit keyword **public** in the class. Also, a class that implements an interface must also be declared with **public**. An interface can extend another interface by using the **extends** keyword. An interface cannot extend more than one interface.\n\n### Interface Code Example\n\nThis section shows the code for an **Automobile** class that implements an **IDrivable** interface.  The keyword **is** is supported for testing whether a class that implements an interface.\n\n    public interface IDrivable\n    {\n        public int getSpeed()\n        {\n        }\n\n        public void setSpeed(int newSpeed)\n        {\n        }\n    }\n\n    class Automobile implements IDrivable\n    {\n        int m_speed;\n\n        public int getSpeed()\n        {\n            return m_speed;\n        }\n\n        public void setSpeed(int newSpeed)\n        {\n            m_speed = newSpeed;\n        }\n    }\n\n    class UseAnAutomobile\n    {\n        void DriveAutomobile()\n        {\n            IDrivable yourIDrivable;\n            Automobile myAutomobile;\n            str sTemp = \"object is not an IDrivable\";\n            \n            myAutomobile = new Automobile();\n            \n            if (myAutomobile is IDrivable)\n            {\n                yourIDrivable = myAutomobile;\n                yourIDrivable.setSpeed(42);\n                sTemp = int2str(yourIDrivable.getSpeed());\n            }\n            \n            Global::info(sTemp);\n            return;\n            // output\n            // Message (06:46:33 pm)\n            // 42\n        }\n    }\n\n## Microsoft Dynamics AX Class Overview\nThere are two main kinds of classes in Microsoft Dynamics AX:\n\n-   Application classes are implemented in X++. They are available in the Classes node in the Application Explorer.\n-   System classes, sometimes called kernel classes, are implemented in C++. They are listed under the **System Documentation &gt; Classes** node in the Application Explorer. However, the source code for these classes is not available.\n\n## Substitute Application Classes for System Classes\nYou should call the substitute application classes instead of calling the system classes that they extend. In the **Application Explorer **under **System Documentation &gt; Classes** there are several kernel or system classes whose names begin with a lowercase x. Examples of the x system classes include **xApplication** and **xVersionControl.** Some of the x system classes are extended by application classes. For example, the Application class extends the xApplication system class. The classes that derive from the x system classes are called **substitute application classes**. In the **Application Explorer **under the **Classes** node, the icon next to the substitute application classes differs from the standard icon.\n\n### Special X++ Global Variables\n\nSome of the substitute application classes that extend an x system class are associated with a special global variable that represents an instance of the class. For example, the **appl** variable references a pre-instantiated object from the Application class. The advantage of the **appl** variable is that the system maintains the object throughout the scope of your session. It would be less efficient for your code to repeatedly use the **new Application()** syntax to obtain an instance of the **Application** class. You should not use the **xApplication** system class. Use the **Application** substitute application class instead. You can reference the static members of the **Application** class by using the standard syntax **Application::checkForNewBatchJobs()**. But you should reference the instance members of the **Application** class by using its corresponding special system variable **appl**, if one exists. This pattern applies to most of the x system classes. The **Session** substitute application class is one exception to this pattern, because there is no special system variable for **Session**. The following table lists x system classes for which there is a corresponding substitute application class. The special global variables are also shown for those classes that have one.\n\n| Application class | System class        | Global variable    |\n|-------------------|---------------------|--------------------|\n| Args              | **xArgs**           | (none)             |\n| Application       | **xApplication**    | **appl**           |\n| ClassFactory      | **xClassFactory**   | **classFactory**   |\n| Company           | **xCompany**        | **appl.company**   |\n| Global            | **xGlobal**         | (none)             |\n| Info              | **xInfo**           | **Infolog**        |\n| MenuFunction      | **xMenuFunction**   | (none)             |\n| Session           | **xSession**        | (none)             |\n| VersionControl    | **xVersionControl** | **versionControl** |\n\n### Example Method That Uses Special Variables\n\nThe following method demonstrates the syntax for using several special variables that reference instances of the substitute application classes.\n\n    static void UseSpecialSystemVariablesForXJob(Args _a)\n    {\n        TreeNode treeNode2;\n        Args     args3;\n        FormRun  formRun4;\n        // appl variable\n        print appl.buildNo();\n        // company variable\n        appl.company().reloadRights(); // referenced through appl\n        // Infolog variable\n        treeNode2 = infolog.findNode(\"\\\\forms\\\\custTable\");\n        print treeNode2.AOTgetProperty(\"Name\");\n     \n        // classFactory variable\n        args3 = new Args(formstr(vendTable));\n        formRun4 = classFactory.formRunClass(args3);\n        formRun4.init();\n        formRun4.run();\n        formRun4.detach();\n        Global::info(\"Method is ending. This is a message in the Infolog.\");\n    }\n\n## Execute Startup Commands\nUse the **SysStartupCmd** class framework to execute commands at startup. When Microsoft Dynamics AX starts, calls are made to the \\***startup** methods on the application-substituted kernel classes **Application** (**Application.startup**) and **Info** (**Info.startup**). The \\***startup** methods are used for vital system and version-specific calls, and you must never directly modify these methods. Instead, use the **SysStartupCmd** framework. Serious consequences may follow if the SYS layer versions of the startup methods are not called. When Microsoft Dynamics AX is started, calls are executed in the sequence shown in the following code.\n\n    appl.startup() // The SysStartupCmd class is instantiated here.\n    sysStartupCmd.applInit()\n    super()\n    sysStartupCmd.applRun()\n    info.startup()\n    sysStartupCmd.infoInit()\n    super()\n    sysStartupCmd.infoRun()\n\n### Commands Available when Microsoft Dynamics AX Starts\n\nThe commands that are available when Microsoft Dynamics AX starts are listed in the **SysStartupCmd.construct** method. The commands include the following:\n\n-   AutoRun\n-   AOTImport\n-   Synchronize\n\nThe following code example shows how to execute a new command when Dynamics AX starts. A class that extends SysStartupCmd is created that performs your specific task. Then modify the construct method on SysStartupCmd to call your class. You can add parameters commands that are executed on startup to the Command to run at application startup field on the General tab in the Microsoft Dynamics AX Configuration Utility. Instead of giving the command from the Dynamics AX Configuration Utility, you might choose to use the command-line parameter **-startupcmd=** *MyCommand*.\n\n    public class SysStartupCmdAutoRun : extends SysStartupCmd \n    {\n        void new(str s, str parm) \n        {\n            // Your code here.\n        }\n    }\n\n    // This is a framework class. Customizing this class may cause problems with future upgrades to the software.\n    class SysStartupCmd\n    {\n        // Code delete for readability\n\n        static SysStartupCmd construct(str startupCommand)\n        {\n            // Code delete for readability\n            switch (s)\n            {\n                // Other cases delete for readability    \n                case 'autorun':\n                    sysStartupCmd = new SysStartupCmdAutoRun(s,parm);\n                    break;\n                // Other cases delete for readability\n            }\n            // Code delete for readability\n        }\n    }\n\n## Batch Processing Classes\nImplement classes by using the batch processing system, and by extending the **RunBase** and the **RunBaseBatch** classes. Remove the **Recurrence** button from the **Batch processing** dialog by using the **Args::parmEnum** method. It is recommended that you designate a class to run as a server-bound batch method. Server-bound batch methods are more secure than methods that are not server-bound batch for the following reasons:\n\n-   The method executes by using the permissions of the user who submitted the method.\n-   The method can interact with the Microsoft Dynamics AX client, which is processing the method, by using only certain Info and Global class methods. This limits interaction with the client.\n\n### Enable a Class to Run as a Server-Bound Batch Method\n\n1.  Create a class that extends the RunBaseBatch class.\n2.  Override the RunBaseBatch.runsImpersonated method to return a value of **true**, as shown in the following example.\n\n        public boolean runsImpersonated()\n        {\n            return true;\n        }\n\n3.  Confirm that the class calls only the following **Info** and **Global** class methods:\n    -   **add**\n    -   **Info.copy**\n    -   **Info.cut**\n    -   **Info.import**\n    -   **Info.export**\n    -   **Info.line**\n    -   **Info.num**\n    -   **Global::error**\n    -   **Global::info**\n    -   **Global::warning**\n\n    The **Info.line** and **Info.num** methods are inherited from the xInfo class.\n\n### Remove the Recurrence Button from the Batch Processing Dialog\n\nWhen you implement a class by using the batch processing system, call the **Args.parmEnum** method, and pass the **NoYes::Yes** system enumeration value to remove the **Recurrence** button. The **NoYes** system enumeration determines whether the recurrence button is removed from the batch processing dialog. The default value is **NoYes::No**. In the following code example, the **InventTransferMultiShip** class is implemented. The **BatchDialog::main** method creates the **Batch processing** dialog.\n\n    static void noRecurrenceButton(Args _args)\n    {\n        Args a;\n        InventTransferMultiShip inventTransferMultiShip;\n        a = new Args();\n        inventTransferMultiShip = InventTransferMultiShip::construct();\n        a.caller(inventTransferMultiShip);\n        a.parmEnum(NoYes::Yes);\n        BatchDialog::main(a);\n    }\n\n## Image Manipulation Classes\nThere are two system classes that enable you to manipulate graphics and icons. The **Image** class enables you to load, save, and manipulate individual images. For example, you can capture a screen and save it as an image, crop or rotate an image, or manipulate the color depth. The **Imagelist** class enables you to work with a set of images that have some common properties, such as size and transparency color. The image lists that are used in the application can be viewed in the application classes called **ImageListAppl\\_\\***.\n\n## Query Object Model\nThe query object model contains classes to define and run a query. These objects are used to define the query data source, the fields returned, record ranges and relations to child data sources. The following illustration shows the object model. The query components shown in the previous figure are system classes. The query classes are more visible when you create a dynamic query in code, but they are also used behind the scenes when you create a static query in the **Application Explorer**.\n\n| System class             | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n|--------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **QueryRun**             | Executes the query and fetches the data.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n| **Query**                | Holds some properties itself and has one or more related data sources. The top level of the query definition.                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| **QueryBuildDataSource** | Defines access to a single data source in the query. If more than one data source exists at the same level in a query, they result in separate SQL statements that are executed sequentially. If one data source exists as a child of another data source, a join is created between the two data sources.                                                                                                                                                                                                                                          |\n| **QueryBuildFieldList**  | Defines which fields are returned from the database. The default is that the field list is dynamic, which returns all fields from the data source table, map, or view. Each data source has only one **QueryBuildFieldList** object, which contains information on all selected fields. It's possible to specify aggregate functions like **SUM**, **COUNT**, and **AVG** on the field list object.                                                                                                                                                 |\n| **QueryBuildRange**      | Defines a subset of records returned based on a single field. A range is translated into a **WHERE** clause in the query SQL statement. If more than one field is used to limit the query (**WHERE** clause), the data source will contain more than one range.                                                                                                                                                                                                                                                                                     |\n| **QueryBuildDynalink**   | Contains information regarding a relation (limitation) to an external record. When the query is run, this information is converted to additional entries in the **WHERE** clause of the query SQL statement. Can only exist on the parent data source of a query. The function is used by forms, when two data sources are synchronized. Then the child data source will contain a dynalink or dynalinks to the parent data source. The function is used even if the two data sources are placed in two different forms but are still synchronized. |\n| **QueryBuildLink**       | Specifies the relation between the two data sources in the join. Can only exist on a child data source.                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n\n## System Classes Overview\nSystem classes (or kernel classes) are implemented in C++. The source for these classes is not available. A system class can have:\n\n-   Static methods (or class methods)\n-   Dynamic methods\n-   Properties: these are member functions to set properties. For example, **LeftMargin**.\n\nYou cannot override system class methods. It is not intended that you design your application objects from scratch by using the system classes. Instead, use them to extend or alter the default functionality in the **Application Explorer**. For example, you could dynamically add extra information to an existing report or change the available options on a form, depending on the user's choice in a previous form.\n\n### Collection Classes\n\nThe Collection Classes in Microsoft Dynamics AX enable you to create lists, sets, structs, maps, and arrays.\n\n### Application Objects Classes\n\nThese system classes hold functions that are activated whenever you use the **Application Explorer **to create your application. For example, the system uses the **FormDesign** class when you define the layout of your form in the **Designs** node in the **Application Explorer.** These classes also enable you to create and modify application objects. For example, if you want to change a property on a form string field, see Forms System classes and Query System Classes.\n\n### Integration Classes\n\nThe integration to the environment of Microsoft Dynamics AX is typically implemented by classes. Some examples of classes of this category are:\n\n-   **COM**: call of methods on COM objects\n-   **DLL**: call of Microsoft Windows DLL functions\n-   **IO**: Read and write external files\n-   **ODBCConnection**: an ODBC interface to a foreign database\n\n### \n\n## Event Terminology and Keywords\nIn Microsoft Dynamics AX, you can use the event design pattern to make your code more modular and reusable. The term **event** is a metaphor that explains how **delegates** are used. When something important occurs during a program run, there might be other modules that need to process the occurrence. These important occurrences are called **events**. When an event occurs, the program tells its **notifier** for the event that the notifier must send notifications of the event. A notification must be sent to all the **event handlers** that are **subscribers** of the notifier. When the program tells its notifier to send the notifications, we call that **raising** an event. The following table displays the terms that are used to describe the event metaphor.\n\n| Metaphorical term | Description                                                                                                               |\n|-------------------|---------------------------------------------------------------------------------------------------------------------------|\n| event             | An important occurrence in a program module where additional modules must process the occurrence.                         |\n| notifier          | The program element that sends information about the event to all the event handlers that are subscribed to the notifier. |\n| subscriber        | The program functions or methods that are subscribed to an event notifier.                                                |\n| event handler     | The methods that subscribe to an event notifier. Only the appropriate kind of methods can be event handlers.              |\n\n### Keywords used for X++ Programming with Delegates\n\nThe following table shows the X++ keywords that describe the use of delegates.\n\n| X++ keyword or term                         | Code                                                                         | Description                                                                                                                                                                                                                                                                            |\n|---------------------------------------------|------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **delegate**                                | **delegate myDelegate(str \\_information) {}**                                | The code shows how the delegate looks in the method editor in the MorphX client. The return type is always void, so it is not mentioned in the syntax. No code is allowed inside the **{}** braces.                                                                                    |\n| **eventHandler**                            | **myClassInstance.myDelegate += eventHandler(otherClass.myInstanceMethod);** | The syntax of the **eventHandler** keyword might give the impression that **eventHandler** is an X++ function, but it is not a function. The **eventHandler** keyword tells the compiler that a method is being subscribed to a delegate.                                              |\n| Subscribe or add a method to a **delegate** | **myClassInstance.myDelegate += eventHandler(OtherClass::aStaticMethod);**   | The static method **OtherClass::aStaticMethod** becomes subscribed to the delegate.                                                                                                                                                                                                    |\n| Call a **delegate**                         | **myClassInstance.myDelegate(\"Hello\");**                                     | This call to the delegate prompts the delegate to call each method that is subscribed to the delegate. The subscribed methods are called in the same sequence in which they were added to the delegate. One subscribed method must complete before the delegate calls the next method. |\n\n\n\n"}