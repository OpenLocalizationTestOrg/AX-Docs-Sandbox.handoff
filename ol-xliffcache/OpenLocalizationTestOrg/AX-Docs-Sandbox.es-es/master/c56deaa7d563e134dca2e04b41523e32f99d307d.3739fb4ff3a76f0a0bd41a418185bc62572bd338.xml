{"nodes":[{"pos":[32,78],"content":"X++ String run-time functions | Microsoft Docs","needQuote":true,"needEscape":true,"nodes":[{"content":"X++ String run-time functions | Microsoft Docs","pos":[0,46]}]},{"pos":[92,142],"content":"This wiki describes the string run-time functions.","needQuote":true,"needEscape":true,"nodes":[{"content":"This wiki describes the string run-time functions.","pos":[0,50]}]},{"pos":[556,585],"content":"X++ String run-time functions","linkify":"X++ String run-time functions","nodes":[{"content":"X++ String run-time functions","pos":[0,29]}]},{"pos":[587,592],"content":"match","linkify":"match","nodes":[{"content":"match","pos":[0,5]}]},{"content":"Searches for a string or expression in another string.","pos":[600,654]},{"pos":[698,708],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[712,721]},{"content":"Description","pos":[724,735]},{"content":"pattern","pos":[824,831]},{"content":"The string or expression to search for.","pos":[836,875]},{"content":"text","pos":[880,884]},{"content":"The string to search.","pos":[892,913]},{"pos":[939,951],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"pos":[953,1024],"content":"<bpt id=\"p1\">**</bpt>1<ept id=\"p1\">**</ept> if the pattern is located in the string; otherwise, <bpt id=\"p2\">**</bpt>0<ept id=\"p2\">**</ept> (zero).","source":"**1** if the pattern is located in the string; otherwise, **0** (zero)."},{"pos":[1030,1037],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The search is case-insensitive.","pos":[1039,1070]},{"content":"The following special characters can be used to create the pattern for the <bpt id=\"p1\">*</bpt>pattern<ept id=\"p1\">*</ept> parameter.","pos":[1071,1166],"source":" The following special characters can be used to create the pattern for the *pattern* parameter."},{"content":"Character","pos":[1271,1280]},{"content":"Description","pos":[1290,1301]},{"content":"A backslash (<ph id=\"ph1\">\\)</ph> nullifies, or escapes, the special treatment of special characters, so that a special character can be matched like a normal letter.","pos":[1362,1510],"source":"A backslash (\\) nullifies, or escapes, the special treatment of special characters, so that a special character can be matched like a normal letter."},{"content":"A pair of backslashes is translated into one non-special backslash.","pos":[1511,1578]},{"content":"Examples:","pos":[1579,1588],"source":" Examples:\n"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab$cd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>ab$cd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[1598,1686],"source":"<strong>match(&quot;ab$cd&quot;,&quot;ab$cd&quot;);</strong> returns <strong>0</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab$cd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>ab$cd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[1696,1784],"source":"<strong>match(&quot;ab$cd&quot;,&quot;ab$cd&quot;);</strong> returns <strong>0</strong>."},{"content":"The backslash isn't escaped.","pos":[1785,1813]},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab<ph id=\"ph2\">\\$</ph>cd<ph id=\"ph3\">&amp;quot;</ph>,<ph id=\"ph4\">&amp;quot;</ph>ab$cd<ph id=\"ph5\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[1823,1912],"source":"<strong>match(&quot;ab\\$cd&quot;,&quot;ab$cd&quot;);</strong> returns <strong>1</strong>."},{"content":"The backslash and dollar sign are escaped.","pos":[1913,1955]},{"content":"<ph id=\"ph1\">&amp;lt;</ph> or ^","pos":[2000,2009],"source":"&lt; or ^"},{"content":"A left angle bracket (<ph id=\"ph1\">&amp;lt;</ph>) or a circumflex (^) at the start of an expression is used to match the start of a line.","pos":[2019,2134],"source":"A left angle bracket (&lt;) or a circumflex (^) at the start of an expression is used to match the start of a line."},{"content":"Examples:","pos":[2135,2144],"source":" Examples:\n"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph><ph id=\"ph2\">&amp;lt;</ph>abc<ph id=\"ph3\">&amp;quot;</ph>,<ph id=\"ph4\">&amp;quot;</ph>abcdef<ph id=\"ph5\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[2154,2245],"source":"<strong>match(&quot;&lt;abc&quot;,&quot;abcdef&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph><ph id=\"ph2\">&amp;lt;</ph>abc<ph id=\"ph3\">&amp;quot;</ph>,<ph id=\"ph4\">&amp;quot;</ph>defabc<ph id=\"ph5\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[2255,2346],"source":"<strong>match(&quot;&lt;abc&quot;,&quot;defabc&quot;);</strong> returns <strong>0</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>^abc<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abcdef<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[2356,2444],"source":"<strong>match(&quot;^abc&quot;,&quot;abcdef&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>^abc<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>defabc<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[2454,2542],"source":"<strong>match(&quot;^abc&quot;,&quot;defabc&quot;);</strong> returns <strong>0</strong>."},{"content":"<ph id=\"ph1\">&amp;gt;</ph> or $","pos":[2586,2595],"source":"&gt; or $"},{"content":"A right angle bracket (<ph id=\"ph1\">&amp;gt;</ph>) or a dollar sign (?) at the end of the expression is used to match the end of a line.","pos":[2605,2719],"source":"A right angle bracket (&gt;) or a dollar sign (?) at the end of the expression is used to match the end of a line."},{"content":"Examples:","pos":[2720,2729],"source":" Examples:\n"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>abc<ph id=\"ph2\">&amp;gt;</ph><ph id=\"ph3\">&amp;quot;</ph>,<ph id=\"ph4\">&amp;quot;</ph>abcdef<ph id=\"ph5\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[2739,2830],"source":"<strong>match(&quot;abc&gt;&quot;,&quot;abcdef&quot;);</strong> returns <strong>0</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>abc<ph id=\"ph2\">&amp;gt;</ph><ph id=\"ph3\">&amp;quot;</ph>,<ph id=\"ph4\">&amp;quot;</ph>defabc<ph id=\"ph5\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[2840,2931],"source":"<strong>match(&quot;abc&gt;&quot;,&quot;defabc&quot;);</strong> returns <strong>1</strong>."},{"content":"?","pos":[2976,2977]},{"content":"or .","pos":[2978,2982]},{"content":"A question mark (?) or a period (.) matchs any one character in the same position.","pos":[2992,3074]},{"content":"Examples:","pos":[3075,3084],"source":" Examples:\n"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>abc.def<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abc#def<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[3094,3186],"source":"<strong>match(&quot;abc.def&quot;,&quot;abc#def&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>colou?r<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>colouXr<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[3196,3288],"source":"<strong>match(&quot;colou?r&quot;,&quot;colouXr&quot;);</strong> returns <strong>1</strong>."},{"content":":x","pos":[3332,3334]},{"content":"A colon specifies a group of characters to match, as indicated by the character that immediately follows.","pos":[3344,3449]},{"content":":a","pos":[3483,3485]},{"content":"Sets the match to letters.","pos":[3495,3521]},{"content":"Examples:","pos":[3522,3531],"source":" Examples:\n"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab:acd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>ab#cd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[3541,3630],"source":"<strong>match(&quot;ab:acd&quot;,&quot;ab#cd&quot;);</strong> returns <strong>0</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab:acd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abxyzcd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[3640,3731],"source":"<strong>match(&quot;ab:acd&quot;,&quot;abxyzcd&quot;);</strong> returns <strong>0</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab:acd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abxcd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[3741,3830],"source":"<strong>match(&quot;ab:acd&quot;,&quot;abxcd&quot;);</strong> returns <strong>1</strong>."},{"content":":d","pos":[3874,3876]},{"content":"Sets the match to numeric characters.","pos":[3886,3923]},{"content":"Examples:","pos":[3924,3933],"source":" Examples:\n"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab:dcd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>ab3cd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[3943,4032],"source":"<strong>match(&quot;ab:dcd&quot;,&quot;ab3cd&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab:dcd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>ab123cd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[4042,4133],"source":"<strong>match(&quot;ab:dcd&quot;,&quot;ab123cd&quot;);</strong> returns <strong>0</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab:dcd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abcd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[4143,4231],"source":"<strong>match(&quot;ab:dcd&quot;,&quot;abcd&quot;);</strong> returns <strong>0</strong>."},{"content":":n","pos":[4276,4278]},{"content":"Sets the match to alphanumeric characters.","pos":[4288,4330]},{"content":"Examples:","pos":[4331,4340],"source":" Examples:\n"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab:ncd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>ab%cd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[4350,4439],"source":"<strong>match(&quot;ab:ncd&quot;,&quot;ab%cd&quot;);</strong> returns <strong>0</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab:ncd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>ab9cd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[4449,4538],"source":"<strong>match(&quot;ab:ncd&quot;,&quot;ab9cd&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab:ncd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abXcd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[4548,4637],"source":"<strong>match(&quot;ab:ncd&quot;,&quot;abXcd&quot;);</strong> returns <strong>1</strong>."},{"content":":SPACE","pos":[4681,4687]},{"content":"SPACE is the space character ( ).","pos":[4697,4730]},{"content":"Sets the match to blanks, tabulations, and control characters such as Enter (new line).","pos":[4731,4818]},{"content":"Examples:","pos":[4819,4828],"source":" Examples:\n"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab: cd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>ab cd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[4838,4927],"source":"<strong>match(&quot;ab: cd&quot;,&quot;ab cd&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab: cd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>ab\\ncd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[4937,5027],"source":"<strong>match(&quot;ab: cd&quot;,&quot;ab\\ncd&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab: cd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>ab\\tcd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[5037,5127],"source":"<strong>match(&quot;ab: cd&quot;,&quot;ab\\tcd&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>ab: cd<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>ab cd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[5137,5226],"source":"<strong>match(&quot;ab: cd&quot;,&quot;ab cd&quot;);</strong> returns <strong>0</strong>."},{"content":"Only the first space is matched.","pos":[5227,5259]},{"content":"An expression that is followed by an asterisk (*) requires a match for zero, one, or more occurrences of the preceding expression.","pos":[5315,5445]},{"content":"Examples:","pos":[5446,5455],"source":" Examples:\n"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>abc*d<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[5465,5551],"source":"<strong>match(&quot;abc*d&quot;,&quot;abd&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>abc*d<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abcd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[5561,5648],"source":"<strong>match(&quot;abc*d&quot;,&quot;abcd&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>abc*d<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abcccd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[5658,5747],"source":"<strong>match(&quot;abc*d&quot;,&quot;abcccd&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>abc*d<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abxd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[5757,5844],"source":"<strong>match(&quot;abc*d&quot;,&quot;abxd&quot;);</strong> returns <strong>0</strong>."},{"content":"An expression that is followed by a plus sign (+) requires a match for one or more occurrences of the preceding expression.","pos":[5899,6022]},{"content":"Examples:","pos":[6023,6032],"source":" Examples:\n"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>abc+d<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[6042,6128],"source":"<strong>match(&quot;abc+d&quot;,&quot;abd&quot;);</strong> returns <strong>0</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>abc+d<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abcd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>","pos":[6138,6224],"source":"<strong>match(&quot;abc+d&quot;,&quot;abcd&quot;);</strong> returns <strong>1</strong>"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>abc+d<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abcccd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[6234,6323],"source":"<strong>match(&quot;abc+d&quot;,&quot;abcccd&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>abc+d<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>abxd<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[6333,6420],"source":"<strong>match(&quot;abc+d&quot;,&quot;abxd&quot;);</strong> returns <strong>0</strong>."},{"content":"An expression that is followed by a minus sign (-) requires a match for zero or one occurrence of the preceding expression.","pos":[6476,6599]},{"content":"In other words, the preceding expression is optional.","pos":[6600,6653]},{"content":"Examples:","pos":[6654,6663],"source":" Examples:\n"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>colou-r<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>color<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[6673,6763],"source":"<strong>match(&quot;colou-r&quot;,&quot;color&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>colou-r<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>colour<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[6773,6864],"source":"<strong>match(&quot;colou-r&quot;,&quot;colour&quot;);</strong> returns <strong>1</strong>."},{"content":"[]","pos":[6908,6910]},{"content":"Matches a single character with any character that is enclosed in the brackets.","pos":[6920,6999]},{"content":"A range of characters can be specified by two characters that are separated by a minus sign (-).","pos":[7000,7096]},{"content":"For example, <bpt id=\"p1\">&lt;strong&gt;</bpt>[a-z]<ept id=\"p1\">&lt;/strong&gt;</ept> matches all letters between a and z, <bpt id=\"p2\">&lt;strong&gt;</bpt>[0-9]<ept id=\"p2\">&lt;/strong&gt;</ept> matches a digit, and <bpt id=\"p3\">&lt;strong&gt;</bpt>[0-9a-f]<ept id=\"p3\">&lt;/strong&gt;</ept> matches a hexadecimal digit.","pos":[7097,7268],"source":" For example, <strong>[a-z]</strong> matches all letters between a and z, <strong>[0-9]</strong> matches a digit, and <strong>[0-9a-f]</strong> matches a hexadecimal digit."},{"content":"Examples:","pos":[7269,7278],"source":" Examples:\n"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>[abc]<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>apple<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>, because it matches the a in <ph id=\"ph5\">&amp;quot;</ph>apple.<ph id=\"ph6\">&amp;quot;</ph>","pos":[7288,7423],"source":"<strong>match(&quot;[abc]&quot;,&quot;apple&quot;);</strong> returns <strong>1</strong>, because it matches the a in &quot;apple.&quot;"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>[abc]<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>kiwi<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>, because <ph id=\"ph5\">&amp;quot;</ph>kiwi<ph id=\"ph6\">&amp;quot;</ph> doesn't contain an a, b, or c.","pos":[7433,7576],"source":"<strong>match(&quot;[abc]&quot;,&quot;kiwi&quot;);</strong> returns <strong>0</strong>, because &quot;kiwi&quot; doesn't contain an a, b, or c."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>gr[ae]y<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>grey<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns 1.","pos":[7586,7658],"source":"<strong>match(&quot;gr[ae]y&quot;,&quot;grey&quot;);</strong> returns 1."},{"content":"This expression also matches <ph id=\"ph1\">&amp;quot;</ph>gray.<ph id=\"ph2\">&amp;quot;</ph>","pos":[7659,7705],"source":" This expression also matches &quot;gray.&quot;"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>gr[ae]y<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>graey<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>, because only one character between <ph id=\"ph5\">&amp;quot;</ph>gr<ph id=\"ph6\">&amp;quot;</ph> and <ph id=\"ph7\">&amp;quot;</ph>y<ph id=\"ph8\">&amp;quot;</ph> is matched.","pos":[7715,7885],"source":"<strong>match(&quot;gr[ae]y&quot;,&quot;graey&quot;);</strong> returns <strong>0</strong>, because only one character between &quot;gr&quot; and &quot;y&quot; is matched."},{"content":"[^]","pos":[7930,7933]},{"content":"If the first character in the text that is enclosed in brackets is a circumflex (^), the expression matches all characters except the characters that are enclosed in the brackets.","pos":[7943,8122]},{"content":"Examples:","pos":[8123,8132],"source":" Examples:\n"},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>[^bc]at<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>bat<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>0<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[8142,8230],"source":"<strong>match(&quot;[^bc]at&quot;,&quot;bat&quot;);</strong> returns <strong>0</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>[^bc]at<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>hat<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[8240,8328],"source":"<strong>match(&quot;[^bc]at&quot;,&quot;hat&quot;);</strong> returns <strong>1</strong>."},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>match(<ph id=\"ph1\">&amp;quot;</ph>[^abc]<ph id=\"ph2\">&amp;quot;</ph>,<ph id=\"ph3\">&amp;quot;</ph>bat<ph id=\"ph4\">&amp;quot;</ph>);<ept id=\"p1\">&lt;/strong&gt;</ept> returns <bpt id=\"p2\">&lt;strong&gt;</bpt>1<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[8338,8425],"source":"<strong>match(&quot;[^abc]&quot;,&quot;bat&quot;);</strong> returns <strong>1</strong>."},{"content":"Anything except a, b, or c is matched.","pos":[8426,8464]},{"content":"Therefore, the t is matched.","pos":[8465,8493]},{"pos":[8538,8546],"content":"strAlpha","linkify":"strAlpha","nodes":[{"content":"strAlpha","pos":[0,8]}]},{"content":"Copies only the alphanumeric characters from a string.","pos":[8547,8601]},{"pos":[8636,8646],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[8650,8659]},{"content":"Description","pos":[8662,8673]},{"content":"<ph id=\"ph1\">\\_</ph>text","pos":[8732,8738],"source":"\\_text"},{"content":"The string to copy from.","pos":[8744,8768]},{"pos":[8776,8788],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"A new string that contains all the alphanumeric characters from the specified string.","pos":[8790,8875]},{"pos":[8881,8888],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[8890,8982],"content":"For example, <bpt id=\"p1\">**</bpt>strAlpha(\"2+2=5 is this correct?\")<ept id=\"p1\">**</ept> returns the string <bpt id=\"p2\">**</bpt>225isthiscorrect<ept id=\"p2\">**</ept>.","source":"For example, **strAlpha(\"2+2=5 is this correct?\")** returns the string **225isthiscorrect**."},{"pos":[8988,8995],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[9168,9174],"content":"strCmp","linkify":"strCmp","nodes":[{"content":"strCmp","pos":[0,6]}]},{"content":"Compares two text strings.","pos":[9175,9201]},{"pos":[9245,9255],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[9259,9268]},{"content":"Description","pos":[9271,9282]},{"content":"text1","pos":[9329,9334]},{"content":"The first string.","pos":[9341,9358]},{"content":"text2","pos":[9364,9369]},{"content":"The second string.","pos":[9376,9394]},{"pos":[9402,9414],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"pos":[9416,9542],"content":"<bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept> if the two strings are identical, <bpt id=\"p2\">**</bpt>1<ept id=\"p2\">**</ept> if the first string sorts earlier, or <bpt id=\"p3\">**</bpt>-1<ept id=\"p3\">**</ept> if the second string sorts earlier.","source":"**0** if the two strings are identical, **1** if the first string sorts earlier, or **-1** if the second string sorts earlier."},{"pos":[9548,9555],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The comparison performed by this method is case-sensitive.","pos":[9557,9615]},{"pos":[9842,9851],"content":"strColSeq","linkify":"strColSeq","nodes":[{"content":"strColSeq","pos":[0,9]}]},{"content":"Converts all uppercase characters to lowercase characters, and converts all characters that have accents to the corresponding unaccented lowercase characters.","pos":[9852,10010]},{"pos":[10045,10055],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[10059,10068]},{"content":"Description","pos":[10071,10082]},{"content":"text","pos":[10187,10191]},{"content":"The string to copy and convert characters from.","pos":[10199,10246]},{"pos":[10254,10266],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"The converted text string.","pos":[10268,10294]},{"pos":[10300,10307],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <bpt id=\"p1\">**</bpt>strColSeq<ept id=\"p1\">**</ept> function exists for backward-compatibility purposes.","pos":[10309,10379],"source":"The **strColSeq** function exists for backward-compatibility purposes."},{"content":"This function supports only the mapping for the following Western European characters:","pos":[10380,10466]},{"content":"AàáâãäÀÁÂÃÄBCçÇDEèéêëÈÉÊËFGHIìíîïÌÍÎÏJKLMNñÑOòóôõöÒÓÔÕÖPQRSTUùúûüÙÚÛÜVWXYýÝZæøåÆØÅ","pos":[10472,10554]},{"content":"aaaaaaaaaaabcccdeeeeeeeeefghiiiiiiiiijklmnnnooooooooooopqrstuuuuuuuuuvwxyyyz~¦Ç~¦Ç","pos":[10559,10641]},{"pos":[10643,10786],"content":"For Unicode-compliant functionality, use the Win32 LCMapString application programming interface (API) via the <bpt id=\"p1\">**</bpt>DLL<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>DLLFunc<ept id=\"p2\">**</ept> classes.","source":"For Unicode-compliant functionality, use the Win32 LCMapString application programming interface (API) via the **DLL** and **DLLFunc** classes."},{"pos":[10792,10799],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[10801,10845],"content":"The following example prints <bpt id=\"p1\">**</bpt>abcdeabcde<ept id=\"p1\">**</ept>.","source":"The following example prints **abcdeabcde**."},{"pos":[10973,10979],"content":"strDel","linkify":"strDel","nodes":[{"content":"strDel","pos":[0,6]}]},{"content":"Creates a copy of a string, from which the specified substring is removed.","pos":[10980,11054]},{"pos":[11115,11125],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[11129,11138]},{"content":"Description","pos":[11142,11153]},{"content":"<ph id=\"ph1\">\\_</ph>text","pos":[11613,11619],"source":"\\_text"},{"content":"The string to copy from.","pos":[11626,11650]},{"content":"<ph id=\"ph1\">\\_</ph>position","pos":[11855,11865],"source":"\\_position"},{"content":"The position at which to begin ignoring characters during the copy operation.","pos":[11868,11945]},{"content":"<ph id=\"ph1\">\\_</ph>number","pos":[12097,12105],"source":"\\_number"},{"content":"The number of characters to ignore.","pos":[12110,12145]},{"content":"A minus sign in front of the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>number<ept id=\"p1\">*</ept> parameter indicates that <bpt id=\"p2\">*</bpt><ph id=\"ph2\">\\_</ph>number<ept id=\"p2\">*</ept>–1 characters before the character at <bpt id=\"p3\">*</bpt><ph id=\"ph3\">\\_</ph>position<ept id=\"p3\">*</ept> should be removed together with the character at <bpt id=\"p4\">*</bpt><ph id=\"ph4\">\\_</ph>position<ept id=\"p4\">*</ept>.","pos":[12146,12334],"source":" A minus sign in front of the *\\_number* parameter indicates that *\\_number*–1 characters before the character at *\\_position* should be removed together with the character at *\\_position*."},{"pos":[12342,12354],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"The remaining characters that are copied from the string.","pos":[12356,12413]},{"pos":[12419,12426],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[12428,12496],"content":"The <bpt id=\"p1\">**</bpt>strDel<ept id=\"p1\">**</ept> function is complementary to the <bpt id=\"p2\">**</bpt>substr<ept id=\"p2\">**</ept> function.","source":"The **strDel** function is complementary to the **substr** function."},{"pos":[12618,12625],"content":"strFind","linkify":"strFind","nodes":[{"content":"strFind","pos":[0,7]}]},{"content":"Searches a string for the first occurrence of one of the specified characters.","pos":[12626,12704]},{"pos":[12783,12793],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[12797,12806]},{"content":"Description","pos":[12812,12823]},{"content":"<ph id=\"ph1\">\\_</ph>text","pos":[13049,13055],"source":"\\_text"},{"content":"The string to search.","pos":[13064,13085]},{"content":"<ph id=\"ph1\">\\_</ph>characters","pos":[13175,13187],"source":"\\_characters"},{"content":"The characters to search for.","pos":[13190,13219]},{"content":"<ph id=\"ph1\">\\_</ph>position","pos":[13301,13311],"source":"\\_position"},{"content":"The position in the string where the search begins.","pos":[13316,13367]},{"content":"<ph id=\"ph1\">\\_</ph>number","pos":[13427,13435],"source":"\\_number"},{"content":"A signed number that indicates the direction of the search and how many positions to search in the string.","pos":[13442,13548]},{"pos":[13556,13568],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"The value of the position of the first occurrence of one of the specified characters.","pos":[13570,13655]},{"pos":[13661,13668],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"To search from the beginning of the string to the end, use <bpt id=\"p1\">**</bpt>1<ept id=\"p1\">**</ept> as the value of the <bpt id=\"p2\">*</bpt><ph id=\"ph1\">\\_</ph>position<ept id=\"p2\">*</ept> parameter.","pos":[13670,13778],"source":"To search from the beginning of the string to the end, use **1** as the value of the *\\_position* parameter."},{"content":"If the value of the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>number<ept id=\"p1\">*</ept> parameter is negative, the system searches the number of characters backward from the specified position.","pos":[13779,13915],"source":" If the value of the *\\_number* parameter is negative, the system searches the number of characters backward from the specified position."},{"content":"The search isn't case-sensitive.","pos":[13916,13948]},{"content":"Here is an example.","pos":[13949,13968]},{"pos":[14165,14236],"content":"The <bpt id=\"p1\">**</bpt>strFind<ept id=\"p1\">**</ept> function is complementary to the <bpt id=\"p2\">**</bpt>strNFind<ept id=\"p2\">**</ept> function.","source":"The **strFind** function is complementary to the **strNFind** function."},{"pos":[14241,14247],"content":"strFmt","linkify":"strFmt","nodes":[{"content":"strFmt","pos":[0,6]}]},{"content":"Formats the specified string and substitutes any occurrences of n with the nth argument.","pos":[14248,14336]},{"pos":[14376,14386],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[14390,14399]},{"content":"Description","pos":[14402,14413]},{"content":"<ph id=\"ph1\">\\_</ph>string","pos":[14468,14476],"source":"\\_string"},{"content":"The strings to format.","pos":[14480,14502]},{"pos":[14510,14522],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"The formatted string.","pos":[14524,14545]},{"pos":[14551,14558],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"If an argument isn't provided for a parameter, the parameter will be returned as \"%n\" in the string.","pos":[14560,14660]},{"content":"The string conversion of values of the <bpt id=\"p1\">**</bpt>real<ept id=\"p1\">**</ept> type is limited to two decimal places.","pos":[14661,14747],"source":" The string conversion of values of the **real** type is limited to two decimal places."},{"content":"Values are rounded, not truncated.","pos":[14748,14782]},{"content":"The <bpt id=\"p1\">**</bpt>System.String::Format<ept id=\"p1\">**</ept> method from the Microsoft .NET Framework can be used to gain additional functionality, as shown in the example.","pos":[14783,14924],"source":" The **System.String::Format** method from the Microsoft .NET Framework can be used to gain additional functionality, as shown in the example."},{"pos":[14930,14937],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[15812,15818],"content":"strIns","linkify":"strIns","nodes":[{"content":"strIns","pos":[0,6]}]},{"content":"Builds a string by inserting one string into another.","pos":[15819,15872]},{"pos":[15933,15943],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[15947,15956]},{"content":"Description","pos":[15960,15971]},{"content":"<ph id=\"ph1\">\\_</ph>text1","pos":[16183,16190],"source":"\\_text1"},{"content":"The string to insert the other string into.","pos":[16196,16239]},{"content":"<ph id=\"ph1\">\\_</ph>text2","pos":[16301,16308],"source":"\\_text2"},{"content":"The string to insert into the other string.","pos":[16314,16357]},{"content":"<ph id=\"ph1\">\\_</ph>position","pos":[16419,16429],"source":"\\_position"},{"pos":[16432,16532],"content":"The position where the first character of the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>text2<ept id=\"p1\">*</ept> parameter should occur in the output string.","source":"The position where the first character of the *\\_text2* parameter should occur in the output string."},{"pos":[16540,16552],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"The combined text string.","pos":[16554,16579]},{"pos":[16585,16592],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <bpt id=\"p1\">**</bpt>strIns<ept id=\"p1\">**</ept> function is complementary to the <bpt id=\"p2\">**</bpt>strDel<ept id=\"p2\">**</ept> function.","pos":[16594,16662],"source":"The **strIns** function is complementary to the **strDel** function."},{"content":"If the value of the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>position<ept id=\"p1\">*</ept> parameter is more than the length of the original string, the string to insert is appended to the end of the original string.","pos":[16663,16821],"source":" If the value of the *\\_position* parameter is more than the length of the original string, the string to insert is appended to the end of the original string."},{"pos":[16952,16959],"content":"strKeep","linkify":"strKeep","nodes":[{"content":"strKeep","pos":[0,7]}]},{"content":"Builds a string by using only the characters from the first input string that the second input string specifies should be kept.","pos":[16960,17087]},{"pos":[17134,17144],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[17148,17157]},{"content":"Description","pos":[17160,17171]},{"content":"<ph id=\"ph1\">\\_</ph>text1","pos":[17348,17355],"source":"\\_text1"},{"content":"The string that contains the characters that can be used to build an output string.","pos":[17360,17443]},{"content":"<ph id=\"ph1\">\\_</ph>text2","pos":[17448,17455],"source":"\\_text2"},{"content":"The string that specifies which characters to keep for the output string.","pos":[17460,17533]},{"pos":[17551,17563],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"A string of the characters that are kept.","pos":[17565,17606]},{"pos":[17612,17619],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[17744,17813],"content":"The <bpt id=\"p1\">**</bpt>strKeep<ept id=\"p1\">**</ept> function is complementary to the <bpt id=\"p2\">**</bpt>strRem<ept id=\"p2\">**</ept> function.","source":"The **strKeep** function is complementary to the **strRem** function."},{"pos":[17818,17824],"content":"strLen","linkify":"strLen","nodes":[{"content":"strLen","pos":[0,6]}]},{"content":"Calculates the length of the specified string.","pos":[17825,17871]},{"pos":[17903,17913],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[17917,17926]},{"content":"Description","pos":[17929,17940]},{"content":"text","pos":[18027,18031]},{"content":"The string to calculate the length of.","pos":[18039,18077]},{"pos":[18085,18097],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"The length of the specified string.","pos":[18099,18134]},{"pos":[18140,18147],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[18245,18252],"content":"strLine","linkify":"strLine","nodes":[{"content":"strLine","pos":[0,7]}]},{"content":"Retrieves a single line from a string that spans multiple lines.","pos":[18253,18317]},{"pos":[18363,18373],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[18377,18386]},{"content":"Description","pos":[18389,18400]},{"content":"string","pos":[18491,18497]},{"content":"A string that might span multiple lines.","pos":[18503,18543]},{"content":"count","pos":[18548,18553]},{"content":"The offset of the line to return.","pos":[18560,18593]},{"pos":[18608,18620],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"pos":[18622,18694],"content":"A copied line of the string that is specified by the <bpt id=\"p1\">*</bpt>string<ept id=\"p1\">*</ept> parameter.","source":"A copied line of the string that is specified by the *string* parameter."},{"pos":[18700,18707],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first line of the string has an offset of 0.","pos":[18709,18757]},{"content":"You can assign multiple lines to one string by embedding the <bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept> or <bpt id=\"p2\">*</bpt>rn<ept id=\"p2\">*</ept> characters in the string.","pos":[18758,18856],"source":" You can assign multiple lines to one string by embedding the *n* or *rn* characters in the string."},{"content":"Additionally, you can use the at sign <ph id=\"ph1\">(@)</ph> immediately before the opening quotation mark and use the Enter key to spread parts of the string value over multiple lines in the X++ code editor.","pos":[18857,19046],"source":" Additionally, you can use the at sign (@) immediately before the opening quotation mark and use the Enter key to spread parts of the string value over multiple lines in the X++ code editor."},{"pos":[19052,19059],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[19356,19364],"content":"strLTrim","linkify":"strLTrim","nodes":[{"content":"strLTrim","pos":[0,8]}]},{"content":"Removes leading blanks from a text string.","pos":[19365,19407]},{"pos":[19441,19451],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[19455,19464]},{"content":"Description","pos":[19467,19478]},{"content":"text","pos":[19579,19583]},{"content":"The string to delete the leading blanks from.","pos":[19591,19636]},{"pos":[19644,19656],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"The string equivalent for the text that leading blanks have been removed from.","pos":[19658,19736]},{"pos":[19742,19749],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[19751,19823],"content":"The <bpt id=\"p1\">**</bpt>strLTrim<ept id=\"p1\">**</ept> function is complementary to the <bpt id=\"p2\">**</bpt>strRTrim<ept id=\"p2\">**</ept> function.","source":"The **strLTrim** function is complementary to the **strRTrim** function."},{"pos":[19829,19836],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[19914,19920],"content":"strLwr","linkify":"strLwr","nodes":[{"content":"strLwr","pos":[0,6]}]},{"content":"Converts all letters in the specified string to lowercase.","pos":[19921,19979]},{"pos":[20012,20022],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[20026,20035]},{"content":"Description","pos":[20038,20049]},{"content":"<ph id=\"ph1\">\\_</ph>text","pos":[20130,20136],"source":"\\_text"},{"content":"The string to convert to lowercase.","pos":[20142,20177]},{"pos":[20185,20197],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"A copy of the specified string that contains only lowercase letter.","pos":[20199,20266]},{"pos":[20272,20279],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <bpt id=\"p1\">**</bpt>strLwr<ept id=\"p1\">**</ept> function is complementary to the <bpt id=\"p2\">**</bpt>strUpr<ept id=\"p2\">**</ept> function.","pos":[20281,20349],"source":"The **strLwr** function is complementary to the **strUpr** function."},{"content":"The <bpt id=\"p1\">**</bpt>strLwr<ept id=\"p1\">**</ept> function uses the <bpt id=\"p2\">**</bpt>LCMapString<ept id=\"p2\">**</ept> function in the Win32 API.","pos":[20350,20425],"source":" The **strLwr** function uses the **LCMapString** function in the Win32 API."},{"pos":[20431,20438],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[20616,20624],"content":"strNFind","linkify":"strNFind","nodes":[{"content":"strNFind","pos":[0,8]}]},{"content":"Searches part of a text string for the first occurrence of a character that isn't included in the specified list of characters.","pos":[20625,20752]},{"pos":[20832,20842],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[20846,20855]},{"content":"Description","pos":[20861,20872]},{"content":"<ph id=\"ph1\">\\_</ph>text","pos":[21300,21306],"source":"\\_text"},{"content":"The text string to search.","pos":[21315,21341]},{"content":"<ph id=\"ph1\">\\_</ph>characters","pos":[21527,21539],"source":"\\_characters"},{"content":"The list of characters to exclude from the search.","pos":[21542,21592]},{"content":"<ph id=\"ph1\">\\_</ph>position","pos":[21754,21764],"source":"\\_position"},{"content":"The position in the string at which to begin the search.","pos":[21769,21825]},{"content":"<ph id=\"ph1\">\\_</ph>number","pos":[21981,21989],"source":"\\_number"},{"content":"A signed number that indicates the direction of the search and how many positions to search.","pos":[21996,22088]},{"content":"If a minus sign precedes <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>number<ept id=\"p1\">*</ept>, the system searches <bpt id=\"p2\">*</bpt><ph id=\"ph2\">\\_</ph>number<ept id=\"p2\">*</ept> characters in reverse order from <bpt id=\"p3\">*</bpt><ph id=\"ph3\">\\_</ph>position<ept id=\"p3\">*</ept>.","pos":[22089,22203],"source":" If a minus sign precedes *\\_number*, the system searches *\\_number* characters in reverse order from *\\_position*."},{"pos":[22211,22223],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"pos":[22225,22330],"content":"The position of the first occurrence of a character that isn't specified by the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>characters<ept id=\"p1\">*</ept> parameter.","source":"The position of the first occurrence of a character that isn't specified by the *\\_characters* parameter."},{"pos":[22336,22343],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The search isn't case-sensitive.","pos":[22345,22377]},{"content":"To search from the beginning of the string to the end, use a value of <bpt id=\"p1\">**</bpt>1<ept id=\"p1\">**</ept> for the <bpt id=\"p2\">*</bpt><ph id=\"ph1\">\\_</ph>position<ept id=\"p2\">*</ept> parameter.","pos":[22378,22485],"source":" To search from the beginning of the string to the end, use a value of **1** for the *\\_position* parameter."},{"content":"If a minus sign precedes the value of the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>number<ept id=\"p1\">*</ept> parameter, the characters will be searched in reverse order, starting from the position that is specified by the <bpt id=\"p2\">*</bpt><ph id=\"ph2\">\\_</ph>position<ept id=\"p2\">*</ept> parameter.","pos":[22486,22675],"source":" If a minus sign precedes the value of the *\\_number* parameter, the characters will be searched in reverse order, starting from the position that is specified by the *\\_position* parameter."},{"pos":[22972,23043],"content":"The <bpt id=\"p1\">**</bpt>strNFind<ept id=\"p1\">**</ept> function is complementary to the <bpt id=\"p2\">**</bpt>strFind<ept id=\"p2\">**</ept> function.","source":"The **strNFind** function is complementary to the **strFind** function."},{"pos":[23048,23055],"content":"strPoke","linkify":"strPoke","nodes":[{"content":"strPoke","pos":[0,7]}]},{"content":"Overwrites part of a string with another string.","pos":[23056,23104]},{"pos":[23166,23176],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[23180,23189]},{"content":"Description","pos":[23193,23204]},{"content":"<ph id=\"ph1\">\\_</ph>text1","pos":[23374,23381],"source":"\\_text1"},{"content":"The original string.","pos":[23387,23407]},{"content":"<ph id=\"ph1\">\\_</ph>text2","pos":[23471,23478],"source":"\\_text2"},{"content":"The string to replace part of the original string with.","pos":[23484,23539]},{"content":"<ph id=\"ph1\">\\_</ph>position","pos":[23568,23578],"source":"\\_position"},{"content":"The position of the original string at which to begin replacing the characters.","pos":[23581,23660]},{"pos":[23668,23680],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"The new string.","pos":[23682,23697]},{"pos":[23703,23710],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The new string can be longer than the original string.","pos":[23712,23766]},{"content":"However, if the value of the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>position<ept id=\"p1\">*</ept> parameter is more than the length of the string, the original string is returned without replacements.","pos":[23767,23911],"source":" However, if the value of the *\\_position* parameter is more than the length of the string, the original string is returned without replacements."},{"pos":[24112,24121],"content":"strPrompt","linkify":"strPrompt","nodes":[{"content":"strPrompt","pos":[0,9]}]},{"content":"Appends a string with the specified number of period characters, followed by a colon and space character.","pos":[24122,24227]},{"pos":[24275,24285],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[24289,24298]},{"content":"Description","pos":[24301,24312]},{"content":"<ph id=\"ph1\">\\_</ph>string","pos":[24401,24409],"source":"\\_string"},{"content":"The original string.","pos":[24413,24433]},{"content":"<ph id=\"ph1\">\\_</ph>len","pos":[24457,24462],"source":"\\_len"},{"content":"The desired final length of the string.","pos":[24469,24508]},{"pos":[24516,24528],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"A string that looks like a prompt for user input.","pos":[24530,24579]},{"pos":[24585,24592],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"In atypical cases, where the value of the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>len<ept id=\"p1\">*</ept> parameter is only slightly more than the length of the original string, the highest precedence is given to adding the trailing space.","pos":[24594,24777],"source":"In atypical cases, where the value of the *\\_len* parameter is only slightly more than the length of the original string, the highest precedence is given to adding the trailing space."},{"content":"Next, precedence is given to the colon.","pos":[24778,24817]},{"content":"The lowest precedence is given to the periods.","pos":[24818,24864]},{"content":"Negative values for the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>len<ept id=\"p1\">*</ept> parameter return the input string appended with a trailing space.","pos":[24865,24962],"source":" Negative values for the *\\_len* parameter return the input string appended with a trailing space."},{"pos":[25176,25183],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[25359,25365],"content":"strRem","linkify":"strRem","nodes":[{"content":"strRem","pos":[0,6]}]},{"content":"Removes the characters that are specified in one string from another string.","pos":[25366,25442]},{"pos":[25486,25496],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[25500,25509]},{"content":"Description","pos":[25512,25523]},{"content":"text1","pos":[25632,25637]},{"content":"The string to remove characters from.","pos":[25644,25681]},{"content":"text2","pos":[25698,25703]},{"content":"The characters to exclude from the output string.","pos":[25710,25759]},{"pos":[25767,25779],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"The remaining content of the original string.","pos":[25781,25826]},{"pos":[25832,25839],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This function is case-sensitive.","pos":[25841,25873]},{"pos":[26006,26065],"content":"This function is complementary to the <bpt id=\"p1\">**</bpt>strKeep<ept id=\"p1\">**</ept> function.","source":"This function is complementary to the **strKeep** function."},{"pos":[26070,26076],"content":"strRep","linkify":"strRep","nodes":[{"content":"strRep","pos":[0,6]}]},{"content":"Repeats a string of characters.","pos":[26077,26108]},{"pos":[26154,26164],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[26168,26177]},{"content":"Description","pos":[26180,26191]},{"content":"<ph id=\"ph1\">\\_</ph>text","pos":[26284,26290],"source":"\\_text"},{"content":"The string to repeat.","pos":[26296,26317]},{"content":"<ph id=\"ph1\">\\_</ph>number","pos":[26342,26350],"source":"\\_number"},{"content":"The number of times to repeat the string.","pos":[26354,26395]},{"pos":[26403,26415],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"A new string that contains the contents of the original string that are repeated the specified number of times.","pos":[26417,26528]},{"pos":[26534,26541],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[26543,26605],"content":"The following example prints the text string <bpt id=\"p1\">**</bpt>ABABABABABAB<ept id=\"p1\">**</ept>.","source":"The following example prints the text string **ABABABABABAB**."},{"pos":[26778,26786],"content":"strRTrim","linkify":"strRTrim","nodes":[{"content":"strRTrim","pos":[0,8]}]},{"content":"Removes the trailing space characters from the end of a string.","pos":[26787,26850]},{"pos":[26885,26895],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[26899,26908]},{"content":"Description","pos":[26911,26922]},{"content":"<ph id=\"ph1\">\\_</ph>text","pos":[27047,27053],"source":"\\_text"},{"content":"The string to remove the trailing space characters from .","pos":[27059,27116]},{"pos":[27124,27136],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"A copy of the specified string that doesn't include trailing space characters.","pos":[27138,27216]},{"pos":[27222,27229],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[27333,27405],"content":"The <bpt id=\"p1\">**</bpt>strRTrim<ept id=\"p1\">**</ept> function is complementary to the <bpt id=\"p2\">**</bpt>strLTrim<ept id=\"p2\">**</ept> function.","source":"The **strRTrim** function is complementary to the **strLTrim** function."},{"pos":[27410,27417],"content":"strScan","linkify":"strScan","nodes":[{"content":"strScan","pos":[0,7]}]},{"content":"Searches a text string for an occurrence of another string.","pos":[27418,27477]},{"pos":[27552,27562],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[27566,27575]},{"content":"Description","pos":[27579,27590]},{"content":"<ph id=\"ph1\">\\_</ph>text1","pos":[28044,28051],"source":"\\_text1"},{"content":"The string to search in.","pos":[28057,28081]},{"content":"<ph id=\"ph1\">\\_</ph>text2","pos":[28283,28290],"source":"\\_text2"},{"content":"The string to find.","pos":[28296,28315]},{"content":"<ph id=\"ph1\">\\_</ph>position","pos":[28522,28532],"source":"\\_position"},{"pos":[28535,28614],"content":"The first position in the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>text1<ept id=\"p1\">*</ept> parameter at which to perform a comparison.","source":"The first position in the *\\_text1* parameter at which to perform a comparison."},{"content":"<ph id=\"ph1\">\\_</ph>number","pos":[28761,28769],"source":"\\_number"},{"content":"The number of positions in the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>text1<ept id=\"p1\">*</ept> parameter to retry the comparison for.","pos":[28774,28853],"source":"The number of positions in the *\\_text1* parameter to retry the comparison for."},{"content":"If a minus sign precedes the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>number<ept id=\"p1\">*</ept> parameter, the system searches the number of characters in reverse order from the specified position.","pos":[28854,28995],"source":" If a minus sign precedes the *\\_number* parameter, the system searches the number of characters in reverse order from the specified position."},{"pos":[29003,29015],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"pos":[29017,29109],"content":"The position at which the specified string was found in the string; otherwise, <bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept> (zero).","source":"The position at which the specified string was found in the string; otherwise, **0** (zero)."},{"pos":[29115,29122],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The comparisons aren't case-sensitive.","pos":[29124,29162]},{"content":"Values for the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>position<ept id=\"p1\">*</ept> parameter that are less than <bpt id=\"p2\">**</bpt>1<ept id=\"p2\">**</ept> are treated as <bpt id=\"p3\">**</bpt>1<ept id=\"p3\">**</ept>.","pos":[29163,29247],"source":" Values for the *\\_position* parameter that are less than **1** are treated as **1**."},{"content":"The direction of the scan is controlled by the sign that is specified in the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>number<ept id=\"p1\">*</ept> parameter.","pos":[29248,29346],"source":" The direction of the scan is controlled by the sign that is specified in the *\\_number* parameter."},{"content":"A positive sign indicates that each successive comparison will start one position closer to the end of the string.","pos":[29347,29461]},{"content":"A negative sign indicates that each comparison will start one position closer to the start of the string.","pos":[29462,29567]},{"pos":[29698,29704],"content":"strUpr","linkify":"strUpr","nodes":[{"content":"strUpr","pos":[0,6]}]},{"content":"Converts all the letters in a string to uppercase.","pos":[29705,29755]},{"pos":[29788,29798],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[29802,29811]},{"content":"Description","pos":[29814,29825]},{"content":"<ph id=\"ph1\">\\_</ph>text","pos":[29922,29928],"source":"\\_text"},{"content":"The string to convert to uppercase letters.","pos":[29934,29977]},{"pos":[29985,29997],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"A copy of the specified string that contains only lowercase letters.","pos":[29999,30067]},{"pos":[30073,30080],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <bpt id=\"p1\">**</bpt>strUpr<ept id=\"p1\">**</ept> function is complementary to the <bpt id=\"p2\">**</bpt>strLwr<ept id=\"p2\">**</ept> function.","pos":[30082,30150],"source":"The **strUpr** function is complementary to the **strLwr** function."},{"content":"The <bpt id=\"p1\">**</bpt>strUpr<ept id=\"p1\">**</ept> function uses the <bpt id=\"p2\">**</bpt>LCMapString()<ept id=\"p2\">**</ept> function in the Win32 API.","pos":[30151,30228],"source":" The **strUpr** function uses the **LCMapString()** function in the Win32 API."},{"pos":[30234,30241],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[30243,30294],"content":"The following example will print <bpt id=\"p1\">**</bpt>ABCDD55EFGHIJ<ept id=\"p1\">**</ept>.","source":"The following example will print **ABCDD55EFGHIJ**."},{"pos":[30416,30422],"content":"subStr","linkify":"subStr","nodes":[{"content":"subStr","pos":[0,6]}]},{"content":"Retrieves part of a string.","pos":[30423,30450]},{"pos":[30511,30521],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[30525,30534]},{"content":"Description","pos":[30538,30549]},{"content":"<ph id=\"ph1\">\\_</ph>text","pos":[30991,30997],"source":"\\_text"},{"content":"The original string.","pos":[31004,31024]},{"content":"<ph id=\"ph1\">\\_</ph>position","pos":[31224,31234],"source":"\\_position"},{"content":"The position in the original string where the part to retrieve begins.","pos":[31237,31307]},{"content":"<ph id=\"ph1\">\\_</ph>number","pos":[31457,31465],"source":"\\_number"},{"content":"A signed integer that indicates the direction and number of positions to retrieve from the original string.","pos":[31470,31577]},{"content":"If a minus sign precedes <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>number<ept id=\"p1\">*</ept>, the system selects the substring backward from the specified position.","pos":[31578,31685],"source":" If a minus sign precedes *\\_number*, the system selects the substring backward from the specified position."},{"pos":[31693,31705],"content":"Return value","linkify":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"content":"A substring of the original string.","pos":[31707,31742]},{"pos":[31748,31755],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[31757,31889],"content":"If a minus sign precedes the value of the <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\_</ph>number<ept id=\"p1\">*</ept> parameter, the substring will be selected backward from the specified position.","source":"If a minus sign precedes the value of the *\\_number* parameter, the substring will be selected backward from the specified position."}],"content":"---\n# required metadata\n\ntitle: X++ String run-time functions | Microsoft Docs\ndescription: This wiki describes the string run-time functions.\nauthor: annbe\nmanager: AnnBe\nms.date: 2016-02-04 22:14:12\nms.topic: article\nms.prod: \nms.service: Dynamics365Operations\nms.technology: \n\n# optional metadata\n\n# keywords: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \n# ms.reviewer: \nms.suite: Released- Dynamics AX 7.0.0\n# ms.tgt_pltfrm: \nms.custom: 31401\nms.assetid: bd9c7380-2718-4f5a-85f9-3bb05a6c736b\n# ms.region: \n# ms.industry: \nms.author: RobinARH\n\n---\n\n# X++ String run-time functions\n\nmatch\n-----\n\nSearches for a string or expression in another string.\n\n    int match(str pattern, str text)\n\n### Parameters\n\n| Parameter | Description                             |\n|-----------|-----------------------------------------|\n| pattern   | The string or expression to search for. |\n| text      | The string to search.                   |\n\n### Return value\n\n**1** if the pattern is located in the string; otherwise, **0** (zero).\n\n### Remarks\n\nThe search is case-insensitive. The following special characters can be used to create the pattern for the *pattern* parameter.\n\n<table>\n<colgroup>\n<col width=\"50%\" />\n<col width=\"50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Character</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>\\</td>\n<td>A backslash (\\) nullifies, or escapes, the special treatment of special characters, so that a special character can be matched like a normal letter. A pair of backslashes is translated into one non-special backslash. Examples:\n<ul>\n<li><strong>match(&quot;ab$cd&quot;,&quot;ab$cd&quot;);</strong> returns <strong>0</strong>.</li>\n<li><strong>match(&quot;ab$cd&quot;,&quot;ab$cd&quot;);</strong> returns <strong>0</strong>. The backslash isn't escaped.</li>\n<li><strong>match(&quot;ab\\$cd&quot;,&quot;ab$cd&quot;);</strong> returns <strong>1</strong>. The backslash and dollar sign are escaped.</li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td>&lt; or ^</td>\n<td>A left angle bracket (&lt;) or a circumflex (^) at the start of an expression is used to match the start of a line. Examples:\n<ul>\n<li><strong>match(&quot;&lt;abc&quot;,&quot;abcdef&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;&lt;abc&quot;,&quot;defabc&quot;);</strong> returns <strong>0</strong>.</li>\n<li><strong>match(&quot;^abc&quot;,&quot;abcdef&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;^abc&quot;,&quot;defabc&quot;);</strong> returns <strong>0</strong>.</li>\n</ul></td>\n</tr>\n<tr class=\"odd\">\n<td>&gt; or $</td>\n<td>A right angle bracket (&gt;) or a dollar sign (?) at the end of the expression is used to match the end of a line. Examples:\n<ul>\n<li><strong>match(&quot;abc&gt;&quot;,&quot;abcdef&quot;);</strong> returns <strong>0</strong>.</li>\n<li><strong>match(&quot;abc&gt;&quot;,&quot;defabc&quot;);</strong> returns <strong>1</strong>.</li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td>? or .</td>\n<td>A question mark (?) or a period (.) matchs any one character in the same position. Examples:\n<ul>\n<li><strong>match(&quot;abc.def&quot;,&quot;abc#def&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;colou?r&quot;,&quot;colouXr&quot;);</strong> returns <strong>1</strong>.</li>\n</ul></td>\n</tr>\n<tr class=\"odd\">\n<td>:x</td>\n<td>A colon specifies a group of characters to match, as indicated by the character that immediately follows.</td>\n</tr>\n<tr class=\"even\">\n<td>:a</td>\n<td>Sets the match to letters. Examples:\n<ul>\n<li><strong>match(&quot;ab:acd&quot;,&quot;ab#cd&quot;);</strong> returns <strong>0</strong>.</li>\n<li><strong>match(&quot;ab:acd&quot;,&quot;abxyzcd&quot;);</strong> returns <strong>0</strong>.</li>\n<li><strong>match(&quot;ab:acd&quot;,&quot;abxcd&quot;);</strong> returns <strong>1</strong>.</li>\n</ul></td>\n</tr>\n<tr class=\"odd\">\n<td>:d</td>\n<td>Sets the match to numeric characters. Examples:\n<ul>\n<li><strong>match(&quot;ab:dcd&quot;,&quot;ab3cd&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;ab:dcd&quot;,&quot;ab123cd&quot;);</strong> returns <strong>0</strong>.</li>\n<li><strong>match(&quot;ab:dcd&quot;,&quot;abcd&quot;);</strong> returns <strong>0</strong>.</li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td>:n</td>\n<td>Sets the match to alphanumeric characters. Examples:\n<ul>\n<li><strong>match(&quot;ab:ncd&quot;,&quot;ab%cd&quot;);</strong> returns <strong>0</strong>.</li>\n<li><strong>match(&quot;ab:ncd&quot;,&quot;ab9cd&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;ab:ncd&quot;,&quot;abXcd&quot;);</strong> returns <strong>1</strong>.</li>\n</ul></td>\n</tr>\n<tr class=\"odd\">\n<td>:SPACE</td>\n<td>SPACE is the space character ( ). Sets the match to blanks, tabulations, and control characters such as Enter (new line). Examples:\n<ul>\n<li><strong>match(&quot;ab: cd&quot;,&quot;ab cd&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;ab: cd&quot;,&quot;ab\\ncd&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;ab: cd&quot;,&quot;ab\\tcd&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;ab: cd&quot;,&quot;ab cd&quot;);</strong> returns <strong>0</strong>. Only the first space is matched.</li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td>*</td>\n<td>An expression that is followed by an asterisk (*) requires a match for zero, one, or more occurrences of the preceding expression. Examples:\n<ul>\n<li><strong>match(&quot;abc*d&quot;,&quot;abd&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;abc*d&quot;,&quot;abcd&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;abc*d&quot;,&quot;abcccd&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;abc*d&quot;,&quot;abxd&quot;);</strong> returns <strong>0</strong>.</li>\n</ul></td>\n</tr>\n<tr class=\"odd\">\n<td>+</td>\n<td>An expression that is followed by a plus sign (+) requires a match for one or more occurrences of the preceding expression. Examples:\n<ul>\n<li><strong>match(&quot;abc+d&quot;,&quot;abd&quot;);</strong> returns <strong>0</strong>.</li>\n<li><strong>match(&quot;abc+d&quot;,&quot;abcd&quot;);</strong> returns <strong>1</strong></li>\n<li><strong>match(&quot;abc+d&quot;,&quot;abcccd&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;abc+d&quot;,&quot;abxd&quot;);</strong> returns <strong>0</strong>.</li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td>-</td>\n<td>An expression that is followed by a minus sign (-) requires a match for zero or one occurrence of the preceding expression. In other words, the preceding expression is optional. Examples:\n<ul>\n<li><strong>match(&quot;colou-r&quot;,&quot;color&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;colou-r&quot;,&quot;colour&quot;);</strong> returns <strong>1</strong>.</li>\n</ul></td>\n</tr>\n<tr class=\"odd\">\n<td>[]</td>\n<td>Matches a single character with any character that is enclosed in the brackets. A range of characters can be specified by two characters that are separated by a minus sign (-). For example, <strong>[a-z]</strong> matches all letters between a and z, <strong>[0-9]</strong> matches a digit, and <strong>[0-9a-f]</strong> matches a hexadecimal digit. Examples:\n<ul>\n<li><strong>match(&quot;[abc]&quot;,&quot;apple&quot;);</strong> returns <strong>1</strong>, because it matches the a in &quot;apple.&quot;</li>\n<li><strong>match(&quot;[abc]&quot;,&quot;kiwi&quot;);</strong> returns <strong>0</strong>, because &quot;kiwi&quot; doesn't contain an a, b, or c.</li>\n<li><strong>match(&quot;gr[ae]y&quot;,&quot;grey&quot;);</strong> returns 1. This expression also matches &quot;gray.&quot;</li>\n<li><strong>match(&quot;gr[ae]y&quot;,&quot;graey&quot;);</strong> returns <strong>0</strong>, because only one character between &quot;gr&quot; and &quot;y&quot; is matched.</li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td>[^]</td>\n<td>If the first character in the text that is enclosed in brackets is a circumflex (^), the expression matches all characters except the characters that are enclosed in the brackets. Examples:\n<ul>\n<li><strong>match(&quot;[^bc]at&quot;,&quot;bat&quot;);</strong> returns <strong>0</strong>.</li>\n<li><strong>match(&quot;[^bc]at&quot;,&quot;hat&quot;);</strong> returns <strong>1</strong>.</li>\n<li><strong>match(&quot;[^abc]&quot;,&quot;bat&quot;);</strong> returns <strong>1</strong>. Anything except a, b, or c is matched. Therefore, the t is matched.</li>\n</ul></td>\n</tr>\n</tbody>\n</table>\n\n## strAlpha\nCopies only the alphanumeric characters from a string.\n\n    str strAlpha(str _text)\n\n### Parameters\n\n| Parameter | Description              |\n|-----------|--------------------------|\n| \\_text    | The string to copy from. |\n\n### Return value\n\nA new string that contains all the alphanumeric characters from the specified string.\n\n### Remarks\n\nFor example, **strAlpha(\"2+2=5 is this correct?\")** returns the string **225isthiscorrect**.\n\n### Example\n\n    static void strAlphaExample(Args _arg)\n    {\n            str s;\n            ;\n            s = strAlpha(\"?a*bc123.\");\n            print s;\n            pause;\n    }\n\n## strCmp\nCompares two text strings.\n\n    int strCmp(str text1, str text2)\n\n### Parameters\n\n| Parameter | Description        |\n|-----------|--------------------|\n| text1     | The first string.  |\n| text2     | The second string. |\n\n### Return value\n\n**0** if the two strings are identical, **1** if the first string sorts earlier, or **-1** if the second string sorts earlier.\n\n### Remarks\n\nThe comparison performed by this method is case-sensitive.\n\n    print strCmp(\"abc\", \"abc\"); //Returns the value 0.\n    print strCmp(\"abc\", \"ABC\"); //Returns the value 1.\n    print strCmp(\"aaa\", \"bbb\"); //Returns the value -1.\n    print strCmp(\"ccc\", \"bbb\"); //Returns the value 1.\n\n## strColSeq\nConverts all uppercase characters to lowercase characters, and converts all characters that have accents to the corresponding unaccented lowercase characters.\n\n    str strColSeq(str text)\n\n### Parameters\n\n| Parameter | Description                                     |\n|-----------|-------------------------------------------------|\n| text      | The string to copy and convert characters from. |\n\n### Return value\n\nThe converted text string.\n\n### Remarks\n\nThe **strColSeq** function exists for backward-compatibility purposes. This function supports only the mapping for the following Western European characters:\n\n-   AàáâãäÀÁÂÃÄBCçÇDEèéêëÈÉÊËFGHIìíîïÌÍÎÏJKLMNñÑOòóôõöÒÓÔÕÖPQRSTUùúûüÙÚÛÜVWXYýÝZæøåÆØÅ\n-   aaaaaaaaaaabcccdeeeeeeeeefghiiiiiiiiijklmnnnooooooooooopqrstuuuuuuuuuvwxyyyz~¦Ç~¦Ç\n\nFor Unicode-compliant functionality, use the Win32 LCMapString application programming interface (API) via the **DLL** and **DLLFunc** classes.\n\n### Example\n\nThe following example prints **abcdeabcde**.\n\n    static void strColSeqExample(Args _arg)\n    {\n            ;\n            print strColSeq(\"\");\n            pause;\n    }\n\n## strDel\nCreates a copy of a string, from which the specified substring is removed.\n\n    str strDel(str _text, int _position, int _number)\n\n### Parameters\n\n| Parameter  | Description                                                                                                                                                                                                                      |\n|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| \\_text     | The string to copy from.                                                                                                                                                                                                         |\n| \\_position | The position at which to begin ignoring characters during the copy operation.                                                                                                                                                    |\n| \\_number   | The number of characters to ignore. A minus sign in front of the *\\_number* parameter indicates that *\\_number*–1 characters before the character at *\\_position* should be removed together with the character at *\\_position*. |\n\n### Return value\n\nThe remaining characters that are copied from the string.\n\n### Remarks\n\nThe **strDel** function is complementary to the **substr** function.\n\n    strDel(\"ABCDEFGH\",2,3); //Returns the string \"AEFGH\".\n    strDel(\"ABCDEFGH\",4,3); //Returns the string \"ABCGH\".\n\n## strFind\nSearches a string for the first occurrence of one of the specified characters.\n\n    int strFind(str _text, str _characters, int _position, int _number)\n\n### Parameters\n\n| Parameter    | Description                                                                                                |\n|--------------|------------------------------------------------------------------------------------------------------------|\n| \\_text       | The string to search.                                                                                      |\n| \\_characters | The characters to search for.                                                                              |\n| \\_position   | The position in the string where the search begins.                                                        |\n| \\_number     | A signed number that indicates the direction of the search and how many positions to search in the string. |\n\n### Return value\n\nThe value of the position of the first occurrence of one of the specified characters.\n\n### Remarks\n\nTo search from the beginning of the string to the end, use **1** as the value of the *\\_position* parameter. If the value of the *\\_number* parameter is negative, the system searches the number of characters backward from the specified position. The search isn't case-sensitive. Here is an example.\n\n    strFind(\"ABCDEFGHIJ\",\"KHD\",1,10); //Returns the value 4 (the position where \"D\" was found).\n    strFind(\"ABCDEFGHIJ\",\"KHD\",10,-10); //Returns the value 8 (the position where \"H\" was found).\n\nThe **strFind** function is complementary to the **strNFind** function.\n\n## strFmt\nFormats the specified string and substitutes any occurrences of n with the nth argument.\n\n    str strFmt(str _string, ...)\n\n### Parameters\n\n| Parameter | Description            |\n|-----------|------------------------|\n| \\_string  | The strings to format. |\n\n### Return value\n\nThe formatted string.\n\n### Remarks\n\nIf an argument isn't provided for a parameter, the parameter will be returned as \"%n\" in the string. The string conversion of values of the **real** type is limited to two decimal places. Values are rounded, not truncated. The **System.String::Format** method from the Microsoft .NET Framework can be used to gain additional functionality, as shown in the example.\n\n### Example\n\n    static void strFmtExampleJob(Args _arg)\n    {\n            System.Double sysDouble;\n            real r = 8.3456789;\n            int  i = 42;\n            utcDateTime utc = str2DateTime(\"2008-01-16 13:44:55\" ,321); // 321 == YMD.\n            str  s;\n            ;\n            s = strFmt(\"real = %1, int = %2, utcDateTime = %3, [%4]\", r, i, utc);\n            info(\"X1:  \" + s);\n            //\n            sysDouble = r;\n            s = System.String::Format(\"{0:##.####}\", sysDouble);\n            info(\"N1:  \" + s);\n            //\n            s = System.String::Format(\"{0,6:C}\", sysDouble); // $\n            info(\"N2:  \" + s);\n            /**********  Actual Infolog output\n            Message (02:16:05 pm)\n            X1:  real = 8.35, int = 42, utcDateTime = 1/16/2008 01:44:55 pm, [%4]\n            N1:  8.3457\n            N2:   $8.35\n            **********/\n    }\n\n## strIns\nBuilds a string by inserting one string into another.\n\n    str strIns(str _text1, str _text2, int _position)\n\n### Parameters\n\n| Parameter  | Description                                                                                          |\n|------------|------------------------------------------------------------------------------------------------------|\n| \\_text1    | The string to insert the other string into.                                                          |\n| \\_text2    | The string to insert into the other string.                                                          |\n| \\_position | The position where the first character of the *\\_text2* parameter should occur in the output string. |\n\n### Return value\n\nThe combined text string.\n\n### Remarks\n\nThe **strIns** function is complementary to the **strDel** function. If the value of the *\\_position* parameter is more than the length of the original string, the string to insert is appended to the end of the original string.\n\n    strIns(\"ABFGH\",\"CDE\",3); //Returns the string \"ABCDEFGH\".\n    strIns(\"ABCD\",\"EFGH\",10); //Returns the string \"ABCDEFGH\".\n\n## strKeep\nBuilds a string by using only the characters from the first input string that the second input string specifies should be kept.\n\n    str strKeep(str _text1, str _text2)\n\n### Parameters\n\n| Parameter | Description                                                                         |\n|-----------|-------------------------------------------------------------------------------------|\n| \\_text1   | The string that contains the characters that can be used to build an output string. |\n| \\_text2   | The string that specifies which characters to keep for the output string.           |\n\n### Return value\n\nA string of the characters that are kept.\n\n### Remarks\n\n    strKeep(\"ABBCDDEFGHB\",\"BCD\"); //Returns the string \"BBCDDB\".\n    strKeep(\"abcZcba\",\"bc\") //Returns the string \"bccb\".\n\nThe **strKeep** function is complementary to the **strRem** function.\n\n## strLen\nCalculates the length of the specified string.\n\n    int strLen(str text)\n\n### Parameters\n\n| Parameter | Description                            |\n|-----------|----------------------------------------|\n| text      | The string to calculate the length of. |\n\n### Return value\n\nThe length of the specified string.\n\n### Remarks\n\n    strLen(\"ABC\"); //Returns the value 3.\n    strLen(\"ABCDEFGHIJ\"); //Returns the value 10.\n\n## strLine\nRetrieves a single line from a string that spans multiple lines.\n\n    str strLine(str string, int count)\n\n### Parameters\n\n| Parameter | Description                              |\n|-----------|------------------------------------------|\n| string    | A string that might span multiple lines. |\n| count     | The offset of the line to return.        |\n\n### Return value\n\nA copied line of the string that is specified by the *string* parameter.\n\n### Remarks\n\nThe first line of the string has an offset of 0. You can assign multiple lines to one string by embedding the *n* or *rn* characters in the string. Additionally, you can use the at sign (@) immediately before the opening quotation mark and use the Enter key to spread parts of the string value over multiple lines in the X++ code editor.\n\n### Example\n\n    static void strLineExample(Args _arg)\n    {\n            str mytxt = \"first-linensecond-linenlast-line\";\n            ;\n            // Prints \"second-line\".\n            print strLine(mytxt,1);\n            // Prints \"last-line\".\n            print strLine(mytxt,2);\n            pause;\n    }\n\n## strLTrim\nRemoves leading blanks from a text string.\n\n    str strLTrim(str text)\n\n### Parameters\n\n| Parameter | Description                                   |\n|-----------|-----------------------------------------------|\n| text      | The string to delete the leading blanks from. |\n\n### Return value\n\nThe string equivalent for the text that leading blanks have been removed from.\n\n### Remarks\n\nThe **strLTrim** function is complementary to the **strRTrim** function.\n\n### Example\n\n    // Returns the text string \"ABC-DEFG\".\n    strLTrim(\"   ABC-DEFG\");\n\n## strLwr\nConverts all letters in the specified string to lowercase.\n\n    str strLwr(str _text)\n\n### Parameters\n\n| Parameter | Description                         |\n|-----------|-------------------------------------|\n| \\_text    | The string to convert to lowercase. |\n\n### Return value\n\nA copy of the specified string that contains only lowercase letter.\n\n### Remarks\n\nThe **strLwr** function is complementary to the **strUpr** function. The **strLwr** function uses the **LCMapString** function in the Win32 API.\n\n### Example\n\n    static void strLwrExample(Args _args)\n    {\n            // Returns the text string \"abcdd55efghij\".\n            print strLwr(\"Abcdd55EFGHIJ\");\n            pause;\n    }\n\n## strNFind\nSearches part of a text string for the first occurrence of a character that isn't included in the specified list of characters.\n\n    int strNFind(str _text, str _characters, int _position, int _number)\n\n### Parameters\n\n| Parameter    | Description                                                                                                                                                                                                     |\n|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| \\_text       | The text string to search.                                                                                                                                                                                      |\n| \\_characters | The list of characters to exclude from the search.                                                                                                                                                              |\n| \\_position   | The position in the string at which to begin the search.                                                                                                                                                        |\n| \\_number     | A signed number that indicates the direction of the search and how many positions to search. If a minus sign precedes *\\_number*, the system searches *\\_number* characters in reverse order from *\\_position*. |\n\n### Return value\n\nThe position of the first occurrence of a character that isn't specified by the *\\_characters* parameter.\n\n### Remarks\n\nThe search isn't case-sensitive. To search from the beginning of the string to the end, use a value of **1** for the *\\_position* parameter. If a minus sign precedes the value of the *\\_number* parameter, the characters will be searched in reverse order, starting from the position that is specified by the *\\_position* parameter.\n\n    strNFind(\"ABCDEFGHIJ\",\"ABCDHIJ\",1,10); //Returns the value 5 (the position of \"E\");\n    strNFind(\"CDEFGHIJ\",\"CDEFGIJ\",10,-10); //Returns the value 6 (the position of \"H\").\n    strNFind(\"abcdef\",\"abCdef\",3,2) //Returns the value 0.\n    strNFind(\"abcdef\", \"abcef\",3,2) //Returns the value 4.\n\nThe **strNFind** function is complementary to the **strFind** function.\n\n## strPoke\nOverwrites part of a string with another string.\n\n    str strPoke(str _text1, str _text2, int _position)\n\n### Parameters\n\n| Parameter  | Description                                                                     |\n|------------|---------------------------------------------------------------------------------|\n| \\_text1    | The original string.                                                            |\n| \\_text2    | The string to replace part of the original string with.                         |\n| \\_position | The position of the original string at which to begin replacing the characters. |\n\n### Return value\n\nThe new string.\n\n### Remarks\n\nThe new string can be longer than the original string. However, if the value of the *\\_position* parameter is more than the length of the string, the original string is returned without replacements.\n\n    strPoke(\"12345678\",\"AAA\",3); //Returns the string \"12AAA678\".\n    strPoke(\"abcde\",\"4567\",4); //Returns the string \"abc4567\".\n    strPoke(\"abcde\", \"4567\", \"10\"); //Returns the string \"abcde\".\n\n## strPrompt\nAppends a string with the specified number of period characters, followed by a colon and space character.\n\n    str strPrompt(str _string, _int len)\n\n### Parameters\n\n| Parameter | Description                             |\n|-----------|-----------------------------------------|\n| \\_string  | The original string.                    |\n| \\_len     | The desired final length of the string. |\n\n### Return value\n\nA string that looks like a prompt for user input.\n\n### Remarks\n\nIn atypical cases, where the value of the *\\_len* parameter is only slightly more than the length of the original string, the highest precedence is given to adding the trailing space. Next, precedence is given to the colon. The lowest precedence is given to the periods. Negative values for the *\\_len* parameter return the input string appended with a trailing space.\n\n    strPrompt(\"ab\",-1); //Returns \"ab \".\n    strPrompt(\"ab\",3); //Returns \"ab \".\n    strPrompt(\"ab\",4); //Returns \"ab: \".\n    strPrompt(\"ab\",5); //Returns \"ab.: \".\n    strPrompt(\"ab\",6); //Returns \"ab..: \".\n\n### Example\n\n    static void JobStrPromptDemo(Args _args)\n    {\n            // Printed string is \"[abc..: ]\"\n            print \"[\", strPrompt(\"abc\", 7), \"]\";\n            pause;\n    }\n\n## strRem\nRemoves the characters that are specified in one string from another string.\n\n    str strRem(str text1, str text2)\n\n### Parameters\n\n| Parameter | Description                                       |\n|-----------|---------------------------------------------------|\n| text1     | The string to remove characters from.             |\n| text2     | The characters to exclude from the output string. |\n\n### Return value\n\nThe remaining content of the original string.\n\n### Remarks\n\nThis function is case-sensitive.\n\n    strRem(\"abcd_abcd\",\"Bc\"); //Returns the string \"abd_abd\".\n    strRem(\"ABCDEFGABCDEFG\",\"ACEG\"); //Returns the string \"BDFBDF\".\n\nThis function is complementary to the **strKeep** function.\n\n## strRep\nRepeats a string of characters.\n\n    str strRep(str _text, str _number)\n\n### Parameters\n\n| Parameter | Description                               |\n|-----------|-------------------------------------------|\n| \\_text    | The string to repeat.                     |\n| \\_number  | The number of times to repeat the string. |\n\n### Return value\n\nA new string that contains the contents of the original string that are repeated the specified number of times.\n\n### Example\n\nThe following example prints the text string **ABABABABABAB**.\n\n    static void strRepExample(Args _arg)\n    {\n            str strL;\n            ;\n            strL = strRep(\"AB\",6);\n            print strL;\n            pause;\n    }\n\n## strRTrim\nRemoves the trailing space characters from the end of a string.\n\n    str strRTrim(str _text)\n\n### Parameters\n\n| Parameter | Description                                               |\n|-----------|-----------------------------------------------------------|\n| \\_text    | The string to remove the trailing space characters from . |\n\n### Return value\n\nA copy of the specified string that doesn't include trailing space characters.\n\n### Remarks\n\n    strRTrim(\"ABC-DEFG- \"); //Returns the string \"ABC-DEFG-\".\n    strRTrim(\" CD \"); //Returns \" CD\".\n\nThe **strRTrim** function is complementary to the **strLTrim** function.\n\n## strScan\nSearches a text string for an occurrence of another string.\n\n    int strScan(str _text1, str _text2, int _position, int _number)\n\n### Parameters\n\n| Parameter  | Description                                                                                                                                                                                                                   |\n|------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| \\_text1    | The string to search in.                                                                                                                                                                                                      |\n| \\_text2    | The string to find.                                                                                                                                                                                                           |\n| \\_position | The first position in the *\\_text1* parameter at which to perform a comparison.                                                                                                                                               |\n| \\_number   | The number of positions in the *\\_text1* parameter to retry the comparison for. If a minus sign precedes the *\\_number* parameter, the system searches the number of characters in reverse order from the specified position. |\n\n### Return value\n\nThe position at which the specified string was found in the string; otherwise, **0** (zero).\n\n### Remarks\n\nThe comparisons aren't case-sensitive. Values for the *\\_position* parameter that are less than **1** are treated as **1**. The direction of the scan is controlled by the sign that is specified in the *\\_number* parameter. A positive sign indicates that each successive comparison will start one position closer to the end of the string. A negative sign indicates that each comparison will start one position closer to the start of the string.\n\n    strScan(\"ABCDEFGHIJ\",\"DEF\",1,10); //Returns the value 4.\n    strScan (\"ABCDEFGHIJ\",\"CDE\",10,-10); //Returns the value 3.\n\n## strUpr\nConverts all the letters in a string to uppercase.\n\n    str strUpr(str _text)\n\n### Parameters\n\n| Parameter | Description                                 |\n|-----------|---------------------------------------------|\n| \\_text    | The string to convert to uppercase letters. |\n\n### Return value\n\nA copy of the specified string that contains only lowercase letters.\n\n### Remarks\n\nThe **strUpr** function is complementary to the **strLwr** function. The **strUpr** function uses the **LCMapString()** function in the Win32 API.\n\n### Example\n\nThe following example will print **ABCDD55EFGHIJ**.\n\n    static void strUprExample(Args _args)\n    {\n            print strUpr(\"Abcdd55EFGhiJ\");\n            pause;\n    }\n\n## subStr\nRetrieves part of a string.\n\n    str subStr(str _text, int _position, int _number)\n\n### Parameters\n\n| Parameter  | Description                                                                                                                                                                                                             |\n|------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| \\_text     | The original string.                                                                                                                                                                                                    |\n| \\_position | The position in the original string where the part to retrieve begins.                                                                                                                                                  |\n| \\_number   | A signed integer that indicates the direction and number of positions to retrieve from the original string. If a minus sign precedes *\\_number*, the system selects the substring backward from the specified position. |\n\n### Return value\n\nA substring of the original string.\n\n### Remarks\n\nIf a minus sign precedes the value of the *\\_number* parameter, the substring will be selected backward from the specified position.\n\n    subStr(\"ABCDEFGHIJ\",3,5); //Returns the string \"CDEFG\".\n    subStr(\"ABCDEFGHIJ\",7,-4); //Returns the string \"DEFG\".\n    subStr(\"abcdef\"),2,99) //Returns the string \"cdef\".\n    subStr(\"abcdef\",2,3) //Returns the string \"bcd\".\n    subStr(\"abcdef\",2,-3); //Returns the string \"ab\".\n\n"}