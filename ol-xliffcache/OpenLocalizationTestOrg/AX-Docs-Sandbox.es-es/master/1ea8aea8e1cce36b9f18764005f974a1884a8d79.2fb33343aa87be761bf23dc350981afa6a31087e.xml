{"nodes":[{"pos":[32,74],"content":"Validations, defaults, and unmapped fields","needQuote":true,"needEscape":true,"nodes":[{"content":"Validations, defaults, and unmapped fields","pos":[0,42]}]},{"pos":[88,222],"content":"Validations are defined on the tables that back up the entities. Validations are defined at both the field level and the record level.","needQuote":true,"needEscape":true,"nodes":[{"content":"Validations are defined on the tables that back up the entities. Validations are defined at both the field level and the record level.","pos":[0,134],"nodes":[{"content":"Validations are defined on the tables that back up the entities.","pos":[0,64]},{"content":"Validations are defined at both the field level and the record level.","pos":[65,134]}]}]},{"pos":[723,765],"content":"Validations, defaults, and unmapped fields","linkify":"Validations, defaults, and unmapped fields","nodes":[{"content":"Validations, defaults, and unmapped fields","pos":[0,42]}]},{"content":"Validations are defined on the tables that back up the entities.","pos":[767,831]},{"content":"Validations are defined at both the field level and the record level.","pos":[832,901]},{"pos":[903,914],"content":"Validations","linkify":"Validations","nodes":[{"content":"Validations","pos":[0,11]}]},{"pos":[932,957],"content":"Entities vs. data sources","linkify":"Entities vs. data sources","nodes":[{"content":"Entities vs. data sources","pos":[0,25]}]},{"content":"Entities are backed by tables (data sources), and validations are defined for these tables at both the field level (<bpt id=\"p1\">**</bpt>Table.validateField()<ept id=\"p1\">**</ept>) and the record level (<bpt id=\"p2\">**</bpt>Table.validateWrite()<ept id=\"p2\">**</ept>).","pos":[959,1151],"source":"Entities are backed by tables (data sources), and validations are defined for these tables at both the field level (**Table.validateField()**) and the record level (**Table.validateWrite()**)."},{"content":"The validations are respected by data entities that are built by using those tables.","pos":[1152,1236]},{"content":"Although these validations are intrinsic to the tables that back a data entity, validations can also be defined at the data entity level.","pos":[1237,1374]},{"content":"Like table-based validations, entity-based validations can be written at the field level (<bpt id=\"p1\">**</bpt>DataEntity.validateField()<ept id=\"p1\">**</ept>) or the record level (<bpt id=\"p2\">**</bpt>DataEntity.validateWrite()<ept id=\"p2\">**</ept>).","pos":[1375,1550],"source":" Like table-based validations, entity-based validations can be written at the field level (**DataEntity.validateField()**) or the record level (**DataEntity.validateWrite()**)."},{"pos":[1557,1589],"content":"Entity-based validation behavior","linkify":"Entity-based validation behavior","nodes":[{"content":"Entity-based validation behavior","pos":[0,32]}]},{"content":"Validation","pos":[1714,1724]},{"content":"Target","pos":[1734,1740]},{"content":"Caller","pos":[1750,1756]},{"content":"DataEntity.ValidateField","pos":[1806,1830]},{"content":"Data types","pos":[1849,1859]},{"content":"Mandatory relationships (both tables and extended data types [EDTs])","pos":[1869,1937]},{"content":"Any custom validation","pos":[1947,1968]},{"content":"Doesn't call <bpt id=\"p1\">&lt;strong&gt;</bpt>validateField<ept id=\"p1\">&lt;/strong&gt;</ept> for underlying mapped table fields","pos":[1978,2056],"source":"Doesn't call <strong>validateField</strong> for underlying mapped table fields"},{"content":"Is called automatically from OData","pos":[2086,2120]},{"content":"Is called by the form engine when a field is modified","pos":[2130,2183]},{"content":"Isn't called automatically if an insert/update is fired from X++ code","pos":[2193,2262]},{"content":"DataEntity.ValidateWrite","pos":[2307,2331]},{"content":"Mandatory columns","pos":[2350,2367]},{"content":"Relationships (both tables and EDTs)","pos":[2377,2413]},{"content":"Any custom validation","pos":[2423,2444]},{"content":"Doesn't call table-level <bpt id=\"p1\">&lt;strong&gt;</bpt>validateWrite<ept id=\"p1\">&lt;/strong&gt;</ept> for underlying tables","pos":[2454,2531],"source":"Doesn't call table-level <strong>validateWrite</strong> for underlying tables"},{"content":"Is called automatically from OData","pos":[2561,2595]},{"content":"Is called by the form engine when a record is saved.","pos":[2605,2657]},{"content":"Isn't called automatically if an insert/update is fired from X++ code","pos":[2667,2736]},{"content":"DataEntity.ValidateDelete","pos":[2780,2805]},{"content":"DeleteActions","pos":[2824,2837]},{"content":"Any custom validation","pos":[2847,2868]},{"content":"Doesn't call table-level <bpt id=\"p1\">&lt;strong&gt;</bpt>validateDelete<ept id=\"p1\">&lt;/strong&gt;</ept> for underlying tables","pos":[2878,2956],"source":"Doesn't call table-level <strong>validateDelete</strong> for underlying tables"},{"content":"Is called automatically from OData.","pos":[2986,3021]},{"content":"Is called by the form engine when a record is deleted","pos":[3031,3084]},{"content":"Isn't called automatically if a delete is fired from X++ code","pos":[3094,3155]},{"pos":[3202,3233],"content":"Table-based validation behavior","linkify":"Table-based validation behavior","nodes":[{"content":"Table-based validation behavior","pos":[0,31]}]},{"content":"Back-end table, or data source, validations are fired automatically as a part of the CUD operations.","pos":[3235,3335]},{"content":"<bpt id=\"p1\">**</bpt>Table.ValidateField, AllowEdit, AllowEditOnCreate<ept id=\"p1\">**</ept> Field-level validations are fired automatically when you perform inserts or updates on the data entity.","pos":[3336,3493],"source":"**Table.ValidateField, AllowEdit, AllowEditOnCreate** Field-level validations are fired automatically when you perform inserts or updates on the data entity."},{"content":"This is true for all paths (X++, OData, and so on).","pos":[3494,3545]},{"content":"These validations occur during the mapping process, when fields are mapped from an entity to individual data sources.","pos":[3546,3663]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>redo1<ept id=\"p1\">](./media/redo1-1024x582.png)](./media/redo1.png)</ept>After the field values from the data entity are copied to mapped data source fields, field validations are run on the set fields.","pos":[3664,3850],"source":"[![redo1](./media/redo1-1024x582.png)](./media/redo1.png)After the field values from the data entity are copied to mapped data source fields, field validations are run on the set fields."},{"content":"Validations include table-level <bpt id=\"p1\">**</bpt>validateField<ept id=\"p1\">**</ept>, which validates <bpt id=\"p2\">**</bpt>AllowEdit<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>AllowEditOnCreate<ept id=\"p3\">**</ept>.","pos":[3851,3958],"source":" Validations include table-level **validateField**, which validates **AllowEdit** and **AllowEditOnCreate**."},{"content":"If a validation fails because of an error, validation for the remaining fields continues.","pos":[3959,4048]},{"content":"Finally, validation checks whether any error occurred during the validation process for any of the data sources.","pos":[4049,4161]},{"content":"If there was an error, the process errors out at this point, and table-level <bpt id=\"p1\">**</bpt>validateWrite()<ept id=\"p1\">**</ept> isn't called.","pos":[4162,4272],"source":" If there was an error, the process errors out at this point, and table-level **validateWrite()** isn't called."},{"content":"To skip <bpt id=\"p1\">**</bpt>validateField<ept id=\"p1\">**</ept> for a back-end table, a consumer can call <bpt id=\"p2\">**</bpt>DataEntity.skipDataSourceValidateField(Int <ph id=\"ph1\">\\_</ph>DataEntityFieldId, Boolean <ph id=\"ph2\">\\_</ph>skip)<ept id=\"p2\">**</ept>.","pos":[4273,4425],"source":" To skip **validateField** for a back-end table, a consumer can call **DataEntity.skipDataSourceValidateField(Int \\_DataEntityFieldId, Boolean \\_skip)**."},{"content":"Note that the field ID for this method is the field ID of the data-entity mapped field, not the back-end table field.","pos":[4426,4543]},{"content":"By using the following API, you can skip validation for a particular field, regardless of the consumer.","pos":[4544,4647]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Over9<ept id=\"p1\">](./media/over9.png)](./media/over9.png)</ept> <bpt id=\"p2\">**</bpt>Table.ValidateWrite<ept id=\"p2\">**</ept> Record-level <bpt id=\"p3\">**</bpt>ValidateWrite<ept id=\"p3\">**</ept> validations that are defined in back-end tables are fired automatically when you perform data-entity inserts and updates.","pos":[4648,4873],"source":"[![Over9](./media/over9.png)](./media/over9.png) **Table.ValidateWrite** Record-level **ValidateWrite** validations that are defined in back-end tables are fired automatically when you perform data-entity inserts and updates."},{"content":"This is true for all paths (X++, OData, and so on).","pos":[4874,4925]},{"content":"These validations occur just before the actual insert or update is applied to the data source.","pos":[4926,5020]},{"content":"If the validation fails, an error is thrown, and the process stops for other data sources.","pos":[5021,5111]},{"content":"<ph id=\"ph1\">![</ph>redo2<ph id=\"ph2\">](./media/redo2-1024x636.png)</ph> To skip <bpt id=\"p1\">**</bpt>validateWrite<ept id=\"p1\">**</ept> for all back-end tables for a data entity, a consumer can call <bpt id=\"p2\">**</bpt>DataEntity.skipDataSourceValidateWrite(Boolean <ph id=\"ph3\">\\_</ph>skip)<ept id=\"p2\">**</ept>.","pos":[5112,5297],"source":"![redo2](./media/redo2-1024x636.png) To skip **validateWrite** for all back-end tables for a data entity, a consumer can call **DataEntity.skipDataSourceValidateWrite(Boolean \\_skip)**."},{"content":"This method turns <bpt id=\"p1\">**</bpt>validateWrite<ept id=\"p1\">**</ept> on or off for all data sources.","pos":[5298,5365],"source":" This method turns **validateWrite** on or off for all data sources."},{"content":"By using the following API, you can skip validation for a particular field, regardless of the consumer.","pos":[5366,5469]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Over10<ept id=\"p1\">](./media/over10.png)](./media/over10.png)</ept> <bpt id=\"p2\">**</bpt>Table.ValidateDelete<ept id=\"p2\">**</ept> Record-level <bpt id=\"p3\">**</bpt>ValidateDelete<ept id=\"p3\">**</ept> validations that are defined in back-end tables are fired automatically when you perform data entity deletes.","pos":[5470,5688],"source":"[![Over10](./media/over10.png)](./media/over10.png) **Table.ValidateDelete** Record-level **ValidateDelete** validations that are defined in back-end tables are fired automatically when you perform data entity deletes."},{"content":"This is true for all paths (X++, OData, and so on).","pos":[5689,5740]},{"content":"These validations occur just before the delete is applied to the data source.","pos":[5741,5818]},{"content":"If the validation fails, an error is thrown, and the process stops for other data sources.","pos":[5819,5909]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Over11<ept id=\"p1\">](./media/over11.png)](./media/over11.png)</ept> To skip <bpt id=\"p2\">**</bpt>validateDelete<ept id=\"p2\">**</ept> for all back-end tables for a data entity, a consumer can call <bpt id=\"p3\">**</bpt>DataEntity.skipDataSourceValidateDelete(Boolean <ph id=\"ph2\">\\_</ph>skip)<ept id=\"p3\">**</ept>.","pos":[5910,6112],"source":"[![Over11](./media/over11.png)](./media/over11.png) To skip **validateDelete** for all back-end tables for a data entity, a consumer can call **DataEntity.skipDataSourceValidateDelete(Boolean \\_skip)**."},{"content":"This method turns <bpt id=\"p1\">**</bpt>validateDelete<ept id=\"p1\">**</ept> on or off for all data sources.","pos":[6113,6181],"source":" This method turns **validateDelete** on or off for all data sources."},{"content":"By using the following API, you can skip validation for a particular data source, regardless of the consumer.","pos":[6182,6291]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Over12<ept id=\"p1\">](./media/over12.png)](./media/over12.png)</ept>","pos":[6292,6343],"source":"[![Over12](./media/over12.png)](./media/over12.png)"},{"pos":[6348,6356],"content":"Defaults","linkify":"Defaults","nodes":[{"content":"Defaults","pos":[0,8]}]},{"pos":[6361,6376],"content":"Initializations","linkify":"Initializations","nodes":[{"content":"Initializations","pos":[0,15]}]},{"content":"<bpt id=\"p1\">**</bpt>DataEntity.initValue:<ept id=\"p1\">**</ept> A data entity is initialized with default values and by using any custom logic that is present in entity-level <bpt id=\"p2\">**</bpt>initValue<ept id=\"p2\">**</ept>.","pos":[6378,6529],"source":"**DataEntity.initValue:** A data entity is initialized with default values and by using any custom logic that is present in entity-level **initValue**."},{"content":"This method isn't called automatically when an insert or update is performed on a data entity from X++.","pos":[6530,6633]},{"content":"It must be called explicitly if it's required.","pos":[6634,6680]},{"content":"The method is called automatically by the form engine when a new record is created.","pos":[6681,6764]},{"content":"<bpt id=\"p1\">**</bpt>DataEntity.initValue<ept id=\"p1\">**</ept> doesn't call the <bpt id=\"p2\">**</bpt>initValue<ept id=\"p2\">**</ept> method for back-end tables that are used in the data entity.","pos":[6765,6881],"source":"**DataEntity.initValue** doesn't call the **initValue** method for back-end tables that are used in the data entity."},{"content":"<bpt id=\"p1\">**</bpt>Table.initValue:<ept id=\"p1\">**</ept> Table-level <bpt id=\"p2\">**</bpt>initValue<ept id=\"p2\">**</ept>, as defined for back-end tables, is fired when you perform a data entity insert.","pos":[6882,7009],"source":"**Table.initValue:** Table-level **initValue**, as defined for back-end tables, is fired when you perform a data entity insert."},{"content":"This is true for all paths (X++, OData, and so on).","pos":[7010,7061]},{"content":"<bpt id=\"p1\">**</bpt>Table.initValue<ept id=\"p1\">**</ept> is run just before the entity is mapped to data source fields.","pos":[7062,7144],"source":"**Table.initValue** is run just before the entity is mapped to data source fields."},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Over13<ept id=\"p1\">](./media/over13.png)](./media/over13.png)</ept> To skip entity-level <bpt id=\"p2\">**</bpt>initValue<ept id=\"p2\">**</ept> for all back-end tables for a data entity, a consumer can call <bpt id=\"p3\">**</bpt>DataEntity.skipDataSourceInitValue(Boolean <ph id=\"ph2\">\\_</ph>skip)<ept id=\"p3\">**</ept>.","pos":[7145,7350],"source":"[![Over13](./media/over13.png)](./media/over13.png) To skip entity-level **initValue** for all back-end tables for a data entity, a consumer can call **DataEntity.skipDataSourceInitValue(Boolean \\_skip)**."},{"content":"This method turns <bpt id=\"p1\">**</bpt>initValue<ept id=\"p1\">**</ept> on or off for all data sources.","pos":[7351,7414],"source":" This method turns **initValue** on or off for all data sources."},{"content":"By using the following API, you can skip <bpt id=\"p1\">**</bpt>initValue<ept id=\"p1\">**</ept> for a particular field, regardless of the consumer.","pos":[7415,7521],"source":" By using the following API, you can skip **initValue** for a particular field, regardless of the consumer."},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Capturea<ept id=\"p1\">](./media/capturea.png)](./media/capturea.png)</ept>","pos":[7522,7579],"source":"[![Capturea](./media/capturea.png)](./media/capturea.png)"},{"pos":[7585,7595],"content":"DefaultRow","linkify":"DefaultRow","nodes":[{"content":"DefaultRow","pos":[0,10]}]},{"content":"<bpt id=\"p1\">**</bpt>DataEntity.DefaultRow: DataEntity.DefaultRow<ept id=\"p1\">**</ept> is used in conjunction with <bpt id=\"p2\">**</bpt>defaultField<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>getDefaultDependencies<ept id=\"p3\">**</ept> to provide defaults.","pos":[7597,7742],"source":"**DataEntity.DefaultRow: DataEntity.DefaultRow** is used in conjunction with **defaultField** and **getDefaultDependencies** to provide defaults."},{"content":"It isn't called automatically by X++ or the form engine.","pos":[7743,7799]},{"content":"<bpt id=\"p1\">**</bpt>Table.DefaultRow: Table.DefaultRow<ept id=\"p1\">**</ept> is called automatically for each data source after mapping is completed, and before the insert and validation on the data source.","pos":[7800,7968],"source":"**Table.DefaultRow: Table.DefaultRow** is called automatically for each data source after mapping is completed, and before the insert and validation on the data source."},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Captureb<ept id=\"p1\">](./media/captureb.png)](./media/captureb.png)</ept>","pos":[7969,8026],"source":"[![Captureb](./media/captureb.png)](./media/captureb.png)"},{"pos":[8031,8046],"content":"Unmapped fields","linkify":"Unmapped fields","nodes":[{"content":"Unmapped fields","pos":[0,15]}]},{"content":"A data entity can have <bpt id=\"p1\">*</bpt>unmapped<ept id=\"p1\">*</ept> fields in addition those fields that are directly mapped to fields of the data sources.","pos":[8047,8168],"source":"A data entity can have *unmapped* fields in addition those fields that are directly mapped to fields of the data sources."},{"content":"There are two mechanisms for generating values for unmapped fields:","pos":[8169,8236]},{"content":"Custom X++ code","pos":[8242,8257]},{"content":"SQL that is run by Microsoft SQL Server","pos":[8262,8301]},{"content":"The two types of unmapped fields are <bpt id=\"p1\">*</bpt>virtual<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>computed<ept id=\"p2\">*</ept>.","pos":[8303,8365],"source":"The two types of unmapped fields are *virtual* and *computed*."},{"content":"Unmapped fields always support read actions, but the feature specification might not require any development effort to support write actions.","pos":[8366,8507]},{"content":"<bpt id=\"p1\">**</bpt>Virtual field<ept id=\"p1\">**</ept>","pos":[8508,8525],"source":"**Virtual field**"},{"content":"A non-persisted field.","pos":[8531,8553]},{"content":"Controlled by custom X++ code.","pos":[8558,8588]},{"content":"Read and writes occur through custom X++ code.","pos":[8593,8639]},{"content":"Typically used for intake values that are calculated by using X++ code and can't be replaced by computed columns.","pos":[8644,8757]},{"pos":[8759,8777],"content":"<bpt id=\"p1\">**</bpt>Computed field<ept id=\"p1\">**</ept>","source":"**Computed field**"},{"content":"The value is generated by an SQL view computed column.","pos":[8783,8837]},{"content":"During reads, data is computed by SQL and fetched directly from the view.","pos":[8842,8915]},{"content":"For writes, custom X++ code must parse the input value and then write the parsed values to the regular fields of the data entity.","pos":[8920,9049]},{"content":"The values are stored in the regular fields of the data sources of the entity.","pos":[9050,9128]},{"content":"Used mostly for reads.","pos":[9133,9155]},{"content":"It's a good idea to use computed columns instead of virtual fields whenever you can, because computed columns are computed at the SQL Server level, whereas virtual fields are computed row by row in X++.","pos":[9160,9362]},{"pos":[9368,9397],"content":"Properties of unmapped fields","linkify":"Properties of unmapped fields","nodes":[{"content":"Properties of unmapped fields","pos":[0,29]}]},{"content":"Category","pos":[9562,9570]},{"content":"Name","pos":[9580,9584]},{"content":"Type","pos":[9594,9598]},{"content":"Default value","pos":[9608,9621]},{"content":"Behavior","pos":[9631,9639]},{"content":"Data","pos":[9689,9693]},{"content":"IsComputedField","pos":[9703,9718]},{"content":"NoYes","pos":[9728,9733]},{"content":"Yes","pos":[9743,9746]},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>Yes:<ept id=\"p1\">&lt;/strong&gt;</ept> The field is synchronized as a SQL view computed column.","pos":[9765,9843],"source":"<strong>Yes:</strong> The field is synchronized as a SQL view computed column."},{"content":"An X++ method is required to compute the SQL definition string for the column.","pos":[9844,9922]},{"content":"The virtual column definition is static and is used when the entity is synchronized.","pos":[9923,10007]},{"content":"After that, the X++ method isn't called at run time.","pos":[10008,10060]},{"content":"<bpt id=\"p1\">&lt;strong&gt;</bpt>No:<ept id=\"p1\">&lt;/strong&gt;</ept> The field is a true virtual field, where inbound and outbound values are fully controlled through custom code.","pos":[10070,10201],"source":"<strong>No:</strong> The field is a true virtual field, where inbound and outbound values are fully controlled through custom code."},{"content":"Data","pos":[10246,10250]},{"content":"ComputedFieldMethod","pos":[10260,10279]},{"content":"String","pos":[10289,10295]},{"content":"A static <bpt id=\"p1\">&lt;strong&gt;</bpt>DataEntity<ept id=\"p1\">&lt;/strong&gt;</ept> method in X++ is used to build the SQL expression that generates the field definition.","pos":[10315,10438],"source":"A static <strong>DataEntity</strong> method in X++ is used to build the SQL expression that generates the field definition."},{"content":"This property is disabled and irrelevant if the <bpt id=\"p1\">&lt;strong&gt;</bpt>IsComputedField<ept id=\"p1\">&lt;/strong&gt;</ept> property is set to <bpt id=\"p2\">&lt;strong&gt;</bpt>No<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[10439,10559],"source":" This property is disabled and irrelevant if the <strong>IsComputedField</strong> property is set to <strong>No</strong>."},{"content":"The method is required if the <bpt id=\"p1\">&lt;strong&gt;</bpt>IsComputedField<ept id=\"p1\">&lt;/strong&gt;</ept> property is set to <bpt id=\"p2\">&lt;strong&gt;</bpt>Yes<ept id=\"p2\">&lt;/strong&gt;</ept>.","pos":[10560,10663],"source":" The method is required if the <strong>IsComputedField</strong> property is set to <strong>Yes</strong>."},{"content":"Data","pos":[10696,10700]},{"content":"ExtendedDataType","pos":[10710,10726]},{"content":"String","pos":[10736,10742]},{"pos":[10797,10822],"content":"Unmapped field comparison","linkify":"Unmapped field comparison","nodes":[{"content":"Unmapped field comparison","pos":[0,25]}]},{"content":"Virtual field","pos":[10957,10970]},{"content":"Computed field","pos":[10980,10994]},{"content":"Metadata properties","pos":[11044,11063]},{"content":"Is computed = No","pos":[11073,11089]},{"content":"Is Computed = Yes","pos":[11108,11125]},{"content":"Computed Field Method = static method","pos":[11135,11172]},{"content":"Read","pos":[11217,11221]},{"content":"X++ (override <bpt id=\"p1\">&lt;strong&gt;</bpt>postLoad<ept id=\"p1\">&lt;/strong&gt;</ept>)","pos":[11240,11280],"source":"X++ (override <strong>postLoad</strong>)"},{"content":"Row by row","pos":[11290,11300]},{"content":"SQL computed column","pos":[11330,11349]},{"content":"Set-based read possible","pos":[11359,11382]},{"content":"Write","pos":[11426,11431]},{"content":"X++ (override <bpt id=\"p1\">&lt;strong&gt;</bpt>mapEntityToDataSource<ept id=\"p1\">&lt;/strong&gt;</ept>)","pos":[11441,11494],"source":"X++ (override <strong>mapEntityToDataSource</strong>)"},{"content":"X++ (override <bpt id=\"p1\">&lt;strong&gt;</bpt>mapEntityToDataSource<ept id=\"p1\">&lt;/strong&gt;</ept>)","pos":[11504,11557],"source":"X++ (override <strong>mapEntityToDataSource</strong>)"},{"content":"Advantages","pos":[11591,11601]},{"content":"Unbound to the schema, keeps the public contract the same, but the implementation can change","pos":[11620,11712]},{"content":"Call X++ methods","pos":[11722,11738]},{"content":"Faster reads, large export can occur directly from the view","pos":[11759,11818]},{"pos":[11853,11861],"content":"Examples","linkify":"Examples","nodes":[{"content":"Examples","pos":[0,8]}]},{"pos":[11863,11994],"content":"The following table provides a computed example if a <bpt id=\"p1\">**</bpt>UnitOfMeasure<ept id=\"p1\">**</ept> relationship exists, and displays that in an unmapped field.","source":"The following table provides a computed example if a **UnitOfMeasure** relationship exists, and displays that in an unmapped field."},{"content":"Virtual field","pos":[11998,12011]},{"content":"Computed field","pos":[12260,12274]},{"pos":[12770,13029],"content":"On postLoad()<bpt id=\"p1\">*</bpt>//Check to see if record exists in UnitOfMeasureInternalCode.UnitOfMeasure//Set hasFixedInternalCode value based on the field<ept id=\"p1\">*</ept>if(this.UnitOfMeasure)this.HasFixedInternalCodeVirtual = NoYes::Yes; else this.HasFixedInternalCodeVirtual = NoYes::No;","source":"On postLoad()*//Check to see if record exists in UnitOfMeasureInternalCode.UnitOfMeasure//Set hasFixedInternalCode value based on the field*if(this.UnitOfMeasure)this.HasFixedInternalCodeVirtual = NoYes::Yes; else this.HasFixedInternalCodeVirtual = NoYes::No;"},{"pos":[13032,13151],"content":"On computedFieldMethod()<bpt id=\"p1\">*</bpt>//Desired SQL computed column statement(CASE WHEN T2.RECID IS NULL THEN 0 ELSE 1 END) AS INT)<ept id=\"p1\">*</ept>","source":"On computedFieldMethod()*//Desired SQL computed column statement(CASE WHEN T2.RECID IS NULL THEN 0 ELSE 1 END) AS INT)*"}],"content":"---\n# required metadata\n\ntitle: Validations, defaults, and unmapped fields\ndescription: Validations are defined on the tables that back up the entities. Validations are defined at both the field level and the record level.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 04/04/2017\nms.topic: article\nms.prod: \nms.service: Dynamics365Operations\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: RobinARH\nms.search.scope: AX 7.0.0, Operations\n# ms.tgt_pltfrm: \nms.custom: 4624\nms.assetid: 7ea995fa-8ea0-403d-8a68-f19993c40a6d\nms.search.region: Global\n# ms.search.industry: \nms.author: kuntalme\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# Validations, defaults, and unmapped fields\n\nValidations are defined on the tables that back up the entities. Validations are defined at both the field level and the record level.\n\nValidations\n-----------\n\n### Entities vs. data sources\n\nEntities are backed by tables (data sources), and validations are defined for these tables at both the field level (**Table.validateField()**) and the record level (**Table.validateWrite()**). The validations are respected by data entities that are built by using those tables. Although these validations are intrinsic to the tables that back a data entity, validations can also be defined at the data entity level. Like table-based validations, entity-based validations can be written at the field level (**DataEntity.validateField()**) or the record level (**DataEntity.validateWrite()**).\n\n#### Entity-based validation behavior\n\n<table>\n<colgroup>\n<col width=\"33%\" />\n<col width=\"33%\" />\n<col width=\"33%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Validation</th>\n<th>Target</th>\n<th>Caller</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>DataEntity.ValidateField</td>\n<td><ul>\n<li>Data types</li>\n<li>Mandatory relationships (both tables and extended data types [EDTs])</li>\n<li>Any custom validation</li>\n<li>Doesn't call <strong>validateField</strong> for underlying mapped table fields</li>\n</ul></td>\n<td><ul>\n<li>Is called automatically from OData</li>\n<li>Is called by the form engine when a field is modified</li>\n<li>Isn't called automatically if an insert/update is fired from X++ code</li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td>DataEntity.ValidateWrite</td>\n<td><ul>\n<li>Mandatory columns</li>\n<li>Relationships (both tables and EDTs)</li>\n<li>Any custom validation</li>\n<li>Doesn't call table-level <strong>validateWrite</strong> for underlying tables</li>\n</ul></td>\n<td><ul>\n<li>Is called automatically from OData</li>\n<li>Is called by the form engine when a record is saved.</li>\n<li>Isn't called automatically if an insert/update is fired from X++ code</li>\n</ul></td>\n</tr>\n<tr class=\"odd\">\n<td>DataEntity.ValidateDelete</td>\n<td><ul>\n<li>DeleteActions</li>\n<li>Any custom validation</li>\n<li>Doesn't call table-level <strong>validateDelete</strong> for underlying tables</li>\n</ul></td>\n<td><ul>\n<li>Is called automatically from OData.</li>\n<li>Is called by the form engine when a record is deleted</li>\n<li>Isn't called automatically if a delete is fired from X++ code</li>\n</ul></td>\n</tr>\n</tbody>\n</table>\n\n#### Table-based validation behavior\n\nBack-end table, or data source, validations are fired automatically as a part of the CUD operations. **Table.ValidateField, AllowEdit, AllowEditOnCreate** Field-level validations are fired automatically when you perform inserts or updates on the data entity. This is true for all paths (X++, OData, and so on). These validations occur during the mapping process, when fields are mapped from an entity to individual data sources. [![redo1](./media/redo1-1024x582.png)](./media/redo1.png)After the field values from the data entity are copied to mapped data source fields, field validations are run on the set fields. Validations include table-level **validateField**, which validates **AllowEdit** and **AllowEditOnCreate**. If a validation fails because of an error, validation for the remaining fields continues. Finally, validation checks whether any error occurred during the validation process for any of the data sources. If there was an error, the process errors out at this point, and table-level **validateWrite()** isn't called. To skip **validateField** for a back-end table, a consumer can call **DataEntity.skipDataSourceValidateField(Int \\_DataEntityFieldId, Boolean \\_skip)**. Note that the field ID for this method is the field ID of the data-entity mapped field, not the back-end table field. By using the following API, you can skip validation for a particular field, regardless of the consumer. [![Over9](./media/over9.png)](./media/over9.png) **Table.ValidateWrite** Record-level **ValidateWrite** validations that are defined in back-end tables are fired automatically when you perform data-entity inserts and updates. This is true for all paths (X++, OData, and so on). These validations occur just before the actual insert or update is applied to the data source. If the validation fails, an error is thrown, and the process stops for other data sources. ![redo2](./media/redo2-1024x636.png) To skip **validateWrite** for all back-end tables for a data entity, a consumer can call **DataEntity.skipDataSourceValidateWrite(Boolean \\_skip)**. This method turns **validateWrite** on or off for all data sources. By using the following API, you can skip validation for a particular field, regardless of the consumer. [![Over10](./media/over10.png)](./media/over10.png) **Table.ValidateDelete** Record-level **ValidateDelete** validations that are defined in back-end tables are fired automatically when you perform data entity deletes. This is true for all paths (X++, OData, and so on). These validations occur just before the delete is applied to the data source. If the validation fails, an error is thrown, and the process stops for other data sources. [![Over11](./media/over11.png)](./media/over11.png) To skip **validateDelete** for all back-end tables for a data entity, a consumer can call **DataEntity.skipDataSourceValidateDelete(Boolean \\_skip)**. This method turns **validateDelete** on or off for all data sources. By using the following API, you can skip validation for a particular data source, regardless of the consumer. [![Over12](./media/over12.png)](./media/over12.png)\n\n## Defaults\n### Initializations\n\n**DataEntity.initValue:** A data entity is initialized with default values and by using any custom logic that is present in entity-level **initValue**. This method isn't called automatically when an insert or update is performed on a data entity from X++. It must be called explicitly if it's required. The method is called automatically by the form engine when a new record is created. **DataEntity.initValue** doesn't call the **initValue** method for back-end tables that are used in the data entity. **Table.initValue:** Table-level **initValue**, as defined for back-end tables, is fired when you perform a data entity insert. This is true for all paths (X++, OData, and so on). **Table.initValue** is run just before the entity is mapped to data source fields. [![Over13](./media/over13.png)](./media/over13.png) To skip entity-level **initValue** for all back-end tables for a data entity, a consumer can call **DataEntity.skipDataSourceInitValue(Boolean \\_skip)**. This method turns **initValue** on or off for all data sources. By using the following API, you can skip **initValue** for a particular field, regardless of the consumer. [![Capturea](./media/capturea.png)](./media/capturea.png)\n\n### DefaultRow\n\n**DataEntity.DefaultRow: DataEntity.DefaultRow** is used in conjunction with **defaultField** and **getDefaultDependencies** to provide defaults. It isn't called automatically by X++ or the form engine. **Table.DefaultRow: Table.DefaultRow** is called automatically for each data source after mapping is completed, and before the insert and validation on the data source. [![Captureb](./media/captureb.png)](./media/captureb.png)\n\n## Unmapped fields\nA data entity can have *unmapped* fields in addition those fields that are directly mapped to fields of the data sources. There are two mechanisms for generating values for unmapped fields:\n\n-   Custom X++ code\n-   SQL that is run by Microsoft SQL Server\n\nThe two types of unmapped fields are *virtual* and *computed*. Unmapped fields always support read actions, but the feature specification might not require any development effort to support write actions. **Virtual field**\n\n-   A non-persisted field.\n-   Controlled by custom X++ code.\n-   Read and writes occur through custom X++ code.\n-   Typically used for intake values that are calculated by using X++ code and can't be replaced by computed columns.\n\n**Computed field**\n\n-   The value is generated by an SQL view computed column.\n-   During reads, data is computed by SQL and fetched directly from the view.\n-   For writes, custom X++ code must parse the input value and then write the parsed values to the regular fields of the data entity. The values are stored in the regular fields of the data sources of the entity.\n-   Used mostly for reads.\n-   It's a good idea to use computed columns instead of virtual fields whenever you can, because computed columns are computed at the SQL Server level, whereas virtual fields are computed row by row in X++.\n\n### Properties of unmapped fields\n\n<table>\n<colgroup>\n<col width=\"20%\" />\n<col width=\"20%\" />\n<col width=\"20%\" />\n<col width=\"20%\" />\n<col width=\"20%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Category</th>\n<th>Name</th>\n<th>Type</th>\n<th>Default value</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Data</td>\n<td>IsComputedField</td>\n<td>NoYes</td>\n<td>Yes</td>\n<td><ul>\n<li><strong>Yes:</strong> The field is synchronized as a SQL view computed column. An X++ method is required to compute the SQL definition string for the column. The virtual column definition is static and is used when the entity is synchronized. After that, the X++ method isn't called at run time.</li>\n<li><strong>No:</strong> The field is a true virtual field, where inbound and outbound values are fully controlled through custom code.</li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td>Data</td>\n<td>ComputedFieldMethod</td>\n<td>String</td>\n<td></td>\n<td>A static <strong>DataEntity</strong> method in X++ is used to build the SQL expression that generates the field definition. This property is disabled and irrelevant if the <strong>IsComputedField</strong> property is set to <strong>No</strong>. The method is required if the <strong>IsComputedField</strong> property is set to <strong>Yes</strong>.</td>\n</tr>\n<tr class=\"odd\">\n<td>Data</td>\n<td>ExtendedDataType</td>\n<td>String</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n\n### Unmapped field comparison\n\n<table>\n<colgroup>\n<col width=\"33%\" />\n<col width=\"33%\" />\n<col width=\"33%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>Virtual field</th>\n<th>Computed field</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Metadata properties</td>\n<td>Is computed = No</td>\n<td><ul>\n<li>Is Computed = Yes</li>\n<li>Computed Field Method = static method</li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td>Read</td>\n<td><ul>\n<li>X++ (override <strong>postLoad</strong>)</li>\n<li>Row by row</li>\n</ul></td>\n<td><ul>\n<li>SQL computed column</li>\n<li>Set-based read possible</li>\n</ul></td>\n</tr>\n<tr class=\"odd\">\n<td>Write</td>\n<td>X++ (override <strong>mapEntityToDataSource</strong>)</td>\n<td>X++ (override <strong>mapEntityToDataSource</strong>)</td>\n</tr>\n<tr class=\"even\">\n<td>Advantages</td>\n<td><ul>\n<li>Unbound to the schema, keeps the public contract the same, but the implementation can change</li>\n<li>Call X++ methods</li>\n</ul></td>\n<td>Faster reads, large export can occur directly from the view</td>\n</tr>\n</tbody>\n</table>\n\n### Examples\n\nThe following table provides a computed example if a **UnitOfMeasure** relationship exists, and displays that in an unmapped field.\n\n| Virtual field                                                                                                                                                                                                                                                       | Computed field                                                                                                          |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------|\n| On postLoad()*//Check to see if record exists in UnitOfMeasureInternalCode.UnitOfMeasure//Set hasFixedInternalCode value based on the field*if(this.UnitOfMeasure)this.HasFixedInternalCodeVirtual = NoYes::Yes; else this.HasFixedInternalCodeVirtual = NoYes::No; | On computedFieldMethod()*//Desired SQL computed column statement(CASE WHEN T2.RECID IS NULL THEN 0 ELSE 1 END) AS INT)* |\n\n\n\n"}