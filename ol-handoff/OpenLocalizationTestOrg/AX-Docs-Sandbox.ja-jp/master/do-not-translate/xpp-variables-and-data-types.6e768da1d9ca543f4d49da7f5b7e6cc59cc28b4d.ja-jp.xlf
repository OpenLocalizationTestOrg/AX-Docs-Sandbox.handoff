<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-188fee3" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8a23d687a6f50295a106b1fec878c3f6567ee199</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dev-itpro\dev-reference\xpp-variables-and-data-types.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">do-not-translate</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">77627ca0f26998e1f22046592d15f9bfd2fd2c08</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d0c9aa3dbb61c2c44a1a099753fb8ee59913fdf4</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>X++ Variables and Data Types | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>This topic describes variables and data types in X++.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>X++ Variables and Data Types</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Variables</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>variable<ept id="p1">**</ept> is an identifier that points to a memory location where information of a specific data type is stored.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The size, precision, default value, implicit and explicit <bpt id="p1">[</bpt>conversion<ept id="p1">](https://ax.help.dynamics.com/en/wiki/x-conversion-run-time-functions/)</ept> functions, and range depends on the variable's data type.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The scope of a variable defines the area in in the code which an item can be accessed.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This area includes instance variables and local variables.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Instance variables<ept id="p1">**</ept> are declared in class declarations and can be accessed from any methods in the class or from methods that extend the class.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Local variables<ept id="p1">**</ept> can be accessed only in the block in which they were defined.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>All variables created by users have local scope.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>When a variable is <bpt id="p1">**</bpt>declared<ept id="p1">**</ept>, memory is allocated and the variable is initialized to the default value.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You can assign a value to a field inline, i.e. along with the declaration of the field itself.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This applies to both static and instance fields.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Variables can be declared anywhere in a code block in a method, not just at the beginning of a method.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Constant variables<ept id="p1">**</ept> (using the keywords <ph id="ph1">`const`</ph> or <ph id="ph2">`readonly`</ph>) are variables where the value cannot be changed when the variable is declared.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Compared to macros, constants have the following benefits:</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can add a documentation comment to the const, not to the value of the macro.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Ultimately, the language service will pick this up and provide good information to the user.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The const is known by IntelliSense.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The const is cross referenced, so you can find all references of a particular constant.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This is not the case for a macro.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The const is subject to access modifiers, either private, protected, or public.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The accessibility of macros is not well understood or even rigorously defined.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Const variables have scope, while macros do not.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You can see the value of a const or a readonly variable in the debugger.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Read-only fields<ept id="p1">**</ept> can only be assigned a value once, and that value never changes; the field can be assigned its value either inline, at the place where the field is declared, or in the constructor.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Currently, that’s the only difference between const and read-only.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>When declaring variables of managed types that aren't authored in X++, you have two options.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You can fully qualify the type names in the declaration by including the full namespace, or you can add a <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statement to your file and then leave the namespace off of the type name.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Variable Code Examples</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Var</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You can now declare a variable without explicitly providing the type of the variable, if the compiler can determine the type from the initialization expression.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Note that the variable is still strongly-typed into one, unambiguous type.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>It’s only possible to use <bpt id="p1">**</bpt>var<ept id="p1">**</ept> on declarations where an initialization expressions are provided (from which the compiler will infer the type).</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>There are situations where this can make code easier to read, but this feature shouldn’t be misused.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You should use a var when you want to declare local variables when the type of the variable is obvious from the right side of the assignment, or when the precise type is not important, for the declarations of for loop counters, and for disposable objects inside using statements.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Don't use var when the type isn't apparent from the initialization expression.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Var Code Examples</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Declare anywhere</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Declarations can now be provided anywhere statements can be provided.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>A declaration is syntactically a statement, a declaration statement.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can, therefore, provide declarations immediately prior to the usage, and you don’t have to declare the variables all in one place.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This gives you fine-grained control over the scope of your variables.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can provide smaller scopes for variables, outside of which the variables can’t be referenced.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The lifetime of the variable is the scope in which it’s declared.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Scopes can be started at the block level (inside compound statements), in <bpt id="p1">**</bpt>for<ept id="p1">**</ept> statements, and in <bpt id="p2">**</bpt>using<ept id="p2">**</ept> statements.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>There are several advantages to making scopes small.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Readability is enhanced.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can reduce the risk of reusing a variable inappropriately during long-term maintenance of the code.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Refactoring becomes much easier.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can copy code in without having to worry about variables being reused in contexts they shouldn’t.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In this example, we declare the loop counter inside the <bpt id="p1">**</bpt>for<ept id="p1">**</ept> statement in which it's used.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The scope of the variable is the <bpt id="p1">**</bpt>for<ept id="p1">**</ept> statement itself, including the condition expression and the loop update parts.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The value can’t be used outside this scope.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If you attempt to do that, you will get the following.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The compiler will issue an error message in the info call, "'i' is not declared."</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You can also scope variables to a <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When you use an object that implements <bpt id="p1">**</bpt>IDisposable, <ept id="p1">**</ept>you should declare and instantiate it in a <bpt id="p2">**</bpt>using<ept id="p2">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statement calls the <bpt id="p2">**</bpt>Dispose<ept id="p2">**</ept> method on the object in the correct way, even if an exception occurs while you are calling methods on the object.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can achieve the same result by putting the object inside a try block, and then explicitly calling <bpt id="p1">**</bpt>Dispose<ept id="p1">**</ept> in a finally block; in fact, this is how the <bpt id="p2">**</bpt>using<ept id="p2">**</ept> statement is translated by the compiler.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The following example shows some of the features described above.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>To avoid confusion, the compiler will issue an error if you attempt to introduce a variable that would hide another variable in an enclosing scope or even in the same scope.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For instance, the following code will cause the compiler to issue the following diagnostic message: "A local variable named 'i' cannot be declared in this scope because it would give a different meaning to 'i', which is already used in a parent or current scope to denote something else."</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This aligns well with the rules that are known from C<ph id="ph1">\#</ph>, but is different from the rule in C++ where shadowing is not diagnosed.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Consts/Readonly variables</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The concept of macros continues to be fully supported in X++.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>However, using constants instead of <ph id="ph1">\#</ph>defines has a number of benefits.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You can add a documentation comment to the const, not to the value of the macro.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Ultimately, the language service will pick this up and provide good information to the user.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The const is known by IntelliSense.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The const is cross-referenced, so you can find all references of a particular constant.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This is not the case for a macro.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The const is subject to access modifiers, either private, protected, or public.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The accessibility of macros is not well understood or even rigorously defined.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Consts have scope, while macros do not.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can see the value of consts and readonly variables in the debugger.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Macros that are defined in class scopes (in class declarations) are effectively available in all methods of all derived classes.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This was originally a bug in the legacy compiler macro implementation, but this loophole is now massively exploited by application programmers.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The new X++ compiler still honors this, but no new code that uses this should be written.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This particular feature also considerably impacts compiler performance.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Constants can be declared at the class level as suggested below.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The constants can then be referenced by using the double-colon syntax.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If you're in the scope of the class where the const is defined, you can omit the type name prefix (MyClass in the example above).</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>You can easily implement the concept of a macro library this way.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The list of macro symbols becomes a class with public const definitions.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>You can also define consts solely as variables.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The compiler will maintain the invariant that the value can't be modified.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Read-only fields can only be assigned a value once, and that value never changes; the field can be assigned its value either inline, at the place where the field is declared, or in the constructor.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Currently, that's the only difference between const and read-only.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Primitive Data Types</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The primitive data types in X++ are anytype, booleans, dates, enums, GUIDs, integers, reals, strings, timeOfDay, and utcdatetime.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Anytype</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>anytype<ept id="p1">**</ept> data type is a placeholder for any data type.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Variables of this type should only be used as arguments and return values.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>If anytype is used as a variable, you must assign a value to it before it can be used or you will get a run-time error.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>After you have assigned a value to it, you cannot convert it to another data type.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You can use anytype variables in expressions although anytype is usually used as arguments and return types.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The size, precision, scope, default value, and range of anytype depends on the conversion type that you assign to it.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can use them in the same way that you can use the data type that you convert them to.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>For example, if you assign an integer, you can then apply relational and arithmetic operators to the variable.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Anytype is automatically converted to dates, enums, integers, reals, strings, extended data types (records), classes, and containers by assigning a value to the type.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Explicit <bpt id="p1">[</bpt>conversion<ept id="p1">](https://ax.help.dynamics.com/en/wiki/x-conversion-run-time-functions/)</ept> functions can be done by using <ph id="ph1">`any2date`</ph>, <ph id="ph2">`any2enum`</ph>, <ph id="ph3">`any2int`</ph>, <ph id="ph4">`any2real`</ph>, and <ph id="ph5">`any2str`</ph>.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>You cannot change the variable to another data type after you have converted to anytype.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Anytype Code Examples</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Boolean</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>boolean<ept id="p1">**</ept> data type contains a value that evaluates to either <bpt id="p2">**</bpt>true<ept id="p2">**</ept> or <bpt id="p3">**</bpt>false<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>You can use the X++ reserved literals true and false where ever a boolean expression is expected.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>A boolean's size is 1 byte.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The default value for a boolean is <bpt id="p1">**</bpt>false<ept id="p1">**</ept> and its internal representation is as a short number.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A boolean is automatically converted to <bpt id="p1">**</bpt>int<ept id="p1">**</ept>, <bpt id="p2">**</bpt>date<ept id="p2">**</ept>, or <bpt id="p3">**</bpt>real<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>It has no explicit conversion functions.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>In X++, the internal representation of a boolean is an integer.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>You can assign any integer value to a variable declared of type boolean.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The integer value 0 (zero) evaluates to false, and all other integer values evaluate to true.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Because the internal representation of a boolean is an integer, boolean values are automatically converted into integers and reals.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Boolean Code Examples</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Date</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>date<ept id="p1">**</ept> data type contains the day, month, and year.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Dates can be written as literals in X++ by using this syntax: <ph id="ph1">`Date literal = day \ month \ year`</ph>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>You must use four digits for the year.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The date data type can hold dates between January 1, 1900, and December 31, 2154.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The size of a date is 32 bits.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The default value is <bpt id="p1">**</bpt>null<ept id="p1">**</ept> and the internal representation is as a <bpt id="p2">**</bpt>date<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>A date has no implicit conversions, but can be explicitly <bpt id="p1">[</bpt>converted<ept id="p1">](https://ax.help.dynamics.com/en/wiki/x-conversion-run-time-functions/)</ept> through the use of <ph id="ph1">`str2date`</ph>, <ph id="ph2">`date2str`</ph>, <ph id="ph3">`date2num`</ph>, and <ph id="ph4">`int2date`</ph>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>You can add and subtract integers from dates but you cannot add or subtract two dates from each other.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>This will result in a compiler error.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Date Code Examples</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Enums</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">**</bpt>enum<ept id="p1">**</ept> (also known as an <bpt id="p2">**</bpt>enumerable<ept id="p2">**</ept>) is a list of literals that X++ uses.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>You must declare an enum in the Application Explorer before you can use it.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Enum values are represented internally as integers.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The first literal has number 0, the next has number 1, the next has number 2, and so on.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>You can use enums as integers in expressions.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The default value for the first entry is <bpt id="p1">**</bpt>0<ept id="p1">**</ept> and the internal representation is a short number.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Enums are automatically converted to a <bpt id="p1">**</bpt>boolean<ept id="p1">**</ept>, <bpt id="p2">**</bpt>int<ept id="p2">**</ept>, or <bpt id="p3">**</bpt>real<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>An enum can also be explicitly <bpt id="p1">[</bpt>converted<ept id="p1">](https://ax.help.dynamics.com/en/wiki/x-conversion-run-time-functions/)</ept> through the use of <ph id="ph1">`enum2str`</ph> and <ph id="ph2">`str2enum`</ph>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>There are hundreds of enumerable types that are built into the standard application.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>For example, the enum <ph id="ph1">`NoYes`</ph> has two associated literals, where No has the value 0, and Yes has the value 1.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>You can create as many enums as you want, and you can declare up to 251 (0 to 250) literals in a single enum type.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>To reference an enum, use the name of the enum, followed by the name of the literal, separated by two colons.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>For example, to use the literal <ph id="ph1">`No`</ph> in the <ph id="ph2">`NoYes`</ph> enum, write <ph id="ph3">`NoYes::No`</ph>.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Creating an Enum</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>In <bpt id="p1">**</bpt>Solution Explorer<ept id="p1">**</ept>, right-click the project, point to <bpt id="p2">**</bpt>Add<ept id="p2">**</ept>, and then click <bpt id="p3">**</bpt>New Item<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Under <bpt id="p1">**</bpt>AX Artifacts<ept id="p1">**</ept>, select <bpt id="p2">**</bpt>Data Types<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Click <bpt id="p1">**</bpt>Base Enum<ept id="p1">**</ept> to select the new item type.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> field, enter the name of your enum, and then click <bpt id="p2">**</bpt>Add<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>This adds a new enum to the project, and opens the enum designer for the new element.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>In the enum designer, right-click on the enum name and then click <bpt id="p1">**</bpt>New Element<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> window, enter the Name of the enum element.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Enum Code Examples</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>GUIDs</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>GUID<ept id="p1">**</ept> (a <bpt id="p2">**</bpt>globally unique identifier<ept id="p2">**</ept>) is an integer that can be used across all computers and networks wherever a unique identifier is required.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Such a number has a very low probability of being duplicated.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>A valid GUID meets all of these specifications:</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>It must have 32 hexadecimal digits.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>It must have four dash characters embedded at the locations 8-4-4-4-12.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Braces (<ph id="ph1">`{}`</ph>) at the beginning and end of a string are optional.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>For example, both <ph id="ph1">`"12345678-BBBb-cCCCC-0000-123456789012"`</ph> and <ph id="ph2">`"{12345678-BBBb-cCCCC-0000-123456789012}"`</ph> are valid GUID strings.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>It must have a total of either 36 or 38 characters, depending on whether or not braces are added.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The hexadecimal digits a-f (or A-F) can be uppercase, lowercase, or mixed.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The size of a GUID is 16 bytes or 128 bits.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The six explicit <bpt id="p1">[</bpt>conversion<ept id="p1">](https://ax.help.dynamics.com/en/wiki/x-conversion-run-time-functions/)</ept> functions for a GUID are <ph id="ph1">`any2guid`</ph>, <ph id="ph2">`guid2str`</ph>, <ph id="ph3">`newGuid`</ph>, <ph id="ph4">`str2guid`</ph>, <ph id="ph5">`Global::guidFromString`</ph>, and <ph id="ph6">`Global::stringFromGuid. `</ph></source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>GUID Code Examples</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The following X++ code examples illustrates how to use the GUID functions.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The output of these examples is shown below.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>GUID Code Output</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The output that is displayed in the Infolog is as follows.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Note that Microsoft Dynamics AX includes the optional braces when it converts a GUID to a string.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Integers</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Integers<ept id="p1">**</ept> are numbers without decimals.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>X++ has two integer types: <bpt id="p1">**</bpt>int <ept id="p1">**</ept>and <bpt id="p2">**</bpt>int64<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Integers are used as control variables in repetitive statements or as indexes in arrays.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>You can also use integer literals anywhere an integer-expression is expected and both relational and arithmetic operators can be applied.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>An integer literal is the integer written directly in the code, for example, 32768.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>An int is 32 bits wide and an int64 is 64 bits wide.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The default value is <bpt id="p1">**</bpt>0<ept id="p1">**</ept> and the internal representation is a long number.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Integers are automatically converted into <bpt id="p1">**</bpt>boolean<ept id="p1">**</ept>, <bpt id="p2">**</bpt>enum<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>real<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>There are four explicit <bpt id="p1">[</bpt>conversion<ept id="p1">](https://ax.help.dynamics.com/en/wiki/x-conversion-run-time-functions/)</ept> functions for integers: <ph id="ph1">`str2int`</ph>, <ph id="ph2">`int2str`</ph>, <ph id="ph3">`str2int64`</ph>, and <ph id="ph4">`int642str`</ph>.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The range of an int is <ph id="ph1">\[</ph>-2,147,483,647 : 2,147,483,647<ph id="ph2">\]</ph>.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The range of an int64 is <ph id="ph1">\[</ph>-9,223,372,036,854,775,808 : 9,223,372,036,854,775,808<ph id="ph2">\]</ph>.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>All integers in either of these ranges can be used as literals in X++.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Integer Code Examples</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Here is an example of declaring integers and using integers in expressions.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>If you try to assign the largest integer plus 1 to an int64, you will get the wrong result.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>This is because it is interpreted as a 32-bit number, and therefore the number is wrapped around and stored as -2,147,483,647 instead.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>To prevent this, add a "u" to the end of the number, for example: <ph id="ph1">`int64 i = 0x8000 0000u`</ph> (0x8000 0000 is 2,147,483,648).</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Reals</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Real<ept id="p1">**</ept> variables can hold decimal values in addition to holding integers.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>You can use decimal literals anywhere where a real is expected.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>A decimal literal is the decimal written directly in the code, for example, 2.123876.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Real literals can also be written using exponential notation such as 1.0e3.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Reals can be used in all expressions and with both relational operators and arithmetic operators.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>A real has a precision of 16 significant digits.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The default for a real is <bpt id="p1">**</bpt>0.0<ept id="p1">**</ept>, and it's internal representation is as a BCD (binary-coded digital) number.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The BCD encoding makes it possible to make exact representations of values that are multiples of 0.1.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>A real variable's range is -(10)¹²⁷ to (10)¹²⁷.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>All reals in this range can be used as literals in X++.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Real variables are automatically converted to <bpt id="p1">**</bpt>boolean<ept id="p1">**</ept>, <bpt id="p2">**</bpt>enum<ept id="p2">**</ept>, or <bpt id="p3">**</bpt>int<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>If the result is an integer or the operator is an integer-operator, reals **** are converted into integers.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>If the result is a Boolean, reals are converted to Booleans, and so on.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>You can also explicitly convert using <ph id="ph1">`str2num`</ph> or <ph id="ph2">`num2str`</ph>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Direct assignments between X++ <ph id="ph1">`real`</ph> and .NET Framework <ph id="ph2">`System.Decimal`</ph> convert the value correctly without the need to call any conversion function.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>The type used to represent real values has changed from interpreted X++.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>This won’t require you to rewrite any code, because the new type can express all of the values that the old one could.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>We provide this material in the interest of full disclosure only.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>All instances of the real type are now implemented as instances of the .NET decimal type (System.Decimal).</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Just as the real type in previous versions, the decimal type in a binary coded decimal type that, unlike floating point type, is resilient to rounding errors.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The range and resolution of the decimal type are different from the original types.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The original X++ real type supported 16 digits and an exponent that defined where the decimal point is placed.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The new X++ real type can represent decimal numbers ranging from positive 79,228,162,514,264,337,593,543,950,335 (2⁹⁶-1) to negative 79,228,162,514,264,337,593,543,950,335 (-(2⁹⁶-1)).</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The new real type doesn’t eliminate the need for rounding.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>For example, the following code produces a result of 0.9999999999999999999999999999 instead of 1.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>A decimal number is a floating-point value that consists of a sign, a numeric value where each digit in the value ranges from 0 to 9, and a scaling factor that indicates the position of a floating decimal point that separates the integral and fractional parts of the numeric value.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The binary representation of a real value consists of a 1-bit sign, a 96-bit integer number, and a scaling factor used to divide the 96-bit integer and specify what portion of it is a decimal fraction.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The scaling factor is implicitly the number 10, raised to an exponent ranging from 0 to 28.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Therefore, the binary representation of a decimal value represents ((-2⁹⁶ to 2⁹⁶)/10(0<ph id="ph1">\\</ph> to<ph id="ph2">\\</ph> 28)), where -(2⁹⁶-1) is equal to the minimum value and 2⁹⁶-1 is equal to the maximum value that can be expressed.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Real Code Examples</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Strings</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Strings<ept id="p1">**</ept> are sequences of characters that are used as texts, help lines, addresses, telephone numbers, and so on.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>To declare a string in X++, use the <ph id="ph1">`str`</ph> keyword.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>String literals are characters that are enclosed in quotation marks (" ") that can be used where string expressions are expected.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Some examples of this would be "StringLit" and "Hello World".</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>If you want the string to span more than one line, precede it with an <ph id="ph1">"@"</ph> character.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>You can use strings in logical expressions, such as comparisons.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>You can also concatenate strings by using the + operator.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The default value for a string is <bpt id="p1">**</bpt>empty <ept id="p1">**</ept>and the internal representation is that of a list of characters.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>There are no automatic conversions for strings but there are several explicit <bpt id="p1">[</bpt>conversion<ept id="p1">](https://ax.help.dynamics.com/en/wiki/x-conversion-run-time-functions/)</ept> functions: <ph id="ph1">`str2int`</ph>, <ph id="ph2">`str2int64`</ph>, <ph id="ph3">`int2str`</ph>, <ph id="ph4">`str2num`</ph>, <ph id="ph5">`num2str`</ph>, <ph id="ph6">`str2date`</ph>, and <ph id="ph7">`date2str`</ph>.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>A string can hold an unlimited number of characters.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>You can specify the maximum length of characters within a string in the variable declaration and force a truncation  to the maximum length of the string.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>An example is shown in the next section.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>String Code Examples</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>TimeOfDay</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>timeOfDay<ept id="p1">**</ept> (or time data type) is an integer value representing the number of seconds that have elapsed since midnight.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>TimeOfDay variables can be used as literals in the same way as integers are used as literals.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>TimeOfDay variables can have relational operators and arithmetic operators applied to them.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>They can also be used in expressions.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The range of a timeOfDay data type is in the closed interval <ph id="ph1">\[</ph>0; 86400<ph id="ph2">\]</ph>.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Values above 86400 (23:59:59) cannot be interpreted.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>TimeOfDay variables are automatically converted into <bpt id="p1">**</bpt>boolean<ept id="p1">**</ept>, <bpt id="p2">**</bpt>enum<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>real<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`str2time`</ph> and <ph id="ph2">`time2str`</ph> conversion functions to explicitly convert timeOfDay.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>TimeOfDay Code Examples</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>utcdatetime</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>utcdatetime<ept id="p1">**</ept> data type combines the <bpt id="p2">**</bpt>date<ept id="p2">**</ept> type and the <bpt id="p3">**</bpt>timeOfDay<ept id="p3">**</ept> type into one type.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>A utcdatetime variable also holds time zone information, though this information is not accessible to X++ code.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The format for a utcdatetime literal is <ph id="ph1">`yyyy-mm-ddThh:mm:ss`</ph>, with the uppercase "T" being a required literal character.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>This format can be written without quotes.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The minimum value is <ph id="ph1">`1900-01-01T00:00:00`</ph> and the maximum value is <ph id="ph2">`1900-01-01T00:00:00`</ph>.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>This matches the upper range of <ph id="ph1">`date`</ph> and <ph id="ph2">`timeOfDay`</ph>.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>The smallest unit of time in utcdatetime is <bpt id="p1">**</bpt>1 second<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>A utcdatetime variable that has been declared but not initialized has the default value of <ph id="ph1">`1900-01-01T00:00:00`</ph>.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>This is the value returned by <ph id="ph1">`DateTimeUtil::minValue()`</ph>.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Some functions treat an input parameter of this minimum value as null.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>For instance, the <ph id="ph1">`DateTimeUtil::toStr`</ph> method returns an empty string, however, the <ph id="ph2">`DateTimeUtil::addSeconds`</ph> method returns a usable utcdatetime value.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>There are no implicit conversion for the utcdatetime data type.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`DateTimeUtil`</ph> class provides many methods for manipulating utcdatetime values.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The explicit <bpt id="p1">[</bpt>conversion<ept id="p1">](https://ax.help.dynamics.com/en/wiki/x-conversion-run-time-functions/)</ept> functions for utcdatetime are <ph id="ph1">`str2datetime`</ph> and <ph id="ph2">`datetime2str`</ph>.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Also, the <ph id="ph1">`Global`</ph> class provides the conversion methods <ph id="ph2">`utcDateTime2SystemDateTime`</ph> and <ph id="ph3">`CLRSystemDateTime2UtcDateTime`</ph> to support common language runtime (CLR) interop.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Comparison operators are the only kind of operators that can be used with the <ph id="ph1">`utcdatetime`</ph> data type.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>The following operators can be used to compare two utcdatetime values: !=, <ph id="ph1">&amp;lt;</ph>, <ph id="ph2">&amp;lt;</ph>=, == , <ph id="ph3">&amp;gt;</ph>, and <ph id="ph4">&amp;gt;</ph>=.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>When you add a utcdatetime field to a table, we recommend that you base the field on an extended data type (EDT).</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>utcdatetime Code Examples</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Composite Data Types</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>The composite data types in X++ are arrays, containers, classes as data types, delegates as data types, and tables as data types.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Array</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">**</bpt>array<ept id="p1">**</ept> is a variable that contains a list of items that all have the same data type.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>The elements of an array are accessed with integer indexes.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>You use a separate statement to initialize each element in an array.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>When you use a <bpt id="p1">**</bpt>Container<ept id="p1">**</ept> data type or an <bpt id="p2">**</bpt>Array<ept id="p2">**</ept> object to create a collection, you can initialize multiple elements by using a single statement.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>When declaring an array, if a <ph id="ph1">`Length`</ph> is specified, the array is a <bpt id="p1">**</bpt>fixed-length array<ept id="p1">**</ept> with <ph id="ph2">`Length`</ph> elements.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Otherwise, it is a <bpt id="p1">**</bpt>dynamic array<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Memory`</ph> is specified, it is a <bpt id="p1">**</bpt>partly on disk array<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>By default, all the items in an array have the default value of the data type in the array.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The three kinds of arrays are <bpt id="p1">**</bpt>dynamic arrays<ept id="p1">**</ept>, <bpt id="p2">**</bpt>fixed-length arrays<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>partly on disk arrays<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>dynamic array<ept id="p1">**</ept> is declared with an empty array option (that is, only square brackets).</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>fixed-length array<ept id="p1">**</ept> can hold the number of items that is specified in the declaration.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Fixed-length arrays are declared like dynamic arrays but with a length option in the square brackets.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Partly on disk arrays<ept id="p1">**</ept> are declared either as dynamic or fixed-length arrays with an extra option that declares how many items should be held in memory.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The other items are stored on disk and automatically loaded when referenced.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>X++ only supports one-dimensional arrays.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>It is possible, however, to mimic the behavior of multiple array indices (see the next section on multiple array indices).</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Variables in objects and tables can be declared as arrays.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>For example, this is used in address lines in the standard application.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>An Array collection class enables you to store objects in an array.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Array indices begin at 1.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>The first item in the array is referenced with <ph id="ph1">\[</ph>1<ph id="ph2">\]</ph>, the second <ph id="ph3">\[</ph>2<ph id="ph4">\]</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>The syntax for accessing an array element is <ph id="ph1">`ArrayItemReference = ArrayVariable [ Index ] `</ph>where <ph id="ph2">`ArrayVariable`</ph> is the identifier of the array, and <ph id="ph3">`Index`</ph> is the number of the array element.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Index`</ph> can be an integer expression.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Item zero<ph id="ph1">\[</ph>0<ph id="ph2">\]</ph> is used to clear the array.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>Assigning a value to index 0 in an array resets all elements in the array to the default value.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Array Code Examples</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Multiple Array Indices</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Some languages, such as C++ and C<ph id="ph1">\#</ph>, allow you to declare arrays with more than one index; that is, to define "arrays of arrays."</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>You cannot directly create multiple array indexes in X++ - only one-dimensional arrays are supported.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>However, you can implement multiple indexes by using the following scheme.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>For example, in C++ and C<ph id="ph1">\#</ph>, if you wanted to declare an array with two dimensions for holding an amount earned by country by dimension, and there were 10 countries and 3 dimensions, you would declare the following: <ph id="ph2">`real earning[10, 3];`</ph> This is not possible in X++.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Instead, you can define a one-dimensional array with the number of elements that is the product of the elements in each dimension.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>An example of this is shown below.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Containers</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>container<ept id="p1">**</ept> is a dynamic list of items containing primitive data types or composite data types.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>A container is helpful when you must pass a variety of value types between the client and server tiers.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>A container is a poor choice when you intend to repeatedly add to a list in a loop because a container is best suited for processes that do not involve excessive modification to the size or contents of the container.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>When a container undergoes excessive additions of data, overall system performance can be decreased by the need to repeatedly copy container data and allocate new space.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>A container is not a class.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>A container contains an ordered sequence of primitive values or other containers.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>The flexibility of <ph id="ph1">`anytype`</ph> makes container a good way to store values of different types together.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>A container can be stored in the database.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>A container is one of the column types that you can select when you use the Application Explorer to add a column to a table.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>A container slightly resembles an array, or collections such as the <ph id="ph1">`List`</ph> or <ph id="ph2">`Stack`</ph> classes.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>However, you can never change the size or content of a container after the container is created.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>X++ statements that appear to modify a container are internally building a new container and copying values as necessary.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Even an assignment of a container to another container variable creates a new copy of the container.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>All of this has performance implications.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>In the X++ functions that provide access to a container (such as <ph id="ph1">`conPeek`</ph>), the container is 1 based not 0 based.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>Indexing is 1-based for arrays.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>The default value of a container is <bpt id="p1">**</bpt>empty<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The container does not contain any values.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Some X++ statements with containers might appear like they modify a container, but inside the system this never occurs.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Instead, the data from the original container is combined with data from the command to build a new container.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>You can create a new container by using one of these functions: <ph id="ph1">`conDel`</ph>, <ph id="ph2">`conIns`</ph>, or <ph id="ph3">`conPoke`</ph>.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>The Global Class has static methods for handling containers.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>These methods include <ph id="ph1">`con2ArraySource`</ph>, <ph id="ph2">`con2Buf`</ph>, <ph id="ph3">`con2List`</ph>, <ph id="ph4">`con2Str`</ph>, <ph id="ph5">`containerFromXmlNode`</ph>, <ph id="ph6">`conView`</ph>, and <ph id="ph7">`str2Con`</ph>.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>There are several intrinsic X++ functions for handling a container, such as <ph id="ph1">`conIns`</ph> and <ph id="ph2">`conPeek`</ph>.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The X++ function <ph id="ph1">`conPeek`</ph> returns an <ph id="ph2">`anytype`</ph> type.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>This makes it easier to read the values from a container when you do not know what type each value is.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`anytype`</ph> can be assigned to any X++ value type, as long as the value can be converted.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Your code is easier to read when it avoids explicit data type conversions.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Assign values from a container to the same data type that was used to put the value into the container.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>You must not assign a container to an <ph id="ph1">`anytype`</ph>, because the system is unable to determine the correct conversions in some cases.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>In these cases, unexpected behavior or errors might occur.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>Comparing container to other options</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>The container type resembles other constructs, such as arrays and collection classes like <ph id="ph1">`List`</ph> and <ph id="ph2">`Stack`</ph>.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>The difference between a container and a List is that an instance of the List class is mutable.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`List`</ph> object first allocates more space than its data consumes.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>As data is added the space is filled.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>This is more efficient than allocating more space every time that an element is added.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Updating a <ph id="ph1">`List`</ph> performs faster than similar operations on a container.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>When you construct a <ph id="ph1">`List`</ph> object, you determine the one type of data that the <ph id="ph2">`List`</ph> object can store.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>This restriction is less flexible than for a container.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>However, you can choose to store objects in a <ph id="ph1">`List`</ph>, whereas a container can only store value types.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>The difference between a container and an array is that an array can hold only items of its declared type.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>You can allocate memory space for an array and fill that space with values later, such as in a loop.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>This is efficient and performs well.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>When you want to build a new container by appending new data, you can use either the <bpt id="p1">**</bpt><ph id="ph1">+=</ph><ept id="p1">**</ept> operator or the <ph id="ph2">`conIns`</ph> function.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">+=</ph><ept id="p1">**</ept> operator is the faster alternative.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`conIns`</ph> function only when you want to add new data before the last index of the original data.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>In previous incarnations of the X++ compiler, it was possible to store object references into containers, even though this would fail at runtime.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>This is no longer possible.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>When the compiler sees an attempt to store an object reference into a container, it will issue an error message.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>If the type of the element that is added to the container is anytype the compiler can’t make the determination of whether or not the value is a reference type.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The compiler will allow this under the assumption that the user knows what they’re doing.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>The compiler won't diagnose the code as erroneous but an error will be thrown at runtime.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>Container Code Examples</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>Classes as Data Types</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>class<ept id="p1">**</ept> is a type definition that describes both variables and methods for instances (objects) of the class.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>A class is only a definition for objects, and all objects are <bpt id="p1">**</bpt>null<ept id="p1">**</ept> when they are declared.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Every application class in the Application Explorer under the <bpt id="p1">**</bpt>Classes<ept id="p1">**</ept> node is a data type in X++.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>You can declare variables of these types in your code.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>You can construct instances of a class and assign the instances to variables.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>The instances are also known as objects.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>Classes can now be nested in source code.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Nested classes are available only inside forms (such as a class that extends FormRun) to represent controls, data sources, or data fields.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>An attribute decoration, such as on a class or a method, can now omit the suffix of the attribute name if the suffix is <ph id="ph1">`Attribute`</ph>.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>So X++ allows <ph id="ph1">`[MyFavorite]`</ph> instead of requiring <ph id="ph2">`[MyFavoriteAttribute]`</ph>.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>Also, attributes are now applied to the handlers of delegates and methods, to map the handlers to those targets.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>In legacy X++, it was possible to designate a method to run either on the client or the server.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>This is no longer possible.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>All compiled X++ code is executed as .NET CIL on the server.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>There is no longer any code that is evaluated at the client site or in the browser, therefore, the two keywords, <bpt id="p1">*</bpt>client<ept id="p1">*</ept> and <bpt id="p2">*</bpt>server<ept id="p2">*</ept>, are now ignored.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>Their use doesn’t cause a compile error, but they should not be used in any new code.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>Private and Protected  Member Variables</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>Previously, all member variables defined in a class were invariably protected.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>It’s now possible to make the visibility of member variables explicit by adding the private, protected, and public keywords.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>The interpretation of these modifiers is obvious and aligns with the semantics for methods:</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>A private member can only be used within the class where it’s defined.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>a protected member can be used in the class where it’s defined, and all subclasses thereof.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>A public member can be used anywhere: it’s visible outside the confines of the class hierarchy in which it’s defined.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>The default for member variables that aren’t adorned with an explicit modifier is still protected.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>You should make it a habit of explicitly specifying the visibility.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>As described, when a member variable is defined as public, it may be consumed outside of the class in which it’s defined.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>In this case, a qualifier designating the object hosting the variable has to be specified, using the dot notation (as is the case for method calls).</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>Reusing the code from above:</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>In this case, field1 is accessed using the explicit ‘this.’</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>qualifier.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>Making a member variable public may not be a good idea since it exposes the internal workings of the class to its consumers, creating a strong dependency between the class implementation and its consumers.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>You should always strive to only depend on a contract, not an implementation.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>Static Constructors and Static Fields</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Static constructors and static fields are new features in the X++ language.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Static constructors are guaranteed to run before any static or instance calls are made to the class.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>The execution of the static constructor is relative to the user’s session.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>You’ll never call the static constructor explicitly; the compiler will generate code to ensure that the constructor is called exactly once prior to any other method on the class.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>A static constructor is used to initialize any static data, or to perform a particular action that needs to be performed only once.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>No parameters can be provided for the static constructor, and it must be marked as static.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Static fields are fields that are declared using the static keyword.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Conceptually they apply to the class, not instances of the class.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>Class Elements in the Application Explorer</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>Under most <bpt id="p1">**</bpt>class<ept id="p1">**</ept> nodes there are two special nodes: a <bpt id="p2">**</bpt>classDeclaration<ept id="p2">**</ept> node and a <bpt id="p3">**</bpt>new<ept id="p3">**</ept> node.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>classDeclaration<ept id="p1">**</ept> contains the X++ <ph id="ph1">`class`</ph> keyword.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>It can also have additional keywords such as <ph id="ph1">`extends`</ph> to modify the class.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>This node can also contain declarations of member variables.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The member variables cannot be initialized to a value in <ph id="ph1">`classDeclaration`</ph>.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The member variables cannot be <ph id="ph1">`static`</ph>.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>In the following example the variables <ph id="ph1">`m_priority`</ph> and <ph id="ph2">`m_rectangle`</ph> are members of the class:</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>new<ept id="p1">**</ept> operator contains X++ logic that is run when the <ph id="ph1">`new`</ph> operator is used to create an instance of the class.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>The logic in the <ph id="ph1">`new`</ph> method might construct an object, and assign the object to a variable that is declared in the <ph id="ph2">`classDeclaration`</ph>.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>Each class is limited to only one <ph id="ph1">`new`</ph> method.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>However, in the <ph id="ph1">`new`</ph> method you often should call the <ph id="ph2">`new`</ph> method of the base class, and you do so by calling <ph id="ph3">`super()`</ph>.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>The following example is the <ph id="ph1">`new`</ph> method for the <ph id="ph2">`YourDerivedClass`</ph> class in the previous <ph id="ph3">`classDeclaration`</ph> example.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>In this <ph id="ph1">`new`</ph> method, the X++ code constructs an instance of the Rectangle class.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The instance is assigned to the <ph id="ph1">`m_rectangle`</ph> variable.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`this`</ph> keyword that is used in the example below is optional, although in practice it sometimes enables IntelliSense to be more helpful.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>During run time, most objects eventually no longer have any variable pointing to them.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>The system scans for such objects and erases them from memory.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>This makes the memory space available for other uses.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Object`</ph> class has a method named <ph id="ph2">`finalize`</ph>.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>However, the <ph id="ph1">`finalize`</ph> method is not a destructor.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>The Microsoft Dynamics AX system never calls the <ph id="ph1">`finalize`</ph> method, even when an object is garbage collected.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>System Classes</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>In the Application Explorer under <bpt id="p1">**</bpt>System Documentation<ept id="p1">**</ept> <ph id="ph1">&amp;gt;</ph> <bpt id="p2">**</bpt>Classes<ept id="p2">**</ept> you can see a list of the kernel or system classes.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>System classes are not written in X++, and you cannot see their source code.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>You cannot add any system classes.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>System classes usually have a <ph id="ph1">`new`</ph> method, but they do not have a <ph id="ph2">`classDeclaration`</ph> node.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>Every application class implicitly extends the <ph id="ph1">`Object`</ph> system class.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>Some system classes are extended by an application class of nearly the same name.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>For instance, <ph id="ph1">`xClassFactory`</ph> is extended by <ph id="ph2">`ClassFactory`</ph>.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>In such cases you should not use the system class.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>For more information, see Substitute Application Classes for System Classes.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Extension Methods</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>The extension method feature lets you add extension methods to a target class by writing the methods in a separate extension class.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>The extension class must be static.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>The name of the extension class must end with the ten-character suffix <ph id="ph1">\_</ph>Extension.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>However, there’s no restriction on the part of the name that precedes the suffix.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>Every extension method in the extension class must be declared as public static.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>The first parameter in every extension method is the type that the extension method extends.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>However, when the extension method is called, the caller must not pass in anything for the first parameter.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Instead, the system automatically passes in the required object for the first parameter.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>It’s perfectly valid to have private or protected static methods in an extension class.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>These are typically used for implementation details and are not exposed as extensions.</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The extension method technique doesn’t affect the source code of the class it extends.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>Therefore, the addition to the class can be done without over-layering.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>Upgrades to the target class are never affected by any existing extension methods.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>However, if an upgrade to the target class adds a method that has the same name as your extension method, your extension method becomes unreachable through objects of the target class.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>Extension methods are easy to use.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>The extension method technique uses the same dot-delimited syntax that you routinely use the call regular instance methods.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>Extension methods can access all public artifacts of the target class, but they can’t access things that are protected or private.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>In this way, extension methods can be seen as a kind of syntactic sugar.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>The target of an extension method must be a class, table, view, or map application object type.</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>Regardless of the target type, an extension <bpt id="p1">**</bpt>class<ept id="p1">**</ept> is used to add extension methods to the type.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>For example, an extension table is <bpt id="p1">**</bpt>not<ept id="p1">**</ept> used to add methods to a table, and there’s no such thing as an extension table.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>Delegates as Data Types</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>delegate<ept id="p1">**</ept> collects methods that subscribe to it.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>The delegate specifies the parameter signature that all its subscriber methods must share.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>When the delegate is called, the delegate calls each of its subscriber.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>A delegate never returns a value and is <bpt id="p1">**</bpt>unable to have a default value<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>However, each delegate starts with zero methods subscribed to it.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>There is no limitation on the number of parameters a delegate can declare and there is no limitation on the type of those parameters.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>The delegate body is always empty because the delegate's only purpose is to define the contract that subscribers must conform to.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>A delegate can now be defined in a table, form, or query, and not just in a class.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>Delegates Code Examples</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>Tables as Data Types</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>All <bpt id="p1">**</bpt>tables<ept id="p1">**</ept> can be treated like class definitions (at least in all practical aspects) in the X++ programming language.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>A table variable can be seen as an instance (an object) of the table (class) definition.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>For every field in a table variable, the default value is <bpt id="p1">**</bpt>empty<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>You can address fields and create methods on tables.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The methods can be invoked on instances of the table.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>To manipulate (read, update, insert, and delete) records in tables, you must declare at least one table variable, which can hold the record in focus.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>The best practice to use the name of the table as the name of the variable, but with an initial lowercase letter.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>Here are a few important differences between tables and objects:</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>You cannot allocate space for table variables—it is done implicitly.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>Fields in table variables are public—you can reference them anywhere.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>Fields in table variables can be referenced with expressions.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>There is no automatic conversion, but table variables that are declared as <ph id="ph1">`Common`</ph> can hold data from any table.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>Scope of Table Variables</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>In most respects, table variables can be considered objects.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>Contrary to objects, they are not allocated explicitly.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>Only a variable declaration is required.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>All tables are compatible with the <ph id="ph1">`Common`</ph> table in the same way that all objects are compatible with the <ph id="ph2">`Object`</ph> class.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>Table variables, which are declared as common buffers, can be used to hold data from any table.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>You cannot access tables without table variables.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>The principles for declaring table variables and objects are the same except for the allocation of space.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Table Code Examples</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>The syntax, however, also allows various possibilities for referencing fields in records, for example by using the <ph id="ph1">`TableName.(FieldId)`</ph> syntax.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>The following example prints the contents of the fields in the current record in the Customer table.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>Note: the following example uses the <ph id="ph1">`fieldCnt`</ph> and <ph id="ph2">`fieldCnt2Id`</ph> methods.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`fieldCnt`</ph> method counts the number of fields in a table, while <ph id="ph2">`fieldCnt2Id`</ph> returns the ID for a field number.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>For example, you can use the <ph id="ph1">`fieldCnt2Id`</ph> method to find out that field number 6 in a table has the ID 54.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>It is necessary to perform this conversion because it is not guaranteed that the IDs of the fields in a table are consecutive.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>Collection Classes</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>The X++ language syntax provides two composite types: arrays and containers.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>They are useful for aggregating values of primitive types.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>However, you cannot store class objects in arrays or containers.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Collection classes<ept id="p1">**</ept> are for storing objects by allowing you to create arrays, lists, sets, maps, and structs that can hold any data type, including objects.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>The classes are implemented in C++ to achieve the maximum performance (they are system classes).</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>Collection classes were formerly called Foundation classes.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>Collection Classes</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>The collection classes consist of <bpt id="p1">**</bpt>arrays<ept id="p1">**</ept>, <bpt id="p2">**</bpt>lists<ept id="p2">**</ept>, <bpt id="p3">**</bpt>maps<ept id="p3">**</ept>, <bpt id="p4">**</bpt>sets<ept id="p4">**</ept>, and <bpt id="p5">**</bpt>structs<ept id="p5">**</ept>.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">**</bpt>array<ept id="p1">**</ept> is similar to the X++ language array type except that it can hold values of any single type, including objects and records.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>Objects are accessed in a specific order.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>list<ept id="p1">**</ept> contains elements that are accessed sequentially.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>Unlike the <ph id="ph1">`Array`</ph> class, the <ph id="ph2">`List`</ph> class provides an <ph id="ph3">`addStart`</ph> method.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>As with the <ph id="ph1">`Set`</ph> class, the <ph id="ph2">`List`</ph> class provides methods <ph id="ph3">`getEnumerator`</ph> and <ph id="ph4">`getIterator`</ph>.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>You can use an iterator to insert and delete items from a <ph id="ph1">`List`</ph> object.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>map<ept id="p1">**</ept> associates a key value with another value.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>set<ept id="p1">**</ept> holds values of any single type.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>Values are not stored in the sequence they are added.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>Instead, the <ph id="ph1">`Set`</ph> object stores them in a manner that optimizes performance for the <ph id="ph2">`in`</ph> method.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>When you add a value to a <ph id="ph1">`Set`</ph> object which is already storing that same value, the add attempt is ignored by the <ph id="ph2">`Set`</ph> object.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>Unlike the <ph id="ph1">`Array`</ph> class, the <ph id="ph2">`Set`</ph> class provides the methods <ph id="ph3">`in`</ph> and <ph id="ph4">`remove`</ph>.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>struct<ept id="p1">**</ept> can contain values of more than one type.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>Used to group information about a specific entity.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>Types Stored in Collections</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>The constructor for each collection class, except <ph id="ph1">`Struct`</ph>, takes in a type parameter that is an element of the <ph id="ph2">`Types`</ph> system enum.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>The collection instance can store items of that type only.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Types::AnyType`</ph> enum element is a special case and it cannot be used to construct a collection object, such as a <ph id="ph2">`Set`</ph> object.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`null`</ph> value cannot be stored as an element in a <ph id="ph2">`Set`</ph> object.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>And <ph id="ph1">`null`</ph> cannot be a key in a <ph id="ph2">`Map`</ph> object.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>Elements Cannot Be Changed During Iteration</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>You can iterate through an X++ collection object with an iterator or enumerator.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>Here are typical examples of how you can obtain an iterator:</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>For<ph id="ph1">`Set`</ph> objects, if any elements are added or removed after an iterator is created, the iterator instance can no longer be used to read from or step through the collection.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>For <ph id="ph1">`Map`</ph> objects, element removals invalidate the iterator just as for <ph id="ph2">`Set`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>However, a <ph id="ph1">`MapIterator`</ph> object remains valid even after a call to the <ph id="ph2">`Map.insert`</ph> method.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>This is true whether the key is new, or whether the key already exists and only the value is actually being updated in the <ph id="ph1">`Map`</ph> element.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>X++ code that calls <ph id="ph1">`Map.insert`</ph> and relies on the iterator object remaining valid might fail if run as .NET Framework CIL.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>Extend a Collection Class</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>You can use the collection classes to form more complex classes.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>For example, a stack might easily be implemented by using a list where the elements are always added to the start of the list.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>The newest element then occupies the top of the stack.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>You can also extend the collection classes.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>For example, you might extend the <ph id="ph1">`List`</ph> class to create a list of customer records where the operations could be made type safe.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>The derived collection class would accept only customer records, not just any record.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>Extended Data Types (EDTs)</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Extended data types (EDTs)<ept id="p1">**</ept> are user-defined types, based on the primitive data types <ph id="ph1">`boolean`</ph>, <ph id="ph2">`integer`</ph>, <ph id="ph3">`real`</ph>, <ph id="ph4">`string`</ph>, and <ph id="ph5">`date`</ph>, and the composite type <ph id="ph6">`container`</ph>.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>An EDT is a primitive data type or container with a supplementary name and some additional properties.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>For example, you could create a new EDT called <ph id="ph1">`Name`</ph> and base it on a <ph id="ph2">`string`</ph>.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>Thereafter you can use the new EDT in variable and field declarations in the development environment.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>You can also base EDTs on other EDTs.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>EDTs are standard data types, but with a specific name and additional properties.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>EDTs undergo the same value and type <bpt id="p1">[</bpt>conversions<ept id="p1">](https://ax.help.dynamics.com/en/wiki/x-conversion-run-time-functions/)</ept> as do the standard data types they are based on.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>The benefits of EDTs are:</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>Code is easier to read because variables have a meaningful data type.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`Name`</ph> instead of <ph id="ph2">`string`</ph>.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>The properties you set for an EDT are used by all instances of that type, which reduces work and promotes consistency.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>For example, account numbers (<ph id="ph1">`AccountNum`</ph> data type) have the same properties throughout the system.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>You can create hierarchies of EDTs, inheriting the properties that are appropriate from the parent and changing the other properties.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>For example, the<ph id="ph1">`ItemCode`</ph> data type is used as the basis for the<ph id="ph2">`MarkupItemCode`</ph> and <ph id="ph3">`PriceDiscItemCode`</ph> data types.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>Create an extended data type</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>This feature is not implemented as a language construct.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>To create an EDT:</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>In <bpt id="p1">**</bpt>Solution Explorer,<ept id="p1">**</ept> right-click on the project, select <bpt id="p2">**</bpt>Add<ept id="p2">**</ept> and then <bpt id="p3">**</bpt>New item.<ept id="p3">**</ept></source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Add New Item<ept id="p1">**</ept> dialog, select Installed and then <bpt id="p2">**</bpt>AX Artifacts<ept id="p2">**</ept> in the left pane.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>In the middle pane, select the EDT type you want to create.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>Enter a name and click <bpt id="p1">**</bpt>Add.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>EDT Code Example</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Null Values for Data Types</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Microsoft Dynamics AX does not support the concept of <bpt id="p1">**</bpt>null<ept id="p1">**</ept> values that is available in many other Database Management Systems (DBMS).</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>A variable in X++ always has a type and a value.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>For each data type, however, one value is considered null (for example, when the <ph id="ph1">`validateField`</ph> table method is executed).</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>Type</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>Value treated as null</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Date</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>1900-01-01</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>Enum</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>Element with its value set to 0.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>Integer</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>Real</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>0.0</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>String</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>An empty string</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>Time</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>00:00:00</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>Utcdatetime</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Any value with its date portion as 1900-01-01 is treated as <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, regardless of the time portion value.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>Therefore the value 1900-01-01T22:33:44 is treated as <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>Note that any <bpt id="p1">**</bpt>utcDateTime<ept id="p1">**</ept> value with its date portion as 1900-01-01 is displayed as blank by the X++ <bpt id="p2">**</bpt>print<ept id="p2">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Only the value 1900-01-01T00:00:00 is displayed as blank by the <ph id="ph1">`Global::info`</ph> method.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>That is the value from the <ph id="ph1">`DateTimeUtil::MinValue`</ph> method.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>As a result, when the <ph id="ph1">`validateField`</ph> method checks whether a user has entered a value in a mandatory field, 0 is not accepted in an integer type field, the first entry is not accepted in an enum type field, and so on.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>Also, the values that are listed in the previous table yield <bpt id="p1">**</bpt>false<ept id="p1">**</ept> in a Boolean comparison, in X++ SQL.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>In non-SQL X++ statements, the equal and relational operators work with these values the same normal way that they work with other values.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>Variables of type container, and classes and variables of table type can be null in the traditional database management system (DBMS) sense.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>A table type is <bpt id="p1">**</bpt>null<ept id="p1">**</ept> if all its fields have their null value.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>